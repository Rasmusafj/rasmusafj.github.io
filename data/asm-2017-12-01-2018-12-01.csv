author,comment,timestamp
skylyrac,Arithmetic/logic instructions can set the flags or not. The second mov should be movs.,1543567816.0
FUZxxl,"After line 22, there is no jump instruction to jump back to the beginning of the loop, so your loop is executed at most once.  This doesn't seem to be what you want.",1543530580.0
seisvelas,"For some additional documentation beyond the in-code comments:

I track fibonacci numbers two at a time. %ebx contains the smaller fibonacci number, and %eax the larger. From my understanding, when I do my exit syscall, the exit code should be whatever is stored in %ebx. 

Since I set my counter, %edi, to 5, I expect the exit status of my program to be 3 (the fifth fibonacci number). Instead I get one. I am running the program and acquiring the results like so:

    hc015@HC015:~$ as fib.s -o fib.o
    hc015@HC015:~$ ld fib.o -o fib
    hc015@HC015:~$ ./fib
    hc015@HC015:~$ echo $?
    1
    
",1543530952.0
TNorthover,"> ""C:/Users/TAJS/AppData/Local/Temp/Coridium/__1TempASMCode.asm:2: Error: junk at end of line, first unrecognized character is ['""

This is because the comment character for ARM on GNU-based platforms is '@' rather than ';'.

The other errors are because ARM used to have a different syntax for Thumb instructions to ARM ones. Years ago ARM invented the ""Unified Assembler Language"" (UAL), but GNU as still defaults to the older version. So you need to add a `.syntax unified` directive to your file before assembling.

You probably also want to specify the CPU on the command-line",1543495916.0
vytah,"Not sure, but since in Thumb mode most operations have to use the destination register as one of the source registers, you usually write `OP rd, rs` instead of `OP rd, rd, rs`

So try `LSLS r0, #2`",1543493982.0
MegaHurtz_,"Also found this last night, https://i.imgur.com/KVnq2pf.png, affirming that LSLS is good ASM, if outside an IT block, whatever the hell that is.  Lol.  Moar reading is in order.",1543502037.0
llkiwi2006,Your disassembly is in an intel-like syntax while gnu as expects an at&t syntax,1543486920.0
jedwardsol,"From assembly you can't operate on a string.  You don't know what a string object looks like.

If you did

    auto size = static_cast<uint32_t>(foo.size());
    char *data = &foo[0];

Then you can access size and data from the inline assembly and alter the string's data that way.

---

If you use c-style strings instead,  you'll find this a lot easier.

    char forward[100];
    char reversed[100];

    cout << ""Enter a string: "";
    cin  >> forward;

    ​__asm {

​",1543467213.0
MOS6502,Been decades since I've done any x86 assembly but I'm guessing you have to convert your inputs into integers. ,1543499334.0
guitmz,"I already found something weird myself:

```
buffer            rb fstat.st_size
```

this makes my executable over 4MB. I should try to understand how to fix this as a first step I guess.",1543338371.0
staticrain2,"Try writing generalized functions with call leave and ret. For using the functions pass variables via the stack. You can try calling C functions from your assembly code by passing parameters over the stack.

Assembly is really cool.",1543339328.0
Thanatanos,"don't ask if you can ask your question, just post your code and ask your question.",1543286263.0
PizzazzUrAzz,"I am making a program that solves kakuro puzzles. The goal is for it to be able to read in any square puzzle (n x n size), print the initial puzzle, attempt to solve the puzzle, and if the puzzle can be solved print the solved puzzle (or that it's impossible if it can't be. I can currently read and print the puzzles correctly, but have been really struggling with implementing parts of the solving. The solving I think can be broken up into four parts:

    1. Checking for duplicates in a given row.
    2. Checking for duplicates in a given column.
    3. Checking the sum of a given row.
    4. Checking the sum of a given column.

I got 1 and 2 down, so that leaves 3 and 4. And really, once I can figure out 3 or 4 I can easily mimic the process for the other. The problems I've been having is that when I run with the sum checking, it always says the puzzle is impossible when it's not. I tried drawing out what I thought I had to do into a flowchart, then transferring that to actual code. I also tried making it in C as psuedocode and then transferring it. I even tried to step through the debugger and adding in print statements and I rewrote this section probably a dozen times now... but it always makes it so that the puzzle is impossible to solve and I have absolutely no clue why. I don't even know if the problem even has to do with it at all or my solve function. I think I've spent too much time staring at my code and changing it and think I need a fresh pair of eyes to take a look at it. 

But before I get to the code, throughout I constantly check if a number is greater than 9 or less than 10. This is because any cell in the puzzle with a value greater than 9 has to be either a clue or block (i.e. can be 9999, 9939, 4099, 1428, etc.). A cell with a value less than 10 has to either be empty or have a guess in it. At least that was how I thought I could approach this. Just wanted to explain that a bit more.

    # Name:         check_sum_row
    #
    # Description:  Checks if a row contains a valid sum.
    #
    # Arguments:    a0      the current row
    #               a1      the current col
    #               a2      the current cell
    #
    # Returns:      1 if passes check, otherwise 0
    #

    check_sum_row:

        addi    $sp, $sp, -FRAMESIZE_40
        sw      $ra, 32($sp)
        sw      $s7, 28($sp)
        sw      $s6, 24($sp)
        sw      $s5, 20($sp)
        sw      $s4, 16($sp)
        sw      $s3, 12($sp)
        sw      $s2, 8($sp)
        sw      $s1, 4($sp)
        sw      $s0, 0($sp)

        move    $s0, $a0            # curr row
        move    $s1, $a1            # curr col
        li          $s2, 0              # total empty cells

        la         $s3, size
        lw         $s4, 0($s3)         # size n

        li      $s5, 0              # sum total
        li      $s6, 0              # sum goal
        li      $s7, 9

        j       sum_row_loop

    sum_row_loop:

        move    $a0, $s0
        move    $a1, $s1
        move    $a2, $s4
        jal     getElement

        addi    $s1, $s1, -1        # col--

        li      $s3, 10

        bgt     $v0, $s7, sum_row_done  # is clue?
        nop

        blt     $v0, $s3, sum_cells     # has value
        nop

        j       sum_row_loop

    sum_cells:

        add     $s5, $s5, $v0           # add to sum
        j       sum_row_loop

    sum_row_done:

        move    $s3, $v0

        li      $s7, 100

        div     $s3, $s7

        mflo    $s6

        bne     $s5, $s6, is_more_in_row
        nop

        li      $v0, 1
        j       sum_check_done

    is_more_in_row:

        addi    $s1, $s1, 1

        move    $a0, $s0
        move    $a1, $s1
        move    $a2, $s4
        jal     getElement

        blt     $v0, $s3, still_possible
       nop

        j       fail_sum_check

    still_possible:

        li      $v0, 1
        j       sum_check_done

    fail_sum_check:

        li      $v0, 0
        j       sum_check_done

    sum_check_done:

        lw      $ra, 32($sp)
        lw      $s7, 28($sp)
        lw      $s6, 24($sp)
        lw      $s5, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, FRAMESIZE_40
        jr      $ra

    # Name:         solve
    #
    # Description:  Solves the puzzle.
    #
    # Arguments:    a0      the current x-coordinate
    #               a1      the current y-coordinate
    #
    # Returns:      1 if puzzle was solvable, otherwise 0
    #

    solve:

        addi    $sp, $sp, -FRAMESIZE_40
        sw      $ra, 32($sp)
        sw      $s7, 28($sp)
        sw      $s6, 24($sp)
        sw      $s5, 20($sp)
        sw      $s4, 16($sp)
        sw      $s3, 12($sp)
        sw      $s2, 8($sp)
        sw      $s1, 4($sp)
        sw      $s0, 0($sp)

        la      $s0, puzzle
        la      $s1, size
        lw      $s2, 0($s1)
        li      $s3, Block_Value
        li      $s4, 1              # start guess at 1
        move    $s5, $a0            # row
        move    $s6, $a1            # col
        mul     $t0, $s2, $s2
        li      $t1, 0              # counter
        li      $t3, 9              # Max number of guesses

        j       solve_loop

    solve_loop:

        beq     $s6, $s2, inc_row
        nop

        beq     $t1, $t0, solve_done
        nop

        move    $a0, $s5
        move    $a1, $s6
        move    $a2, $s2
        jal     getElement
        move    $s7, $v0

        beq     $s7, $zero, check
        nop

        addi    $s6, $s6, 1
        addi    $t1, $t1, 1
        j       solve_loop

    inc_row:

        addi    $s5, $s5, 1
        li      $s6, 0

        j       solve_loop

    dec_row:

        addi    $s5, $s5, -1
        move    $t6, $s2
        addi    $t6, $t6, -1
        move    $s6, $t6

        j       back_track

    check:

        beq     $s4, $t3, back_track

        move    $a0, $s5
        move    $a1, $s6
        move    $a2, $s4
        jal     isValid

        beq     $v0, $zero, inc_guess
        nop

        j       guess

    inc_guess:

        addi    $s4, $s4, 1
        j       check

    guess:

        move    $a0, $s5
        move    $a1, $s6
        move    $a2, $s4
        jal     setElement

        addi    $s6, $s6, 1
        addi    $t1, $t1, 1
        li      $s4, 1
        j       solve_loop

    back_track:

        beq     $s5, $zero, no_solution
        nop

        beq     $s6, $zero, dec_row

        j       continue_bt

    continue_bt:

        addi    $s6, $s6, -1        # col--

        move    $a0, $s5
        move    $a1, $s6
        move    $a2, $s4
        jal     isValid

        beq     $v0, $zero, back_track

        j       revert

    revert:

        move    $a0, $s5
        move    $a1, $s6
        jal     solve

    no_solution:

        bne     $s6, $zero, continue_bt

        li      $v0, 0
        j       solve_done

    solve_done:

        lw      $ra, 32($sp)
        lw      $s7, 28($sp)
        lw      $s6, 24($sp)
        lw      $s5, 20($sp)
        lw      $s4, 16($sp)
        lw      $s3, 12($sp)
        lw      $s2, 8($sp)
        lw      $s1, 4($sp)
        lw      $s0, 0($sp)
        addi    $sp, $sp, FRAMESIZE_40
        jr      $ra

Any help would be most appreciated.",1543289489.0
vytah,"You need to do two things:  
locate the argument string  
convert it to a number

If it's Linux, then the argument number is probably on top of the stack, followed by pointers to each argument.

Converting them to numbers is mostly just a loop where you subtract 48 and multiply by 10.",1543195990.0
rlee0001,"Use .int when you want an integer.

Use .word when you want exactly one word of memory to be reserved.

That-is, use the one that best conveys your intent. In a fixed size data structure where it's critical that exactly one word be allocated for a given field, use .word. For a counter variable that you use as an operand in some arithmetic, use .int.",1542920327.0
FUZxxl,Which ARM assembler do you use?,1542918069.0
InfinitelyManic,This assumes GNU AS [http://www.coranac.com/files/gba/re-ejected-gasref.pdf](http://www.coranac.com/files/gba/re-ejected-gasref.pdf) ,1542941769.0
alexeyneu,"  b dq 00fffffffffffe00h  
  c db 8 dup('k')  
  
`byte ptr (b) + 1` drags `0xfe`",1542683714.0
TNorthover,"The sign extension isn't directly represented in either of the equations. The equations represent 32-bit arithmetic, so you have to decide what to do with the 24-bit offset. The rule is to sign-extend it so that you can branch both forwards and backwards; basically it's just saying that 0xffffff represents a jump of 4 bytes backwards (well, ignoring the 8 offset for later) rather than a large number forwards.

The two 0 bits are there purely for efficiency: since every instruction must be 4-byte aligned (the low 2 bits of its address are 0) there's no point in encoding those in the offset. If you always pre-multiply by 4 (i.e. add two 0 bits) you can represent longer jumps.

Finally, the 8 you mentioned is an artefact of the pipeline of early ARM CPUs. Becuase of their internal design they happened to have the value of ""PC+8"" lying around handy that they could feed into a branch instruction, so they defined the branch instruction to take advantage of that. It's widely regarded as a poor design decision these days and has been corrected in AArch64.",1542656638.0
responsecode418,"3 rd line down on the new code has 

>ldr r7, $4

instead of 

>mov r7, $4",1542556500.0
afrocolt,oh god. i remember that fucking program. logisim is what it’s called right? fuck that,1542420663.0
uzimonkey,"There's probably a better subreddit for this, maybe /r/cpudesign?",1542430267.0
staticrain2,Please give more detail. What das SLI and FA stand for?,1542415335.0
thegnomesdidit,"a colon (:) indicates a label, internally it is interpreted as a memory address, but it's easier for the human to keep track of labels rather than memory addresses (which may change if you change the structure of your program).   
byte <nn> indicates that <nn> bytes are being reserved locally (IE inline with your program memory) for whatever purpose. I suspect line1 and line2 hold fixed-length strings of the data to be displayed on the LCD.   
l1ptr and l2ptr are again memory reservations (2 bytes = 16 bits), you can usually move to and from memory locations with a special syntax such as:    
 MOV AX, [l1ptr]    
the compiler interprets this as a request to read or write the data at the specified memory location. check your assemblers documentation on the correct syntax for this",1542247365.0
vytah,"First of all, this is a question more suited for /r/java

Second, ASMifier doesn't work with Java or Groovy files. You need to compile your sources to .class files and then it doesn't matter where they came from.",1542215977.0
uzimonkey,You're probably not going to get very good answers here for two reasons:  This sounds like a homework question and there's not much information to go on here.  What architecture are you even talking about?  Is that ARM?,1542161160.0
afrocolt,pay attention in class lol,1542182637.0
FUZxxl,What have you tried? Where exactly are you stuck?,1542137659.0
hellscyth,"1: four spaces at the beginning of each line to get code
 
    like this

2: In high level languages, when the recursive call occurs at the end, it's called tail recursion. Compilers can optimize this into a simple for loop. That's what you want to do. Good luck.",1542134003.0
Vannaka420,"Check out [compile explorer](https://gcc.godbolt.org/z/3SPL1f), it takes the high-level code and shows the assembly spit out by the compiler. The link above has your code written in c and compiled with MIPS GCC 5.4.",1542141098.0
thegnomesdidit,"In the first example, start at L0, not L1 (this exemplifies how confusing spaghetti code can get). (*edit* it may even be an error in the example - perhaps the first instruction should have been JMP L0, but remember these labels could be jumped to from any other part of your program)    
   
In the second example the three dots after IfDone: represent ""fill with some other code"", but the other code is left out for brevity. That other code could do anything else your imagination allows, such as print a different message, generate an error, display a picture of a unicorn, or even exit the program. ",1542123657.0
kotzkroete,Looks like the first instruction was supposed to jump to L0.,1542123644.0
FUZxxl,Do you use NUL-terminated strings (aka C-strings)?  how is `OutString` defined?,1542007833.0
dougvj,"There is actually no such thing as 'address of r1' like there is for variables in languages like C. Registers are registers, they are not in memory they are part of the CPU architecture and they *only* hold values.

However, register values can have different meanings. The value of a register might be an address, or it might be an integer value, or might be something entirely different like a character. It is up to you the programmer to make the distinction, not the assembly language.

If the value of r1 is an address in memory and you want to read the contents of that memory, then you need to load that value from memory into a different register before doing the comparison, like so:

    ldr r2, [r1]  
    cmp r2, #0x020

At this point the value of r1 still has the memory address, and the value of r2 has whatever the contents of that memory address was when you did the load.

Does that make sense?",1541922172.0
alexeyneu,registers is not a memory and all this instructions do write op so it doesnt matter.,1541317431.0
willrandship,"It would overwrite it, and code that looks at that register for the other variable would see the most recent value stored there.",1541326026.0
Net07,"There is no 'full' or 'empty' with registers. Registers simply hold values. 0 is a value, and so is any other number. Registers are part of the CPU, not memory (RAM).

Simply put, when you write to the register, it will overwrite whatever value you had before, but ONLY in that register. When you read that register again, it will have your newly set value. If you loaded a value into the register from memory, your memory value will NOT change.",1541382983.0
felixame,"Hi. I think I may be able to explain away some of the misconceptions you have. I'm assuming you're already familiar with a high-level language and I'm assuming you're talking about x86 asm.

The idea of variables in a high-level language is a little different to how data is stored and recalled in assembly but I'll refer to putting a value into an area of memory and referring back to that value as a ""variable"" anyway since you seem to understand the concept. In simplest terms, when ""declaring a variable"" in x86 asm, all you're doing is telling the program how large the data is (byte, word, dword, qword, ect.) and what name you will use to refer to that data. The programmer doesn't make the decision where in memory that data lives. Generally, that's beyond the scope of your program. You don't have to worry about assigning a variable to the wrong area in memory because that's all handled for you by the hardware/OS.

That being said, you cannot ""assign a variable"" to a register like al. Registers are just there as working space. Think of general use registers as temp variables. They are located on the CPU die meaning the CPU can access them much faster than traditional memory. For all intensive purposes, they're just a place where you can store a value for easy manipulation whether that be doing arithmetic with it, comparing it to other values, or anything else your program needs to accomplish. If you were to move a value into a register (as an example, the instruction ""mov eax, value"") whatever value was in the register before is now overwritten with the value you just put in it. A register is never ""full"" nor ""empty"". Whatever you move into a register, goes into that register. It's just a convenient place for us to hold a value.

Hopefully that clears some things up. Learning assembly by your self can be confusing and I wish you the best of luck.",1541996377.0
WrongAndBeligerent,I hope you aren't paying for this class ,1541262806.0
FUZxxl,"Which operating system?  Generally, just do network programming like you would do in C but write the code in assembly instead.  I strongly recommend you to call into the libc for all the network functionality.  Implementing DNS yourself is just not fun at all.",1541164637.0
jephthai,"Windows or linux? I've done some winsock stuff in x86_64 on windows. I could maybe dig some out, but it's only for establishing a TCP connection and sending and receiving bytes. ",1541562277.0
,"I liked ""Programming from the Ground Up"" by Bartlett. In case you might also want to learn about MIPS, the second chapter of ""Computer Organization and Design"" by Patterson & Hennessy is good.",1541115540.0
MCRusher,"www.godbolt.org is a good resource to use while you are learning, it shows you the asm representation of your C and C++ code.",1541120130.0
alexeyneu,only language where best is live classes i think,1541235422.0
vytah,"You need to perform 32 iterations (for 31,…,0), but you perform only 31 (in the first iteration, R4 is 31 and in the last R4 is 1)

Maybe move `CMP R4, #0`/`BEQ L16` from the beginning to just before `SUB R4, R4, #1`, it might work then.",1541109691.0
CJKay93,"You cannot dynamically allocate any section, .bss or otherwise. To do any dynamic allocation at all under any circumstance on any system, you need to allocate from a heap. If you are running on top of an operating system that provides a C runtime, the function you would call to dynamically allocate a zero-initialised object would be [calloc()](https://en.cppreference.com/w/c/memory/calloc).

If you are running without an operating system, then you would need to manually implement your own memory allocation routines.

I don't know x86 assembly or even what environment you're executing this in, but I imagine it would look something like this:

    %include ""asm_io.inc""

    call read_int
    
    mov ebx, eax
    mov eax, 1

    call calloc

The address of the newly allocated memory is then placed in eax.

Emphasis on the fact that you haven't specified the environment you're using, so nobody is going to be able to give you an exact answer.",1540994048.0
TNorthover,"The constraint you should use for a 32-bit float is 't' rather than 'w' (which allocates a d-register).

Also the 'y' operand modifier you're using instructs the compiler to print its register in indexed (`dN[0]` or `dN[1]`) form. That's only the right syntax in a pretty limited set of circumstances, and certainly not for all operands of a `vmul`.",1540818127.0
jedwardsol,"    int mat1[M][N]
    mat1[i][j]

is the same as

    mat1 + i*N + j

so any operations on mat1 only use N, i and j.

In the assembly,  you know mat1 is indexed with eax and you know where i and j are stored.  So anything extra in the calculation of eax is N.",1540776683.0
ThrowAwaylnAction,It's not possible to answer this question. To do so would have to take into account all of the many ways that a program could be written. ,1540773696.0
spc476,There's not enough information given.  What platform?  What CPU?,1540775412.0
thegnomesdidit,"Pulling mostly from my experience using i386 functions are generally called thusly:

1. The calling code stores any parameters for the function either in registers, memory or on the stack. For higher level languages (such as c) the compiler will handle this for you, but in lower level languages its up to you to decide how this is done.   
   
2. The function is called with a call statement or similar, whch is similar to a jump / goto statement except that it also stores the current instruction pointer so that program flow can be resumed from the funtion with a return statement. A function itself is really just a label, an aďdress in code memory that can be called from anywhere else in the code. Its a little more complicated in fancy modes like protected mode where you are calling external libraries, but essentially the same
   
3. The called function usually has to store the state of any registers it will affect during its execution   
   
4. The function executes its code, and stores a result (if any) in memory, a register or on the stack    
   
5. The machine state (registers) are restored ready for return to the main program flow, obviously if a register stores the result of an operation in the function you dont want to restore that, but the calling code must be aware of that
   
6. Program flow is returned to the calling code with a ret statement or similar (there may be different ret statements for different types of call or interrupts)   
   
All this doesnt necessarily happen in this order, for example machine state could be saved before the call and restored after",1540789876.0
MCRusher,"Woah... button input is a very complicated example.

Try using www.godbolt.com

A handwritten win32 fasm hw program:

    format PE console
    entry _main

    include 'win32a.inc'

    section '.idata' readable import data
        library msvcrt,'msvcrt.dll'
        import msvcrt, printf,'printf'

    section '.rdata' readable data
        hw db 'Hello World!',0Dh,0Ah,0

    section '.text' readable executeable code
    _main:
        push ebp
        mov ebp, esp
        push hw
        call [printf]
        mov esp,ebp
        pop ebp
        xor eax, eax
    ret

All that for just a hello world, although It can be simplified some.",1540776338.0
FUZxxl,How is the joystick connected to the computer?  Is there any framework you are using?  Are you programming an X11 program or not?  What does the rest of your code look like?  It's impossible to say how to implement this functionality without some more details on your part.,1540800303.0
uzimonkey,This question is unanswerable.  It's both too broad and too vague.,1540812478.0
FUZxxl,"A register is a special piece of storage in the CPU that can be directly used by the CPU.  On most architectures, registers are not mapped into RAM and are entirely separate from main memory.  The `eax` register has nothing to do with function calls, but it is a convention to return a function's return value in `eax`.  Function calls are done with the `call` instructions.

As for your second question: how you do this strongly depends on the platform, architecture, and framework you are programming for.  Can you give us some more context?",1540768389.0
alexeyneu,"it's Accumulator register,extended one
what else you wanna know",1541237174.0
MCRusher,"Well less than is the opposite of greater or equal.

So if the flags say greater than or equal (jge), it skips over the code in the ~~else~~ block by jmping to a label past that code.

At least I believe so, the _______ stuff is kind of confusing, and I'm relatively new to asm.",1540755405.0
TNorthover,"    bne x29, x0, ENDj       #   if x29 != x0, ENDj, else

This is comparing j against x0 (hardwired to 0) instead of b (in x6) isn't it? You should probably also think about the direction of the comparison. 

    addi x29, x29, -1       #   decrement j     ---NOT WORKING---   

You need to reset j to 0 again before starting the next inner loop, not just subtract one from it.",1540584406.0
PE1NUT,"The first error is about this line:

    movl   (%edx,1,4), %eax #second = arr[1]

According to the GAS documentation, the syntax for the addressing modes is: 

> segment:displacement(base register, index register, scale factor)

Your second argument (1) is not an index register, and therefore the assembler fails. You could for instance load 1 into %eax, and then use movl (%edx, %eax, 4), %eax.

The second error is about this line:

    movl   (8(%ebp),%ebx,4), %ecx

The correct syntax seems to be:

    movl  8(%ebp, %ebx, 4), %ecx

This gets rids of both of the errors for me.

    ",1540505881.0
FUZxxl,Why did you [cross-post](https://stackoverflow.com/q/52998233/417501) this from Stack Overflow?  Didn't you get enough help over there?,1540505944.0
FUZxxl,"That depends on which assembly syntax and which CPU architecture you use.  For example, on x86 it's

    add foo, bar

to add `bar` to `foo` in Intel syntax, but in AT&T-syntax it's

    add bar, foo

to add `bar` to `foo`.",1540481709.0
Luna_Lovecraft,"Depends on the syntax.

https://imada.sdu.dk/Employees/kslarsen-bak/Courses/dm18-2007-spring/Litteratur/IntelnATT.htm

Tldr,
Intel Syntax: Instruction destination, source
AT&T Syntax: Instruction source, destination. 

I have seen both used and language isn't neccessarily a factor depending on how and where you are writing the code.  I would ask your teacher to confirm which syntax you use in class. ",1540481934.0
noobhecker,"Thank you all, the reason I'm asking here is the exam is tomorrow. I did study earlier but only realize something is wrong here just now. I will ask for clarification tomorrow.",1540482831.0
mikeblas,"RDTSC retreives a register that (essentially) increments with every clock cycle. The general approach is to get that counter, run some code, then get the counter again. You can subtract the two counter readings to learn how many clock cycles passed between the two readings.

Your assignment will be a bit difficult because you have to make your assembly code compatible with the C code that's hosting it. That's just the nature of using inline assembly.

Intel has a [whitepaper about timing code execution using RDTSC](https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf), which will give a lot more details than I care to write out.
",1540428885.0
TNorthover,"Your string to print appears to be at the start of the sector, which means the CPU will interpret it as a bunch of instructions and execute it first (rather than knowing to jump to `start`).

The hello world string is probably harmless (maybe corrupting a few registers). Other strings will fail for various reasons, a common one being they misalign the stream so that when the CPU does eventually get to `start` it's in the middle of what it thinks is an instruction.

The sequence 'T', 0 for example ends up treating the first byte of the `call print` instruction as the operand for an ""addb"" instruction and going even more haywire from there.",1540421243.0
alexeyneu,org comment is wrong. Bios starts on this location without any of yours commands. This directive aligns code to fit this context ,1541238320.0
rlee0001,"The function your looking for, in general, I'd called ""itoa"". Hope that helps.",1540361784.0
PE1NUT,"Given the names of your registers and the fact that you are using 'syscall', I'm assuming you are on x86-64.

If you are writing this in pure assembly, you can't make use of 'printf', and will have to write a suitable conversion yourself.

First you need to define some mutable memory space where you can build up the string before doing the syscall to write. If the number you want to print is simply a one-digit decimal number, the conversion is easy: just add ascii '0' (48 in decimal) to it. But that only works for numbers 0 to 9. If your number is larger than that, you first need to implement a binary to decimal conversion. 

Edit: your example doesn't seem to work on my platform (OSX, gcc). When I compile it, I get:

    test.asm:9:9: error: 32-bit absolute addressing is not supported in 64-bit mode
        mov $message, %rsi # address of string to output

But that problem seems to be specific to OSX.",1540364684.0
BS_in_BS,What platform are you on?,1540356747.0
FUZxxl,"What operating system are you programming for?

if your number is just a single digit, you can convert it to ASCII by adding `'0'` (not `0`) to it.  If your number is made of multiple digits, you have to manually convert it to a string by repeatedly dividing by 10.  This is slightly tedious, so a number of library functions exist to do so.",1540373448.0
gastropner,"I short, you need to convert it to a string, and then display that.",1540378498.0
FUZxxl,I see you have deleted your last post.  Please don't do that.  Future readers might profit from the answers people give to you.  Don't deny them this opportunity by deleting your post.,1540482239.0
alexeyneu,"for hex output it's done like that:
https://github.com/bitcoin/bitcoin/blob/742ee213499194f97e59dae4971f1474ae7d57ad/src/utilstrencodings.h#L125  
trick is to halve a byte and then use table

",1541240443.0
jedwardsol,"    mov (%rdi, %rcx, 4), %rax

This is loading an 8 byte value from the array.  Your `int` is a 4-byte type.",1540315048.0
ThrowAwaylnAction,"It looks ""reasonable"". One bug seems to be the use of 4 rather than 8 in the array indexing (the registers are 8 bytes apiece).",1540315811.0
Efaen,"Sure, this could be an address to some static string:

push   $0x804a244

And I guess you'd find argument to phase_1 (that will become the second argument to strings_not_equal) here:

pushl  0x1c(%esp)",1540234488.0
CompellingProtagonis,"lol bomb lab was rough man(/woman), I feel for you. The string is going to be a pointer, so look for something that could be a memory address. As u/Efaen mentioned, $0x804a244 could be a pointer to a static string. Bomb lab was pretty straightforward up until phase 4, more just testing concepts, so you shouldn't have to worry about trickery. Good luck!",1540247653.0
Gamazu,Compare the string pointed at  0x804a244 with the string pointed to on the stack. The stack frame is  0x14 bytes long and it's the address of the first long pointed to at stack+0x1c or esp+0x1c .,1540235427.0
gastropner,"You can use INC no problem, it's just that you need to do it twice, since in your example, each item is 2 bytes large, which means one INC makes ESI point to the middle of the old value instead of going on to the next.",1540196900.0
alexeyneu,wtf is 2000Hh?,1541241189.0
DOOMReboot,"Take a deep breath, relax,  and handle each step one instruction at a time.  Or, raise that payment by an order of ten.",1540043453.0
PerfectCreatures,R/reverseengineering,1540004038.0
1v1ltnonoobs,this might help you out: [https://www.codeproject.com/Articles/15971/Using-Inline-Assembly-in-C-C](https://www.codeproject.com/Articles/15971/Using-Inline-Assembly-in-C-C),1540007116.0
jhaluska,"Just write in C++, disassemble it and then put in the appropriate ASM instructions.  It'll help you understand how each C instruction maps to ASM.",1540016544.0
shinyquagsire23,"Hm, I don't really see anything up with it, but if I had to suspect anything it would be functionality outside this snippet, it doesn't follow the general ARM64 ABI well. IIRC in ARM64, usually X0-X7 are considered scratch, and X8-X24 are stored/restored from stack if used.

I'd suggest three things, one would be to pass your string as X0 into the function, and the second would be to not pass X1 as an index and instead just increment the string pointer and your output, and the third would be to return the length through X0 at the end. This way everything is contained and you can reuse the function without it mutating memory, super important for threading too.

Also there's a way to autoincrement for an ldr (`ldrb w3, [x0]!` should load into w3 the value at x0 and increment x0 by 1 I think) but you can also just do it separate. Also I've never seen `br x30` ever, I've only ever seen `ret` which does the same thing (jumps to lr/x30).

Edit: nope I was wrong, `ldrb w3, [x0], #0x1` would load into w3 the byte at x0 and then increment x0 by 1",1539991357.0
afrocolt,simply put what are you trying to do and what’s failing. this is badly formatted ,1539658202.0
MCRusher,"Alright well I finally figured it out: edx & ecx were volatile, and printf modified them which broke the program. Thanks for the attempt at help.",1539672779.0
jedwardsol,"The jump is relative to where the instruction is

So `JE 8` means that if the jump is to be taken,   the value of the instruction pointer will be the current value + 8

And note that the current value of the instruction pointer is already past the jump instruction.

So if the JE instruction was at address 0

    0000   JE  8
    0002   mov ax, 1
     

Then the destination of the jump will be 000A;     IP is at 2,  and 2+8 = A.

   ",1539631530.0
kiwidog,"https://defuse.ca/online-x86-assembler.htm

Bookmark this

And this: http://ref.x86asm.net",1539631386.0
rlee0001,">    pushl %ebp           # setup
>    movl %esp, %ebp      # setup
>    pushl %ebx

This is preserving the value of ebx...

>    movl 8(%ebp), %ecx    # ecx = i
>    movl 12(%ebp), %ebx   # ebx = j

...because we overwrite it here.

>    leal (%ecx, %ecx, 8), %edx  # edx = 9*i
>    sall %2, %edx   # edx *= 4
>    movl %ebx, %eax   # move pointer to j
>    sall %4, %eax   # eax *= 4
>    subl %ebx, %eax # eax = 4*eax - j
>    sall %2, %eax   # eax *= 8

I would hope that your professor wants to know why these instructions are doing what they're doing, and not just for you to restate the obvious of what they're doing on their face. I think you should spend more time really understanding this.

>    movl array2(%eax, %ecx, 4), %eax

This loads 32 bits from the source array (first part of copy).

>    movl %eax, array1(%edx, %ebx, 4)

And this saves them to the destination array (second part of copy).

>    popl %ebx

And this is restoring ebx.

>    movl %ebp, %esp

This is part of the stack frame tear down.

>    popl %ebp           # finish
>    ret                 # finish

I can't imagine that your professor will accept ""finish"" as a satisfactory analysis. Make sure you understand stack frames and function calls fully.",1539557072.0
jedwardsol,"array1[i][j] is the same as \*(array1 + i\*N + j)

so if you work out which array is being written to, you can work out what N is.

And vice versa",1539557214.0
ThrowAwaylnAction,0xC,1539504419.0
merrychap-c,"```
   mov eax, 0x4 // eax = 4
   mov ebx, 0x2 // ebx = 2
   or eax, ebx  // eax = 6, ebx = 2
   mul eax, ebx // eax = 12, ebx = 2
```",1539509639.0
rlee0001,It's the number of bits to shift by. The salq instruction is basically doing a multiplication here by 2 to the power of whatever is in cl.,1539386361.0
jedwardsol,It is; the MSB of `4321` is a 0,1539304472.0
DOOMReboot,"Read up on two's complement and how signing works.  The most significant bit of 4321 is 0, while 8002 is 1.  8002 actually represents a negative number since its first bit is set.  When you put/get a two byte word into a larger register the sign is maintained so that's why you're actually getting FFFF8002.",1540043812.0
igor_sk,Why do you think it should be andnps?,1539235996.0
ibuysleep,Just link in and call the C functions like one normally would from assembly.,1538812865.0
,"Assuming you're using MASM, and if you don't mind using 32bit examples - [http://www.win32assembly.programminghorizon.com/tutorials.html](http://www.win32assembly.programminghorizon.com/tutorials.html) is where I first learned Win32 asm stuff a decade or two ago, and they're all still relevant - the basic Win32 API hasn't changed in a long time. It's largely trivial to convert the examples to 64bit, but you can assemble in 32 bit mode if you just want to get up and running fast.

The [http://www.masm32.com/board/index.php](http://www.masm32.com/board/index.php) forums are also a great place to ask - and despite the name, there is plenty of 64bit MASM knowledge floating around there.

",1538891430.0
levidurham,"Assemblers were originally written in bytecode by people who where tired of writing in bytecode. Now, more often than not, you modify a compiler or assembler to output your new bytecode. 

Some compilers these days do their own assembling, negating the need for the intermediate step of generating assembly. ",1538705519.0
hsoolien,Punch cards at one point. I have hand assembled some code back in the 8bit days.,1538699499.0
antiquekid3,"Hand-assembling, particularly old architectures like PDP-8 and PDP-11, is very straightforward, and much of the software was written in assembly. When new architectures are developed, many people take advantage of developing cross-compilers that are hosted on an existing architecture so that higher level languages can be used. ",1538745932.0
zeissikon,"Mnemonics to help writing machine code. Someone would analyze the problem, say with applied mathematics, someone else would write an organigram, someone would write assembly code, someone would punch the cards, someone would run batches of punched cards in the machine and give the core dump or the punch out to the actual users with a problem. Over the years almost all parts were automated programmed or simplified. ",1538740369.0
auto-cellular,"Assembly is a directly electrically interpretable ""language"" (that is it transform binary memory content into physical electric tension change. Those tensions materialize the binary states of memory and registers)

So assembly is both a programming language, and physical gears turning inside the cpu. And the first ""programs"" were just switching the right bits on/off into the memory.

As far as i know the first assembly programs where done through wiring and activating switches 
https://www.computerhope.com/cdn/eniac.jpg",1538738060.0
derpdetonator,"Alright, I will start this off by saying I do not have much experience with x86 assembly. I am more experienced with ARM. However, I can give a few tips. First, you need to realize that the 'function' asm0 is being passed two paramets, 0xb6 and 0xc6. These are hexadecimal integers. In binary and decimal, these numbers are

1. 0xb6 = 0b10110110 or 182
1. 0xc6 = 0b11000110 or 198

These numbers are just like the inputs to a function call in C. They will be pushed to the stack. At the start of asm0, you say push ebp, which is the pointer to the bottom of the stack. Saying push ebp preserves the current position of the stack. Now, you move the bottom of the stack to the current top of the stack by saying mov ebp, esp. After that, you put values into eax and ebx which are general purpose registers. DWORD PTR is a way of saying how big the value will be (in this case 4 bytes). Saying mov eax, DWORD PTR [ebp+0x8] means go to the address at ebp +0x8 bytes, and put the value at that address into eax, giving it 4 bytes of space. Mov ebx, DWORD PTR [ebp+0xc] is similar. Mov eax, ebx is self explanatory. The rest is simply popping the stack and returning. I am not going to calculate the value for you, but hopefully this helps otherwise.",1538660037.0
InfinitelyManic,"Are you trying to output something to the screen? 

If so then you'll most likely want to use a system call for that.  

Also, are you trying to learn x86 (32-bit) or x86-64 (64 bit) assembly? You can write 32-bit code on a 64-bit machine running a 32-bit OS; however, I just wanted to be sure of your goals. 

What operating system are you using? 

What books are you using to study? 

Are you using a debugger? 

&#x200B;

&#x200B;",1538695657.0
lballs,"I just looked up the instruction set in the PIC16F87XA datasheet and it appears that the BTFSC, BTFSS instructions don't support the W register.  It sounds like your assembler should have thrown an error.  I am guessing that the W was translated to a 0 and you are actually performing the operation on register 0 of the current bank.  I haven't touched PICASM in a decade so I may be missing something.",1538596083.0
lballs,What is the actual binary machine code generated by this line of assembly?  That should show the exact operation being translated by the assembler. ,1538672946.0
arkdinos,"I have taken it and I highly recommend it, solid course.",1538474579.0
_hAxel,Updated with all 7 assignments.,1540349139.0
nemotux,"There are many ways to skin a cat. And there are many ways to code the exact same thing using wildly different instructions.

In the end, you have a 2-way decision point. Execution can go one way or the other. The only difference between your two examples is whether the ""then"" part of the original source ends up at the target of the branch or as the fall-through of the branch.

It might be more intuitive to the human eye for the branch to be structured one way or the other. But from the machine's point of view, it doesn't really matter. Both are correct.

Often compilers will take a non-intuitive route because, while there are many options, some are faster on average for the computer to implement than others.",1538402106.0
TNorthover,"You certainly can reverse the condition on any branch, though the labels in both your examples seem messed up.

The reason to do it the textbook’s way in this case is probably to keep the asm in the same order as the input C code and allow a fallthrough (i.e. avoid an unconditional branch at the end of the block).",1538387747.0
ThrowAwaylnAction,Can you be more specific about what the problem is?,1538198056.0
DOOMReboot,What do you have so far? Do you know how to subtract? Do you know how to write loops?,1538081151.0
goatcheese90,"Without outright telling you how to do it, maybe [this](http://www.bbc.co.uk/skillswise/factsheet/ma12pape-l1-f-division-using-repeated-subtraction) will help at least understand how division by repeated subtraction works. Basically subtract the divisor until you reach zero and count how many times you repeat this subtraction(hint you'll need to use a separate register for your counter)  
I'll let you think about how to deal with numbers that aren't evenly divisible  ",1538081481.0
Fd335,"Basically you will need to have your counter value (number of times you need to divide) in a register, and you will need to write a subroutine that will subtract the divider from the divident the number of times specified in your counter. You can do that by subtracting from the counter at the end of your subroutine and checking if your counter has reached 0,at which point you quit the subroutine. ",1538081315.0
FUZxxl,What architecture are you programming for anyway?,1538116610.0
BCosbyDidNothinWrong,I'm going to have to charge extra for this due to your use of a question mark after a statement.,1538082092.0
BCosbyDidNothinWrong,How much do you want to pay and when does your teacher expect it? ,1537996381.0
GearBent,"What architecture? x86, z80, 68k, PPC, MIPS, AVR, ARM?",1537977616.0
sideofszechuan,Nope,1537993933.0
coreb,"Are you after a line for line conversion, or is optimizing the math okay? It'll be simpler to convert this python code:

    i = 1
    while i < 85:
      if i % 3 == 0:
        i -= 1
      else:
        i *= 3
      print(i)  

That produces the same set of numbers. Of course the following would be the easiest to translate into ASM:

    print(3)
    print(2)
    print(6)
    print(5)
    print(15)
    print(14)
    print(42)
    print(41)
    print(123)

Reply back with the Architecture you're on and the code you've already tried to write, and you may get some help.


EDIT: [Highly optimized version](https://godbolt.org/z/QjFSCj)

    .LC0:
            .string ""%d\n""
    main:
            pushq   %rbp
            movq    %rsp, %rbp
            movl    $1, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $3, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $2, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $6, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $5, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $15, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $14, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $42, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $41, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $123, %esi
            movl    $.LC0, %edi
            movl    $0, %eax
            call    printf
            movl    $0, %eax
            popq    %rbp
            ret


But seriously, [this makes the work trivial](https://godbolt.org/z/ZHzw_D).",1538062874.0
Gamazu,"I had never heard of the term strength reduction before but yes, using xor <reg>, <reg> instead of mov reg,0 is an optimization. Much like using shifts for division or multiplication by factors of 2.",1537919353.0
philthechill,"What are the criteria for something to ""count"" as reduction in strength? I don't see this optimization as being any weaker...",1537929925.0
jedwardsol,"    sub ax, B        

What is `ax`?  Hint, it's not 30010.",1537669118.0
llkiwi2006,"You didn't save the base pointer at the start of the frame

EDIT: I mean you are supposed to save rbp to stack, and rsp to rbp.

You didn't do either so you basically changed the stack without restoring when the function ends, ~~which is probably what's causing the segfault.~~

Read up on how stack frames on x86 work here: https://en.m.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames

Btw, gcc enables -fomit-frame-pointer when you compile with -O or greater, which skips saving base pointer, so just beware if you are looking at disassembled code.",1537658531.0
afrocolt,i’m assuming you just need to figure out the internal structure of certain file types and read it the same as a txt. what exactly are you struggling with?,1537616128.0
socorros,All of this is available online. This forum isn't stack exchange. ,1537519264.0
lIlIllIlll,/u/mttd :),1537484642.0
TNorthover,"Telling us the error is usually good practice, though I have a couple of guesses.

The first issue is that C functions on macOS (& iOS etc) are prefixed with a '_', so that should be `call _nameOfFunction`.

Another issue you'll probably hit soon is that macOS assembly is usually done in what's called AT&T syntax, which is a slightly different way of writing x86 assembly.

It's probably a good idea to get familiar with both, but you can tell Clang to expect Intel syntax, either with a `.intel_syntax noprefix` directive in the file or `-masm=intel` on the command-line.",1537463318.0
CapitalistLetter,"I'd recommend [this book](https://www.amazon.com/Assembly-Language-Step-Step-Programming/dp/0470497025). Its on linux, which IMHO I think has a simpler api than windows.

About compiler generated assembly - compilers are evil wizards. The assembly they generate will look weird, mainly because it is, and wthat won't realy help you learn assembly.",1537161852.0
sauronsystems,"Have your C compiler emit assembly instead of letting it emit an object file. (I think it's -S in gcc and clang..) 

This is a really great way to see how various calling conventions work, see what happens when registers need to get spilled, and more.  ",1537159711.0
Enlightenment777,"1) Use C compiler output as a starting point to learn assembly.  This is what I always have done in past decades when I learn assembler code for a new processor that I haven't previously used.

2) Enable compiler option to output a mixed-mode output text file that shows both the original **C** code and compiler generated **Assembler** code.

3) Disable compiler optimization or set it one step above none, otherwise it might be hard to understand what the compiler does at higher optimization levels.
",1537164830.0
baggyzed,"What do you mean by ""know""? Those structures are used quite extensively during OS development, so knowing at least what they are used for and how they are used would be good. I'm sure that this is also covered in the book though, or that it references you to the Intel manuals or other sources for this.

If you mean ""knowing"" the layout of the structures, then no - this is pretty much something you need to know once or twice, when you implement functions which fill these structures and pass them to the CPU. If you ever need to know what the structures look like in memory, you don't need to learn this by heart - you just go back to whatever source of documentation you prefer (I just google it, and it usually brings me to a wikipedia page, which describes most CPU-related structures well enough).",1536819787.0
CJKay93,"The syntax for data structures is virtually the same for all architectures because defining structures is not... architectural.

A structure is literally just some allocated memory where some of the regions of that memory have meaning.",1536760049.0
SakishimaHabu,"Try using the yasm assembler, since you can use Intel or AT&T format and still assemble it. Run it on a 64 bit machine. Assemble with dwarf debugging and listing files enabled. Use gdb or ddd to walk through your data structures. Have fun.",1536768328.0
spc476,"First of, the instruction

    move eax,[edx]

treats the contents of `EDX` as an address, and moves the contents of that address into the `EAX` register.  Now, `LEA`.  It stands for ""load effective address"" but it can also be viewed as a special form of addition/multiplication.  The instruction:

    lea ebx,[edx + eax*2]

will take the contents of `EAX`, multiply it by 2, add that result to the contents of `EDX` and assign the result to `EBX`.  Only `EBX` is updated---the other two registers remain unchanged.  The implied intent of the instruction is to calculate an address, but it's really doing addition and multiplication in a single instruction.  The multiplications are only by powers of two (2, 4, or 8 in 64-bit machines) and up to two additions (one register, some immediate value).  So you can multiply `EAX` by 5:

    lea eax,[eax*4 + eax]

or calculate a simple formula like 3*x+8:

    lea eax,[eax*2 + eax + 8]

That's pretty much all there is to `LEA`.  ",1536556890.0
TNorthover,"The key point is that x86 lets you do lots of weird calculations to calculate an address before loading the value to use in an instruction (or storing to it).

Back in the mists of time someone decided it'd be really neat if you could just stop after doing those calculations instead of actually using them for anything. And LEA is what does that.",1536588331.0
ScrappyPunkGreg,"Nice job.

You'd like the game TIS-100.

https://store.steampowered.com/app/370360/TIS100/
",1536449798.0
Hell__Mood,"Watch me playing with ""wolf64"" (interactive version, escapable, freedos, still 64 bytes) [https://www.youtube.com/watch?v=hEmK64CKpP0](https://www.youtube.com/watch?v=hEmK64CKpP0)",1536577852.0
daemoncode,"Nice!
",1536379767.0
AsmCoder110,That's so cool. ,1536425208.0
nyrol,"As the hint given says, ""Think of how you learned to do multiplications of decimal numbers in primary school, and translate that to binary numbers"".

Basically loop through each digit in the multiplier, multiplying by each digit in the multiplicand, and once you're at the next digit, shift over your result.

Try writing out a multiplication of 2 4-bit binary values and do it by hand to see the process you need.

eg:

        1001
       x1101
       _____
        1001
           0
      100100
    +1001000
    ________
     1110101",1536260266.0
scubascratch,"Remember how to do long multiplication on paper one digit at a time?

Do the same thing on paper in binary for a clue. Like multiple 1011 x 1101.
You wind up shifting things left by one bit at a time for each bit of width in the 2nd input, and summing the shifted results.
",1536259699.0
qscrew,"*It's all about playing with Condition Codes*™:

    __mul8_4x4:
        ANDI R17, 15
        ANDI R18, 15
    __mul8_8x8:
        LDI R16, 0
    label0:
        SBRC R18, 0
        ADD R16, R17
        LSL R17
        LSR R18
        BRNE label0
        RET

If r17 and r18 is guaranteed to be less than 16 (i.e. upper nibbles are clear) or you want to do 8-bit multiplication modulo 2⁸, lines before __mul8_8x8 are not needed. You can use `FMUL` if you like to cheat but that probably wouldn't get you good points. Refer to the AVR instruction manual for understanding how the above code works.",1536934121.0
baggyzed,https://software.intel.com/en-us/articles/intel-sdm,1536126960.0
BubbaMc,Assembly Language Step by Step by Jeff Duntermann is a fantastic read.,1539121778.0
Brane212,Wh y are you blabbing for half an hour about something that you could said in 30 seconds flat ?,1536033085.0
ScrappyPunkGreg,"Switch from x86 to 6502 assembly and make an old-school Nintendo game using this publicly available tutorial I have on GitHub:

https://github.com/gregkrsak/first_nes",1535901521.0
phaserescu,"A good idea is to choose something that can't be done in other languages (or is hard to do) but is a natural fit for assembly. For example if you choose to do an OS in assembly people might go ""mmm yeah, you'll use assembly in some parts of it... so why not?"". But obviously an OS is a big undertaking. But there are various utilities that need to have full access to the computer, like a memory tester\[1\], or an hdd bad blocks tester\[2\], or even a boot loader\[3\].

When you hear about these types of programs, users of the usual programming languages, don't have an immediate idea on how to approach those in their programming language and even if they do, at some point they have to write some assembly. 

I think that one such program, even if you don't implement all features is a good fit for both the assembly language and your final exams project.

&#x200B;

\[1\] [https://en.wikipedia.org/wiki/Memtest86](https://en.wikipedia.org/wiki/Memtest86)

\[2\] [https://en.wikipedia.org/wiki/S.M.A.R.T](https://en.wikipedia.org/wiki/S.M.A.R.T).  
\[3\] [https://en.wikipedia.org/wiki/GNU\_GRUB](https://en.wikipedia.org/wiki/GNU_GRUB), [https://en.wikipedia.org/wiki/LILO\_(boot\_loader)](https://en.wikipedia.org/wiki/LILO_(boot_loader))  
",1535901382.0
casecorp,Take a look at https://2ton.com.au for some ideas,1535904065.0
ScrappyPunkGreg,"
>Over the course of years and decades, small errors and inaccuracies can mutate into bigger errors and even serious security vulnerabilities. The process is insidious because it is largely invisible. To summarize:

>Incomplete or misleading documentation is dangerous; which also means that

>Insufficient or misleading source code comments are dangerous

>Complex, difficult to use hardware design is dangerous

>Last minute design changes tend to cause unanticipated problems

>Using programming languages without understanding their subtleties is dangerous

>Whatever you don’t understand willeventually hurt you

>Over time, minor errors can turn into major problems without anyone realizing
",1535817130.0
,If you ever need to buy an PC to learn a programming language then you and us all failed! ,1535646899.0
TNorthover,"There's no reason a real PC will behave any differently in that respect from a VM. If you can't use MASM in a VM you won't be able to on a native Windows machine.

What problem are you hitting in the VM?",1535647543.0
fearless0,"I would use masm32 sdk to start of with
and it even has a little editor to help with beginning to program in asm - quick editor (qeditor.exe)

Then you can paste in the code, save it as some filename (test.asm for example):

    .386 
    .model flat, stdcall
    .stack 4096
    option casemap:none
    
    include \masm32\include\windows.inc
    include \masm32\include\kernel32.inc
    includelib \masm32\lib\kernel32.lib
    
    ExitProcess PROTO dwExitCode:DWORD
    
    .data ; define your variables here
    
    .code
    
    main PROC ; write your assembly code
    
        Invoke ExitProcess, 0
    
    main ENDP
    
    END main

Qeditor menu->Project->Assemble & Link

Obtain the masm32 sdk from here: http://masm32.com/download.htm",1535649411.0
uzimonkey,"You can still do x86 assembly on a mac, just not with masm.  The thing about assemblers is they're all very similar, 99% of what you're doing will be x86 instruction mnemonics and that's the same across all assemblers.  On a mac you'll have access to assemblers like nasm that should work fine.

If you *must* use masm then an VM will work fine.  I don't know what is wrong with masm on your VM but it's not mystical, you're just doing something wrong and you should work through that problem.  Or you could always dual boot Windows and OS X on your mac.

Finally, if you want to get a Windows machine for this then literally anything will do.  Even a cheap, even used, Windows laptop should be fine.",1535654069.0
FUZxxl,If you can't run the code in a VM you are doing something wrong.  It should work most definitely.,1535665334.0
_simu_,"If you don't want to run Windows in a VM, you can just install Windows on your Mac ([https://support.apple.com/boot-camp](https://support.apple.com/boot-camp)) instead of buying a PC.",1535651961.0
AmroMustafa,"Hey, I think that's an amazing project! But can you please before coding some part explain the theory and jargon behind it and how it relates to everything else just so that everyone can understand the whole thing to some extent.",1535519874.0
ibuysleep,"You're probably gonna get recommendations for vim and emacs, both of which are good options.  I used vim until I switched to Colemak, now I'm using micro.  I've used nano, micro, and vim for ASM projects, and emacs would do just as well.

The correct answer is the same editor that you'd use for non-ASM projects.

There are wrong answers however.  Notably, Eclipse.",1535070042.0
antiquekid3,"I use Vim with build scripts for most of my assembly projects, from PDP-8 and 4004 to ARM and others. ",1535068137.0
Gamazu,"Visual Studio Code
free ; runs on Windows, Mac and Linux ; modern ; I use for large z80, 68k and x86-64 projects

I still miss Brief but VS Code is pretty good.",1535066560.0
ScrappyPunkGreg,"I used [Sublime Text 3](https://www.sublimetext.com/3) on this project of mine (if you're into NES games): https://github.com/gregkrsak/first_nes


Sublime Text is Windows/Mac/Linux cross-platform, [supports custom scripting/plugins in Python](http://docs.sublimetext.info/en/latest/extensibility/plugins.html), and has a browsable library of pre-made plugins.
",1535099713.0
,E.M.A.C.S,1535056491.0
philthechill,What type of software? Console app? Device driver? Complete PC operating system? BIOS? Embedded system?,1535066462.0
mcandre,MS Word bruv,1535073876.0
skeeto,"> If you go to PowerPC reference materials, you'll see [horrid tables](https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/050-PowerPC_Addressing_Modes_and_Assembler_Instructions/ppc_instructions.html#//apple_ref/doc/uid/TP30000824-TPXREF105) that look like some sort of dystopian declension table from a long-forgotten Slavic language. 

Love it.",1534447307.0
FUZxxl,I think `jmp near _amsg_exit` should do the trick.,1534282057.0
baggyzed,"It's FASM that does this kind of near->short JMP optimization: https://flatassembler.net/docs.php?article=manual#1.2.5 .

So it's possible that your original EXE was assembled with FASM.

EDIT: Nevermind. I see your problem was the other way around. Anyway, it's weird that using ""near"" didn't help for all those assemblers.",1534400907.0
MakeItEnd14,"I am a complete n00b in asm but I found this very helpful.

http://asmtutor.com",1534264985.0
BCosbyDidNothinWrong,Why is a Microsoft guy doing PowerPC asm?   Is there a version of Windows for Power9? ,1533911848.0
bllinker,I'm very confused - r2/radare2/the reverse engineering framework?,1533612653.0
chaign_c,"Checkout this if you need a PowerPC emulator!
http://github.com/nongiach/arm_now",1533594731.0
FUZxxl,Your distribution is configured to build position-independed executables (PIE).  Pass `-fno-pie` to `gcc` to make this code work.,1533475053.0
ruertar,"Just curious: Where did you get 74 from?

It appears it is simply an attempt to compare the values at address `0x347a` and stored in `r15` offset by 0 bytes (so effectively whatever `r15` points to).",1533228762.0
Steel_Neuron,Out of curiosity: Is this from microcorruption.com? :),1533285392.0
jhaluska,"/u/ruetar is correct.  Shameless plug, feel free to post MSP430 questions in /r/msp430 .  ",1533229773.0
qscrew,The first example is clearly wrong: the `c` and `d` constraints (the register `ecx` and `edx` respectively) should be also specified in the clobbered register list; otherwise undefined behaviours would result. That one isn't a pretty good example of inline asm usage tbh; implementing macro + extended asm version of some intrinsics might have served better for that purpose. btw the [GCC manual](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html) is pretty well written IMO.,1532946966.0
balkenbrij,"it's 14 in hex, so 20 bytes?",1532634047.0
tobiasvl,"Perhaps a dumb question, but are you familiar with the hexadecimal number system? ",1532637999.0
jhaluska,"\>   So basically, if jeq #0x4498 <check\_password+0x14> made the jump, it would have landed in the memory location 4494 

No.  It would only land on 0x4494 if the jump wasn't taken.

It's jumping to the address #0x4498.  The <check\_password+0x14> part is 0x4484 + 0x14 which is how 0x4498 was calculated.",1532635036.0
nyrol,"4484 + 14 = 4498. I'm positive they taught addition with 4 digits in grade one. As long as your base is above 9, it doesn't matter which one you're in, this will always be true.",1532641888.0
601error,"Whatever looks good to you and your assembler will accept.  Personally I prefer lower case. 
",1531978157.0
ibuysleep,"If x86, use all lowercase
Otherwise (ARM is soooo much better) use all uppercase",1532048218.0
x86_heirophant,Not aware of any standard. Only one I know is all caps other than text strings for assembly. ,1531972468.0
neptronix,Thanks for this!,1536240910.0
mcandre,"Hmm, so the assembler (looks to be GNU as in this case) does not have enough knowledge about the architecture details to reject invalid instructions, even mangling improper instructions in surprising ways?

Is there a possibility of patching gas to reject invalid instruction configurations per-arch more proactively? How can the developer mark a .S file to note the target architecture? I think this is possible for x86 vs. x86_64, but what about arm, mips, sparc, ppc, and so on?",1531576324.0
jhaluska,">This is all interesting. It just goes to show that it is regular behavior for an assembler to just take your shitty assembly and do whatever it fucking feels like with it. This is, I should remind everyone, because assembly language is too high level.

That's a bit of an overreaction.  It's an illegal/undocumented instruction.  The assembler had the choice to either error out, encode an illegal instruction,  or replace it with something that is guaranteed to run and be disassembled.

From the looks of the instruction encoding, I would be shocked if the same circuitry for the mov/shift wasn't being used.  That would make the ""mov r0, pc"" just a specific subset (shorthand) of the lsl instructions.  I know the MSP430 architectures does similar things.",1531578613.0
,I *really* like that graphical representation of the instruction encoding. Was that generated by a tool or created specifically for the article?,1531621643.0
igor_sk,I have an impression that “LSR by 32” is RRX,1531583431.0
AccidentalRebel,"I uploaded the source as it might be helpful to others who want to learn assembly.  It's abandoned but there's a lot that can be learned from what I've implemented.

Some features that might be interesting:

* Debug functions - Contains simple but handy functions for debugging. Can log single characters and can do assertions.
* Random number generation - Uses Xorshift algorithm. Can generate a  random number from 0 to 65534. Also has helper functions to generate a  value from within a range or a random percentage.
* Cursor functions - Contains helper functions to place and move the text cursor on the screen.
* Board setup - The game sets up the board by drawing it and adding bombs randomly on it.",1531323315.0
ScrappyPunkGreg,"~~Beware, there is a .COM file in this repo.~~",1531329576.0
ola-hates-me,I know that it runs on DOS but will it be possible to build/run it on Linux? How cumbersome is the task?,1531364894.0
drbuttjob,"Homebrew NES developer here. I highly suggest you take a look at [the Nerdy Nights tutorials](http://nintendoage.com/pub/faq/NA/index.html?load=nerdy_nights_out.html). They are a great starting point to development using 6502 for the NES. Also check out the [NESDev Wiki for more documentation](http://wiki.nesdev.com/w/index.php/Nesdev_Wiki).

The Nerdy Nights tutorials include code downloads that also include an assembler, NESASM3, for Windows. The same assembler is available online for Mac and Linux and is really easy to use, and will take your ASM source and assemble directly to .NES file format, which you can run emulators like FCEUX. The wiki also has some documentation on putting these files on cartridges, though I'm not familiar with this aspect of development.",1530983898.0
llkiwi2006,"I don't know of any, but you should look into the romhack and tas communities, they will have plenty of resources",1530955999.0
ScrappyPunkGreg,"Check out this ""start here"" repo on GitHub: https://github.com/gregkrsak/first_nes

It's based on (among others) the bunnyboy tutorial, but uses cc65 instead of nesasm.

Included are quick start instructions and a makefile for a .NES target builds.

(I'm the author-- feel free to contribute!)",1531247412.0
baggyzed,"The branch version does a single neg directly on eax inside the branch, whereas the cmov version does a mov from eax to edx, then a neg on edx, and only after all that, it does a cmov from edx back to eax.

Without that extra switch between eax and edx, it would probably take the same amount of time.

EDIT: The article already tries to explain this, using ""cycles"", Simply put, cycles are the unit of measuring ""time"" on CPUs (1 second = <cpu frequency> cycles). Each instruction executes for one or more cycles (I think 'nop' takes 0 cycles), so the more instructions you have, the more cycles they will use. Although this rule applies less strictly to modern CPUs, which will usually try to optimize a block of instructions before they are executed (kind of like an optimizing compiler, but not that advanced), thus executing them in less cycles than they would usually take. You don't have to start counting cycles when programming in asm (unless you're programming for older CPUs, where squeezing out every possible cycle is important). It's usually sufficient to just count instructions, like I did above.",1530628852.0
aqrit,"ofc, it should be done using `adc`.

but good luck trying to trick a compiler into using that.",1530756116.0
SoulRip5150,"The processor doesn't know.  It deals with the current operation being pointed at.  The cmp instruction will set 2 bits in the EFLAGS registers.  The zero flag and the carry flag.  After the cmp instruction you will have a conditional jump statement that makes it's path decision based on the EFLAGS bits. 

 For the cmp instruction, ([dst = src] ZF = 1, CF = 0), ([dst < src] ZF = 0, CF = 1), ([dst > src] ZF = 0, CF = 0).  The compiler will decide which condition jump instruction it needs to have the proper logic paths.  

The odd thing is the asm is usually opposite of the c logic.  For example (a > b) would be (cmp b,a) jl(jump if less than). ",1530368190.0
zokier,"The CPU doesn't know nor care about what the high-level source code looked that produced the machine code it's executing. CPU just goes on instruction by instruction through the code. A `CMP` instruction? Just subtract the arguments, set the flags, move on to the next instruction. Was it a `<` or `>` that caused the `CMP` to be emitted? Doesn't matter one iota for the CPU.",1530369851.0
PE1NUT,"On most CPUs, the subtraction or CMP command will set the 'Negative' or 'Zero' status bit (or none of the above) depending on the outcome of the comparison.

The actual decision is taken in the subsequent conditional jump instruction, where the jump only takes place depending on one or more status flags. The conditional jump instruction that was chosen, in combination with whatever the preceding instruction did, decides the behaviour of the test.

http://unixwiz.net/techtips/x86-jumps.html",1530368202.0
faissaloo,"It doesn't, CMP determines a series of properties about its operands and saves them to the EFLAGS register. What the compiler spits out can be all manner of things, consider:  

    cmp a,b  
    jl x  

and  

    cmp b,a  
    jg x  

these are equivalent.",1530402439.0
fishybell,"Fantastic write up.

The end gave a good chuckle:

> [3]:Age of Empires has an interesting malloc() implementation, which calls the VirtualAlloc() function with an address which is not 64K aligned, and then proceeds to rely on the OS having rounded the address down, accessing memory which is actually slightly outside the bounds of the allocation.",1530315693.0
baggyzed,"> Microsoft does something interesting in their implementation: the remaining space to allocate remains in eax, the “new” stack pointer is stored in ecx, and the old stack pointer remains in esp until it is updated to its final value at the end of the function. To free up ecx for this use, it's saved on the (old) stack, and restored once all pages have been touched, and eax is therefore free to use as a temporary.

I'm kind'a surprised at this statement.This isn't interesting at all. It's how all functions backup and restore non-volatile registers that they need to use for themselves.

EDIT: OK, they could've used the EBP & EBX registers, and done all that push/pop dance to get a stack frame, but that's what a stupid compiler would do. _alloca was clearly implemented manually, in assembly (just like most memory-related functions in the MS CRT).",1530514870.0
BS_in_BS,"gcc can generate pretty dumb assembly unless you up the optimization level (default is -O0 I believe). try with -O2, -O3, ~~or -O4~~ for better assembly. though at higher levels, it can do more tricks which might make it more difficult to understand",1529799468.0
FUZxxl,"These first few lines are only emitted for the `main` function to work around old versions of the startup code which do not maintain the 16 byte alignment required by newer ABIs.  If you rename your function, they'll go away.  

> Why is it subtracting those values from esp at <+14> and <+17> ? I would say allocating space on the stack for local variables, but main has no local variable. And also, why didn't it make the subtraction in a single step ? Why two ?

You see all this pointless code because you turned off optimizations.  Enable optimizations and all of this is going to go away.",1529840826.0
nemotux,"The error is because you have no definitions of the readint and writeint functions that you're calling. I don't really remember anything about Borland's library support and am not familiar with these function names, but perhaps you are expecting these functions to come from a library somewhere? If so, you probably need to specify that library to the linker (tlink) so it knows where to find the relevant code to link against.

Edit: fixed a word.",1529406567.0
FUZxxl,"http://idownvotedbecau.se/imageofanexception/

Please do not post just images of your error messages! Always copy/paste the error message into your question so others with the same question can find it easily!",1529427865.0
FUZxxl,"It's called effective address because it computes the effective address of the given memory operand and stores that in a register instead of loading from memory.  The effective address of course being the address that results from the address computations in the memory operand.  For example, if your memory operand is `12(eax,ebx,2)` (in Intel syntax, that would be `[eax+ebx*2+12]`), `eax` is 10 and `ebx` is 20, the effective address is 10 + 20*2 + 12 = 62.",1529319109.0
FUZxxl,">     msg: db ""hilo"", 4, 0

What do you expect the 4 to do here?  A newline is ASCII code 10 if that's what you want to do.

I see that you use C standard library functions as well as raw system calls in your program.   This is the source of your problem: you do a `printf` without a newline, causing `printf` to only write to its internal buffer.  Then you exit the program with a direct system call instead of calling `exit` or returning from `main`, so the buffer is never flushed.  To fix this, simply return from `main` or call `exit` instead of doing a direct `_exit` system call.",1529307767.0
fishybell,I learned from [this one](http://highered.mheducation.com/sites/0072467509/index.html). It targets a virtual processor -- the [LC-3](https://en.wikipedia.org/wiki/LC-3) -- designed to have as little functionality as necessary to get work done. It's a great starting place to get used to the constructs used in assembly language.,1529161872.0
tobiasvl,I don't understand what the exercise is. What's the input and output? Are the letters user input (and screen output?) or registers?,1528837078.0
TNorthover,What have you got so far?,1528713573.0
zefyear,"You can work up a scheme for ""portable"" assembly with with nothing more than m4 macros and a reasonable build tool.

As far as (x86) assemblers are concerned, I use NASM but I've heard YASM is somehow a ""better"" replacement. 

Emacs includes a serviceable major-mode, although I personally use the fantastic `nasm-mode`. Vim includes only very basic syntax highlighting for editing x86 assembly, although syntax files exist of course.

I've never used the tool but some serious hackers I've met use [terse](http://www.terse.com/). Terse, as I understand it, allows for some ""portable"" assembly, but with more conditional inclusions and less 'generic' instructions than something like LLVM IR. If you do use it, you'll undoubtedly have to manually write out your opcodes for every new instruction (age, not sophistication is the issue at hand here). I've had to do this with the Plan9 assembler (an ancient ancestor of the Go assembler) and it's every bit as tedious as it sounds.


In all of these cases, you're going to soon find that ISAs differ from one another in subtle and substantial ways. And while it's always possible to code to the lowest-common-denominator, you'll be getting the worst of all worlds if your `repne` is expressed as a series of conditional branches because you wanted ""portable assembly"".",1528689501.0
TNorthover,"LLVM's actual assembler is designed to be compatible with the GNU one. If you're going to be moving between architectures they're a pretty good choice since the instructions change but the surrounding directives remain roughly the same so there's less to learn each time.

The flipside is that the directive syntax isn't especially adapted to any particular architecture so it can be a little clunky at times. On x86 you probably want to use the `.intel_syntax` directive to make that slightly better because AT&T is pretty ugly.",1528699354.0
ghostsarememories,"You forgot [a86](http://eji.com/a86/features.htm#FeaturesA86) assembler. 
",1528737663.0
baggyzed,"> there needs to be 6 digits.

> every digit should be between 1 and 6.

> there should be no double, so no two #5 within those 6 digits.

I've never done one of these, so this might be a stupid question (please ignore if that is the case): can't you just brute-force it?",1530194227.0
__Cyber_Dildonics__,Are you doing this on the board itself or an x86 desktop?  ,1528472382.0
fb39ca4,Do you have an FPU available?,1528350310.0
,[deleted],1528206644.0
,[deleted],1528152036.0
ScrappyPunkGreg,"TL;DR - Using a .BSS can bloat programs that need to be small, with the proposed solution of:

>One solution would be to use the very top of the allocated stack region (upper limit) as a place to store your data. Since the Windows loader will allocate pages for the stack of your main thread when your process is initialized, we can tell the loader to allocate a little extra for us to use for general purpose data storage.

Is there any way to guarantee that future versions of Windows will maintain the behavior detailed in the article?
",1528381687.0
ScrappyPunkGreg,"This is very well-written. I'm impressed.

Lots of good, tiny details here, like a quick palette initiation with ```inc```, and a 32000 count ```stosw``` clearscreen.

Target is MS-DOS .com file, by the way.",1528037175.0
CJKay93,"This went way over my head.

Thanks for posting, reallying interesting read regardless.",1527966838.0
DOOMReboot,You're such a POOPBUTT.,1527767078.0
jedwardsol,"> If it is command destination, source

It isn't.

There are 2 ways of writing x86 assembly.  The Intel syntax which is `instruction  destination, source` and AT&T syntax which is `instruction source, destination`

All the `$` and `%` mean this is AT&T",1527477886.0
kingobob,"Try using - fomit-frame-pointer, and the usage of the stack will become more clear. Stacks grow down, and are generally used by subtracting down from the current bottom of the stack. ",1527482639.0
spc476,"Unix tends to use AT&T style syntax, which is not what Intel uses.  Second, here's my commentary on the code you've presented:

Set up stack frame.  It's not used here, but the compiler generated the code
anyway.

        func1
                push    rbp
                mov     rbp,rsp

`EAX` is how we return data to the caller.

                mov     eax,2

Remove the stack frame and return to the caller.

                pop     rbp
                ret

This sets up the stack frame so we can reference local variables `l` and `res`.

        main
                push    rbp
                mov     rbp,rsp
                sub     rsp,16


Call `func1()`.  I'm not sure why `EAX` is set to 0 ...  perhaps a quirk of
the compiler or needed for this particular OS.

                mov     eax,0   ; not sure why this is here
                callq   func1

Save result of `func1()` to `l`.

                mov     [rbp-4],eax

Set `res` to `l + 2`.  This code isn't optimized because `EAX` already has
the contents of `l` so there's no need to reload it.

                mov     eax,[rbp-4]
                add     eax,2
                mov     [rbp-8],eax

Call `printf(""RESULT..."",res)`.  The calling convention for x86-64 requires
the paramters for a function in `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`.  If
there are more than 6 parameters, the rest is on the stack.

Again, this code isn't optimized.

                mov     eax,[rbp-8]
                mov     esi,eax         ; RSI = 'l' (second parameter)
                lea     rdi,[rip+0x95]  ; RDI = string (first parameter)
                mov     eax,0           ; again, not sure what this is for
                call    printf          ; call printf()

Return 0 to caller.

                mov     eax,0

Remove the stack frame.  Since we had local variables, there's a bit more to
removing the frame than before.  The leave instruction does that for us.

                leave
                ret
",1527484772.0
ease78,">if you need me to post the code i can do that too !

Do that. In a more general sense, this is an exahustive search problem. I'm assuming you have a double array as your map. Just go through your map's indices, and look for 1's. Return the index.

I mean it's not trivial given it's MIPS. Good luck with that.",1527180691.0
TNorthover,"Properly printing a 2-word quantity in decimal notation is fairly tricky. You'd have to be able to implement the repeated long-division needed to recover the string one digit at a time.

If it's just for personal use though, you can just print the two values and stitch them back together afterwards (in a script or whatever). If you print them as hex and skip a space between them no-one will even notice!",1527156325.0
dnabre,"Not that familiar with what MARS provides. What is the format of the time in the two registers. If it's the pretty standard seconds and microseconds as two separate numbers. 

You shouldn't have too much trouble converting and combining them into one floating point number. You can then print that number (if you have something to print floats). 

You can do the same sort of combination with basic math operations shouldn't be too hard. Or just printing integer '.' integer. 

If it's a two-register (32-bit each, 64-int integer), you can do arithmetic shifts  to toss the low-order bits of the lower-order register, pull the low-order bits from the higher-order register and tack them on to the high-order end of the low-order register. Basically dividing the whole 64-bit integer by 2 until the upper 32-bits are empty (all 0 bits). Then just print the lower order number. 

The above will take some bit manipulation work, but it's all relatively straight forward is you understand how the operation works.",1527192704.0
InfinitelyManic,"There are really no tricks; just good techniques. 

The key you must understand about ASM programming is that you are generally controlling every bit that goes into registers, memory, and onto the stack. 

If your course intends to allow user defined functions then you should create those functions pursuant to calling conventions for your OS. See https://en.wikipedia.org/wiki/X86_calling_conventions

You need to understand how the stack works in respect to how it grows, how to keep is aligned, etc. Reading the calling conventions, among other material, will help you. 

I generally avoid placing too many items onto the stack, willy nilly, since accessing memory [stack] is slower than accessing registers. But you need to following the class material. ",1527261542.0
aqrit,"One can create a “stack frame” by sacrificing a register to hold a base pointer.

IMO, the biggest failing of all macro assemblers is their not being able to track variables on the stack  without  stealing a register.",1527347001.0
Daneel_Trevize,"Much like your post, you should probably break it down into steps:

Confirm you can compile a Hello World program for MIPS32/your target environment.

Clarify if you mean argument string supplied at executable launch, or reading from input once the program's already running.

Adapt the Hello World to instead output the supplied string.

Clarify if you meant string or character, as typically a character is 1 byte, while an integer is typically 32bits, so your string would be limited to 4 useful values (and maybe a NULL byte terminator) if it were to fit in 1 integer.

Clarify if you meant any characters were valid input, or if only those from the range 0-9 (possibly also a-f if accepting hexadecimal strings) were to be accepted, or something else such as names of numbers, e.g. ""two"".",1527063549.0
FUZxxl,Can you make an [MCVE](https://stackoverflow.com/help/mcve) by repeatedly cutting down your code until only the error remains and then show us that MCVE?  It's hard to diagnose a problem without seeing enough code to assemble it ourselves.,1527070425.0
FUZxxl,They aren't in the manual because you are supposed to use the C preprocessor and include the file `<sys/syscall.h>` for the numbers.  This header defines macros of the form `SYS_xxx` where `xxx()` is the desired system call.,1526899331.0
InfinitelyManic,"I think if you install the standard version of gdb you can locate the xml files for the various system calls as follows:

    $ locate syscalls | less 

    /usr/share/gdb/syscalls/aarch64-linux.xml
    /usr/share/gdb/syscalls/amd64-linux.xml
    /usr/share/gdb/syscalls/arm-linux.xml
    /usr/share/gdb/syscalls/gdb-syscalls.dtd
    /usr/share/gdb/syscalls/i386-linux.xml
    /usr/share/gdb/syscalls/mips-n32-linux.xml
    /usr/share/gdb/syscalls/mips-n64-linux.xml
    /usr/share/gdb/syscalls/mips-o32-linux.xml
    /usr/share/gdb/syscalls/ppc-linux.xml
    /usr/share/gdb/syscalls/ppc64-linux.xml
    /usr/share/gdb/syscalls/s390-linux.xml
    /usr/share/gdb/syscalls/s390x-linux.xml
    /usr/share/gdb/syscalls/sparc-linux.xml
    /usr/share/gdb/syscalls/sparc64-linux.xml
    ...

",1526867388.0
13_0_0_0_0,What's the history of the table look like? Have they been steadily adding them over the decades? Or were most of them designed up front?,1526871514.0
ThrowAwaylnAction,No wonder why you don't understand; the image is incoherent. The only part that's discernible is bitwise concatenation.,1526851135.0
kingobob,"Pseudodirect is a MIPS jump instruction. The first 4 bits come from the PC and the next 26 come from the pseudodirect command itself (since the opcode is 6 bits).

The last two bits are just zero to make it aligned. Basically, this is a MIPS short jump. ",1526864404.0
BCosbyDidNothinWrong,/r/titlegore,1526920741.0
magion,Maybe this will help? https://www.guidodiepen.nl/2017/03/clever-bit-tricks-with-ascii/,1526790483.0
CSI_Tech_Dept,"I personally never seen EBCDIC outside of learning that it exists. Is it still used anywhere?

As for ASCII I think memorizing it is overkill. I only remember that 0 is terminating character, that 0x20 is space, between null and space there are control characters, that 'A' starts at 0x41 and 'a' starts at 0x61, and digits start at 0x30 etc",1526833277.0
FUZxxl,"Print out a little ASCII sheet and tape it to your monitor.  After referring to it for a while, you start to know it by heart.",1526809424.0
Enlightenment777,"In 2018, other than for school tests / historical discussions / old code / outdated IBM hardware, EBCDIC is obsolete.

The easiest way to convert from ASCII to EBCDIC is using a simple character lookup table, and a 2nd table for converting from EBCDIC to ASCII.",1526834238.0
FredSchwartz,"ASCII paper tape and Teletypes, EBCDIC punch cards and IBM.  Look at how adding a bit to a character in ASCII moves it from control character to uppercase letter to lowercase to numeral to special, and how incrementing the value moves you to the next letter or numeral. Also look at a punch card and how the zones map to ranges of letters and how the EBCDIC alphabet is discontinuous.  The Wikipedia pages are excellent, and look for an article by Eric S. Raymond about things programmers used to know.",1526827435.0
InfinitelyManic,"I think the encoding will be the least of your worries. If you wish to get a headstart then focus on the instruction set of the class; e.g., x86, x86-64, ARMv7.  Also get familiar with the tools that you will be using in the class; e.g. NASM, GAS, objdump, readelf...  Definitely learn how to convert between hex binary, decimal. ",1526854847.0
FUZxxl,int 0x80 is not the right way to do system calls in 64 bit mode. Where did you get this from?,1526671204.0
skeeto,"You didn't say what operating system you're using, but I'm going to
assume it's Linux. It looks like you're mixing up 32-bit and 64-bit
assembly. You can't just switch to 64-bit registers and do everything
else the same way.

You're writing 64-bit assembly but making an old-fashioned 32-bit system
call. You need to make a 64-bit system call, using `syscall` instead of
`int 0x80`. Here's the calling convention from syscall(2):

       arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7
       ──────────────────────────────────────────────────────
       x86_64        rdi   rsi   rdx   r10   r8    r9    -

And a [syscall
table](http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/). As is you're using `stat(2)`, which I'm sure you don't intend.

Also keep in mind that `rbx` is a non-volatile register, though you
won't need it when you make the syscall correctly.
",1526671283.0
TNorthover,"Specific questions are much more likely to be answered than ""do my homework for me"".

Edit: Oh FFS! You even posted this on /r/Do_My_Programming, despite it being long dead! Muppet.",1526584184.0
x86_heirophant,Vim,1526251323.0
skeeto,"I wrote my own Emacs major mode to get what I wanted: [nasm-mode](https://github.com/skeeto/nasm-mode) + [x86-lookup](https://github.com/skeeto/x86-lookup).

> but how do I even assemble code for it?

Use [nasm](https://www.nasm.us/).",1526265268.0
DOOMReboot,Tasm,1526253905.0
FUZxxl,nano and the shell.,1526256880.0
sadbasturd99,"The way I use assembly which is more of just a little bit of a hobby, you can put it into C# code, Visual Studio, pretty much any version.  A good example of this is the Sieve of Eratosthenes.",1526302039.0
dybuk87,Notepad++ ,1526367715.0
skeeto,"You don't get to have raw VGA access on Linux — or, really, any modern
operating system. The closest thing is the [framebuffer](https://cmcenroe.me/2018/01/30/fbclock.html) `/dev/fb0`.
Switch to a virtual console (before running your program), [open that
file](http://www.ummon.eu/Linux/API/Devices/framebuffer.html), and then write raw pixel data to it.

Alternatively you could call OpenGL from assembly. Obtaining an OpenGL
context from assembly would be a ton of work (speaking the X protocol)
but you could use a library for that.
",1526249352.0
charleslomboni,Thanks for sharing bro. ,1526132547.0
dybuk87,I update language to english in github,1526221562.0
DOOMReboot,Very nice,1526204491.0
MajorDerp4,"You have to make a loop that iterates by one and breaks once the value equals the inputted number.

        #you can figure this out with a quick google search

    $t0 = userInput 

        #user inputs 15

    loop:
        beq $t1, $t0, continue
        addi $t0, $t0, 1
            #add the other conditions in here
        j loop",1525832383.0
MajorDerp4,Do you still need help with this?,1525892910.0
MajorDerp4,"You managed to submit this two times please remove this one, I have answered your question on the other post.",1525832484.0
MajorDerp4,Spacing ,1525800304.0
TNorthover,"This is the IDE editing your code and adding those two lines? The first one is weird and wrong, but most functions start with

    push ebp
    mov ebp, esp

for debugging reasons. It's known as setting up a frame pointer and lets debuggers show you the callstack/backtrace.

The idea is that `ebp` points to a linked list of what's called ""frame records"". Because of how it's created each one is two pointers: the address of the next record followed by the address to return to. If the debugger looks up where that return address is (either just within a function, or with debug-info the exact source line) it allows you to see where your function was called from, where that was called etc etc back to `main`.

As for how to stop it, I'm afraid I have no idea.",1525806095.0
spc476,"You haven't specified which architecture, but I'll assume x86 for this.  The easiest way to do that is:

        mov             eax,-3          ; numerator
        mov             edx,7           ; denominoator
        cvtsi2ss        xmm0,eax        ; load as single IEEE-754
        cvtsi2ss        xmm1,edx        ; load as single IEEE-754
        divss           xmm0,xmm1       ; divide, result in xmm0

`CVTSI2SS` means ""ConVerT Scalar Integer to Scalar Single"".  ",1525553830.0
jitspadawan,">they were not fond of my question

IDK they seemed to think it was cute and at least one person tried to help...",1525783217.0
FUZxxl,What architecture are you programming for?,1525577574.0
,[deleted],1525725822.0
B-Elgy,"Obviously we can’t do all of your code for you, but we’ll give you some points. Try writing the program in c, then convert it to assembly. If you have issues during the conversion step, then we’d be happy to help.",1525400787.0
pobretano,"Hello! I have no practical knowledge of assembly, but I can help with the algorithmical reasoning. 

You can use an iterative approac to fill the triangle/vector, the same way you would fill the triangle manually. Look at the example below:

    
    1
    1 1
    1 2 1
    1 3 3 1
    1 4 6 4 1
    [] [] [] [] [] []
    

We can suppose the first five lines are in the memory already, specifically the output vector.

In order to fill the \[blank\] line, you need only the last one. In fact, you just need three variables that way:

      a    b     c     d  ...
    ...  [a+b] [b+c] [c+d] ...

In our example:

    1 4 6 4 1
    [1][1+4][4+6][6+4][4+1][1]

As I already said, I am not good in ASM, but it can be easily implemented in a language like C: we just need a variable acting as a pointer and two to add terms \(and maybe another in order to store the value in memory\).",1525393782.0
DOOMReboot,Why are you running out of registers?  Are you not allowed to use memory?,1525455223.0
Rockytriton,You have to draw one in graphic mode ,1525216995.0
DOOMReboot,You want to display text and a cursor in 320x200? ,1525552562.0
dybuk87,What environment do you use?  Is it dosbox? ,1526216480.0
TNorthover,"This problem is basically what the C++ exception mechanism was designed to solve. There are lots of moving parts involved that you can't hope to reproduce locally from your own assembly code:

  + You have to reclaim the stack space allocated and restore sp to its value before the call.
  + You have to restore all other callee-saved registers (possibly distributed throughout the stack) to their original values in One.
  + You have to run any cleanup routines required on your path through the call-stack (destructors etc).
  + In addition, your specific case involves a jump after you reach the callee, which is extremely problematic unless the compiler knows it's going to happen (otherwise variables won't be in the registers the compiler expects by the time flow reaches `LABEL_1`).

Solving these properly in C++ involved annotating every function with metadata about which registers it saved and where, and writing a whole unwinder (e.g. `libunwind`) to process that data and perform the necessary actions safely.

I don't think you can realistically replicate that in local assembly (or should try); your best bet is to hook into the existing infrastructure: call `__cxa_throw` (or whatever the MSVC equivalent is) in MyImportedFunctionFromAnotherModule and put appropriate catch clauses in One to deal with the exception and dispatch flow to LABEL_1.",1525202963.0
ScrappyPunkGreg,"Have you thought about writing it in C and observing what the compiler outputs, perhaps with and without optimizations turned on?",1525129812.0
TNorthover,What have you got so far and where are you stuck?,1525071572.0
PerfectCreatures,"Lol this is java; java always running on emulator it has it own kind of assembly so that why it ""write once, use anywhere""",1525140585.0
FUZxxl,Dafuq is this thread?,1525083549.0
__Cyber_Dildonics__,Delete this nonsense,1525060652.0
PerfectCreatures,Lol because it not compatible. Simple thing.,1525047035.0
PerfectCreatures,"You suck that why! I'm hater, i never forgive, i never forget!",1525052100.0
spc476,"That's because the command is not doing what you think it's doing.  It's treating the result of `ECX + (ESI * 4)` as an address, and adding the contents of that address to `EDX`.
",1525055966.0
B-Elgy,"I made this server for a class, and thought it was kinda cool. It’s only been tested on MacOS, but I’d assume it would work on all XNU machines. Any and all criticism is welcome.",1525007773.0
Forteeek,"hey, great job! must've been quite a challenge, kudos for wrapping your head around it",1525018958.0
spc476,"To call this function:

    AH = 06h
    DL = 0 .. 254 (character to output)
    DL = 255 (check for input and return if exists)

If `DL` is *not* 255, then this function returns nothing.  If `DL` was 255 upon input, then this returns:

    ZF (zero flag) = 0
    AL = input character

or

    ZF = 1 (no input)

So, an implementation of `ReadChar` might be:

        readchar        mov     ah,6
                        mov     dh,255
                        int     21h
                        jz      readchar
                        ret

`ReadString` would be a function that repeatedly calls `ReadChar` and stores the data into memory.  You will need to use the `BX`, `SI` or `DI` registers as a pointer to memory.  `WriteString` will call `INT 21h`, function 6 repeatedly for input, reading consecutive bytes pointed to by `BX`, `SI` or `DI`.  Some examples:

        mov     dl,[bx] ; read character pointed to by BX into DL
        mov     dl,[si] ; read character pointed to by SI into DL
        mov     dl,[di] ; read character pointer to by DI into DL

        mov     [bx],al ; save character in AL to memory pointed to by BX
        mov     [si],al ; save character in AL to memory pointed to by SI
        mov     [di],al ; save character in AL to memory pointed to by DI

        inc     bx      ; increment pointer in BX to next location
        inc     si      ; increment pointer in SI to next location
        inc     di      ; increment pointer in DI to next location

That should be enough to get you working.
",1524963471.0
AngusMcBurger,"The \+4 is likely because it is relative to the end of the current instruction rather than the start, much like jumps and branches",1524830327.0
TNorthover,"I'm going to assume you're asking about that extra ""+ 4"" rather than the point of PC-relative addressing itself.

If so, it's because it made early CPU designs slightly easier to implement. They tended to have a simple 3-stage pipeline (fetch, decode, execute) so had the PC of the instruction they were fetching from memory lying around all the time. That was 2 instructions ahead of the PC of the instruction they were actually executing. So by making reads (& writes) of PC return that value directly, they saved having to add logic (a subtraction unit, probably) to adjust it to the instruction that was actually being executed.

Of course, as CPUs became more sophisticated, that extra logic became less and less significant in the scheme of things. You even needed to insert compensation anyway when the CPU didn't have exactly a 3-stage pipeline. But because they needed to keep compatibility they couldn't get rid of this offset.

At least, that's what happened with ARM. The good news is that the did fix it when they made a fresh break with the 64-bit instruction set.",1524831025.0
TNorthover,"It's a ""load byte unsigned"" instruction. By default a MIPS load will take the contents of memory, load it, and sign extend the result to 32 (or 64) bits.

This is fine for subsequent arithmetic if your byte in memory represented a number in the range [-128, 127], but often only positive numbers are allowed and it should be [0, 255]. That's when you'd use `lbu`.

I suspect your teacher said it was for overflow because if you only care about arithmetic at the byte level (and avoid division) then it doesn't actually matter which you use -- the first 8 bits of the result only depend on the first 8 bits of the inputs for addition, subtraction and multiplication.

If you want to determine whether an 8-bit calculation overflowed though, it does start mattering whether the inputs were signed or unsigned and a common way to check is to do the calculation (correctly) at 32-bits and then look at whether the bigger result is still within the range of a byte.",1524772803.0
,"Please only use either this for .EXE format

    FORMAT MZ

or this for .COM format.

    ORG $100 ; $100 = 0x100 = 100h

Anyway, after the label

    DIVISION_LOOP:

you should have the DX register cleared after EVERY divisions, not just when you initialised for the first one.

So the first path of the code should be something like this :

    ...
    DIVISION_LOOP:
        XOR DX,DX ; Clear the DX register, which is equal to MOV DX,0 but use 1 byte less.",1524752542.0
dybuk87,"There are two main errors:

First already mentioned , you have to clear dx registry at  division\_loop startup:

 DIVISION\_LOOP:    

XOR DX,DX 

if you dont do that then dx will never be 0 \(after div cpu put  rest of the division into dx\).

In next loop you will divide   dx:ax by  bx, so the dx part will go to ax, and ax will by always non zero value.

Another problem is print method, you do not try to print string but chars change print loop to:

	print\_loop:

		pop ax

		push cx

		mov cx, 1

		mov ah, 0eh

		xor bh, bh

		add al, '0'

		int 10h

		pop cx

	loop print\_loop",1526238169.0
FUZxxl,“I couldn't make it work” is not an error description.  What does your program to and what do you expect it to do instead?,1524736139.0
TNorthover,What are you using as a debugger? Being able to step through assembly programs instruction by instruction is essential for working out what's actually going on when things break.,1524737475.0
DEElekgolo,"Some Words™  would help.

Also checkout the [simd ](https://www.reddit.com/r/simd/)subreddit.",1524723040.0
willrandship,"Where did y and z come from? If you're checking 3 numbers, shouldn't the function be

def function(x,y,z):

Regardless, it's pretty straightforward.

Assuming x,y,z are in registers $4,$5,$6, and we're returning in $2 and $3.

First, copy $4 to $2 and $3

    move $2 $4 
    move $3 $4 

Then we do some comparisons

You can implement a < b and a > b like this:

    #a > b
    sub $temp $a $b
    blez $temp past_if
    #your if statement
    :past_if


    #a < b
    sub $temp $a $b
    bgez $temp pastif
    #your if statement
    :pastif

All that's doing is:

temp = a - b

if temp >= 0, skip the next chunk of code (so it runs if temp < 0)

The if statements themselves would just be the copying from $4, $5, and $6 to $2 and $3.",1524658099.0
jedwardsol,https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Loop_Instructions,1524513770.0
jedwardsol,"You know how many characters wide the screen is.
 1^st character on the 2^nd line is immediately after the last character of the 1^st line.

In other words,  calculate what number needs to go inside the `[]`",1524512501.0
ScrappyPunkGreg,"(first block) These lines suggest you're making a .COM file, where the code and data segments are the same. If you need to know more about that, look up the segmented memory architecture of the x86.

    assume cs:code, ds:code
    org 100h 


(second block) This looks like you're in text mode (as opposed to a VGA mode, for example). You're using the accumulator to set one of the extra segment registers to the start of the text mode screen.

    mov ax,0B800h               
    mov es,ax 


(third block) The memory locations B800:0000, B800:0002, B800:0004, and so on are the locations where text characters are written. The attributes (color, etc.) are the odd bytes. So, yes, two bytes per character.

    mov byte ptr ES:[0], 218 
    mov byte ptr ES:[2], 196
    mov byte ptr ES:[4], 196


(fourth block) After this, I'd prefer to (someone correct me) call the exit to DOS function:

    mov ax,4c00h
    int 21h 


EDIT: Added clarification on which code blocks go with each paragraph.",1524514934.0
cyandyedeyecandy,"Each cell in text mode consists of a character byte (even addresses), and an attribute byte (odd addresses). When accessing `es:[3]`, you're writing the attribute byte for the 3rd character.",1524509408.0
tekyfo,"Many of these cases are easy to avoid for the compiler, so they will not appear even at low optimization levels (unless maybe -O0). It therefore does not make sense for the CPU to try to be faster in these cases.",1524474154.0
FUZxxl,">  am I able to call a function in C that in the C program that is written as commands in assembly?

Yes.  Just call it from your assembler code and remember to link in the C object during linking.  There are two things you need to do beforehand:

* find out what the calling convention for your platform is
* find out how the C compiler decorates symbols.  Typically, there is either no decoration (i.e. to call `printf` you call the symbol `printf`) or decoration by a single underscore (to call `printf` you call the symbol `_printf`)

> I did some research and I am pretty sure what I am looking for is inline assembly but I am not sure.

No.  For the sake of all that is holy, don't use inline assembly. It's really not what you need.",1524313400.0
CJKay93,"To make calls to functions written in assembly, you need to make sure the assembly functions you write follow the same [calling convention](https://en.wikipedia.org/wiki/Calling_convention) as your C compiler.

While the compiler is technically free to do what it wants, in the context of the Nucleo boards it probably won't (it takes a lot of effort to document a calling convention!). The Nucleo boards use STM32 microcontrollers, which themselves use Arm Cortex-M CPUs, and Arm already defines a calling convention for these CPUs: the Procedure Call Standard for the Arm Architecture (AAPCS) which [you'll find on Arm's InfoCenter](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/index.html).

The section that is relevant to you is §5.1.1, which will tell you what the compiler will use each register for, and consequently what it will try to do when you ask it to call your assembly function.

To make the call, you will need to ensure that you have linked both your assembly file and your C file into the final binary/executable (ask your professor if you're unsure about how to do that), and you will need to write a [function prototype](https://en.wikipedia.org/wiki/Function_prototype#Example) in C that matches the name and parameters that your assembly function is expecting, and returns what your assembly function is returning.",1524318395.0
FUZxxl,Do you have a question?  “I'm having trouble getting qemu to work” is not an error description and gives other people absolutely no starting point to figure out what went wrong.  Please be a bit more detailed.,1523981765.0
chaign_c,"Hey you can use arm_now to quickly deploy a qemu virtualmachine, within 30 secondes (install + setup + run).
https://github.com/nongiach/arm_now",1524564930.0
dennixtreme,"does it crash/exit prematurely, or does it remain in an infinite loop?",1523967293.0
aqrit,"where does your code start executing?

cause I'd guess it starts executing in PRINT_BOARD proc then dies when it hits the return.

edit:
aka. the call never gets executed
the first instruction executed by the program is:
    mov bx, 0B800h

    MAIN PROC
        PRINT_BOARD PROC
            ...
            RET
        ENDP
    ...
    ENDP

",1524004527.0
jedwardsol,"write writes a series of bytes,   it doesn't format them in any way.  The 2^nd parameter is a pointer to the bytes to write,  not a value.

You will need to create a string yourself - arrange for a `4` and then a `0` to be written.",1523801064.0
B-Elgy,"There are a few issues with your program.
First the write syscall takes the following parameters: 
eax: 4  (write syscall)
ebx: file descriptor to print to (1 for stdout) 
ecx: pointer to string 
edx: length of string

In order to write a string it will write edx bytes starting at address ecx, to file descriptor edx.
You are missing the length parameter, but that isn’t the main issue. You are currently passing ecx as 40 this means that it is trying to read from address 40. You need to convert the number 40 to a string “40” in ram. There are many ways to do it, the easiest would probably be to link against the c standard library and call sprintf. I personally prefer to use a method which prints the hex value of a register, this is very useful for debugging. Examples of both below. (Intel Syntax)

Sprintf example:

    .section text:
    global start
    .extern sprintf
    start:
    mov esi, 20
    add esi, 20
    push esi
    push dword formatString ; use qword for 64 bit
    push dword outputString ; same as above
    call sprintf
    mov eax, 4 ; for the following on a 64 bit system use qword instead of dword and rax,rbx,rcx,rdx, instead of eax,ebx,ecx,edx
    mov ebx, 1
    mov ecx, dword outputString
    mov edx, 2
    int 0x80
    .section data
    formatString: db ‘%d’,0
    outputString: times 2 db 0

My method: (same 64 bit changes as above)

    .section text
    mov esi, 20
    add esi, 20
    mov eax, esi
    call printEax
    ;exit
    printEax:
    mov ecx, 0
    mov edx, dword printEaxBuf
    .loop:
     rol eax, 4
     mov ebx, eax
     and ebx, 0x0F
     add ebx, dword hexString
     mov edx, byte [ebx]
     inc edx
     dec ecx
     jnz.loop
     mov eax, 4
     mov ebx, 1
     mov ecx, printEaxBuf
     mov edx, 9
     int 0x80
     ret
.section data
hexString: db ‘0123456789ABCDEF’
printEaxBuf: db ‘00000000’, 0x0a
     
     
     
    ",1523802668.0
InfinitelyManic,Can you show your code and debugger values? ,1523665831.0
chaign_c,"Hey, you ca use arm_now to easily deploy a mips virtualmachine https://github.com/nongiach/arm_now ",1524565148.0
dumael,"> > Oh yeah, you also shouldn't put a multi-instruction pseudo-instruction in the branch delay slot, because only the first instruction will execute as part of the branch delay slot. I never tried it, but I hope the assembler warns you when this happens.

> dumael$ cat test.s

    .set mips32r2
    .set noreorder
    jr  $25
    ulw $4, 0($5)

> dumael$ /opt/local/mips-img-linux-gnu/2016.05-03/bin/mips-img-linux-gnu-as test.s -o test.o

    test.s: Assembler messages:
    test.s:4: Warning: macro instruction expanded into multiple instructions in a branch delay slot

Yup. GNU MIPS assemblers running in what's called 'reorder' mode, will attempt to fill the delay slot, or shove a nop in there. In noreorder mode, you get warnings.

> One rule about branch delay slots is that you cannot put another branch instruction in a branch delay slot. Because that would be Inception-level crazy.

MIPS claims this is what's called **UNPREDICTABLE** behaviour. Or, throw the ISA manual out the window, the processor has left the reservation. Ok, I'm exaggerating a little, **UNPREDICTABLE** behaviour does have constraints, but your current program's execution is fubar.

I read that a non-minor cpu architecture either had a defined or implementation defined behaviour that putting a branch (branch 2) in a delay slot of a branch (branch 1), could result in the execution of a single instruction from branch 1's target, before transferring control to branch 2's target.",1523559775.0
jedwardsol,"How much do you understand about what the code is doing?  

Many of the comments are incorrect and they're mainly a repetition of what the instruction is doing instead of description of why the instruction is there.

What are the parameters to the function?  Work out what the code is doing with them,  so you can rewrite the algorithm in English.  Then you can work out how to undo it.  ",1523414885.0
TNorthover,"You've basically got to reimplement a long division algorithm like you learned in school, only instead of there being 10 ""digits"" there are 18446744073709551616 of them.

Fortunately the x86 divide instruction is already specified to handle a 128-bit input so you won't have to go through any contortions to deal with the case where you have to carry a digit.",1523369536.0
DOOMReboot,The answer should be so easy to find that it's ridiculous to ask here.  It should be one of the first things you learn in class.  Don't you have a textbook?,1523292233.0
__Cyber_Dildonics__,This is the kind of stuff they should teach in school,1523256655.0
quasar_ayush,I dont know the concept,1523329424.0
quasar_ayush,But we were asked to find its answer on our own. So please can u help,1523258002.0
sdmike21,"100% behind the ""format your code"" proposal.",1523043990.0
TNorthover,"It'd be good to give advice about formatting, but if it's ignored all you get is a post that people will ignore because it's ugly. No real harm done.

I really dislike the zero-effort posts, but banning seems a little harsh and anything less is equivalent to any of us telling them to get their shit together. My opinion there would change if people here actually started doing the posters' homework.

A step further are threads where actual payment gets discussed (rare, but it happens) and people that delete their posts after getting an answer. Those are clearly unethical (even if the deleted post was innocuous, it's done because the poster thinks they're concealing wrongdoing) and I think we should have extremely firm stomping policies for those two.",1523044485.0
DOOMReboot,"They should also use a descriptive title instead of things like ""This code isn't working"" or something even less descriptive.",1523190422.0
dumael,"Just to be explicit on MIPS alignment rules for aligned loads and stores; the effective address must be divisible by the size of the access. (E.g. at least 2 bytes aligned for a sh/lh instruction, at least 4 bytes for a sw/lw).

One other thing: one trick MIPS uses (along with other architectures), is to reserve a register ($gp) to point into the (middle of) a specialized data section of an executable in memory called the 'small data section' or '.sdata'.

Provided you let the compiler do the lifting, or know the necessary assembler voodoo, global variables can be stored in that section and accessed with a single instruction.

This is for embedded or static programs. For the likes of Linux or *BSDs and presumably Windows for MIPS for position independent code, this register instead points a structure called the GOT, which holds the addresses of globally accessible symbols.",1523039512.0
shinyquagsire23,"I think you're misunderstanding how compilers work, to be honest. .byte 1 will always just output a 01 byte. This does seem very classwork-esque though but I'll try to not *just* answer the question.

`.equ` is basically the equivalent of C's #define if I remember correctly. Basically you can use those anywhere and it will just substitute in the value. Depending on the compiler you can even use some C preprocessors as well.

And again, depending on the compiler, usually it is possible to do some compile-time math. So if I wanted to write in some value which depended on a `.equ` from earlier (ie in embedded I've used this for baudrate calculations), you can sometimes do something like

```
.short ((someVal*1234) + 1)
```

The lengths of what you do depends a lot on the compiler, I can't stress that enough.

In this case though, if you wanted to add a value at compile time, you could do

    .short Ta+1
    .short Sn+1

and that might work. At runtime you would need to use actual assembly to do the adding. So really it depends on what you're doing.",1523087605.0
BCosbyDidNothinWrong,Ask your TA,1523022878.0
CapitalistLetter,"Step 1: get number from user.

Step 2: multiply that number.

Step 3?: display the result.",1522988461.0
InfinitelyManic,"Is learning x86 or x86-64 Assembly a requirement for your degree program? 

I suggest you learn both since you are likely going to see x86 operating systems and x86 applications on x86-64 operating systems. 

If you are studying on your own, then I suggest you finish the book you referenced; which I also have. 

I also recommend ""Hacking: The Art of Exploitation"", 2nd Edition; which covers x86 Assembly in a exploit writing context. 

Then look at Ray Seyfarth's Introduction to 64 Bit Intel Assembly Language Programming for Linux. ",1522952203.0
TNorthover,"All things being equal I'd skip x86 myself. Even x86_64 managed to iron out a lot of its quirks and it can hardly be called relevant these days for anything except legacy purposes.

On the other hand, if you've got a book that you're happy with and it's x86, go for it! Having learning resources you're happy with is far more important than any particular architecture you learn first. Most of the details are pretty similar across cores once you get down to it.",1522957034.0
reddittidder,"I found David Black-Schaffer's free course on MIPS ISA to be one of the best out there. It also has assignments and labs dealing with MIPS assembly, though it goes beyond it. You may find these videos interesting. If you feel up to it, check out the course that is mentioned in the video descriptions. It is a free course (and pretty awesome IMO)

https://www.youtube.com/watch?v=PlavjNH_RRU&list=PLylNWPMX1lPlmEeeMdbEFQo20eHAJL8hx",1523101383.0
auto-cellular,"Build a tetris or snake game ?
If it's available on your platform, you can use SDL2 as a shared library to access the hardware. 
If you have a pc emulator, you might want to write your game using a build-your-own-system tutorial, your game being what the boot loader would boot.",1522876621.0
skeeto,Solve some challenges over at r/dailyprogrammer.,1522863433.0
dumael,"Fun fact:

32 bit integer arithmetic calculations on a 64 bit MIPS implementation give a 32 bit result, sign extended to 64 bits.

Logical operations don't perform this.",1522787330.0
Brane212,"BTW, I was reading-through RISC-V documentation and so far it looks very much like MIPS...

Am I missing something major here ?

What are significant differences between MIPS and RISC-V ?

",1522819363.0
JonnyRocks,That site doesnt exist. ,1522666382.0
auto-cellular,"You store them 16 bits at a time (FFFF is the max of unsigned 16 bits). If you want a 32 bits number, you have to build it yourself, you'll need two registers to represent it, and you'll need to implement your own operations, out of the 16 bits ones.",1522600680.0
scubascratch,"Typical microprocessors only support simple numeric types like integer and floating point (essentially real) numbers.

To operate on complex numbers you have to break the storage and operations down into the real and imaginary components and do the operations as you would with basic arithmetic on something like a simple 4-function calculator.

Storing a complex number would require storing the real and imaginary components in two registers or memory locations for example.

Adding together two complex numbers requires fetching and adding the real components of the two complex numbers, storing the resulting real component sum, then repeating this operation on the complex components.
",1522596217.0
zokier,"Strictly speaking microprocessors (and by extension assembly languages) do not even have natural numbers afaik, never mind real or complex numbers. I think the closest thing to ""integers"" in programming are finite fields in mathematics. Not sure if floats have any equivalents in mathematics, they are kinda their own specialized things.

If you need complex numbers, check out some libraries like [GNU MPC](http://www.multiprecision.org/mpc/home.html).",1522604037.0
auto-cellular,"To write a program using assembly language, you foremost need a manual.  Then if you knwo C++, you might try to simply write a C++ program for your target platform and then dissassemble it. But you probably don't have to do that for a simple task like you have there. You also have to distinguish between system calls, and processor supported instructions. Then you simply write the program like you would in C++. I you want to be helped, you have to provide a particular question, to express where is your difficulty. Here you simply copy an assignement, and paste it on reddit. That's not something people will respond to, unless you specifically says that you have no personnal interest in it, and would like to find somebody to just do it for you.",1522565525.0
FUZxxl,"I answer a lot of assembly questions on Stack Overflow.  The number one reason for downvotes is insufficient research.  If an answer to your question can be found by reading the assembler manual or by doing some basic research, don't waste other people's time.",1522517885.0
reddittidder,Your question has less to do with NASM and more to do with your understanding of Linux and navigating the shell. Learn those basics first.,1522591409.0
heckin_good_fren,Permissions maybe? Try fixing them~~running with sudo~~.,1522486180.0
jedwardsol,"Read and understand the code ... then notice that it only reads from the BPB; it doesn't write to it.

So it has to be initialised by you (or the formatter) before the code is run.",1522447841.0
AganigA,"I was using the version 9.1.20

I unistalled it and installed the 9.1.19, now it work.

I dont know if the problem was the version or just reinstalling it solves the problem",1522269880.0
jedwardsol,"What do you intend to do with the numbers in array.  now you're calculating  score += (x-1) * 2^x


Also  `mov ax,[bx]  ` will get 2 bytes from the array but you want to read it a byte at a time I think",1522257550.0
CJKay93,I think you might be underestimating the difficulty of what you're trying to achieve.,1522183830.0
xxc3ncoredxx,"A naive approach would be to implement the RAM as an array in your C code and just have global variables for each register, then translate each MIPS instruction to an equivalent C instruction. In fact, I don't see why that shouldn't work as long as your process can access enough memory on the host machine.",1522208907.0
hipstergrandpa,"I know Hopper can generate pseudo code of the disassembled binary. I'm sure other disassemblers can do that as well. From there, you can write the functionality in a higher level language such as C. Trying to do a direct translation from one assembly language to another by hand is a bit much though...",1522191671.0
AngriestSCV,"If you just want to run the executable look into qemu. It dynamicly jits the asm into something that works on the host machine. I'm not sure of your exact problem, but it may be able to help.",1522205612.0
uzimonkey,"1. It is what it is.  All I can say is ""suck it up.""  The alternative is binary which is even less readable, octal which is oddly in groups of 3 or decimal which is extremely awkward when you're representing data.

2. So don't use visual studio?  Any text editor will do, there are literally hundreds of them.

3. Yep.  Again, it is what it is and assembly is what it is because that's just how the CPUs work.  They don't make this easy to learn, they make it this way because it has to be.  Anything piled on top to make it ""easier"" would just get in the way for the people who actually need to use assembly.

4. Um...  yeah?  Assembly is specific to the CPU architecture you're using.  Again, there's no way around that.

5. No, you can't.  You can't do anything in assembly that you can't do in a high level language.  It isn't magic, it's not giving you access to things that programs don't normally have access to.  The operating system is still there to protect you.",1522012374.0
__Cyber_Dildonics__,Maybe you should spend more time learning and less time worrying about what you don't like from the things you don't understand.,1522031950.0
ThrowAwaylnAction,This is a super shitty post.,1522038242.0
FUZxxl,"> Hexadecimal, I can read it, but why do I need that stuff? If you want to not have normal Numbers/Letters, then please use BINARY.

Binary is terribly uneconomic.  It's just a load to type.  If you dislike hexadecimal, you might prefer octal.  The encodings of x86 instructions (specifically, the modr/m and sib bytes) actually kinda make sense in octal, so there's that.

> You need to tell if my machine is x64 or x86.

My one machine is a MIPS.  My other machine is a Raspberry Pi (arm64).  My console is an nvidia Tegra (ARM).  My space heater\^W\^W home server is a SPARC64.  My microcontroller is an MSP430.  My UNIX box is a VAX on which PDP-11 programs can run.  The book I read (The Art of Computer Programming) uses MIX in some volumes, MMIX in others. And on my shelf, I have this PA-RISC box I need to play around with more. Each of these is a different architecture.  Each of these requires you to get familiar with the instruction set and ABI documentation.  Get away from the idea that it's just x86 vs. amd64.

> I'm not 100% sure of this: but I've heard it can damage your computer if you do the wrong thing? (Correct me if I'm wrong)

With modern computers that's pretty unlikely.  The last time you could damage something on an Intel chip was the F00F bug back in 1997.  The bug allows you to lock up the computer unless the operating system takes certain counter measures, but that's about as bad as it gets.

Older hardware might be worse off.  There are some infamous killer pokes you could use to fry your graphics hardware back in the 80s and way back in the 50s, you could send your computers core memory smoking by executing an instruction that jumps to itself, jokingly dubbed an `hcf` (halt and catch fire) instruction.",1522025578.0
BCosbyDidNothinWrong,assembly wasn't created so that some kid who thinks it can damage his computer feels like it's his favorite thing. Nut up and delete this bullshit post. ,1522023217.0
shinyquagsire23,"1. Hex is useful for representing addresses and sizes. If I wanted 1MiB of data, that's 0x100000 in hex, I could *never* tell you the number in decimal, binary I'd forget a 0 maybe. 8GiB is 0x100000000. 4KiB is 0x1000. They're just nicer numbers. Some embedded systems expect certain address alignments for addresses and they also work well with hex.

2. Yeah.

3. Yeah. I like ARM better tbh, there's some fun systems like the GBA to play with ARM.

4. Yeah, that's just how it is. If you're writing assembly you're basically ensuring that assembly code isn't portable. Not that it's a bad thing because it's needed sometimes, but still. But that's why you'd use ifdefs or something like that.

5. It's very difficult to do that, that's usually why you have a kernel and/or hypervisor watching and limiting access to things (with the help of MMUs and such). On some embedded boards it's more than possible to accidentally write some incorrect voltage to a power control register  or write a fuse which permanently bricks a system, but usually there's protection measures around that sort of thing (ie to set dangerous MMIO registers you need to follow a specific sequence).

Personally, I don't like x86 much. It's useful for modifying some games though, I've done some widescreen patches for older games once and I've looked at assembly, but I rarely write x86 stuff. ARM is nice for mobile/embedded though, I don't mind writing assembly for that. I'll usually use it for situations where I'm patching something or I need the compiler to not screw me over.",1522052625.0
zokier,"> Hexadecimal, I can read it, but why do I need that stuff? If you want to not have normal Numbers/Letters, then please use BINARY.

Any half-decent assembler allows you to write your numbers in whatever base you want

https://flatassembler.net/docs.php?article=manual#1.2.4

http://www.cburch.com/csbsju/cs/350/docs/nasm/nasmdoc3.html#section-3.4.1

> Visual Studio doesn't use Assembly without playing around with it.

Well, I'd say that is VS' fault more than assemblys.

> It's hard to learn.

uh-huh

> You need to tell if my machine is x64 or x86. 

wat. First of all x86_64 has been around like for a decade, so you can mostly just assume 64bit these days. Secondly, 64bit systems tend to run 32bit code just fine, so this is pretty much a non-issue.

> I'm not 100% sure of this: but I've heard it can damage your computer if you do the wrong thing? (Correct me if I'm wrong) 

You are wrong. ",1522012527.0
UpTide,"It's important to remember that asm is for commanding the processor directly. A computer can't read letters or numbers; hex is a nice way of reading in nibbles, 11111111 or 0xff?  (try 111111111111111111111111 ... much easier to say 0xffffff) A good thing to use when learning is the calculator in windows, change it to programming mode.",1522028596.0
nyrol,"I've been having some troubles too.

1. Instructions are too short. Maybe if they had you type out the whole word, it would be more clear
2. I can't ever tell what base an immediate value is in. Why not just underscore every number with the base instead of using things like ""#"" and ""%""?
3. Writing it in R studio is too difficult, and doesn't seem to want to compile. Maybe I'll try it in MATLAB.
4. I write a game for the N64 in MIPS64 assembly, and it can't run on my x64 platform. They're both 64 bit, they should be compatible.
5. It doesn't work to make websites.
6. I can't use ""if/else if"" or ""while"" like in other languages. If they just added this to assembly, that would help out a lot.
7. It takes too many lines to do anything.
8. There are so many registers that no one even knows what most of them do.
9. It's hard to learn.
10. I programmed my computer to turn on an attached desk lamp, and it wouldn't do it.",1522094233.0
InfinitelyManic,"1. Rai and Jiri at Lungha. Rai of Lowani. Lowani under two moons. Jiri of Umbaya. Umbaya of crossed roads. At Lungha. Lungha, her sky gray.

2. Shaka, when the walls fell.

3. Kadir beneath Mo Moteh.

4. Darkmok at Tanagra.

5. Shaka! Mirab, his sails unfurled.
",1522041621.0
nyrol,Everyone this is clearly a troll post. Just downvote and move along.,1522093551.0
proboardslolv5,"You cant damage your computer with assembly. When you run any program on a modern operating system, inclusing one that was written in assembly, you arebusing virtualized memory, not physical memory. Your registers are virtual, etc everything is virtual. The OS wont let you access resources you dont have permission to and wont let you harm the machine",1522069177.0
poshpotdllr,">Visual Studio doesn't use Assembly without playing around with it.

assembly is for computer scientists, not hipsters. you have some other things you need to fix about your attitude if youre using visual studio. dont be stupid. ",1522080587.0
wapxmas,"Assembler is not programming language at all, therefore you have no reason to treat it so.",1522166478.0
jedwardsol,An [LCG](https://en.wikipedia.org/wiki/Linear_congruential_generator) is not complicated to implement,1521759000.0
SlowCoach,"I am not familiar with x86, but in some applications it is acceptable to get some ""random"" values from the hardware's timer.",1521768514.0
zefyear,"systems without a `rand` are common, read the page on LCG recommended by /u/jedwardsol.

    random:
      push rbp
      mov rbp, rsp
      ;; `next` must be seeded with some special value.
      mov rax, [next]
      ;; multiply our ctr by 1103515245
      mul rax, rax, 1103515245
      ;; add 12345
      add rax,12345
      mov [next], rax
      ;; now divide by 65536
      mov rbx, 65536
      div rbx ; result is stored in RAX
      ;; there exists a method of doign this bitwise, look it up
      mov rdx, 0 ; clear rdx to make sure div doesn't think we're using it's part
      mov rbx, 11 ; our divisor
      ;; we divide by 11 to get our ""random"" remainder between 0-10
      div rbx
      ;; It is a common calling convention on x86 to return our result in AX.
      mov rax, rdx
      ;; increment so our values fall between 1-11.
      inc rax
      pop rbp
      ret

This is not cryptographically secure.",1521769462.0
auto-cellular,"It really depends on what kind of randomness you need. Personnally i use this :
https://pastebin.com/FVW3EhRc

Obviously i tested it on 64 bits randomness. If you take the modulo 11 (+1) you should have a good random generator from 1 to 11. I don't know what would happen if you use it with a 16 bits strategy though. You would have to test it. But because it only uses shifts and bitwise, it is indeed easy to use the 64 bit strategy, even if you have only 16 bits shift and logic instructions. You need to avoid ""bad"" seeds (like 0) also, i only stress tested it on 1 bit on, all bit off seeds, but i often used it with arbitrary seed without noticeable problems.

Not cryptographically secured.",1521805102.0
auto-cellular,"Bonjour. Je ne suis pas extrêmement doué en assembleur, surtout si tu dois travailler en 32bits, mais j'ai quelques notions. Apparemment tu es sous windows et dos, en mode 32 bits. C'est important de le préciser si tu souhaites qu'on t'aide.

La première question que j'ai est : est ce que ton code compile ? (est ce que tu obtiens un executable ...). Et si oui, que se passe t'il lorsque tu l’exécutes ? Par ailleurs j'ai tendance à utiliser linux, donc je ne suis pas trop en mesure de lancer des tests pour essayer de comprendre s'il y a un problème.

Qu'est ce que ton programme est supposé faire exactement ? Est ce qu'il y a une interface utilisateur, et à quoi ressemble t'elle (si c'est sous dos, ça peut être un menu, ou même juste une boucle principale qui crache l'heure toutes les 10 secondes ...) ?

------

English version :
Hello, it looks like you are trying to build an executable that runs under 32bits intel on the DOS platform. Did you succeed on building the executable ?  What is it that your target program should do, do you have a main loop, do you have to consider input from the user ?",1521719437.0
auto-cellular,"La partie ou tu converti AL en ascii ne me semble pas super claire, là aussi des commentaires pour expliquer ce que tu es en train de faire seraient plus que bienvenus ...

You use aam only after executing a mul instruction between two BCD digits (unpacked). mul stores the result in the AX register. The result is less than 100 so it can be contained in the AL register (the low byte of the AX register). aam unpacks the AL result by dividing AL by 10, stores the quotient (most-significant digit) in AH, and stores the remainder (least-significant digit) in AL.

Apparemment aam s'utilise après une multiplication .. mais je ne vois pas de multiplication dans ton code

Du coup est ce que l'instruction d'affichage affiche quelque chose sur l'écran (même si c'est du garbage) ?",1521728294.0
auto-cellular,"Bon je vais essayer de dire comment je comprends ce que fait ton programme.

- mov ah,0

- int 10h

https://en.wikipedia.org/wiki/INT_10H
ça dit que tu vas passer dans AL le video mode. Bon tu ne mets pas de valeur dans AL pour ce que je peux voir. Donc j'ai aucune idée de ce que c'est supposé faire ... Peut être ajouter des commentaires ?",1521724871.0
ScrappyPunkGreg,"I learned quite a bit from this article, but I have a question: Is there a reason why you didn't use the `ecx` register and `loopnz` instruction?
",1521740393.0
piginpoop,"why not just use windbg?

-

You can do:

disassemble /s <function-name>

to get output like:

Dump of assembler code for function xxxx:

xxx.c:

568     in xxxx.c

   0x00007fab4f5dab50 <+0>:     push   r15


   0x00007fab4f5dab52 <+2>:     push   r14

   0x00007fab4f5dab54 <+4>:     push   r13

   0x00007fab4f5dab56 <+6>:     push   r12

   0x00007fab4f5dab58 <+8>:     mov    r13,rsi

   0x00007fab4f5dab5b <+11>:    push   rbp

 .....................

Maybe this could help.",1521708009.0
DeuceDaily,"You would be well off discussing this with your teacher.

You need to be aware of the differences between the visual c++ compiler and clang.

Read here:

https://msdn.microsoft.com/en-us/library/45yd4tzz.aspx

and here 

http://clang.llvm.org/compatibility.html#inline-asm

You will also need to know the difference between AT&T and Intel assembly syntax. Which may be a bit to handle just learning.

http://www.imada.sdu.dk/Courses/DM18/Litteratur/IntelnATT.htm

You would likely be better off working on a Windows machine, even if it meant finding time to do it at school.

Depending on your teacher's knowledge and willingness to work outside the curriculum, you may or may not have the resources in class to deal with these differences.

If you really want to do it in XCode, you could also potentially get permission to install LLVM on a widows machine at school.

https://llvm.org/docs/GettingStartedVS.html",1521467718.0
__Cyber_Dildonics__,I always wonder why the kids that ask for help can't even be bothered to put their question in the title.,1521481077.0
Green_TeaRoll,">whenever I ran the codes 

Why the hell are you taking a programming course",1521508651.0
__Cyber_Dildonics__,How much will you pay me to do your homework?,1521251247.0
reddittidder,"Please stop adding HLA to the list of ""assembler"" books. If you really need that kind of stuff, just do C. I'ts a much better ""high level assembler."" ... HLA is neither C nor assembly and it's a tragedy that it is presented (by well meaning people of course) over an over again as one of the ""better"" books on learning assembly.",1520988990.0
thousandthousandeuro,nice,1520888284.0
uzimonkey,"I would address the points you don't understand, a new book or resource probably isn't going to help you any more than what you already have.  I know there is a tendency to blame the book when you don't understand, but fight it.  The book is rarely the problem.

Unless the book _is_ the problem, which book are you reading?",1520831596.0
jedwardsol,"https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf

Volume 1,  3.4.3.1

Volume 1, appendix A",1520543338.0
InfinitelyManic,"If you want to see the behavior live then you'll need to use a debugger, like GDB. ",1520546695.0
kl0wny,Are you looking for something like this? https://c9x.me/x86/html/file_module_x86_id_35.html,1520539803.0
msm_,"Well, a lot of reasons:

- you usually have a limited number of opcodes (modern x86 with all extensions doesn't count), and if you want to write/read ASM you need to know them well anyway.
- Historically screens were much smaller, and asemblers are the first programming languages. Also, maybe, file size (not for source files, but disassembled code takes a lot of space).
- The reason for long names is readability.

But arguably this:

    MoveImmediateToRegister ecx, 4
    DivideAndModuloEaxAndEdx ecx
    SignExtendDoubleWordInEaxToQuadWordInEdxEax

is not more readable than

    mov ecx, 4
    div ecx
    cdq

You can probably get away with middle ground like:

    move ecx, 4
    divide ecx
    convert4to8

But good luck with readable mnemonics for **PMADDUBSW** (Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words) or **PSADBW** (Computes the absolute differences of the packed unsigned byte integers; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results)",1520465184.0
UpTide,"Just a total random guess: maybe it was because it makes the code easy to print?
https://www.nasa.gov/feature/margaret-hamilton-apollo-software-engineer-awarded-presidential-medal-of-freedom",1520479905.0
ragnar_graybeard87,Write your own language? Well most are written in C... so id say you should lookup a book called build your own lisp,1520424272.0
csl,"Try to write simple functions in assembly and call them from a language you know thru FFI. That way you don’t have to write entire programs in asm, and you can test your code from easier languages. Almost all support FFI.",1520450132.0
reddittidder,This is not ASM specific but I'll leave it here just in case: [Let's Build a Compiler](https://compilers.iecc.com/crenshaw/) by Jack Crenshaw. ,1521035807.0
uzimonkey,"There's nothing tricky about the code here, virtually any text on x86 assembly will teach you what's happening.

However, what this code is _calling_ is another matter.  It's talking to the XMS driver (which is I think himem.sys) and and I think asking for another block of memory.  It's missing some labels here, but I think it's repeating this until it allocates all of the upper memory.",1519981371.0
mmonga,"A good tutorial is  [Paul Carter's one](https://pacman128.github.io/pcasm/). However, as /u/uzimonkey noted, this is probably overkill if your only goal is to understand the fragment you posted.",1519995170.0
Narishma,That code doesn't do anything specific to an 80386. It should work just fine on any 16-bit x86 CPU.,1520002825.0
CapitalistLetter,When I worked on a game for DOS I used the graphics mode for drawing every pixel by itself. It was done by changing the values of a given buffer of pixels on the screen. I'm pretty sure that something like that exists for more modern systems. [Here](https://en.wikipedia.org/wiki/INT_10H) are the specification for it.,1519903921.0
TNorthover,It's extremely dependent on the hardware and software surrounding the MIPS CPU. What simulator or board are you using?,1519905023.0
jedwardsol,"It can't.

Perhaps `ecx` is holding the address of the string. What is your code?",1519796714.0
InfinitelyManic,"I see. man 2 gettimeofday would provide most of general information you need. 

Below is an ARMv8 example function using the gettimeofday syscall under Arch Linux.  
The push2/pop2 items are not real assembly instructions; they're just macros that I created elsewhere. 

    _time:                                                                                                                                                                                                                                        
            push2 x29, x30                                                                                                                                                                                                                        
            mov x8, #169            //  <syscall name=""gettimeofday"" 
    number=""169""/>                                                                                                                                                               
            ldr x0,=t                                                                                                                                                                                                                             
            mov x1, xzr                                                                                                                                                                                                                           
            svc #0                                                                                                                                                                                                                                
            pop2 x29, x30                                                                                                                                                                                                                         
            ret   ",1519698585.0
ThrowAwaylnAction,"From only looking at the screenshot you showed, and not doing any research on the matter, I'm guessing that COMPAT stands for compatibility (obviously), and that the reason there are two defines is that they are macros that compile two different functions depending on whether some compiler flag is set to indicate that the system should be compiled in ""compatibility"" mode. In particular, notice that the first arguments (structure pointers) have different types, though the second argument has the same type. So I'm guessing that the structure changed over time; that the new structure is the one that's preferred; and that if you have old code that you can't change immediately, you can compile the code in compatibility mode to get the old behavior using the old structure declaration.",1519720054.0
InfinitelyManic,Do you intend to use the syscall in assembly in or to modify the syscall in kernel space?,1519678364.0
CapitalistLetter,Well... what have you tried?,1519427389.0
rlee0001,"You'll need to use at least two bytes of memory to hold the result:

Least significant byte to store the numeric portion of the result.

Most significant byte to store either 0x00 or 0x01 depending on the state of the carry flag.

These two bytes are then an unsigned 16 bit integer. Storing signed results would be a little different.

Doesn't the 6800 have 16 bit registers and arithmetic though? Or am I thinking of the 68000?",1519433659.0
spc476,"Motorola chips are big endian---which means the MSB is at the lower address [1].  I never learned the 6800 but I do know the 6809 (from the same company) and there, it would be something like:

        vx      fdb     $1234
        vy      fdb     $0987
        vz      fdb     0

                lda     vx+1    ; load LSB
                adda    vy+1    ; add LSB of other variable
                sta     vz+1    ; store LSB of result
                lda     vx      ; load MSB
                adca    vy      ; add with carry
                sta     vz

And to clarify, `FDB` here declares a two-byte value in memory.

[1] Confusing, I know.
",1519433663.0
Wainsten,"I updated the post with the emulator i'm using, and the code i wrote",1519513389.0
auto-cellular,"Your registers are only 8 bits, so in order to add two number that are more than 255, you will need to first add the low bits, then add the high bits and the carry (it's the same addition that we were tought in school).

     let's say you want to add A+B.
     let A= ah*256 + al (ah is the 8 bit high part, and al the 8 bit low part).
     let B= bh*256 + bl (bh is the 8 bit high part, and bl the 8 bit low part).

When you add two 8 bits numbers (range 0...255) the result can both be lower than 255 (no problem there), or higher than 255. But you certainly know that 255 is written 

      11111111 
in binary, and you can see that if you add 255+255 (maximum possible) you get 

     11111111 + 11111111 = 1 11111110 
(you just add a 0 to the right, like you do when you multiply by 10 in base 10, here you have multiplied by 2 in base 2). The carry flag is one bit, and you never need more than this single bit as you can see by adding 255+255. So if you do a+b --> c [carry set],you got 256+c as a result. It will only give you the 8 low bit of the sum in your register, and the next bit is in the carry flag. You have to add this cary flag to the high sum, like you did in school with base 10 additions.

It's like if you had to add two numbers greeter than 9 ... maybe  14+ 19. 
You only know how to add things that are under 9. So you do 4+9 = 3 [carry flag set] 
Then you do 1+1 =2 and you get 23. But you still need to add the carry flag ... and it's value is 10, so you have 33 as the sum of 14+19.

You can do the same here, with two number greater than 255 ... let's say 260 + 265, you have to split them  1 * 256 + 4 (1 is the high part, and 4 the low part) and 1 * 256 + 9.   Now you simply do 4+9 = 13 [no carry here] and then 1+1 =2. And you get 2 * 256 + 13 as a result. (no carry to add in this exemple, if the carry flag had been set by adding 4+9, you would simply add one more to the high number and get 3 * 256 +13 instead of 2 * 256 + 13)

Once you have the basic algorithm, the user manual will give you all the particular instructions you need to carry out your algorithm. You'll probably want to put in comments, in order to show the reader what algorithm you are trying to implement.",1520959216.0
jedwardsol,"They're 2 different calls.

If you're calling `write` then 2 is the file descriptor for stderr.

If you're calling `exit` then rdi is the error code,  which can be anything you want it to be.   He chose 0 because no error occured.",1519401293.0
InfinitelyManic,"The first systcall function is write; which generally means you are using mov rdi, 1 as the first parameter to output something to the screen. 

The second syscall function is exit; which generally means you would use mov rdi, 0 to indicate a return value of ""0"".  You may use other numbers; however, the max value that will be displayed is 255.  Run the program then do:

    $ echo $?  

Each syscall is independent of the other. 

Each syscall has parameters that are generally populated by moving values into registers. 

The syscall registers for Linux are 
 x86_64        rdi   rsi   rdx   r10   r8    r9    -

    $ man 2 syscall 
 ",1519401487.0
TNorthover,"> Since ax is a 32-bit register, what size should I declare an uninitialized variable?

ax is 16-bit, so if you want to store or load ax from a variable it should be that size (which is called ""word"" on x86). So your later 'dw' looks correct.

> However the procedure still errors, if I do some like `imul 3`.

imul doesn't have a version taking just an immediate value, you'd have to put that 3 into a register (of some width).

> Do I have to convert decimals to binary or hex before doing the arithmetic?

These largely don't matter as far as the computer is concerned, it just has a number. Where hex, binary and decimal come into play is when you convert to or from a string representation. And from the sound of your earlier question you do have a string that needs converting into a number.

> Is the minimum size of a variable to store something from ax a word because the procedure to get input would do it as signed integers? Why would I not be able to access the lower 8 bits?

You could store the lower 8 bits only (as 'al') but if the value you received was unsigned and larger than 255 you'd lose some data (or if it was signed and out of that range). The fact that you were told to use ax strongly suggests that larger values are anticipated.

> Why is cwd necessary, what if you just did arithmetic using words initially?

It's needed because idiv is going to look at some part of dx as one of its inputs. You need to make sure that dx:ax contains a correct 32-bit representation of your number, which is what cwd does. If you used a different size you'd still have to ensure that (say) edx:eax contained valid data.",1519347869.0
mttd,"- Paper (PDF): http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2018/02/ndss2018_05A-4_Bauman_paper.pdf
- Slides (PDF): http://web.cse.ohio-state.edu/~lin.3021/file/NDSS18a-slides.pdf",1519229581.0
DuplicatesBot,"Here is a list of threads in other subreddits about the same content:

|Title|Subreddit|Author|Time|Karma|
|---|---|---|---|---|
|[A Static Binary Rewriter that does not use heuristics and with an emphasis on simplicity and correctness](https://www.reddit.com/r/netsec/comments/7z1bzk/a_static_binary_rewriter_that_does_not_use/)|/r/netsec|/u/TechLord2|2018-02-21 08:57:19|0|
|[Multiverse achieves reliable static binary rewriting via superset disassembly](https://www.reddit.com/r/securityengineering/comments/7yz8dr/multiverse_achieves_reliable_static_binary/)|/r/securityengineering|/u/dguido|2018-02-21 04:32:19|3|


----

 I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&subject=remove%20user&message=mttd)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&subject=remove%20subreddit&message=asm)

Now you can remove the comment by replying delete! (op only) ",1519229723.0
jhaluska,"I feel like you're missing out on the spirit of ASM if you're wanting to cut and paste other people's code.

You can always create your own image format and write a converter in another higher language.  Something simple like, 2 bytes for image width, and 1 byte for a height and then just the raw pixels already converted for your palette would save a lot of coding time.",1519144299.0
DOOMReboot,Do you know how to plot a single pixel?,1519132492.0
Hexorg,Are your bmps palleted or full color? If it's palleted then you can just copy bytes from the bmp to video ram.,1519128517.0
CapitalistLetter,Do you know how to print to terminal? How to read a file? ,1519131217.0
moocat,http://www.mattzeunert.com/2015/08/19/viewing-assembly-code-generated-by-v8.html,1518788245.0
runvnc,"If you are interested in assembly and browsers, just worth a mention there is something called Web Assembly (wasm) which seems a bit different than actual assembly but may be interesting.",1518907539.0
antiquekid3,"It's interpreted, not compiled/assembled, so no. You could find the source for the interpreter and figure out from there what happens when that statement is interpreted, however.",1518758004.0
InfinitelyManic,"[edit]

Are you using a debugger?

What resource are you using for this?

You will need to save some registers before calling printf to avoid clobbering. Below is an exaggerated example of what registers to save and restore.

I suggest you create user defined functions; place them after the exit function; then call the functions accordingly. 

    _write:
    push {r0-r10,lr}
    ldr r0,=fmt
    bl printf
    pop {r0-r10,pc}



",1518763457.0
TNorthover,"It looks like you're expecting the call to printValue to preserve a lot more registers than it actually does. The [AAPCS](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf) says what registers have to be preserved by a function call, and critically r2 is not in the list.",1518842705.0
ragnar_graybeard87,Use linux. Checkout securitytube assembly megaprimer if ya like.,1518326368.0
_LeBronse,"Hey there,

You should definitely check out [Programming From the Ground Up](https://savannah.nongnu.org/projects/pgubook/). It is free and has you work through small little projects each chapter so it's very hands on. I find that everything in it is well explained.

As a little side note, I just opened a chat room on matrix for assembly programming. You can access it using Riot from [here](https://riot.im/app/#/room/#asm_programming:matrix.org). Feel free to join it and ask questions while you're working on something :)",1518423325.0
BLUuuE83,I recommend [this book](https://beginners.re/).,1518332219.0
uzimonkey,"> Someone told me to stick to one architecture. Then another guy tells me to start with 6502. Someone also told me to write a basic c program and compile it with gcc.

Stick to one architecture.  It doesn't really matter which one you pick, they all have their own ways of working but the basic concepts are mostly universal.  The trick is to get over the hump and learn your first architecture.  6502 is a good place to start though since it's such a simple machine, there are only a handful of instructions.

> I think my big confusion is which operating system to use. My heart likes to use linux so I guess I should stick to it. 

This doesn't matter at all.  If you like Linux, use Linux.  Though if you're going to be writing programs from the ground up, Linux does have the advantage of having a simpler system call interface than Windows.

> So how and where do I start?

Get a book.  I can't really recommend a book unless you want to be using 16-bit x86 on DOS, but I can definitely unrecommend a book that's often recommended: The Art of Assembly Language.  It seems like everyone recommends this book, but the entire book reads like a manual for his own ""HLA"" assembler, something you'll probably never use.  There might be good info sprinkled in there, but 95% of it is completely irrelevant.

Once you have a book, start writing programs.  The simplest program will be just something that assembles and when runs exits successfully.  Next up, hello world.  Next up, get some input.  Then write a program that turns an input string into an integer.  Then write a program that generates a random number.  At that point you're about ready to make a number guessing game.  And so on and so forth.

I know it's kind of a simplistic answer, but the materials and tools are there and now the rest is up to you.  Hit the book, start writing programs.  Don't get discouraged if you get lost or confused, that's normal.  Work through it, google for answers, ask questions, solve the problem and move on.  Every day you'll understand a little bit more, so just keep going.",1518341445.0
InfinitelyManic,"If your goal is security related then the current top four architecture targets to consider are x86, x86-64, ARMv7, and ARMv8. Given the 64-bit trends, I suggest you start with x86-64 then ARMv8.  
There aren't many books available for ARMv8; however, the documentation is adequate. You will need to choose a debugger and other object file tools (e.g., gdb, objdump, readelf).  ",1518365975.0
Caje9,I have just started learning also.  If you go with x86_64 on Linux this youtube series was a good quick start guide for me.  https://www.youtube.com/watch?v=VQAKkuLL31g&list=PLetF-YjXm-sCH6FrTz4AQhfH6INDQvQSn,1518443606.0
CapitalistLetter,"I learned in high school ASM for DOS, and [this](https://www.amazon.com/Assembly-Language-Step-Step-Programming/dp/0470497025) book helped me convert my knowledge to an actual OS. It is also a very good book to start with.",1518348444.0
moccajoghurt,"This could help you:

https://www.homeschoolmath.net/teaching/sine_calculator.php

It explains how to calculate sine with basic operators. You could write a function that does that for you. Maybe there are more comfortable ways, so you probably should wait for some other replies.",1517945355.0
bmnz,One method is the use of lookup tables. You basically hardcode a value for every degree and reference the table instead of doing a computationally intensive calculation.,1517948026.0
ummwut,A third-degree polynomial approximation will get you close enough for most stuff.,1517961266.0
FUZxxl,Try implementing CORDIC.,1518012732.0
DOOMReboot,"Did you try unchecking the ""read-only"" checkbox in file properties?

",1517956881.0
TNorthover,"It's the first `mov` in main that's most worrying. That's a load, and transfers the first 4 bytes of the string ('hell') from memory into ecx. There's really not much you can do with it after that.

`lea` is probably what you actually want: instead of loading the bytes, it would put the address of the bytes into the destination register (which should be a 64-bit register). That's exactly what puts is expecting.

I'm going to leave it there for now because this looks like homework and while we're often happy to help out, we're not going to do all the work.",1517628257.0
InfinitelyManic,I recommend this book for x86-64 Linux based assembly. https://www.amazon.com/Introduction-Bit-Assembly-Programming-Linux/dp/1484921909/ref=sr_1_1?ie=UTF8&qid=1517846307&sr=8-1&keywords=ray+seyfarth,1517846355.0
InfinitelyManic,"This is a NASM x86-64 printf example. 


    ;  nasm -felf64 -g -F dwarf joseph_001.s -o joseph_001.o  && gcc joseph_001.o -o joseph_001
    ;
    section .data
            msg:    db `Hello World!\n'`

    section .text
            global main
            extern printf

    main:
            call _write

    _exit:
            mov rax, 60
            xor rdi, rdi
            syscall

    _write:
            push rbp
            mov rbp, rsp
            lea rdi, [msg]
            xor rax, rax            ; no floating point values to print from floating point regs
            call printf
            xor rax, rax            ; return
            leave
            ret
~
",1517847507.0
InfinitelyManic,"You are mixing x86 (e.g.,int 0x80) and x86-64 (rdi, rdp), among other things.  This will work but it may violate convention. 
So are you focusing on 32-bit assembly or 64-bit?",1517846107.0
uzimonkey,"Isn't this something your engineers should be tackling and not random people on the internet with zero knowledge of your goals or constraints?

This smells like a homework question.",1517237365.0
thamesynne,"The thing that makes this really smell like a homework question is that its underlying assumptions are about two decades out of date. CISC vs RISC is a dead debate; the techniques RISC processors used have long since been applied to CISC architectures, and because of the increasing disparity between processor and memory speeds, not to mention the exponential growth in transistor counts, the complexity inherent in CISC processors has ended up finding its way into architectures that began as RISC. Moreover, between out-of-order execution, register renaming, variable-length instructions and branch prediction, the whole point of RISC has pretty much evaporated; even ARMs are pretty much CISCs now. And every processor still available now uses multiple data buses, hybrid Harvard / von Neumann architectures and separated L1 caches.

The future won't be about whether or not to simplify instruction set architectures; that bonfire's been pissed out already. It'll be about how the hell we actually effectively use dozens of cores per processor. Simply put: If you aren't being taught about parallel programming, hardware-level multithreading, read and write barriers and cache consistency in a processor course, you aren't being taught well.

Sorry.",1517382595.0
TNorthover,"CFstrings come in lots of strange shapes and sizes. There are a few comments around the internal definition of the __CFString struct in https://opensource.apple.com/source/CF/CF-1153.18/CFString.c.auto.htm, even that doesn't explain all the magic numbers.

The 7 in 0x7c8 (your 1992) appears to represent the brute fact that a CFString is number 7 in a global type-id table.",1517100805.0
PointlessProgrammer,"This was way more popular popular than I thought it was going to be so here is a (somewhat) practical project using this method.  It is a small app written in assembly to launch Launchpad.

https://github.com/jslegendre/asm-launchpad",1517357026.0
jedwardsol,"The locals were laid out from the top of the stack to the bottom. Ie. in the opposite to how the disassembler presented them.

So the copy of argc ended up at rbp-34. Then the compiler needed to reserve space for the copy of argv and realised it needed the 4 bytes of padding because it couldn't put the 8-byte pointer at rbp-3c",1517072114.0
jedwardsol,"The locals were laid out from the top of the stack to the bottom.   Ie. in the opposite to how the disassembler presented them.

So the copy of argc ended up at rbp-34.  Then the compiler needed to reserve space for the copy of argv and realised it needed the 4 bytes of padding because it couldn't put the 8-byte pointer at rbp-3c",1517071902.0
matjeh,"The coordinates returned from int 33h / ax=3 are in the range cx=0..639 and dx=0..199 regardless of the screen mode so you'd need to half the x coordinate (cx) value when comparing against VGA mode 13h coordinates.

You're resetting the mouse driver with int 33h / ax=0 (Dosbox doesn't auto-capture mouse unless you do that first) and assume you're capturing the mouse in the Dosbox window by clicking or pressing ctrl-F10, so I can't see anything that could be the problem.

One point to note is that you will probably want to store the mouse buttons value (bx) in a variable, and also the previous value, so you can determine when a button was clicked (old value = 0, new value = 1) rather than just when the mouse button is down, otherwise it will toggle state as fast as your loop runs while the mouse button is down.

For toggling state of the first rectangle I'd suggest something like :

    check_mouse_input:
        call get_mouse_button_press
    
        mov ax, mouse_last_button
        cmp ax, 0
        jne change_input_color_return ; button was pressed last loop, don't make another change
    
        mov ax, mouse_button
        cmp ax, 1
        jne change_input_color_return ; button not pressed, no changes needed
    
        mov ax, first_input_x
        shl ax, 1
        cmp cx, ax
        jb skip_top_button ; miss - mouse is left of left side of rect
    
        mov ax, first_input_x1
        shl ax, 1
        cmp cx, ax
        ja skip_top_button ; miss - mouse is right of right side of rect
    
        mov ax, first_input_y
        cmp dx, ax
        jb skip_top_button ; miss - mouse is above top side of rect
    
        mov ax, first_input_y1
        cmp dx, ax
        ja skip_top_button ; miss - mouse is below of the buttom side of rect
    
        jmp handle_left_click ; mouse is inside rect, mouse button is newly-down
    
    skip_top_button:

And to add to libmouse.asm :

    mouse_last_button dw ?
    mouse_button dw ?

...

    get_mouse_button_press:
    
        mov ax, mouse_button
        mov mouse_last_button, ax
    
        mov ax, 03h ; Mode for reading mouse motion counters
        int 33h
    
        mov mouse_button, bx
        mov mouse_x, cx
        mov mouse_y, dx
    
        ret
",1517141870.0
aphistic,"I assume you're using bash? bash only allows exit codes 0-255. See https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html

I also found this, it has a good answer for a similar question: https://stackoverflow.com/questions/3734102/why-cant-i-return-bigger-values-from-main-function",1517020616.0
InfinitelyManic,"Only the bottom 8 bits will be returned; so the other bits are discarded when displaying the first parameter register (e.g., edi, edi, r0, x0...) echo $?. 

Try 0xF0, you'll see 240... 

You should use write syscall since the exist status was not intended to be use for nothing more than an exit or function call return status. ",1517024072.0
Qvuen,"You're moving the address of intA/intB into eax/ecx (I'm assuming Intel syntax). Try

    mov eax, [intA]
    mov ecx, [intB]
    ...

Which should move the value into eax/ecx instead of the address. I could be wrong, it has been a while.
",1517020262.0
InfinitelyManic,"Are you using a debugger? 
Also, what is intA; a constant created by equ or a label to an address in .bss or .data? 
If you are doing division then you should be using eax (dividend/quotient), ebx (divisor), edx (remainder). 
edx should be cleared first.  
Please include all your code. ",1517065311.0
jedwardsol,"In what way doesn't it work?

If the ints are equal,  what is the next instruction executed after the JE is taken?   What do you want it to be?

If the ints are *not* equal,  what is the next instruction executed after the JE is *not* taken.   What do you want it to be?",1516994533.0
uzimonkey,"> Of course everyone learns a language in their own pace: I learned C++ (up to constructors) in about a month, and javascript and HTML (together) in a month. So given this, how long would it take me to learn if i commit 3-5 hours a day?

There's no answer to that.  You've learned the very tip of the C++ iceberg and a bit of web development.  There's no real way to say how quickly you'll pick up assembly.  You have little to no systems programming experience and presumably no hardware experience.  You're fighting an uphill battle, learning a lot of low-level concepts as you go.  Assume it will take you much longer than anything else for all the reasons below.

> So my next question is:is assembly language as difficult as C++ or python or java? is it easier?

No, it is orders of magnitude more difficult.  Python and Java hide the details of the machine from you almost completely, you don't need to know a thing about computers to program in them.  C++ is only a notch or two below that, you can ignore these details but in order to use C++ effectively you really need to know them.

Assembly, on the other hand, is about as low as you can get.  You're interacting directly with the CPU and _nothing_ is abstracted for you apart from instruction mnemonics and the few features your assembler gives you such as labels.  It's tedious and requires you to visualize the state of the CPU across instructions.  What is a simple if statement in any of the languages you listed will be at least 3 instructions that, to a beginner, are combined in bizarre and nonsensical ways.  It's only once you understand what these instructions really do and how they effect the state of the machine that you'll understand assembly.

There's no doubt about it, assembly is esoteric.  Where most programming languages are at least readable even if you don't know the language (incomprehensible functional languages like Haskell and APL aside) assembly looks like random gibberish.  Even if you have some understanding of what each instruction does, know what they do in combination simply isn't easy.  The learning curve is quite literally almost vertical.",1516782424.0
nemotux,"I think this all depends on your goal. If you're talking about being able to read assembly code for application code, I think it's not that hard to get off the ground and be able to consume assembly generated by a compiler. You could probably become somewhat proficient within a couple weeks or so. You'd have to learn about the basic processor architecture, the core of the instruction set, and things like calling conventions. But you could ignore a lot of stuff and still be able to read application code pretty well.

A step above that would be *writing* application code that uses libraries to do the nitpicking stuff. This is a step, but it's a big step to take (going from reading to writing), as you need to pickup things like laying out memory appropriately, knowing how to interface with the libraries you need, knowing the instruction set well enough to be able to synthesize sequences of instructions effectively to accomplish even small tasks. If you don't have a lot of experience programming in higher languages, you could be talking months or years to be effective at this level.

Then there's digging into system code. That's an even bigger step. You start getting into weird corners of the instruction set, knowing about OS conventions, knowing much more about hardware issues such as paging, interrupts, devices, etc. It's probably not worth it to attempt this without more experience in C and/or C++.",1516841873.0
MJHApps,"* Which flavor of assembly are you learning?

* How familiar are you with numerical systems other than Decimal? (Binary/Hexadecimal)

* What is your final project?

",1516824308.0
hextetrahedron,"I can’t really address your questions directly, but here are some resources that really helped me...

[Nand2Tetris](http://www.nand2tetris.org) 

You can get a cheap copy of 

[Introduction to Computing Systems: From Bits and Gates to C and Beyond](https://www.amazon.com/gp/aw/d/0072467509/ref=mp_s_a_1_1?ie=UTF8&qid=1516859862&sr=8-1&pi=AC_SX236_SY340_QL65&keywords=introduction+to+computing+systems&dpPl=1&dpID=412TO0yF2hL&ref=plSrch) 

by buying a used or international version...

Try loading up a DOS VM and going thought a book such as

[Peter Norton's Assembly Language Book for the IBM PC](https://www.amazon.com/gp/aw/d/0136619010/ref=mp_s_a_1_1?ie=UTF8&qid=1516859978&sr=8-1&pi=AC_SX177_SY255_QL65&keywords=peter+norton+assembly&dpPl=1&dpID=31nKUihP8lL&ref=plSrch) 

Also, write simple code in C, compile it, and then disassemble it to inspect the underlying assembly.

Hope this helps!",1516860331.0
,"I learned it with a school friend when I was 10. Those were simpler times though: we had an Intel 80286 which only does 16 bit instructions, and we'd have to create a .COM file, which was just loaded into memory and literally started execution at the first byte. I'd say it took us a few weeks to kind of get the hang of it. We could poke directly into video memory, to create cool effects as well as disastrous crashes.

These days, you have a lot more instructions, it's 64 bit, and it's expected that your code will end up in an ELF or PE executable. To do graphics, maybe the old video modes are still supported somehow, but I think you're expected to call into other libraries now to do anything visually interesting. It's going to take a while, it depends on what your goal is.",1516817989.0
telemachus_sneezed,"How long does it take to learn how to make things with LEGOs?  Days?  Weeks?  Then how long does it take to make a Millenium Falcon (about the size of a toaster oven) with LEGOs?

ASM programming is like LEGOs blocks.  There are a finite set of possible ""instructions/words"" that you can feed to the CPU.  They are the most rudimentary instructions you can give to a CPU; load, store, increment, etc. .  But CPUs know nothing about arrays (except as a vector instruction), or linked lists, or Simpson's rule to derive the value of a definite integral, or a function called in a Windows GUI.  Those are all abstract concepts the CPU knows nothing of.  Humans have to construct them with ASM instructions, like LEGOs.  And its varying levels of difficult to do well.

The good news is that all CPUs work the same conceptually (except perhaps quantum ones).  So there will always be ""load value to register x"", ""move contents of memory location y to memory location z"" instruction, etc. .  But each ""family"" of CPU will have a different short instructions/acronyms to do the same (logical) task.  Furthermore, the tools used to create assembler programs suck for novices, IMHO.  They will also have ""their esoteric  expressions"" for a program on the same CPU family, presumably to make things ""easier"" for the programmer.

The answer to ""how long does it take to learn assembly language"" is indeterminate.  The ""relevant"" answer in your case is however long it takes to master the questions that will be asked on an exam.  (Hopefully you can learn what you need to answer those questions within a 3-4 month period.)  Go through your professor's course synopsis (the long one, with titles for every class), and ask him what sorts of questions will be on the exam.  Then as you learn to program assembly, figure out what the questions will look like on the test.  There will be bits of boolean algebra and computer architecture theory; learn whatever is required for the test.  All assembler classes have the same concepts, but each test and what the professor chooses to emphasize will vary greatly.

If you *really* want to *learn* to function as an assembler programmer, avoid using x86 as a learning platform (unnecessarily confusing).  Buy a raspberry pi or an arduino, and learn assembly language off the ARM cpu.  And realize that other than writing hardware drivers, or simple tasks for an ""embedded"" platform, you'll never *need* to ""master"" it.

>  So my next question is:is assembly language as difficult as C++ or python or java? is it easier?

I find it so freaking easy to write something simple in assembler that works properly on a CPU.  Its damn near impossible for me to write something complex and have it run properly on a CPU.  Its about learning how the CPU ""thinks"", and then realizing what makes it so difficult is all the folderol you have to tell the CPU so that it does something humans will recognize.",1522526937.0
kiwidog,"A month for learning, ~6 for full understanding. This isn't something you can compare per person. A friend of mine who has never touched computers before really learned assembly, reverse engineering, and found 2 0ds in the first month. I just call him naturally talented at this stuff.",1516804865.0
tobiasvl,"Why on earth would you take a photo of your screen instead of pasting your code into pastebin/gist? It'd be a lot easier for us to test it. 

The problem is that you're using interrupt 21h. That's a DOS interrupt, you can't use it in Windows protected mode. You should instead use Windows API calls.

How are you learning assembler? I think you might be using outdated learning material. ",1516531710.0
,[deleted],1516354193.0
Asl687,Making a isometric zx spectrum Next game in z80.,1516358111.0
InfinitelyManic,"Personal: Working on completing my exams for a x86/64 Assembly and Shellcoding on Linux course that I started a while ago. 

I got distracted by ARMv7 & ARMv8 Assembly and a personal ARMV7 bare-metal project; so I hope to finish the exam assignments this year. ",1516580819.0
wonkey_monkey,"I'm writing an x86/x64 Reverse Polish Notation compiler with extensions that allow you to program conditional jumps (and therefore loops) and allow it to read and write video frame data. I've got it generating Mandelbrots:

https://www.youtube.com/watch?v=aMKES8sP3wc (YouTube's compression ruins it a bit)

(it ends just before the accuracy of 80-bit floating point becomes apparent because at that point it was taking 5 minutes per frame to render) and running Conway's Life, among other things.",1516799384.0
ScrappyPunkGreg,"Converting a very basic ""start here"" RP2A03/6502 NES tutorial from the NESASM assembler to the ca65 assembler (cc65 binutils).

Just getting started on the conversion. I know cc65 is the hot new thing, and NESASM is considered old hat, so I figured I'd get with the times.
",1517289299.0
Caje9,"Recently started learn it for fun (masochism?).  Very minimal coding experience, just interested in messing around and think it's cool manipulating the computer on that level.  Might eventually make some simple data analysis projects.  ",1517605274.0
mtanski,It's not a bad looking interface.,1516630746.0
,Nice.,1515511572.0
Brane212,"Is there a link to project's homepage ?

Can't fin anything...
",1515525576.0
FUZxxl,"What architecture is this? If it's ARM, you need to load the address as a separate step.",1514941051.0
FUZxxl,"In general, it is a good idea to place your constants into literal pools so they are always within a kilobyte of the code that uses them.  This speeds up the code a little bit as you don't have to load an address every time you need the constant.",1514985441.0
hipstergrandpa,Found this site through the 34Cwhatever CTF that was going on this past weekend. What an amazing resource this site is! Clear and simple explanations of ARM. Def check this out for those who are interested in ARM assembly.,1514682554.0
rlee0001,"Asm files are plain text. If they can't be read, then either your hard drive failed, or the program you're using isn't a plain text editor.",1513808337.0
jedwardsol,"`sub esp,8`   reserves 8 bytes of stack space for you to do with as you wish.

ebp-4 points into the middle of it though, if you have a standard stack frame.

What is this string you want to create?  It fits in the 8 bytes?",1513744029.0
fearless0,"    MyProc PROC
        LOCAL somestring[256]:BYTE

        lea eax, somestring ; eax points to start of string
        mov ebx, Addr somestring ; ebx points to start of string
        ret
    MyProc ENDP",1513773302.0
TNorthover,"I'm quite fond of https://microcorruption.com/. It's an assembly-based set of security challenges, where you hack into ever more sophisticated microcontroller (MSP430) based locks.",1513769255.0
BS_in_BS,Is the double in a register or memory? if in a register you need to malloc 8 bytes and use STR to put it in the allocated memory. then just return the address you stored the double into.,1513706403.0
dralois,"/u/BS_in_BS and /u/celegans25, I solved the problem by pushing the value onto the stack and then returning the address of the stack pointer to the c function. Is this a safe way to solve the issue?

Edit: fixed this horrible mistake",1514937823.0
nuntetemo,Good job. OS X 64 bit asm is a beast to program because is not very well documented. What are your sources and tools? ,1513678049.0
InfinitelyManic,"I'm looking through the code but I'm use to the Intel syntax.
If it's just echoing then have you considered incorporating sendfile? 
You may still need argv but you can initially <<< pipe data into the prog from the CLI. 

I don't know if macOS has that syscall.",1513736810.0
FUZxxl,"You can (with appropriate privileges) open a frame buffer device (like `/dev/fb0`), map it to memory and then start drawing.  However, it's much more versatile to let a library like SDL do this for you as the framebuffer approach won't work if you have X running.  It works basically the same way, except you let SDL map the frame buffer for you and deal with the nasty implementation details.",1513586071.0
SeanPesce,"Is it a static program? Like it would literally just have to print the exact sequence of M, I, C, H, A, E, L every time the program is executed? If that's the case, why not just load the string address (or sequentially load each character), length, and output descriptor into the argument registers and make a syscall with the console output code? I don't use MIPS but in Intel x86 syntax on 32-bit Linux this would just be something like:


    section .data

        name db 'M\nI\nC\nH\nA\nE\nL\n'  ; '\n' is the line feed character


    section .text

        mov edx, 14        ; String length (including newlines)
        mov ecx, name
        mov ebx, 1        ; File descriptor for standard output, aka stdout or the console
        mov eax, 4        ; System call code for writing data
        int 0x80          ; System call interrupt


Apologies for any formatting issues, I'm on my phone.


Edit: Looks like MIPS syntax would just be something like:

    .data
        name .asciiz 'M\nI\nC\nH\nA\nE\nL\n'   # Null-terminated string
    .text
        li $v0, 4     # syscall code for printing a string
        la $a0, name  # Load address of string into argument register
        syscall



",1513525174.0
__Cyber_Dildonics__,I'll do it for $70 on an Amazon gift card code.  You will need to send me your class materials so I can see what the lesson says.  You will also need to tell me what environment they have you using.,1513454020.0
InfinitelyManic,"    extern printinteger

    SECTION .data
    buffer: db 'Enter two natural numbers as the parameter and the operation: num1 +/- num2'

    vetor_naturals: dd '0x30', '0x31', '0x32', '0x33', '0x34', '0x35', '0x36', '0x37', '0x38', '0x39'

    SECTION .bss
    number1: resb 4 
    sign: resb 4 
    number2: resb 4

    SECTION .text
    global main
    main:

    xor eax, eax
    mov ebx, [esp+8]
    mov ecx, [esp+4]
    cmp ecx, 3
    je OP1

    PRINT_ERROR:
    mov eax, 4
    mov ebx, 1
    mov ecx, buffer
    mov edx, 75
    int 0x80
    ret

    OP1:
    mov eax, [esp + 24]
    mov ecx, -4

        CICLO1:
        add ecx, 4
        cmp ecx, 0x40
        jg PRINT_ERROR
        cmp eax, [vetor_naturals+ecx]
        jne CICLO1
        shr ecx, 2

        OP2:
        mov edx, [esp+32]
        mov ebx, -4

        CICLE2:
        add ebx, 4
        cmp ebx, 0x40
        jg PRINT_ERROR
        cmp edx, [vetor_naturals+ebx]
        jne CICLE2
        shr ebx, 2

        MINUS:
        mov edi, '0x2D'
        mov esi, [esp+28]
        cmp esi, edi
        je SUB
        mov edi, '0x2B'
        cmp esi, edi
        je OPER
        jne PRINT_ERROR

        SUB:
        neg ebx
    
       OPER:
       add eax, ebx

       TREATMENT:
       push eax
       call printinteger
       pop eax
       jmp END

    END:
    ret",1513195932.0
Catralitos,"The error message is in Portuguese, but I doubt that matters.",1513182609.0
,"> The NES was released some time before I was born, so I have no idea when (late 70's maybe) (I'm 15).

How does the author know 6502 assembly but not how to use wikipedia?",1513026056.0
quadruplefault,If anyone has any questions I'll be happy to answer them as I'm the author of the article. ,1512660388.0
wapxmas,Hello! Why aren't this [docs](https://flatassembler.net/docs.php) useful for you ?,1512745931.0
adzm,"If you are using the samples from kip irvine you are expected to extract the library files, including this one, to c:\irvine -- see http://kipirvine.com/asm/gettingstartedvs2010/",1512199120.0
UpTide,"    loop:

        bl for

        cmp R9, 0x80000000

        it eq

        beq endFor

        //R9 is loaded from memory.

        bl forLoop

    endFor:

        b _halt


    //R8: returnLinkPointer R9: data, R10:Length, R11:IndexPointer,  R12:ArrayPointer

    for: //loops array, R10 is index in this case.

        mov R11, R12

        ldr R10, [R11]

        mov R8, LR

    forLoop:

        cmp R10, 0x0

        ittte gt

        subgt R10, R10, 0x1

        addgt R11, R11, 0x4

        ldrgt R9, [R11]

        ldrle R9, =0x80000000

        mov pc, R8


    _halt: b _halt

    .end

man, that formatting is bad. sorry",1512182285.0
