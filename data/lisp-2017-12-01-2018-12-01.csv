author,comment,timestamp
defunkydrummer,"Thank you very much to the SBCL maintainers team.

We are lucky to live in a time where Lisp development is still ongoing, many teams carrying the flag of open-source Lisp: 

- SBCL (new release today)
- SICL (last commit 2 hours ago)
- ECL (last commit, yesterday), 
- CLASP (last commit 2 days ago)  
- CCL (last commit 7 days ago), 
- CLISP (two weeks ago), 
- CMUCL (1 month ago) 
- ABCL (3 months ago)

et al.

>bug fix: restored sb-thread support on OpenBSD.

This one is a major one!
",1543587954.0
ObnoxiousFactczecher,"     Failure:            lockfree-list.impure.lisp / LOCKFREE-LIST-PERFORMANCE

;(",1543585768.0
ImpracticalPotato,Have you heard of [scheme2llvm](https://web.archive.org/web/20111220233738/http://www.ida.liu.se/~tobnu/scheme2llvm/)? Its a scheme to llvm compiler. I know LLVM is not assembly but it might be low level enough to be of interest to you. Also see self plug [scheme2llvm in CL](https://github.com/terminal625/scheme2llvm),1543620031.0
kazkylheku,"Note that the tokens in this expression language are passed straight to the assembler where they become assembler tokens.

There are no symbols or numbers. If you use `eax` as a name, it looks like that will just become a register reference (and the expression processor isn't aware you're using that register).

Or, if you write a function call like `(123)`, it seems like it will just try to call code at address 123.

Basically it's a nested expression preprocessor for assembly language.

Why on earth does it use Intel syntax; at least in AT&T the `%` sigil on registers puts them in their own namespace.
",1543906073.0
suhcoR,Nice article. But why on earth is he using JS?,1543576276.0
theangeryemacsshibe,"\>""lisp""    
\>adds numbers, compiler in JS, doesn't even inline +

cleavir would be a better educational tool smh",1543634326.0
SlightlyCyborg,Thanks for this!!!,1543760026.0
flaming_bird,r/emacs might be a good place to cross-post this.,1543519215.0
a_Tick,"Extract the parts you want to vary to procedure arguments.

    (defun add-org-custom-emphasis-keywords (str face-type )
      (add-to-list 'org-font-lock-extra-keywords
    			   `(,(concat ""\\("" str ""\\)\\([^\n\r\t]+\\)\\("" str ""\\)"")
    				 (1 (face ,face-type invisible t))
    				 (2 at-face)
    				 (3 (face ,face-type invisible t)))))
    
    (add-org-custom-emphasis-keywords ""!"" 'at-face)


Note that I'm using backquote, as backquote allows one to temporarily disable quotation to execute code, and I've removed the nested quotes which you had, as, as far as I can tell, those are incorrect.",1543530763.0
timezone_bot,"6pm UTC happens when this comment is 2 hours and 41 minutes old.

You can find the live countdown here: https://countle.com/wCN7P3Jid

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1543418319.0
clintm,"Last episode of the year?  But there's a whole month left!
",1543422968.0
Shaken_Earth,Nice!,1543454852.0
kazkylheku,"Basically if your type system dispatches only on flat types like `string` or `widget` and not things like `vector of integer`, the obvious thing is to take the complex, parametrized types that you care about and map them to some non-parameterized type, like a wrapping struct.

This works for anything: you can dispatch on anything that isn't a supported type by wrapping it in one.

E.g. in some languages with ""basic types"" that aren't classes, you can wrap them in classes and then you get dispatch. It's kind of the same thing. Wrapping an `int` in an `Integer` class for the sake of participating in dispatch isn't much different from wrapping some array of double-floats in an `array-double` struct.

As far as OOP dispatch is concerned, there is no strict need for types to be anything other than symbolic labels which are arranged into an inheritance lattice. ",1543363939.0
Candid_Calligrapher,"I'm pretty sure you could use cl-parametric-types along with EQL-specializers on the class-of of the arguments (since cl-p-t needs to instantiate new structs it has to give them a name)..
",1543361829.0
republitard,"All that's missing is a macro to enable this:

    (defmethod/parametric my-method (foo (list/string))
        ;; With automatic unboxing
        (frobnicate (aref (car foo) 0)))
",1543617236.0
zxvf,You could sign up for Advent of Code for a supply of neat little problems to solve. ,1543299782.0
flaming_bird,"Good luck - ask people on `#lisp` on Freenode or the Lisp Discord server for any help you might need.

Also, https://portacle.github.io/ and http://www.gigamonkeys.com/book/ - that's the starter pack.",1543308969.0
defunkydrummer,">I'm challenging myself to learn Common Lisp in one month (November 27 - December 27 2018)

Hi Tom, 

Congratulations on setting yourself this challenge.  Just one observation: One month is not enough for learning CL completely. I have been programming for 29 years, and when I started in CL i used almost all the full time I could get, about 4hrs/day; after one month of course I could write useful programs, but still isn't enough to explore it in depth, simply because CL is loaded, packed with features; even more if you consider the features that particular implementation bring (i.e. java interop for ABCL, C embedding for ECL, etc), or libraries that extend the language (i.e. `iterate`). 

It is truly a hacker's language.

The good thing is that CL is addictive like a hard drug, so, once you start. it's difficult to stop. 





",1543331079.0
Tiomaidh,Good luck!,1543290123.0
dougie-io,Good idea. You should also provide a cut-off time for each day with a timezone - so you don't have people from around the world messaging you that the day is over when it is still mid-day for you.,1543330360.0
agumonkey,Same. So we owe each other.. and we're now balanced. Damn,1543411728.0
ImpracticalPotato,bribery don't charge these batteries,1543619577.0
stassats,Stop learning it!,1543324246.0
Bogdanp,Today's recording: https://www.youtube.com/watch?v=F9-j_8Rr59s#t=5m56s,1543237498.0
timezone_bot,"9am UTC happens when this comment is 21 minutes old.

You can find the live countdown here: https://countle.com/Dc8NtkZY7

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1543221512.0
dzecniv,Cool. Do you want to contribute to https://lispcookbook.github.io/cl-cookbook/editor-support.html ?,1543107192.0
flaming_bird,"My comment will be in two parts.

--------------

Speaking functionally, every `LET` is equivalent to calling an anonymous function via a `LAMBDA` form. Therefore, every time you would like to use a `LET` but aren't allowed to, you can cheat your way by using a `LAMBDA`.

    (let ((x 2) (y 4)) 
      (+ x y)) ;=> 6

    ((lambda (x y) (+ x y)) 
     4 2) ;=> 6

Note that even strictly functional languages such as Haskell [allow you to define variables](https://stackoverflow.com/questions/11531328/defining-variables-inside-a-function-haskell); in its case, due to automatic memoization, it is purely syntactic sugar. In Lisp, it may cause computation to be repeated.

----------

Speaking Common Lisp, CL is a multi-paradigm language and therefore functional programming is only one of all paradigms that you can utilize to write idiomatic CL. You can use imperative programming, you can do object-oriented programming via CLOS, you can utilize one of various paradigms that were implemented on top of CL via various packages. If someone translated their C++ programs (C++ is also multi-paradigm!) to Lisp, it would likely need some fix-ups to make it more idiomatic stylewise, but still in the ""spirit"" of Lisp.

I don't know the exact words that your teacher used, but I would say that it is more than possible to teach functional programming in Common Lisp, while also I would also say that teaching that functional programming is the only idiomatic way of writing Common Lisp is is wrong.

EDIT: And yes, `LET` is NOT harmful as it makes it possible to avoid multiple computation and generally increases code readability. I'd say that your teacher only told you to avoid using `LET` for training functional programming.",1542993531.0
stassats,"This is the thing that pushes away people from lisp — someone projecting their radical ideas onto the language. Lisp gives you the freedom to either use local variables or not use them. Ordinary functions are a mixture of both, you don't want to bind each intermediate result to a variable, but neither you want an incomprehensible soup of function calls (nor defining a myriad of one-off functions to hide that). And if the best name you can come up for a variable is X or I, then it's not really helpful to have such a variable.

Something more radical, it's not even shunned to use global variables in common lisp.",1543017093.0
notlikethisplease,"Must have been something related to that specific exercise; there is no connection between lack of local variables and functional programming (though in functional programming, you generally shouldn't *mutate* these local variables).

As a sidenote, in some languages with the necessary conveniences (primarily haskell, roughly speaking a strictly functional language), [tacit programming](https://en.wikipedia.org/wiki/Tacit_programming) is common. In tacit programming, you don't even specify the arguments to a function, you just compose functions. A lack of local variables would be quite typical when programming in such a style. This is not restricted to functional programming, however; forth is a language where idiomatic code is tacit but imperative.",1542997019.0
kazkylheku,"The teacher was fond of what is sometimes called ""point-free style"": combining existing functions together to express a computation without binding variables.

Local variables are not ""anti-functional"" in any way, so long as you do not mutate them by assignment.

In the pure conception of Lambda Calculus, there are no local variables as such other than function parameters. The *let* construct is sometimes regarded as having a basis in syntactic sugar for *lambda*. So that is to say, `(let ((a expr-1) (b expr-2)) body)` is equivalent to `((lambda (a b) body) expr-1 expr-2)`.

However, note that `a` and `b` meet the definition of ""local variables"" in either version! Function parameters are local variables.

The avoidance of `let` may just be a way of encouraging the students to think about functions.

The purpose of courses like this isn't to teach you how to effectively use Lisp for software engineering. Rather, the agenda is to focus on a narrow area of computer science. Lisp programming is essentially thrown under the bus for the sake of this agenda.

I believe that college academics has done a great harm to Lisp. For many people in computing, courses like this are their first (and often only) contact with Lisp, from which they walk away with completely the wrong idea.",1542998537.0
lispm,"There is a style in programming, often applied to Functional Programming, which avoids variables: https://en.wikipedia.org/wiki/Tacit_programming

Generally in Lisp there is a lot of freedom and flexibility. Best to learn when to use what programming style in which situation. If there is one single right way in Lisp: there is no single right way.",1542996589.0
CallMeMalice,"A lot of people focus on the goal of the teacher which is fine. I'd just like to add that introducing local variables is actually really beneficial for documenting what your code is doing. 

Simple operations and well-named functions might work, but often you don't get both (or any). Using local variables help to understand what goes where - (let ((marks-best-guess (car (guesses 'mark))) and now we know why we used car in the first place. This might not be the best example, but you get the idea.

I also find it easier to debug code with
named values. ",1543013695.0
jrbartme,"My guess is that your teacher was trying to introduce the paradigm of writing code that does not have side effects.  Assignment has a side effect of altering a memory location.

https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect

Some languages, like prolog, do not have assignment.  Instead they have variable binding.  This may seem like the same thing as assignment, but a variable can only be bound once and cannot be updated.  For instance, there is no “++” operation and it doesn’t make sense in the context.  Instead, you might recurse on yourself with a new value one more than before.

I had a similar course in college that used Lisp and Prolog to introduce non imperative ways to think about and solve problems.

One thing you can often notice is how some programmers are stuck in the mold of their first language.  For instance, someone who learned C might prefer writing “for” loops with an index in languages that let you loop over the list or array itself. (Or instead of using Map or Reduce type functions). And this becomes even more obvious in languages where recursion is preferred to loops.",1543010292.0
phalp,"Forth is the only language where people might be uncomfortable with local variables, and even then discomfort would usually be wrong.",1543002775.0
drcz,"*(I feel there is something offtopic in the answers talking about tacit style or teacher's mistake, so here's something else; edit:* /u/CallMeMalice *seems to share the point)*  


I was wondering the same thing many years ago!

I didn't have any teacher (just some random articles), but felt dirty when using `let` forms, precisely because I did first examples using `lambda`s as the only way to bind stuff (also I mostly used my own lisp where I didn't implement `let`s at first). In scheme in particular there is `let*` form, which felt ""even dirtier"" as the order of these local bindings matters. So my question was: are ideas which require considering any sort of ordering/sequencing really pure? Are my programs really denotational if I use `let*` ?

*(I guess when you write ""functional"" you mean ""denotational""...* [*http://thecorememory.com/Next\_700.pdf*](http://thecorememory.com/Next_700.pdf)*)*

This seems to be a common fallacy of equivocation... Obviously (he\_he) our ideas have hierarchical structure, and if we want to describe them, we have to get them ordered because we explain stuff (in speech and text, including programs \[yes, even befunge\]) linearly. And we order them by conceptual dependencies (usually the bottom-up way).

That's perfectly ""pure"" (""denotational""), as in most math textbooks where you first define sets, relations and functions (that's the first chapter you always skipped), then structures, then actions/mappings, then morphisms, and structure-preserving constructions (\[direct\] products, quotients, etc)...   `let` allows you to do that in a very local way -- to de-structure your expression; even to make the expression more readable by giving names to certain ""partial explanations"" (if you consider an expression as an explanation).

I guess it sometimes reads better in the opposite direction (top-down), with `where` form, as in ISWIM or (if you prefer languages which are actually implemented ;)) haskell -- but that depends on the reader too.

And speaking of haskell, why don't these guys feel guilty when they use `do` notation?! Now that's imperative thinking!

So I guess I understand your doubt, but it seems not only okay, but preferred. The ordering is ""along the dependency axis"", not ""along the process time axis""; the only temporal relation there is is about ordering/sequencing of explaining notions, not computing object that these notions capture.

In case you wonder: what I feel dirty about now (and try to avoid as much as possible even outside of LISPs) is rather the use of verbs/verb prhases for function names, and any attempt at cps (that's not only ""talking about time"" using ostensibly pure device, but just one step from feeling comfy with call/cc -- EVIL!!!).

Last thing, don't get too dogmatic though. It will slow you down, quite likely unnecessarily. But also be pure. Good luck!",1543042936.0
rogersm,"This is something that is done when teaching functional languages at university courses. I recall this way of teaching 20 years ago when I learnt ml. Today Paradigms of Computer Programming course is a good example.

I would say the idea is to force the pupil to think in the realm of functions and not use assignment because it predisposes the pupil to think of loops.

In functional languages, loops may not even exist in the base language (they're a function) and they're introduced after teaching invariants (that are better explained if variables have not been introduced), so in a pedagogical sense it makes sense to delay the introduction of variables until later in the course.",1543048224.0
maufdez,"I did not read all the comments, but in the ones I read I did not find the advice I wished somebody had given me early on, that is ""figure it out"", and I don't mean it in the mean way, what I want is for you to look at your knowledge of computer science, and reason about it, forget about style or propaedeutic purposes, and think about what you know about how things work, and then, a lot of the times you can answer the question yourself, or end up investigating and learning valuable knowledge instead of just getting rules.

What does it mean for a program to be in the functional style? Does using local variables makes it not functional? if so, how?, Is it generally bad to use let or can you identify when it is?, if it is ok to use local variables, what are the advantages and disadvantages to do it?

&#x200B;

Again, I don't want to sound rude, but reasoning about this things (and other questions you might come up by yourself), is more valuable to you becoming a well rounded programmer than trying to stick to rules. Common Lisp is a language that allows you to ""break the rules"" and if you understand what you are doing, sometimes doing it is the best thing to do.  ",1543076753.0
justin2004,"> thus our teacher made it clear that it was forbidden to use any local variables (“Don't use let”) in order to program Fibonacci functions.

sounds like an application of:
https://en.wikipedia.org/wiki/Wittgenstein%27s_ladder",1543115020.0
kazkylheku,Note that pattern matching notation is a big component of various mainstream functional languages. Pattern matching is a form of local variable binding. Q.E.D. teacher was an idiot; forget about it.,1543189800.0
MakeItEnd14,"Not sure what to make of this but it looks really interesting.
Good job!",1542920026.0
Aidenn0,"Yes to windows/sbcl working just fine; I did a cross-platform application and had zero complaints from windows users.  Big hint: put the .dll files (e.g. sqlite) in the same directory as your executable.  If by ""system arguments"" you mean command line arguments, those are no problem; if you mean something else, please clarify.",1542870451.0
defunkydrummer,">The issue is that it for Windows and I wandted to know how reliable was the compiling for Windows (probably with SBCL). I know it exists but can I expect to be able to maintain my application this way? Looking around it doesn't seem like a lot of people are doing this​

>I was also wondering if system arguments were easily accessible, I know this can be an issue on windows.

>In the end I'm hoping to have a single executable interact with a bunch of excel files and a SQLite or SQL database.

It works just fine, the Windows issues warning was there only for some threading issues. I use or have used ABCL, CCL, SBCL and CLISP on Windows machines, they work fine. 

In any case if you experience any problem that can be blamed on the compiler, you can switch to using CCL (Clozure Common Lisp) which is stable on windows and is another of the really good free Lisp implementations out there. 

As for the command line arguments there are compatibility libraries for this, see UIOP, for example [line 221 here](https://github.com/fare/asdf/blob/master/uiop/image.lisp). There's also this one from the same author (Fare):

https://github.com/fare/command-line-arguments

>interact with a bunch of excel files and a SQLite or SQL database.

You can use CLSQL for your SQL needs.

As for the excel files, I will make a shameful plug for my [reasonably fast, reasonably buggy excel library](https://github.com/defunkydrummer/lisp-xl), perhaps you can perfect it (i don't have enough time these months.)



",1542897734.0
zulu-inuoe,"Regarding any dependent DLLs, Windows has a couple of different canonical ways to deal with that:
1. If the dependencies are well-known and have a maintained installation procedure, incorporate their installation with yours or just document that your program depends on them. This is how. NET applications work (they depend on some runtime being installed)
2. If your dependency is a package that doesn't have some well-known installation procedure, then typically you pack the dependencies with your application. This is commonly the case for GUI libraries packing SDL2 or Qt. Likewise, this is often how Sqlite is included as a dependency.

You should review the search algorithm used by Windows, but the TLDR is to put dlls in the same dir as your executable. For distributing an application this works 99% of the time.

Lastly, mind 32-bit vs 64-bit.",1542914543.0
timezone_bot,"6pm UTC happens when this comment is 1 hour and 54 minutes old.

You can find the live countdown here: https://countle.com/4baBImTu8

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1542729910.0
pauljewell,"Shame - I will be travelling at this time this evening, so I won't be able to join :( 
Thanks again for these sessions - I guess I will be catching up on YouTube!",1542781010.0
hubbabubbathrowaway,"I read through the whole book a few years ago and did nearly all the exercises. The last two are still on my TODO list as life happened and I just didn't have the time nor energy.

This book had an extreme, and I think good influence on me as a programmer. It's on top together with The Pragmatic Programmer and The Art of Unix Programming as the big trio that made me who I am today. While I don't use the concepts much in my everyday work, the way I think about problem solving in general has changed. You can find some of the concepts from the book in nearly every language out there, from JavaScript to C#, even in Golang. I'd even say most other programming languages are slowly becoming more Lisp-y. Have a look at [Racket](https://racket-lang.org/) and [How To Design Programs](https://htdp.org/) aswell.",1542744702.0
roccobarbi,"I'm studying the book as part of a programming languages exam at university (along with common lisp, prolog, haskell and c). It is absolutely great and it will change the way you think about programming (eg. about recursion and iteration). I hope you will enjoy it as much as I'm doing. ",1542739712.0
strngsvlmstng96,"Would you say that making this language helped you understand programming better. If so, how?",1542868291.0
lispm,"    (
        (solved (caesar-cipher plaintext i))
        (format t ""Solved: ~a ~%"" solved)
            )

This has some weird formatting, which should give you a clue that something is not right.

Remember: there are basically 4 different forms allowed in Common Lisp:

    (some-macro ...)
    (some-function ...)
    (some-special-operator operator)
    ((lambda (some-arglist) some-body) ...)


Your code is none of above. It is:

    ((foo ...) (bar ...))

Basically it is missing the operator (function, macro, special operator, lambda expression).

    (what-operator-do-you-want
       (foo ...)
       (bar ...))


The error message itself is kind of unhelpful. I have seen a stream of questions on Stackoverflow with basically the same problem. I think it would be useful for the CLISP maintainers to come up with a better error message for this syntax error.

The CLISP error says that in

    ((foo ...) (bar ...))

(FOO ...) is a not LAMBDA expression like (lambda (...) ...).
That's true, but the actual typical error is one level above: the list ((foo ...) (bar ...))
 is missing an operator or a lambda expression at the front.",1542617453.0
theangeryemacsshibe,"- Your indentation and parenthesis placing is fugly. Pls stahp.
- You do need a LET form to bind SOLVED, and there are no extra parens after DO in LOOP.",1542614155.0
blue-dog-blues,"I am 100% linux based and I cannot just swap out distros like that, so not using Guix or the other one.  

However, I am fully on stumpwm, emacs, lem, stumpwm and now next browser.  Perhaps as clim keeps on getting better we can start to get full lis gui apps.

Lots of other users doing similar.",1542585988.0
emacsomancer,"Yes, I have [one machine](https://babbagefiles.xyz/guix_maze_of_lispy_little_passages/) that is GuixSD+StumpWM (and I run Emacs everywhere already).  With GuixSD, that means the package manager and cron are also Guile-based. There's a Common Lisp browser ([Next Browser](https://next.atlas.engineer/)) as well (not quite ready, I think). So that machine has Lisp for lots of the user-facing pieces.  

I know there are some people doing GuixSD+[exwm](https://github.com/ch11ng/exwm) as well.",1542593305.0
zck,"I found Guix really hard to get into. I love the idea, but I couldn't quite figure it out. :(",1542610721.0
strngsvlmstng96,"GuixSD is really intriguing to me! I will try to install it in a VM. I do also have a ThinkPad X201, but I'm not sure it will work there",1542596825.0
redback-spider,"I use nixos with exwm and would love to use next-browser if there would be any packages for it.

No lvm support for GuixSD makes it hard to use it for me. But yes I think exwm > stumpwm used the latter in the past, but it's buffer-switching (app switching) can't compete to the fuzzy matching find-buffer thing from emacs.

Also you have more context switching is it a app or only a emacs frame I want to switch so 2 menues instead of 1. Also elisp > common-lisp :D",1542734060.0
lispm,"https://github.com/sharplispers

",1542565496.0
bendudson,"There is a lot of good stuff here, generally well documented and with some tests. I also work on scientific computing / HPC kind of things, and would like to be able to use CL for this more. I've found Tamas' libraries very useful. Since CL is a standard these libraries will be around and useful for a long time. It would however be a shame if they faded into obscurity, only for someone else to implement their own from scratch. 

I have unofficially adopted/forked/usurped one of them, array-operations ([https://github.com/bendudson/array-operations](https://github.com/bendudson/array-operations)). ",1542575719.0
_priyadarshan,"Are [these the repos](https://github.com/search?utf8=%E2%9C%93&q=user%3Atpapp+language%3A%22Common+Lisp%22&type=Repositories&ref=advsearch&l=Common+Lisp&l=)?

[sharplispers](https://github.com/sharplispers) could be a possibility.

I also noticed, [Clarification: on orphaning my Common Lisp libraries](https://tpapp.github.io/post/orphaned-lisp-libraries/)",1542565543.0
where_void_pointers,"I do a lot of scientific computing, mostly in Python these days and have considered switching to Julia when the language is more stable. I do my hobby projects in Common Lisp. While working in CL, I have kept my eye out for how easy or hard it would be to do scientific computing in CL (partly because some of my projects will require some minimal scientific computing algorithms eventually), and honestly I have to agree Tamás with regards to doing scientific computing in CL and Julia (I've done a little with it, but mostly seen what others have been able to do).

Some of it definitely has to do with the differing interests in the communities that use them. The numerical library situation would be a lot better in CL if more people were using CL for this (there would be more libraries as well as better abstractions and other things). It would be a lot worse in Julia if not many people were using Julia for it. This sort of thing is true for all languages. The interests of the community of people who use it determines how many tools for what kinds of work are available. This shouldn't be surprising. CL has always been a sort of general language with a general target and a wide range of interests of its programmers, so with a small community, there just aren't that many doing scientific computing. Julia was designed for scientific computing by people doing it and that interest has dominated its use. Python is like CL in that it has a community with a wide variety of interests, but its community is many times larger (and is the go to language for scientific computing, but this is still a niche use) so there has been a lot of work on the scientific computing end of it just from shear numbers. One of the important variables here are large collaborative scientific computing libraries, ones big enough that they have many people developing them. Julia has them. Python does (take a look at Numpy and SciPy for examples). CL has a few (Maxima is a good example), but not as many.

Some of it is other things that the article also brought up.

Typed arrays not necessarily actually being packed arrays of the element type (whether it ends up actually being a t array or an array of pointers to whatever type it was given underneath) definitely makes scientific computing harder. But it is also a strength in other respects. CL is rather accommodating for how an implementation on a particular machine might do things. This is a good thing, but it isn't without a price.

Generics dispatching on class rather than type is an interesting topic. I've definitely sometimes wanted the latter so far in doing CL for non-scientific things. It is certainly doable to make another group of generics that do this using the MOP. After all, the MOP can be used to make the ANSI standard generics. I would bet at least someone has done this already. Just, I don't know who. It doesn't seem to be commonly used if it has been done. One sticky issue would be resolving which method is more specialized, but I can think of a few ways that can be done.

CL is a nice language for many things. Just, it isn't always the best for many things. Scientific computing is definitely one of its weak areas, both due to some things about the language but a lot of it just from not having accrued a lot of libraries and other tools due to there not being that many people interested in using it for scientific computing. That is the area where Julia shines both from a design (it draws a ton from Fortran and Python's Numpy after all) and from its community.",1542529058.0
ruricolist,"What impresses me personally about Julia is the effort the community has put into tracking down and implementing numerical algorithms that are legally unencumbered. The legal situation around numerical computing is a nightmare; Julia is, among other things, a resource for anyone who wants to port these algorithms into other languages (CL included) in the future.",1542575564.0
defunkydrummer,"Fair points on the article (the lack of generic vector type, for example).

I think Julia is very nice and I see Julia as a great replacement for Python. I don't see it as a replacement for CL in general because it doesn't have the full flexibility and power of CL. 

But it seems to be a smartly designed language, which isn't something I could say for some ""modern"" languages like Go. I also like, a lot, that Julia was designed with *speed* in mind. The last 20 years we had a trend of ""speed is not important"": Ruby, Python, etc.


 ",1542554907.0
tzjmetron,"I enjoyed reading the article. I am not an expert in the domain, but his arguments seem to make a lot of sense.",1542526953.0
heisig,"I hear plenty of people arguing over ""What is the best language for scientific computing?"", while they actually mean ""What is the best language for scientific computing that mostly behaves like Fortran and C++?"".  This is a huge difference.  Julia improves upon NumPy, C++, Fortran, Matlab and some others.  But fundamentally, it is still a notation for long sequences of floating point instructions.  Julia's focus is on numbers and arrays, not on objects and metaobjects..

But what if specialized imperative floating-point code isn't the best solution for scientific computing?  What if the tension between performance and maintainability can only be resolved by treating our scientific algorithms as data instead of code and by writing symbolic code generators instead of numerical codes?  In this case, Common Lisp might be an excellent language for scientific computing.

",1542637686.0
wellsford-lisp,"I talked with Tamas a while ago about this. While where\_void\_pointers post is a much more eloquent exposition that I can make one thing I can add is that Tamas did not regret using Common Lisp but Julia offers  a more ""batteries included"" approach for scientific computing which meant he could spend more time on research and less on building tools. Along with that, the Julia community spoke to his needs more than the CL community with its diverse interests could. 

&#x200B;",1542586348.0
joinr,">A sufficiently rich parametric type system with multiple dispatch integrated into the language and supported by a JIT compiler is the secret weapon of Julia. Most of the time, you don't have to do anything, as it happens automatically for concrete types.

Seems like uber type hinting.  Wonder why this hasn't caught on elsewhere (I think shen has a similar capability with its type system).
Pixie language tried going thus route with a custom jit via rpython (with mixed results).

>[Common lisp] has an ANSI standard, which means that portable code written decades ago will run on a recent implementation. This is a great advantage, but at the same time this freezes the language development at the point the standard was finalized. No matter how flexible and forward-looking it is, it cannot predict and accommodate all possible advances for decades.

Sounds familiar.  Sounds like the only way around is a new CL implementation (maybe like clasp) that provides substantial,  non portable extensions to address the limitations (or undefined bits) of the spec tamas ran up against.  Or library kludges. 
Maybe common lisp implemented in Julia with the type system directly exposed via more expansive type hints. 

On the other hand, code written for Julia last year may not run today due to volatility from flexibility (no spec).

Definitely sounds like he's in an active community where his contributions are both valued and used (more conducive to research interests) vs the (imo impressive) one man army gig.  Happy trails tkpapp",1542600127.0
CelloAxeMurder,"Are you sure `~/.mkclrc` doesn't work?

    $ cat '(print ""HI"")' >~/.mkclrc
    $ ./src/bin/mkcl
    ""HI"" 
    This is ManKai Common Lisp 1.1.10
    ...

BTW, if you're running mkcl via roswell, try `~/.roswell/init.lisp`",1542564518.0
ProfessorSexyTime,"Looks interesting, just keep in mind [uLisp](http://www.ulisp.com/) exists, but that's pronounced like the Greek letter mu (μ).",1542382910.0
larsbrinkhoff,Written by /u/netsettler.,1542353942.0
sugarshark,"A common approach in Common Lisp programming is that you first create a language suited for the problem and then write your solution in it. Of course, usually this is an iterative process, rather than sequential.

To get a feel for this approach, watch the *old but gold* screencast from Rainer Joswig (20min):

https://www.youtube.com/watch?v=5FlHq_iiDW0

(Thanks Zach for putting this on youtube) ",1542304080.0
KDallas_Multipass,"You're in luck!  /u/baggers_  just put out a video that introduces one of the killer features
https://www.reddit.com/r/Common_Lisp/comments/9wdk2r/lots_of_bits_of_lisp_macros_2_hr_episode/",1542303846.0
Bourgond_Aries,"Here are some things that will be extremely tedious to do in languages without macros, and every time you want to redo the operation, you'll have to redo the tedious steps.

1. Try and create a \`log\` ""function"" that prints both the expression and the result's value without writing the expression twice. ([https://pkgs.racket-lang.org/package/logger](https://pkgs.racket-lang.org/package/logger))
2. Rewrite \`(x h g f)\` to \`(f (g (h x)))\` as as seen in the threading library [https://pkgs.racket-lang.org/package/threading](https://pkgs.racket-lang.org/package/threading), this is also much used in clojure using \`->\`.
3. Make your own pattern matcher.
4. Memoize any function by just changing \`define\` into \`define/memoize\` ([https://pkgs.racket-lang.org/package/memoize](https://pkgs.racket-lang.org/package/memoize) or [https://pkgs.racket-lang.org/package/memo](https://pkgs.racket-lang.org/package/memo))
5. Create your own control structure. (e.g. [https://pkgs.racket-lang.org/package/spipe](https://pkgs.racket-lang.org/package/spipe))

The zen of lisp comes once you realize that the code you normally write is just you being a macro processor, and that lisp allows you to implement that processor so you don't have to do the work.

&#x200B;

Language is the ultimate abstraction.",1542310145.0
defunkydrummer,">what makes Lisp so specific and enjoyable for every Lisp fans.

In my own opinion, specific to Common Lisp, in no order:

1. Interactive image-based programming
2. Metaprogramming
3. The fact that you have the CLOS Object-oriented system available. CLOS is deluxe OOP. And you can even modify it!
4. The fact that you aren't forced to do OOP, and you aren't forced to do functional programming. You can program in the paradigm that better suits your problem. 
5. The ""conditions and restarts"" system. This is deluxe exception handling.
6. The `loop` keyword which some hate. This is a comprehensive domain-specific language, specific for doing iterations.
7. The fact that low-level is also within your reach: you can inline functions, disassemble them, disable argument count checking, etc.
8. Speed. CL can run quite fast.

>so far it didn't looked that different from defining a function, so I may have found an over-simplified example

Consider macros as functions that don't evaluate their arguments. And on Lisp those arguments can also be source code. So Macros can take source code as input and produce source code as output.

Now, since Lisp source is made of lists, and Lisp has a ton of functions to operate on lists, writing a function that transforms source code X into source code Y isn't really difficult at all.

>I'm also planning to start “Practical Common Lisp”.

Do it, it's an excellent book.

>I'm very curious to have a clear example about a practical case where Lisp “programmable programming language” makes things way easier compared to other languages like Python or C++

I'm afraid only years of experience with the Blub languages will be able to convince you. But the PCL book will help.

",1542310159.0
feralwhippet,"""On Lisp"", Paul Graham",1542330351.0
lisper,"http://flownet.com/ron/lisp/djbec.lisp

Scroll down to the function xpt-add and note the embedded infix syntax and the MODP macro which makes all the arithmetic inside it modular.

Also:

http://www.flownet.com/ron/lambda-calculus.html

https://github.com/rongarret/tweetnacl/blob/master/ratchet.lisp
",1542304203.0
flaming_bird,"> I've tried to learn quickly how you can extend the language, but so far it didn't looked that different from defining a function

Well, that's how you extend Lisp - you write functions. Macros are actually functions that transform Lisp code into Lisp code, so writing macros is writing functions; writing compiler macros is writing functions; writing reader macros is the same, except your functions now read from a stream and output, again, Lisp code. Extending the Common Lisp Object System means that you either write functions that you then insert into proper places of the object system (and they are called methods), or you define new classes and/or subclasses, which you can define these methods on. But, in case you wanted to ask ""that's how normal object-oriented programming works"", you define these methods and these classes *inside* the object system. CLOS is actually built in Lisp and its internal structure is defined by the Metaobject Protocol with multiple places where a programmer may write their own functions to influence the object system's behavior.

The implication of all that is that you can write functions to influence the syntax, you can write functions to influence the compiler, you can write functions to influence the way code is read, you can write functions to influence the object system. All of these parts of the language accept input from programmer - hence, they are programmable - hence, the language is programmable.",1542307279.0
agumonkey,"data, data, data, your code is data, your code as data is data

you can compute nearly everything

it doesn't matter the language level, you can implement it

tree recursion is your first bestest of friends, and induction solving process is the second one

ps: but please, stay away from kitchen sinks, lisp allows it too",1542315573.0
dzecniv,"> I'm a computer science PhD student.

did you see https://lispcookbook.github.io/cl-cookbook/arrays.html and https://lispcookbook.github.io/cl-cookbook/numbers.html ? Hope it helps, it was contributed this year by another scientist.

> things way easier compared to other languages like Python

I find that python's meta-programming concepts like decorators and with- statements are peculiar and limited. They follow their own rules, they are hardly extendable. You must learn how to create a decorator or the methods that make context managers to implement your owns. And yet they're limited, you can't do anything you want inside a context manager. All these would be written with regular macros in Lisp (and they are, see cl-annot for decorators). I wouldn't say it is way easier to write your own macros, but it's way easier to refactor your code how you like. (and in the end, we're like writing only functions indeed)
",1542326591.0
kazkylheku,"A good example of metaprogramming is how Common Lisp provides support for assigning into ""generalized places"":

    (setf (aref a i) 42)  ;; put 42 into array a at index i.
    (setf (car c) 'foo)  ;; put foo symbol into cons cell c's ""car"" slot.
    (setf (gethash key h) val)  ;; store val into hash table

The system is extensible: the programmer can introduce new kinds of places that can be assigned.

The set of operators is also extensible. In addition to `setf` there is `pushf` (push on a list stored in a place), `incf` (increment place), `rotatef` (exchange value among two or more places).

All of these operators ensure that a place which is accessed and updated is evaluted only once, and evaluation takes place in a left to right order regardless of the data flow direction.

The whole system of generalized places is built on macros. When macros are expanded, it goes away.  For instance, what is the code generated for incrementing the `car` of a `cons` cell stored in variable `a`, by a `delta` value?

    [2]> (macroexpand '(incf (car a) delta))
    (LET*
     ((#:TEMP-3213 A) (#:G3214 DELTA) (#:NEW-3212 (+ (CAR #:TEMP-3213) #:G3214)))
     (SYSTEM::%RPLACA #:TEMP-3213 #:NEW-3212)) ;

We can see that the increment is done in a sophisticated, robust way. Firstly, the expressions `a` and `delta` are evaluated into temporary variables.

The `car` is accessed to retrieve its current value, and this is added to the previously computed delta. This intermediate result is held in another temporary variable, `#:new-3212`.   Finally, the new value is stored into the `car` by calling a function: `system::%rplaca`.   

(The regular `rplaca` function is not used most likely because its return value is not suitable; the `incf` operator is required to return the new value, which would require an additional expression in the generated code.)

Nothing inside `incf` has hard-coded knowledge about how to treat `car`; that comes from a framework, where expanders for places are registered.

As you can see, macros behave like miniature compilers: they analyze expressions, generate temporary variables to coordinate evaluation and so on.

Think about how easy that is for the language implementor. All you have to do is provide the run-time support functions for storing into different kinds of places; no need to muck around with assignment syntax. Your macros do the rest. You can write them, test them and debug them interactively.



",1542310936.0
Goheeca,"* metaprogramming:
  * macro:
     * input: AST
     * output: AST
     * compile time manipulation
     * Turing complete
     * example: new language construction (e.g. missing the **with** construction just add it)
  * reader macro:
     * input: character sequence
     * output: AST
     * read time manipulation
     * Turing complete 
     * example: new syntax (e.g. missing the indentation sensitive syntax just add it)
* object system (CLOS):
   * being able to synchronize representations of a type (formal (class) and actual (instance)) (resolves circle-ellipse problem)
   * generic functions -- multiple dispatch
   * multiple inheritance
   * method combination (resolves multiple inheritance problems)
   * MOP (for more crazy stuff)
* conditions and restarts (~exception handling):
  * a condition (vs exception) is:
     * signaled (vs thrown) [at low-level]
     * handled (vs catched) [at high-level]; via:
     * restarted (vs N/A) [at mid-level]
  * You have to deal with the exception at the place you caught it. Usually, you either lose control what you can do because of abstraction or you're forced to choose a policy because you're at a too low level of abstraction.

Roughly; there might be some caveats. And it's not like other languages can't mimic various parts of it.

EDIT: Homoiconicity makes the macro part nice.",1542306806.0
afmoreno,"Other folks have mentioned the ""killer"" feature of Lisp: meta-programming but part of why you might be finding Lisp underwhelming is that many ""newer"" languages have incorporated many Lisp features. In fact, Peter Norvig claims Python as a Lisp.

RE: the wizard book. I think this book is more about how to think about programming, i.e., to develop the discipline required to bring good structure to your code. For instance, the first two chapters are totally functional--no assignment operations take place in the code. This is remarkable for a book introducing programming (well, there are no stated pre-requisites). The main course is grokking the `eval` and `apply` functions at the heart of a Scheme interpreter--pretty nice for an introductory book!

If you are interested in Lisp programming, you might want to check out Clojure: it is a Lisp and has very nice syntax for literals. It also has a very lively development community, especially when it comes to front-end technologies. (Yes, Common Lisp has a rich enough set of libraries to do just about anything. And there is no question that Common Lisp is the most complete language. I can only think of Smalltalk as an alternative when it comes to how comprehensive Common Lisp is).

Good luck!",1542320884.0
mredding,"So by analogy, when you code in C, it gets lexed and parsed, and transformed into an AST. This then gets transformed by the compiler and the executable is born. In Lisp, you ARE writing in AST, albeit in a serialized form. There is no distinction between the code, the program, and the data. The code IS data that you can write code to transform, and this can happen at runtime. You can't do this in C. Your code can generate code at runtime, compile it, and run that, and this is NORMAL for Lisp. It also makes DSLs trivial.",1542306664.0
xinnay,"Practical Common Lisp is cool. I'm very interested in Common Lisp, but when I wanted to know some features of Common Lsip, it is hard for me to find it out, and it always made me frustrated.

I used macro once, and it really attract me. When I write some repeat code with Python, sometimes I will wonder if can I make it in Common Lisp.",1542332610.0
Alexander_Selkirk,"I think this is a very nice example about the power of functional programming in Lisp:

https://aphyr.com/posts/312-clojure-from-the-ground-up-modeling

(By the way, Clojure is unanimously considered a Lisp. However it also has some things in common with languages of the Scheme family, among them a tendency to minimalism and a very strong support for a functional programming style.)
",1542757893.0
nillynilonilla,"It *is* just normal function defining. The magic comes in beforehand, by having function defining be nearly the only syntax, and unlike other functions-are-the-only-syntax languages, such as Forth or PostScript, the parens make it so you don't have to do everything backwards and keep a stack in your head. Functions as the only thing, is like the way the subtle universe works, which makes everything work out relatively splendidly.",1542352310.0
joinr,">from what I'm reading about Lisp, it looks like it is absolutely suited for my subject.

What makes you say that?

>I have started to read the “wizard book”, because it seems to be the golden rule to understand everything

Since you're already in the Wizard Book (SICP), chapter 4 is where the higher-minded metacircular magic happens (metalinguistic abstraction as the authors say).  

""The evaluator, which determines the meaning of expressions in a programming language, is just another program.""  

If our evaluator is a program, and programs are already data (lists) interpreted by our list processor, we can trivially write new programs (evaluators) to interpret expressions however we want (extending the existing ""language"" or altering/replacing its semantics) by transforming input programs (lists) prior to applying eval to the result:

""An important advantage of making the evaluator accessible as a Lisp program is that we can implement alternative evaluation rules by describing these as modifications to the evaluator program.""

They then implement Scheme in Scheme (write your own eval, and analyzer).  This is effectively the broadest means of extending the language using its own constructs (defining a custom eval), yet the resulting implementation of eval is incredibly elegant and simple to read.  Seeing eval so simply defined in chapter 4.1.1 was a big lightbulb moment for me (as it turns out, there are even simpler ways to define eval).   Later, the simple evaluator is extended to enable different semantics, like nondeterministic programming and logic programming.

Another insightful book is Lisp in Small Pieces, which takes an approach similar to the metacircular evaluator chapter in SICP, and implements varying lisp dialects with more complex features, as well as demonstrating how to bootstrap interpreters from non-lisp languages.

Peter Norvig has an excellent post on implementing a lisp in python that helped me grock how powerful yet simple  a lisp can be [here](http://norvig.com/lispy.html).  I found his implementation of an interpreter, to include [extending it](http://norvig.com/lispy2.html) to include macros, continuations, and more.  A lot of this also exists in his book Paradigms of Artificial Intelligence Programming, except the base language is Common Lisp, but the target is still Scheme.  He bootstraps an interpreter, and later a compiler for a virtual machine.

Rather than hacking a custom eval function every time, lisps typically make use of macros to formalize specific extensions to the language.  Macros serve as a kind of escape hatch or middleware between the user and eval.  It gives you the ability to modify the input program (the s-expression) prior to passing it off for evaluation.  Since the program (s-expression) is a datastructure that the host lisp has rich facilities for manipulating, macros are very powerful and flexible means for extending the lisp in a controlled fashion.  Macros are effectively a recognition of the utility of metalinguistic abstraction, endowing the programmer with the powers of the language-creator.

Ultimately, ""On Lisp"" and ""Let Over Lambda"" (and PAIP) leverage macros in fascinating and powerful ways, where SICP introduces the concept on a more fundamental, constructive level.  By eschewing syntactic shackles and embracing a simple unified data representation for expressions in the language (lists), you end up with a simultaneously simple yet powerful system that's inherently amenable to extension via metalinguistic abstraction.",1542409378.0
ImpracticalPotato,"In order to understand the true power of Common Lisp, you must understand its greatest weakness.

Common Lisp is unrestrained power. What does this mean? Any one can make a huge mess since there are macros, eval, CLOS, etc. People coming from overly restricted languages like C++ can and will use every ""powerful"" feature they find to walk code, change semantics of the language, repackage built-in symbols, and do all other sorts of impossible nonsense. Why does this happen? Because when you are weak, like a C++ developer, you never learn restraint. Because of this, Common Lisp suffers from a management problem. If all your developers are using a weak language, there is only so much damage one developer can do. Here is a similar idea by Fare who [pointed out](https://fare.livejournal.com/tag/lisp) that CL is a ""hippie language"". He has experience managing CL projects with ASDF. There was another blog post by another author about how CL is too powerful but I can't seem to find it.

&#x200B;

If all developers could exercise restraint then perhaps Common Lisp could flourish. But this is like saying if everyone in the world was good there would be world peace. That will never, ever happen, except if your world if small enough or everyone is homogeneous. This is why Common Lisp projects start small and stay small. It's like communism, you need everyone to follow the rules. Thus the link between communism, open source, and common lisp.

&#x200B;

However, there might be hope for a solution in a lisp that incrementally adds power \[at one point the [X3J13](https://en.wikipedia.org/wiki/X3J13) committee was debating whether common lisp should be separated into different parts like a ""core""\] and/or permissions/capabilities like [scheme48](http://s48.org/). I think it was Paul Graham who said that as time passes, weak languages like C++ absorb features from common lisp. Or see [Greenspun's tenth rule](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule). In common lisp, everybody gets absolute power no matter what, their is no social hierarchy, thus no government, it's anarchy. That's why fundamentally weak languages with things tacked to mimic Common Lisp on succeed economically but Common Lisp does not. Self plug: I'm trying to figure out how a lisp bytecode interpreter could have capabilities, not extensively, but similar to the JVM.

&#x200B;

**TLDR:** To understand the true power of Common Lisp, you MUST exercise restraint, otherwise you will make a complete mess of things while you are inexperienced.",1543623180.0
CelloAxeMurder,"""So to me, programming hasn't changed much in 50 years because, they got locked into this strange set of limitations""",1542235326.0
rman666,"OT: I met Minsky once about 25 years ago at an AI conference in Phoenix. True to his pictures he was wearing a turtle neck. I don’t remember much more, unfortunately.",1542249027.0
Bourgond_Aries,"He's talking about macros but that nobody ""does that yet""? Did he mean something else?",1542241100.0
CelloAxeMurder,"Lem is a really exciting project. What is ""Added “peace of paper” like symbolics"" though?",1542214739.0
Aidenn0,"Is there a getting-started guide for lem?  I don't know many emacs keystrokes, and `M-x help` did not work.",1542223623.0
agumonkey,Heresy !,1542230433.0
dcooper8,"Nice article, a couple comments:

Lisp can be interpreted, but normally is compiled -- and can be incrementally compiled to achieve the effects you describe. 

Lisp-Lang.org is not “the” Common Lisp website, it’s “a” Common Lisp website. Another (longer-standing) one is common-lisp.net. 
",1542183005.0
ObnoxiousFactczecher,"> first-class functions (functions that can take functions as arguments)

That's functions *that can be used as values*. In other words, in the ""functions that can take functions as arguments"" scenario, they're the latter functions (""functions as arguments""), not the former ones.

> it’s interpreted

It's not, overwhelmingly.",1542210866.0
lispm,"\> Next one is [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp) which started almost 10 years later - in 1984.

Common Lisp did not start new.

Common Lisp is a modernized version of Maclisp and especially another Maclisp successor: Lisp Machine Lisp. From Scheme it mostly (only) got the idea of default lexical binding. Maclisp itself is a variant of the original Lisp 1.5 and was started in the late 60s.

""Common Lisp the Language"" (the original reference) says: ""Common Lisp originated in an attempt to focus the work of several implementation groups, each of which was constructing successor implementations of MacLisp for different computers.""

When Common Lisp first appeared, several of the Lisp books got new editions where the code was slightly changed to Common Lisp.

As such it is in direct line of heritage with the original Lisp and largely compatible. Winston/Horn's classic LISP book got a second edition in 1984 taking the CL changes into account. In 1989 a 3rd edition then got more CL changes, like the use of CLOS.

Emacs Lisp is also a based on Maclisp - but simpler / more primitive than both Maclisp and Common Lisp - since it was originally only designed as a language to implement/script an editor. Over time the programs implemented in it got more complicated and new language features got introduced - incl. a lib providing CL functionality - which was not loaded by default, but was used by a lot of other libs.

Scheme was a new dialect with some incompatibilities and new ideas, but it was first developed on top of Maclisp and it slightly shines through. Later versions of Scheme had some influence from Common Lisp (like the numeric tower or CLOS like object extensions in actual implementations). Clojure OTOH is a fully incompatible with any earlier Lisp - it's basically a new language with some influence from Common Lisp. No Lisp code can be easily ported and most of the time it would make no sense, since the language is so different.

Common Lisp and Scheme are languages with standards and many different implementations. Emacs Lisp, Racket and Clojure are mostly language/implementation combinations - they each have one single lead implementation (though Emacs Lisp has seen mostly compatible forks - like the Xemacs version).

&#x200B;",1542139418.0
KahMue,"You could peek inside the 'loop'-clause by macroexpand-1ing it:

    (macroexpand-1 '(loop for n from 1 below x by 1 when (d n) sum n))

`(BLOCK NIL`

`(LET ((N 1) (#:LOOP-LIMIT-733 X))`

`(DECLARE (TYPE (AND NUMBER REAL) #:LOOP-LIMIT-733)`

`(TYPE (AND REAL NUMBER) N))`

`(SB-LOOP::WITH-SUM-COUNT #S(SB-LOOP::LOOP-COLLECTOR:NAME NIL`

`:CLASS SB-LOOP::SUM`

`:HISTORY (SB-LOOP::SUM)`

`:TEMPVARS (#:LOOP-SUM-734)`

`:SPECIFIED-TYPE NIL`

`:DTYPE NUMBER`

`:DATA NIL)`

`(TAGBODY`

`SB-LOOP::NEXT-LOOP`

`(WHEN (>= N #:LOOP-LIMIT-733) (GO SB-LOOP::END-LOOP))`

`(IF (D N)`

`(SETQ #:LOOP-SUM-734 (+ #:LOOP-SUM-734 N)))`

`(SB-LOOP::LOOP-DESETQ N (1+ N))`

`(GO SB-LOOP::NEXT-LOOP)`

`SB-LOOP::END-LOOP`

`(RETURN-FROM NIL #:LOOP-SUM-734)))))`

which is interesting to read, I think.Given the fact that 'do' expands into 'tagbody-go' as well, one might get the impression, constructing highly optimized loops would be much easier, using tagbody-go directly.",1542154346.0
defunkydrummer,">So function that returns t when number is multiple of 3 

I can bet `npm` has a library called `ismultipleof3`

",1542137156.0
sammymammy2,"Instead of using a series of declare forms you can just wrap all the arguments into one call.

So

    (declare (type fixnum var) (optimize (speed 3))",1542145691.0
eduol,"Thank you for sharing!

I'd like to know more about your reasons to choose Common Lisp instead of Racket",1542152456.0
defunkydrummer,">In the end we still got very nice improvement, from 3.767s down to 0.243s.

Yes you did!!

It would be interesting to compare what you did, with a simple (loop) that does everything and uses type declarations (loop also allows type declarations).

",1542137485.0
Falcon5757,Chance for a sequel?,1542559305.0
CelloAxeMurder,"Starting it back up. We had a few meetings a couple of years ago, but then the thing expired on Meetup due to other commitments. ",1542058901.0
adam_kruszewski,"Great news! I might move to Austin next year, so I'll defintively bookmark your meetup :)",1542405304.0
metayan,"Ah, so nothing today…

How about some nice OpenGL fireworks in CEPL for the final stream this year? ;)",1542221334.0
phalp,"I don't believe anything that creates a large number of lines or boxes on the screen can really work out. Parens are nice because they nest but don't themselves have a big visual footprint. If there's a path which doesn't dead-end too soon, it's *selectively* applying multiple visual aids to bring out the structure without creating visual chaos.

EDIT: I'm thinking of something like:

    _defun oper-to-string (oper)_
    "" Convert a functional operator to a string representation""
    _let ((str-res ""nil""))_
    ⎛setf str-res             ⎞
    ⎜⎛cond ((eq oper #'+) ""+"")⎞⎟
    ⎜⎜     ((eq oper #'-) ""-"")⎟⎟
    ⎝⎝     ((eq oper #'*) ""*"")⎠⎠
     ------------o------------


Understanding the underscore as underlined text, and the characters which may not show up as large parentheses. At the end is a kind of superbracket line.

EDIT: It could be pretty useful just to mark parens which aren't closed until a later line. If you did that you could reduce some of the indentation and also make it easier to visually match parens. Could color them or use another type of bracket like this:

    ｢defun oper-to-string (oper)
    "" Convert a functional operator to a string representation""
    ｢let ((str-res ""nil""))
    ｢setf str-res             
          ｢cond ((eq oper #'+) ""+"")
                ((eq oper #'-) ""-"")
                ((eq oper #'*) ""*"")｣｣｣｣
",1542061122.0
justin2004,"parens are visual clutter? 

expressions have to be bounded in some way.

is attention drawn to lisp's expression boundaries just because the closing boundaries mostly occur contiguously?

i bet the 'parens are visual clutter' feeling comes mostly from people that either:

- don't use a text editor that highlights the complementary paren when the cursor is on a paren.

- haven't used lisp for more than like a dozen hours or so

EDIT: 
but since the writer of that blog post doesn't satisfy either of those conditions i'll add one more guess...

- maybe some people expect elegance to be both pleasingly stylish in manner AND appearance",1542071818.0
notlikethisplease,"Am I missing something, or is the only problem with the second version that two adjacent child expressions of the same parent are assigned the same color, and are thus not distinguished as separate expressions without parentheses? Because if so, you could fix that by using a different color for each contained child expression (instead of the seemingly more complicated solution the author proposes).",1542079365.0
Phenobody,!remindme 5 days,1542091988.0
ImpracticalPotato,You may be interested in this post: [Five Approaches to SEXP highlighting](http://lemonodor.com/archives/001207.html) . Those people mentioned might give you ideas and/or source code,1542238846.0
tzjmetron,The interesting bit is this - https://www.ravenpack.com/careers/ :-) (apparently the place where he currently works).,1541879597.0
dasuxullebt,"The image, lol :3",1541803606.0
defunkydrummer,"/u/jasilven : Make your lisp happy and peaceful by using `enable-happy-lisp`, this will stop the shouting:

    (defun enable-happy-lisp ()
        ""For a life of joyful, gleeful programming and endless mirth.""
        (setf *print-case* :downcase)
        (format t ""~{~80:@<~A~>~%~}"" '(""Happy, happy!!"" 
                                       ""Lisp is SO happy now!!"")))

Author: Yours truly

License: MIT

",1541782340.0
bobbane,"/u/flaming_bird is correct about the use of case to make it clear what is REPL input and what is REPL output.

Remember, Lisp goes clear back to the days of Teletype interactivity - just letters on a roll of newsprint.  The only reasonable way to make output look different from input was to have user input be lower-case, and Lisp output be UPPER-CASE.

Really, you get used to it with exposure.  But...

If you just want Common Lisp to not shout at you, [\*print-case\*](http://clhs.lisp.se/Body/v_pr_cas.htm) is the setting you want.  Put `(setq *print-case* :downcase)` in your Lisp's init file.

Eventually you will want to know stuff like what the reader does with case, and how to control it, and the difference between symbols and strings; this should be enough to get you started without feeling shouted at.

&#x200B;",1541775534.0
flaming_bird,"Common Lisp programmer here.

The basic reasoning is to differentiate user input from compiler output. User-typed code will usually be lowercase and Lisp output will be uppercase. Therefore, the result of evaluating `(list 'foo 'bar 'baz)` will be `(FOO BAR BAZ)`.

By default, the Lisp reader upcases all symbols, though, so you can tell Lisp to evaluate `(LIST 'FOO 'BAR 'BAZ)` or even `(LiSt 'FoO 'bAr 'BaZ)` - they are equivalent.",1541773119.0
nillynilonilla,"IS LISP ANGRY? IS LISP ANGERY?!?!?!! AS A YOUNG LANGUAGE LISP WAS TEASED FOR ITS HOMOICONICITY AND ITH THPECIAL ETHTH EXPRETHION THYNTAX. LISP WAS TOLD IT WAS SLOW AND EVEN TEASED FOR ITS GARBAGE COLLECTION1!! LISP DID EVERYTHING FIRST! EVERY LANGUAGE MUST ACKNOWLEDGE LISPS SUPERIORITY!! IS LISP ANGEREY!?!!?

LISP WAS BETRAYED BY A SERIES OF CORPORATIONS AND GOVERNMENTS WHO FUNDED MUCH OF ITS DEVELOPMENT, FOR REASONS STILL OBSCURE!! THEN LISP WAS ABANDONED BY ACADEMICS WHO PREVIOUSLY ADORED IT! IS LISP ANGEREY!?!!?

DESPITE MODERN PEOPLE MAKING PILES OF MONEY ON SECRET LISP PROJECTS, AND MODERN PUNDITS TOUTING LISPS QUITE OBVIOUS SUPERIORITY, THE ONCE BEAUTEOUSLY ASCENDANT LISP LANDSCAPE STILL LIES IN RUIN, LIKE VAST ANCIENT ELVEN CITIES, CRUMBLING, SURROUNDED BY THOUSANDS OF RECENTLY BUILT AND QUICKLY ABANDONED HOVELS AND LEAN-TOS AND A FEW TUMBLEWEED TOWNS, INHABITED BY ONLY THE MOST REBELLIOUS, IDEALISTIC, TENACIOUS, OR FOOLISH WIZARDS AND SORCERESSES, BUT CONSTANTLY FREQUENTED BY MANY GAWKING TOURISTS. IS LISP ANGRY????

LISP HAS EVEN HAD TO ENDURE THE SAGA OF POOR LITTLE DYLAN, WHO WAS TO BE ITS SUCCESSOR, FILLED WITH PROMISE OF WISDOM, YOUTHFUL STRENGTH, AND BEAUTY, BUT SEDUCED BY THE LIKES OF JAVA, AND BEFUDDLED AND TRICKED BY MORE CORPORATE GREED, FELL TO THE HERESY OF INFIX, AND WENT ON TO LANGUISH IN OBSCURITY. BUT IS LISP EVEN ANGRY!?!!?

SO MANY PEOPLE SEEM TO TALK ABOUT HOW GREAT LISP IS, BUT DOES ANYONE HAVE THE TIME, ENERGY, WISDOM, RESOURCES, AND ABILITY TO COOPERATE ENOUGH TO BUILD A NEW LISP WORLD?!?!? OR EVEN JUST SLOWLY FORM A NEW CIVILIZATION??!?? AND YOU ASK IS LISP ANGERY??!?


WAIT.. AM I SHOUTING?? (DOES THIS SOUND LOUD TO YOU GUYS?? (THIS IS JUST MY NORMAL VOICE.))

Oh. Um.. Actually, scratch that. Lisp is really pretty chill. I had just somehow done `stty olcuc` and was typing on a TeleType. 
",1542110921.0
where_void_pointers,"Symbols are upcased to all caps by default when being read. In fact, the names of all the functions in the CL package and CL-USER have this. There is a way be able to use capitalization and other characters in symbols. You have to enter them between vertical bars as in

    '|foo|

which is the symbol of lowercase foo. To demonstrate that the builtin functions are captitalized, you can try running

    (apply #'|list| 1 3)

and see that CL will complain that there is no function with the name in the CL-USER package.


Common Lisp is not the only programming language where a lot of stuff is in all caps (though the language may hide it from the user or be case insensitive and allow lower case versions of things to be used). Fortran is another example. Well, to be more accurate, FORTRAN (which is actually the acronym FORmula TRANslation). Standard FORTRAN used to require that a lot of things be in all caps, but pretty much all compilers were forgiving and let one use lower case. It wasn't until a recent standard (I think it was Fortran 90) that such an allowance was entered into the standard, if I remember correctly.",1541789094.0
Duuqnd,LISP CONVERTS SYMBOL NAMES TO UPPERCASE BY DEFAULT.,1542180279.0
strngsvlmstng96,"Thanks for all the answers in this thread. This is something that throws me off a little, but I know that Lisp means no harm :) ",1542079691.0
theangeryemacsshibe,"copypasting the intro from the README:

---

# magrathea: chaotic-neutral web security for Hunchentoot

- Bored of people scanning your website for vulnerabilities you don't have?
- Want to do something about skiddies?
- Hate scrapers?

Magrathea is just for you! It uses state of the art [zip bombs](https://en.wikipedia.org/wiki/Zip_bomb), with zero configuration required for normal use. 

---

anyways the general principle is that you maintain a list of regexps for sketchy paths and/or functions which detect them, and if one IP loads too many of those paths too quickly, Magrathea triggers and zip bombs the scraper. some of you may notice the reference to the [temporarily-closed planet with thermonuclear missiles](https://www.youtube.com/watch?v=lQYpdNmmhBY).

this is my first really-CLOS project, but the hunchentoot docs were quite clear about subclassing acceptors and it worked on my machine^(tm).",1541753894.0
Laugarhraun,"This is most excellent, and I found the source pleasant to read.

Just 1 typo: irrelevent → irrelev**a**nt",1541767314.0
waspishly_simple,"I'm all for defence but your counter-attacking ""defence"" is foolish and could be construed as an attack and therefore illegal.

It's especially problematic for false positives.",1542102032.0
republitard,">     (define $Γ~__ (with-symbols {i} (. g~#~i Γ_i_#_#)))

Looks like line noise. Are `g~#~i` and `Γ_i_#_#` the names of  variables, or is the compiler picking those apart and doing things that would give Cthulhu nightmares?",1541648876.0
MWatson,"ABCL is alive and well. I especially like using it for mixing deeplearning4j with Common Lisp code. I don’t know how the core dev team feels about asking for tips, but Patreon style tipping is a good way to let developers know that you like what they are doing.

Rich asked for contributions when we was first rolling out Clojure and I and many other people were happy to support something we believed in.",1541532823.0
defunkydrummer,">Does anybody know if ABCL is still an active project? 

ABCL is still active, of course.. I use it, calling Java libs is extremely easy.

NOTE: It seems the ABCL Trac is down, it used to be working just one or two months ago. I'm opening a post on /r/common_lisp about this.

>JRE 1.11?

Not sure if I follow. Do you mean ""Java Runtime Environment (64bit) 8 Update 111""?

For what it's worth, my machine has Java SE Runtime Environment 1.8.0_161, ABCL works fine.



",1541530801.0
defunkydrummer,">getting a nice GUI for CL

Note that for GUIs there are other alternatives. Listing only the free ones I can remember:

Multi-platform:

- Qt through EQL, qtools and others
- Tcl/tk through LTK and Celtk
- Gtk

Only for X11:

- McCLIM, *the stuff that really boring dreams are made of.*


",1541531811.0
eccp,You might want to look at Clojure and the Seesaw library (a wrapper for Java Swing) if you are targeting the JVM,1541528764.0
timezone_bot,"6pm UTC happens when this comment is 1 hour and 37 minutes old.

You can find the live countdown here: https://countle.com/69LZbBk4f

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1541521376.0
_my_name_is_earl_,"> The broadcaster indicated that the channel is intended for mature audiences.

I'm scared",1541534674.0
pauljewell,"6PM UTC as in the heading or 7PM UTC as in the message :)
I suspect the latter, now summer time has passed?",1541612513.0
,"Did you forget to upload to YouTube this week? Sorry if you are just busy.

&#x200B;

I need my hit, man",1541771301.0
maufdez,"I think this is one of those questions that have many answers depending on who you ask, I like Common Lisp but some  people prefer a Lisp1 and would suggest Common Lisp, some people will suggest Clojure (I am not one of them), there is at least one person suggesting PicoLisp, and so on. My suggestion, to be objective is to try to understand what the differences are, and see if you consider them advantages or disadvantages, then you can decide for yourself.

That said, I would stick with Scheme (or Racket) or Common Lisp, I personally recommend Common Lisp, here are some things I like about it (some might be true for Scheme too).

\- Multiparadigm (you are not constraint to functional or object oriented, etc)

\- CLOS (one of the best Object Systems ever)

\- Uniform and simple syntax

\- Several implementations to fit your needs

\- A great community with diverse interests

\- A ton of native libraries and bindings to C libraries

\- SLIME, which is one of the best programming environments I've experienced in my life (I've been programming for 33 years and have tried a lot of languages and IDEs).

\- You can write very simple prototype code, and if necessary tweak it easily to make it highly performing (to the level of a C program or better many cases).

\- Disassembly

\- The Debugger and Restart system, which is useful not just for development but to debug a running program, and has some characteristics that make it invaluable, [have a look at this](https://malisper.me/debugging-lisp-part-1-recompilation/).

\- And of curse Macros, the macro system in common lisp is very powerful, allows you to change things at various stages, and I think most of the time is very readable and understandable.

&#x200B;

\*Edit: Correction of a erroneous phrase.",1541520775.0
where_void_pointers,"It depends on what you want to do with it and what sorts of things you would like to do while learning it.

Standard Scheme is relatively small and thus there isn't that many different things to learn, though some of them can be quite hard (continuations, syntax-case, etc. are particularly difficult). But every Scheme implementation adds a lot of implementation specific things. If you decide you want to switch implementations, you might be in for a bit of work and re-learning. Huge variation between implementations. You might find it doesn't have what you need for what you want to work on. But it has a certain elegance to it and some of its features can be just the right thing you need. Also, from a purely learning perspective, it can be fun and educational to try to figure out how to do every iterative construct with recursion (Scheme doesn't have any iteration structures, just recursion that if done right won't blow the stack) if you don't have any experience with a language that works like that before, though you feel right at home in that respect if you have used an ML, Haskell, etc.

Common Lisp is significantly bigger than Scheme, with many quite standardized extensions beyond the language. Also, it is much easier to switch implementations since most implementation specific features you would want to use you would use a glue library that wraps around the equivalent features for several implementations. It also has SLIME and is pretty interactive. However, it can be kind of ugly. But it is surprisingly easy to feel comfortable in when coming in from another language.

I can't speak much about Clojure, sadly.


Me, when I came to lisp the first time, I played around a bit with Common Lisp and Clojure but didn't stick with it. Then came back a couple years later and tried Scheme and really loved it and stuck with it quite a while. It was very worthwhile. Went over to Common Lisp almost a year ago and been doing it quite heavily since then. Really enjoying it.",1541539920.0
dzecniv,"If you're interested into Common Lisp, I like those resources: https://github.com/CodyReichert/awesome-cl for a beginner-friendly list of libraries, and the https://lispcookbook.github.io/cl-cookbook/",1541591229.0
tzjmetron,"As much as I like Common Lisp, I would have to say Clojure. Once you start building stuff, you will need a community, and Clojure has a very helpful community. Plus, great functional programming support, of course.",1541528515.0
tankfeeder,try PicoLisp.,1541517017.0
dzecniv,"The author has many interesting Lisp projects. For example:

- https://github.com/fisxoj/postmodern-passenger-pigeon migrations for postgre
- several Clack middlewares https://github.com/fisxoj/clack-middleware-compression
- https://github.com/fisxoj/map ""octave-like"" functionnality",1541513905.0
defunkydrummer,Thank you very much /u/fisxoj . This is very useful.,1541529970.0
svetlyak40wt,"By the way, I also have Docker images for Lisp development and deployment. They are built with SBCL or CCL and include Quicklisp, Roswell and Qlot:

https://github.com/40ants/base-lisp-image

Also, it have sane versioning, changelog and regular updates.

Here is how you can use it to start the repl:

```
docker run --rm -ti 40ants/base-lisp-image:latest-ccl-bin
```

",1541579177.0
defunkydrummer,">Coalton is a dialect of ML embedded in Common Lisp. It emphasizes practicality and interoperability with Lisp, and is intended to be a DSL that allows one to gradually make their programs safer.

Wow.

Applause to Mr. Robert Smith. This is something i have dreamt about so much -- an unification of ML with Lisp. Yes, there is Qi and Shen, but they were too much their own languages, with a syntax that made me scratch my head (but then, maybe i have to switch shampoos).

May this metric ton of coal be the fuel that puts the next CL projects on the fast track. This is very exciting, and let's hope I can have enough free time (and brain power) to contribute too.

*Fun fact: The first ML implementation was written on a Lisp (can't remember which one, pehaps Le_Lisp?)*

",1541431117.0
stylewarning,"This isn’t really ready for prime-time. Hopefully an MVP will be working in about a weekend or two, but it’s a barely functioning prototype right now. Don’t get too excited! :)",1541429639.0
Lower_Cryptographer,"SLIME is better than Jupyter notebooks AFAIK

You can literally use Jupyter with Common Lisp though: https://github.com/fredokun/cl-jupyter

Also I never liked DrRacket, it's really slow and not very interactive.

EDIT: https://github.com/fredokun/cl-jupyter/blob/master/about-cl-jupyter.ipynb",1541339100.0
vermiculus,"As long as you don't use the Java-y bits of Clojure right off the bat, I don't think you'll miss out on the 'a-ha' moment of Lisp.  If you want, you can try to find a Lisp-based tutorial and just do it in Clojure – most differences at that level are nominal (usually quite literally: `defn` instead of `defun`, etc.).

You could also use Emacs+Elisp; that environment is still ok to work with on windows.",1541351119.0
roccobarbi,"I would say that you can do a lot with slime (on emacs) and the free version of a commercial common lisp implementation (e.g. Allegro Express).

Personally, I find that it speeds up my work on other languages a lot. It might be a very basic usage, but it enables me to define my own very high level language that compiles to Javascript. This way I can express the equivalent of tens or hundreds of lines of Javascript with just a few lines of code (I often work with the same code structures, changing implementation details as needed).

And this is just scraping the surface of what you can do with lisp. ",1541342522.0
ObnoxiousFactczecher,"> easy, interactive programming (a-la Jupyter notebooks)

I find it strange that you'd find Lisp environments as ""arcane and ancient-feeling"" when they're mostly the same thing. It's not that it's a ""silly reason"", it's more like a completely wrong perception. If anything, Jupyter feels to me severely flawed in how it pretends to be something improved when it really copies the deficiencies of the Lisp environments, for example in how manually re-evaluating portions of code can screw up the consistency of your program's state. Of course, Lisp doesn't generally make the mistake of saving the screwed-up state with your source file, or pretending that it is something that it isn't.",1541417112.0
defunkydrummer,">I find most Lisp environments I've tried kind of arcane and ancient-feeling

Have you tried the combination of Common Lisp, Emacs and SLIME? It *looks* arcane and ancient, but I guarantee you that in terms of programmer productivity, it's as modern as it gets.

Also, installing it can be as easy as one click -- just download Portacle, the Portable Common Lisp Environment.

>and it seems to be easier to use in a familiar, interactive way

I would say one of the drawbacks of Clojure is lesser support for interactive programming compared to CL and Smalltalk. 

>However, I'm a bit wary since it's predominantly functional and based on the JVM. How much would I miss out on regarding the Lisp ""a-ha moment""?

You wouldn't miss any ""a-ha moment"" with Clojure since it is also made of s-expressions and supports macros. However it is a significantly different language to (Common) Lisp and Scheme, with a different philosophy, firstly because it is focused on functional programming.  



",1541431586.0
dzecniv,"Alternative interactive tools for CL:

- https://hub.docker.com/r/drmeister/cando/ (https://github.com/drmeister/cando) is Jupyter notebook for CL in C++ (CLASP implementation)
- cl-repl: https://github.com/koji-kojiro/cl-repl (in development but works and easy to setup)
- there's also Lem, a ready to use CL editor with an ncurses and an Electron interface, and the Darkmatter notebook: https://lispcookbook.github.io/cl-cookbook/editor-support.html
",1541355984.0
joinr,">it seems to be easier to use in a familiar, interactive way (e.g. >with BeakerX notebooks).

There are several notebook environments, as well as interactive online mediums for learning: 

http://gorilla-repl.org/

https://www.maria.cloud/

http://timothypratley.github.io/power-turtle/

Most folks use a editor though, varying from the Emacs/Vim holy wars, to graphical IDEs.  Note: every environment is inherently interactive...you spend most of the time ""conversing"" with the REPL, and the tooling exists to help enrich the conversation.  Most of the IDEs have insta-repls (allow inline evaluation of forms in source-code, showing the result next to the form...).  I typically stay in the REPL and eschew the cool toys like Instarepls, but they are cool and possibly helpful for beginners.

[cursive](https://cursive-ide.com) is popular.

I use emacs (actually SpaceMacs) which is easy to get a highly useful interactive environment setup [shown here](https://www.youtube.com/watch?v=Uuwg-069NYE) or written instructions [here](https://practicalli.github.io/spacemacs/) .  Windows users need to grab the emacs windows prebuilt binaries, but should be able to follow along (I'm on W10 most of the time).

There are plugins for VSCode and other editors as well, although I don't think they compete on the same level as aforementioned ones.

>However, I'm a bit wary since it's predominantly functional 

Why?

>and based on the JVM.

Clojure is more than just the jvm variant.  Arguably, the JVM version is tied in popularity too.  CLJS seems to be in heavy use as well (proportionally).

ClojureScript can run many places (browser, Node, any JS runtime including v8 and core, rhino, graaljs).  ClojureCLR runs on the .net virtual machine (significantly less popular, but no less functional).  There's presence in multiple ecosystems, typically with first-class interop since clojure is designed for hosting and leveraging the broader ecosystem (in addition to portable clojure ala .cljc).

You even have the option these days of native-image generation via Graal for a decent subset of programs so you can ditch the JVM and only pack bits you need into a relatively small executable.  You (currently) lose support for the lispier bits (can't use eval, compile), but - as demonstrated with non-bootstrapped clojurescript for years - this ends up being extremely useful for deploying many kinds of applications.  It's a new (read experimental) area though, but folks are putting it into production - or using cljs for scripting - or sticking with clojure (via the clj script) for scripting too.  There may be support for classpath modification in the future with graal, so that could mean some limited introduction of eval in the future.

>Also, alternative interactive ways of using other Lisps are welcome suggestions!

I'll add the nth recommendation for portacle.  That's a solid environment for Common Lisp, built around Emacs.  Like spacemacs, the maintainer has already selected and configured a bunch of useful packages for you, so it just works out of the box.",1541450151.0
f0urier,Just install [https://cursive-ide.com/](https://cursive-ide.com/) and Clojure and try it out.,1541505187.0
github-alphapapa,"The [start page](http://lambdaway.free.fr/lambdaspeech/?view=start) helps explain what's going on.  It's a peculiar, lazily evaluated, regular expression-based lisp.  Interesting.",1541331162.0
dzecniv,"I'd go with `djula:render-template*` to begin with. Compiling the html seems too early optimization.

Why do you want to ""grab all html and css, all the routes"" ? Since you define routes, they'll be visible once you call `clackup`.

As for CSRF, I'm pretty sure Clack/Hunchentoot are secured by default, I remember I wanted to bypass them. 

I would test things with Woo when everything works by default too. Looks like you're trying to do a lot, and forgot to get a minimal case working.

Good luck, show us the result !",1541252161.0
xach,">  Of course in CL, one typically prepends the fn name with the class,

No, one doesn't. The generic functions and their names should come first and specify a protocol, and classes should be used to implement parts of the protocol when convenient.",1541241476.0
whism,If you wrote it like this: `(dot (a 'foo) b c)` it would be easy to write a macro in CL translating to a generic function invocation.,1541213593.0
theangeryemacsshibe,"    ((. slightlycyborg 'drive) the-tesla)

Okay, that's nasty. What about:

    (drive slightly-cyborg the-tesla)

You'd probably write `(defmethod drive ((driver person) (vehicle vehicle)))` in CL to define that. (though you may argue an invocation like `(ride slightly-cyborg the-bicycle)` would be less likely to raise UNBOUND-VARIABLE)

IMO writing macros that translate to more CL is less painful than writing a new Lisp, it's backwards compatible and doesn't give you cpython level slowness.",1541371443.0
defunkydrummer,">Of course in CL, one typically prepends the fn name with the class

On CL, methods aren't really tied to one class. See CLOS.

",1541432964.0
ObnoxiousFactczecher,"If `which sbcl` returns /usr/local/bin/sbcl, then sbcl should be runnable. Maybe it's a 32/64-bit problem? Are you running a 32-bit binary on a 64-bit system? The newest binary archive for 64-bit systems has a name of [sbcl-1.4.13-x86-**64**-linux-binary.tar.bz2](http://prdownloads.sourceforge.net/sbcl/sbcl-1.4.13-x86-64-linux-binary.tar.bz2).",1541117396.0
kazkylheku,"The `ENOENT/""No such file or directory""` error is probably bubbling up out of the `exec` system call.  It doesn't pertain to the `sbcl` file, but possibly to the lack of an interpreter for that file.  Just like ""hash bang"" scripts have interpreters (that they nominate on the `#!` line), binary executables also require an ""interpreter"", like for example `/lib/i386-linux-gnu/ld-linux.so.2` which knows how to handle the executable and attach it shared libs.

I don't feel like digging around in the kernel at the moment, but consider this indirect evidence:

    $ cat foo.sh
    #!/bar/xyzzy
    $ ./foo.sh
    bash: ./foo.sh: /bar/xyzzy: bad interpreter: No such file or directory

This looks more informative: but it's `bash` doing that, not the kernel! It's taking the `ENOENT` error and investigating by digging into the file. If we exec it, say, via `env`:

    $ env ./foo.sh
    env: ./foo.sh: No such file or directory

Same confusing message as the `./sbcl` problem. If we run this under `strace` we find:

    execve(""./foo.sh"", [""./foo.sh""], [/* 19 vars */]) = -1 ENOENT (No such file or directory)

",1541127361.0
guicho271828,sbcl sometimes have a weird provlem like this. try disabling ASLR by chainging the kernel parameter.,1541120648.0
paulfdietz,How did you install it?,1541113121.0
dzecniv,"Don't you have sbcl in the repositories ? `dnf install sbcl`

Also, you might like Portacle (portable Emacs + CL environment): http://portacle.github.io/

https://lispcookbook.github.io/cl-cookbook/getting-started.html

ps:  There's something about SBCL_HOME, read the doc carefully.",1541114824.0
ryukinix,"wtf, this is really weird! Do you tried `which sbcl`?",1541115929.0
jpco,"what do you get from `file /usr/local/bin/sbcl`? if it's a script, what does it say? this looks like it might be an error where that file is a script trying to call a ""real"" binary that doesn't exist.",1541119150.0
clintm,"What are the chances of having a ""ELS 2018 Call for Videos Posted to YouTube"" event?

I loved RME's video, but something tells me there's more out there.
",1541030453.0
pauljewell,No worries - looking forward to the next episode!,1540966728.0
piotr404,take care and see you soon !,1540990050.0
Baggers_,"Cool, but it's an odd target. Lua seems to most frequently be embedded in another project so I'm not sure why you would embed lua and the compile lisp to it rather than embed a small lisp and use it directly.

It would be cool to see that breakdown. There is the 'differences from other lisps' section in the readme, but i'd imagine there are lisps that can go toe to toe with lua for perf/memory.. I could be very wrong there though, not my area",1540897026.0
theangeryemacsshibe,"Symbols? Nope.    
Quote? Nope.

Stuff this. A Lisp does list processing. It's the damn name, for Alonso's sake.",1540972551.0
proteus777,"Not really a Lisp since it has taken the retardedly braindamaged Clojure-inspired syntax approach. 
No, I don't want to be typing [[ ]] all the fucking time. Good riddance.",1540891841.0
kazkylheku,"> *Anywhere you can run Lua code, you can run Fennel code.*

Anywhere?

You can use Lua snippets in an `.rpm` file (build recipe).

Can you use Fennel instead, what is involved, and is it practical?",1540912069.0
MutoShack,"Small but fair update. Thanks for all the good work, SBCL people!",1540795327.0
larsbrinkhoff,"One of the original Lispm hackers, Greenblatt, is interested in making a new one.",1540760262.0
LegionPharma,"Regarding projects to create modern Lisp machines, there is one slow-burning effort by Stanislav Datskovskiy aka /u/asciilifeform: [http://www.loper-os.org/](http://www.loper-os.org/)

The last thing he was doing is trying to get a micrograph of the Symbolics Ivory chip he has for complete reverse-engineering, but the few labs he contacted either were too expensive or failed to deliver. If you have the equipment and the skills to take a shapshot of the 1um chip, or if you know someone who has, please contact Mr. Datskovskiy: [http://webchat.freenode.net/?channels=#trilema&nick=fromloper](http://webchat.freenode.net/?channels=#trilema&nick=fromloper)",1540772827.0
VanLaser,"7bit at the deskthority.net forum runs some groupbuys for doubleshot keycaps including space cadet legends. He also has such a PCB designed. If you have a lot of patience and DIY skills, you can build a modern keyboard a la Space-Cadet.",1540803337.0
excited_to_be_here,"QMK firmware allows tonnes of customization/configuration options for keyboards including Unicode output which would tick off Space Cadet features like APL and Greek symbols. 

This could be achieved pretty easily on a standard sized keyboard using layers. I might be missing what exactly it is you're looking for from a Space Cadet style board though.

If you're interested there's a group buy for keycaps designed to replicate the Space Cadet keyboard called SA Symbiosis here: 

https://kono.store/products/sa-symbiosis-keycaps",1540808284.0
Duuqnd,Working space-cadet reproductions would be awesome. I'd buy a few. It'd be interesting to use with Emacs.,1540844514.0
tarhuntas,"If you mean the keyboard keycaps, there’s SA Symbiosis and 7bit’s round6. The actual keyboard is more complicated; 7bit has proposed a ‘hyper7’ keyboard ([https://deskthority.net/w/images/8/83/HONEYB\_HYPER7\_CADET.png](https://deskthority.net/w/images/8/83/HONEYB_HYPER7_CADET.png)) and the keycaps have been produced and sold, but so far we don’t have a PCB for it ([https://deskthority.net/workshop-f7/hyper7-development-t11344.html](https://deskthority.net/workshop-f7/hyper7-development-t11344.html)). The front legends would have to be done by hand, I fear.

I myself got the keycaps I want and I’m in the process of building the keyboard, or understanding how to do it... dealing with shift registers, reading matrices, and then using either ps2 or usb to connect to the computer. I’m probably overcomplicating it a bit, but it has been fun.

You can dig some stuff about the original keyboard here, including the microcontroller code: [https://web.archive.org/web/20150112030657/http://home.comcast.net/\~mmcm/kbd/SpaceCadet.html](https://web.archive.org/web/20150112030657/http://home.comcast.net/~mmcm/kbd/SpaceCadet.html); here there is also the code to use it using USB: [https://github.com/MMcM/lmkbd2](https://github.com/MMcM/lmkbd2). Apparently all the keyboard processing was done on the processor, not on the keyboard itself. I wonder if that would give any advantage nowadays...",1540857685.0
theangeryemacsshibe,"There were only two languages used in the OS on Lisp Machines: assembler and Lisp.

As most of the kernel would be in Lisp, most of the kernel was GCed.",1540704730.0
larsbrinkhoff,"Short answer: Yes.

Longer non-answer: A Lispm expert is sure to correct me soon, but I believe there was no distinct operating system kernel as we understand them today.  Rather the entire system is a single blob of Lisp code.  Sure, the boot, garbage collector, etc are fundamental parts of the system and could be regarded as the kernel.",1540711729.0
fnordulicious,"I won’t post the actual source, but here’s a fun part at the top of `gc>gc.lisp` from Symbolics Genera 8.5.

    ;                                      +---------------------------------------+
    ;;                                     |       SATISFACTION GUARANTEED         |
    ;;;                                    |     OR DOUBLE YOUR GARBAGE BACK       |
    ;;;; Symbolics Garbage Collector       |                                       |
    ;;;;                                   |  	   Cape Cod Refuse Co.             |
    ;;;;                                   |	Wellfleet, Massachusetts           |
    ;;;; Remodularized March 1987 by DLA   |                                       |
    ;;;                                    |	    Inventors of the               |
    ;;                                     |	Copying Garbage Collector          |
    ;                                      +---------------------------------------+
    
    
    ;;; This file contains the machine-independent part of the Garbage Collector.
    ;;; LM2 garbage collection is no longer supported.
    ;;; Machine-dependent code may be found in 
    ;;;   SYS;xCONS     (storage allocators)
    ;;;   SYS2;xGC      (GC primitives called by this file, and architectural extensions)
    ;;;   SYS2;xGC-DEFS (Machine-dependent macros)
    ;;; All user interface routines may be found in SYS2;GC-CONTROL-PANEL

It’s all written in Lisp – specifically Zetalisp. The machine-dependent code has lots of low level manipulation with `%LOGDPB` and `%POINTER-LESSP` and `%READ-INTERNAL-REGISTER` and stuff, but it’s all Lisp.",1540757488.0
ohgetoutnow,This sounds like a challenging project.  Will you be archiving your streams so I can catch them on my off hours?,1540685970.0
theangeryemacsshibe,">JavaScript

Kill it with fire.",1540640202.0
ProfessorSexyTime,"> Some revelvant reference material can be found here, the closest thing that I would like to achieve is the first in the list:

[Parenscript](https://common-lisp.net/project/parenscript/) probably blows all of those out of the water.",1540757897.0
jaoswald,"That kind of misses the point of the Lisp Machines which were not usually accessed over a serial line, but on a dedicated display with keyboard, mouse, and relatively high resolution graphics display.",1540660281.0
joinr,"Some people get turned off by the ""math"" basis for a lot of the early examples and exercises.  Stick with it.  The math-based stuff maps nicely to computing without needing to mutate (or changing state), which makes the first 2 chapters provide a solid basis for computation.  Complexity gets layered on after that.

You can evaluate most of the early programs ""in your head"" similar to how one would solve math problems using substitution, like.   2 +3 * (5 * 9), we can substitute the result of (5*9) once we've computed it, since the values don't change (under the initial paradigm the authors introduce).  This has profound implications.

Also, do the exercises.  They are designed for educating you almost as much as the prose is.

Ch 1-3 will provide a solid philosophical and applied basis in computation, and architecting programs, while ch4 starts the mind-bending a bit.  Ch5 goes further and introduces an emulated machine, so you can learn about computing at a lower level.  Focus  on getting through 1-3.  If you're captivated, hit up 4, and continue to 5 to go lower.  You can get a pretty broad (and I think portable) CS foundation just from that book.",1540571686.0
kuemmel234,"'The Little Schemer' might be a good start as well, if you are into LISP like languages. That one is less about computation and more about thinking, though.

I personally would say that SICP is too hard for a first, but that's saying more about me than about you.

Racket is very easy to install on most OS's and there's even a 'SICP mode' I believe. It's a great start into the programming world I think.",1540590130.0
Pour_Louis,"SICP is super hard. Check out [Bill the Lizard](http://www.billthelizard.com/2009) for help when you get stuck. 

Ableson and Sussman switch the MIT Program to Python in the late 1990's as libraries took over and nobody could get the source code. [Why they swapped](https://cemerick.com/2009/03/24/why-mit-now-uses-python-instead-of-scheme-for-its-undergraduate-cs-program/)
 

Currently, they use [Guttag's Book](https://www.amazon.ca/Introduction-Computation-Programming-Using-Python-ebook/dp/B01K6F2236/ref=sr_1_1?ie=UTF8&qid=1540566621&sr=8-1&keywords=guttag) which I am working through now.

What is interesting is that the same material is covered in large part. I would bluntly state that Sussman especially was not a very good teacher. He's  a genius, but I don't think that explaining things in relatable  ways was a strength of his. 

Please note that experienced Software Engineers working in teams take about a year to get through SICP, so be patient with yourself. 

Why Scheme? I started using it because of SICP as well. Python has a lot going for it, most of which I discovered after learning a bit of scheme. 

Dr. Racket is the 'new scheme'. You can also use Guile or MIT scheme through emacs. Good luck. ",1540567004.0
PracticalData,"If you get stuck, or if you wish to refresh some part of SICP (or all of it) in a condensed fashion, take a look at ""Scheme and the Art of Programming"" by Springer and Friedman. It's basically the same material, spoon-fed and straightforward. You can find it legally free, online.",1540602040.0
agumonkey,"SICP was a surprising enlightenment for me too. Such a different culture. 

If you need more, I suggest brown university PLAI (there are two editions, first one appealed to me more but 2nd might be better after all). Then you may peek at prolog books (bratko, or shapiro)",1540645974.0
metaobject,What scheme implementation are you using or planning to use?  What OS?,1540566822.0
afmoreno,"What's your working environment? I found it tricky to figure out what Scheme version to use but I ended up with Chez after playing with Racket and Guile. I use Emacs with `geiser` which is nice although I have to restart the Scheme interpreter every now and then.

I think the magic bullet for the course is the exercises--do them all! I worked my way through the first 3 chapters and then life interrupted. I got a lot out of it and hope to have time to get back into it sometime soon.

Good luck!",1540566878.0
clintm,"My advice would be to take it slow and, if you feel overwhelmed at some point, take it in small brain-sized chunks.  SICP is dense with knowledge, especially by modern standards, but you can definitely do it.",1540672888.0
,[deleted],1541001901.0
crabbone,I've been using Waterfox since it's the only version of Firefox that retained the old extensions model allowing me to use KeySnail.  I'm going to try this out and see how far can it go.  Very happy someone is working on something like this.,1540719813.0
blue-dog-blues,"I just wanted to comment on the deleted post, the technical critique is perfectly valid and there was no need to delete the comment.  We need people like you to open our eyes sometimes.  Please re-post your critique and any others that you may have.

However, the author isn't designing a nuclear power plant.  It's just a browser.  The author managed to single handedly replace Conkeor for me and that has HUGE value.  The harsh critiques should be welcome so that we can either start working on improvements to remediate the issue or provide the right kind of packaging to warn users of issues when they want to test out the browser.

I hope we can get the funding going a little bit so that we can help the author push through the next dev stages, and eventually to be able to address serious technical critiques.


",1540587493.0
,[removed],1540551382.0
flaming_bird,Previous discussion at https://www.reddit.com/r/lisp/comments/3uc7vd/free_capi_implementation/,1540500118.0
defmacro-jam,"That's a good idea.  I am unaware of such a project, however.

IMO it would be an even better to contribute native backends to McCLIM.",1540500157.0
__lm__,"It is not a complete solution, but [rlwrap](https://github.com/hanslub42/rlwrap) adds readline feature to programs that don’t have them. You can use it with SBCL: `rlwrap sbcl`",1540488282.0
ruricolist,"If you're actually asking why, it's a matter of licensing: readline is GPL, SBCL is public-domain. [According to Wikipedia](https://en.wikipedia.org/wiki/GNU_Readline#Implications_of_GNU_Readline's_GPL_license) CLISP actually had to switch to the GPL because it linked readline.",1540498908.0
stassats,It's left for third parties to add such functionality.,1540487722.0
activeXray,I really like sly,1540496444.0
defunkydrummer,">However, for beginners who are curious about Lisp but don't want to learn Emacs this can be annoying.

It is an order of magnitude more annoying to learn Lisp without a good editor system like Emacs + SLIME, Vim + SLIMV, the Clozure system, LispWorks, etc. 

Try to learn lisp without auto-indent, a good s-expression editor, etc, and the beginner will end up getting a very bad impression of lisp.

",1540580744.0
lispm,[McCLIM Listener](https://github.com/McCLIM/McCLIM/tree/master/Apps/Listener),1540499349.0
beizhia,"This is a bit of a side-question, but I've noticed it's not just SBCL. It especially seems to be a LISP-like thing - clojure, fennel are both the same way (for JVM and Lua). Is there some broader reason for this?",1540532608.0
paulfdietz,"One thing I like in a REPL is file name completion.   Do any of the REPL  packages support that?

EDIT: ah,  I see linedit does.",1540553230.0
ryukinix,Take a look: https://github.com/koji-kojiro/cl-repl,1540526396.0
quantumphilisp,"I use it throught sublime text repl. I don't have much experience in other languages except php in js in my classes, but it works very well until I get the time and motivation to learn how to use emacs. For the beginners wanting to learn lisp part I mean ! I don't know what readline is",1541439485.0
Baggers_,The answer to my 'why compare the location of y when we asked for :target x' is answered both in the [sbcl source](https://github.com/sbcl/sbcl/blob/0d54dc6530f39fe9fcb04071afe0c6a1e8bb6cee/src/compiler/x86/macros.lisp#L41) and briefly mentioned in Paul's article. the `move` macro checks the location of `x` implicitly and omits the move if the source and destination are the same.,1540488517.0
CelloAxeMurder,"I've only watched half it so far, but SBCL and compiler internals has to be one of my favourite topics in Lisp. Thanks for putting these sessions together.",1540498689.0
tarhuntas,On page 8 of http://www.bitsavers.org/pdf/symbolics/software/genera_8/Symbolics_Common_Lisp_Dictionary.pdf we find that profusion of `\`. Is it an error? or...?,1540400173.0
flaming_bird,"The logarithmic function is the inverse of the exponential function, and logarithmic growth is the mirror of exponential growth along the `y = x` axis.",1540371461.0
theangeryemacsshibe,As far as I know log and log3 are equivalent in terms of big-O notation due to the log laws. (logn x/logn 3 = log3 x),1540370607.0
Aidenn0,"This is logarithmic because you divide by 3 each time.

To make the math easier, let's do it in 10ths of a radian (so we stop when X is 1).

- X=3 : 1 iteration (3/3 = 1)
- X=9 : 2 iterations (9/3 = 3, 3/3=1)
- X=27: 3 iterations (27/3 = 9, 9/3 = 3, 3/3 = 1)

To see how this is logarithmic:

- log3(3) = 1
- log3(9) = 2
- log3(27) = 3

As others have noted the base is not written for big O notation, since it can only make a constant difference:

- log9(3) = 1/2
- log9(9) = 1
- log9(27) = 3/2

Note that log is the inverse of exponential (the values of X are 3^1, 3^2, 3^3), which is one way you can detect a logarithmic algorithm.  Another way to detect a log term is divide and conquer algorithms: binary search is log(n).  Merge sort is n*log(n) (The divide part means you do log(N) iterations, but you have to do a compare for all N elements in each iteration as part of the merge)",1540399899.0
zulu-inuoe,"What you wrote wouldn't compile in C since it would lead to a struct with infinite size.
So I'm assuming one of those is meant to be a pointer.
Unfortunately afaik there's no way to forward declare with cffi. I remember running into this issue and hacked my own solution around it.

The simplest way is to just define your pointer as (:pointer :void)
Cffi itself doesn't do anything right now with the types beyond figuring out the size, and a pointer to void is the same size as a pointer to anything else",1540293891.0
lisp-is-noice,"sorry for short answer ... no time ... shouldn't you use pointers instead ?
for example the b-struct in a could be a pointer (to a structure).
",1540263302.0
fizzgiggity,I just discovered this subreddit and felt that this belonged here. It is a keyboard which originally went to an LMI-CADR Lisp machine which I purchased from a fellow of the Computer History Museum. It was one of two spare keyboards discovered in storage so no machine for this to go with unfortunately. As a bonus this keyboard can be converted to USB fairly easily thanks to a GitHub project created by Mike McMahonon of Symbolics fame. With limited knowledge this has been a gateway to learning more. Besides learning about the history of Lisp machines I would love to find some energy reserves one of these days and get started with some programming. ,1540258127.0
shizzy0,This post coupled with the [Symbiosis group buy](https://kono.store/products/sa-symbiosis-keycaps?variant=12358483968100) has got me considering getting a set.,1540268173.0
kevisazombie,I want this for emacs usage :(,1540312229.0
JASSM-ER,I am envious!,1540261552.0
p1mps,/r/MechanicalKeyboards,1540281097.0
SlightlyCyborg,I'm suprised `()` require `<shift>`,1540324014.0
lispm,"The largest drawback (besides the price) is that LispWorks does not include the source for its GUI toolkit, like some other commercial Lisps do or did. Though they have a lot of examples and quite a bit of documentation.

LispWorks exists since the late 80s. In its current incarnation it nicely runs on various different platforms. The big appeal is that the IDE and GUI toolkit runs mostly unchanged under Windows, macOS and GTK/Linux/UNIX.

Over the last decade it got quite substantial new features like:

CAPI supporting high-res screens with better quality drawing

new platforms for the full implementation, like 32bit/64bit ARM/Linux and others

Symetric Multiprocessing, but no parallel GC so far

CAPI support for newer input models (like touch gestures IIRC)

non-graphics port of mostly the full LispWorks implementation to Android and iOS (incl. recently a 64bit version of iOS), incl. a Java interface

remote debugger/listener

and a bunch of other stuff.

So, I think they have added quite substantial stuff in the last years. I have for example a version of it on an ARM processor and it is very is robust. Generally problems are fixed very fast and you get patch files which are loaded on startup - so you don't need to install a new version. One can of course dump new images, if needed.

If you want to check out the full product and play around with it, contact their sales address and they'll give you a time-limited version.

In my view it's the best desktop Lisp available - it probably has the best implementation of any dynamic programming language I've seen so far (compared to Lisp, Schemes, Racket, Smalltalk, ...). But then it's also one of the most expensive. At least they don't charge for applications, only for the development tool.

",1540240457.0
f0urier,"I was in the same boat. After a couple of arguments with u/lispm, I've finally decided to pull the trigger. You just have to save a little, consider it as an expensive hobby ;) The arguments are

* CAPI. One of the typical questions to Lisp users is ""how can I create a GUI app"". With CAPI problems solved. Yes CAPI is kinda limited and you don't have as much control or features as with Qt, but if you are targeting some particular platform you can still go with platform specific things: i.e. on Windows you can implement missing functions with CFFI considering you can get the [window handle](http://www.lispworks.com/documentation/lw71/CAPI-W/html/capi-w-600.htm#46621) while on OSX you can easily access all [Cocoa](http://www.lispworks.com/documentation/lw71/OBJC/html/objc.htm) APIs.
* Fantastic support of Cocoa on Mac OSX
* Good Windows support, very stable
* IDE, while the text editor is weak the IDE features like Stepper, Profiler, Code Coverage, Debugger, different browsers, multiple REPLs, integration with everything and ability to inspect anything including any UI element are great (although the tools are little bit limited in functionality, could be better)
* Application delivery - including tree-shaker - so my app is not of the size of Electron app for as simple dialog application, including delivery of LW app as a dll
* Java integration - so I can use not only CFFI/FLI to access C libraries, but combine them with the great Java libraries as well! 
* A set of included goodies like async IO, threads, SSL, fast integer arithmetics, etc
* General feeling of all-in-one solution. LW + Quicklisp and you have no excuses to not  to write Lisp apps anymore unless you have some very specific requirements.

As for the downsides:

* Price, separate licenses for different platforms and unaffordably expensive 64bit editions. I would prefer to have one price for all platforms of course.
* no maintenance package for Hobbyist edition, I think the community of Hobbyist editions have to request it from LW company
* Lack of sources apart from Editor
* IDE could be better - so much more possible to do to make it better if the sources for IDE would be available for license owners (I've submitted a plenty of feature requests, and some of them were implemented in the last version 7.1 actually)

As for if the company will exists - it is a small company of 3-4 people, it will survive for quite a while I guess. Also the CL standard is not going anywhere soon, so once you have an implementation you just continue to use it for years to come.

P.S. You can meet Martin from LW at every ELS conference and discuss the things personally.",1540470773.0
defunkydrummer,">but the pricing is high

I will say the pricing is inexpensive. You'd be surprised to see how much a license costs for widely used professional software like [SAS](https://www.sas.com/store/products-solutions/cSoftware-p1.html?storeCode=SAS_US) or [Alteryx](https://www.alteryx.com/products/platform-details/pricing). (Go ahead, click to see prices.)

And many, many of those per-user licenses are happily paid by many companies worldwide. And this comment is regarding the full Professional pricing!! Hobbyists can use the Hobbyist edition which starts at $500.  (Note: I have no relationship with the LW company.)

I mean, a professional needs quality tools. See how much a dentist, a musician, a photographer, etc. has to invest for his/her tools.

>All stories linked on their website are old, some obsolete.

They can only link to success stories using the LW implementation. There are modern Lisp success stories, just not all of them using specifically LispWorks. For some examples of modern Lisp success stories:

- The core of grammarly.com is a Common Lisp program

- CL is used at Rigetti to do quantum computer simulation. 

- A major, leading graph database is fully written in CL as well.

- The major data loader for PostgreSQL (which is **the** Open Source RDBMS) was recently rewritten in CL for a *massive* speed improvement.

>Most software `looks` like '90ish era

As a Lisper, you already know that Lisp is more about `substance` than `form.`

",1540237907.0
flaming_bird,"I'm not a LispWorks user so I cannot say for my own, but I've alerted the LW people to this post, so they can add their two cents to the discussion.",1540237063.0
bitwiggler,"I find CAPI is pretty nice to program in. The interface builder in LW is first rate. Here is an app using it in the App store  [https://itunes.apple.com/us/app/typing-common-lisp-edition/id1202707132?mt=12](https://itunes.apple.com/us/app/typing-common-lisp-edition/id1202707132?mt=12)

CAPI may not be as sexy as some newer interface toolkits, but it is far nicer in my experience than Allegro CG.

Additionally Allegro CG only works on the non-multithreaded editions, with the exception of Windows.

Allegro includes a world of libraries with it, that LW does not. In the end using them both through Slime/Swank are on par with SBCL/CCL. They are both very polished systems that tend to perform much more consistently, and have superior restarts and GC handling than SBCL in my experience. 

One caveat I would apply to either is, ensure your development platform and target delivery platform are the same.  Otherwise you're forking out double the cost.",1540243551.0
_priyadarshan,"Another nice GUI app, developed with LispWork, [mediaimport](https://github.com/fourier/mediaimport)",1540278836.0
stylewarning,"How has Lisp made my life better/easier/etc.? Maybe first, some soft aspects.

* It has given me an income since the start of my professional programming career.
* It has given me the most interesting kinds of projects to work on for money, from fingerprint analysis to quantum computing.
* It has provided me a very valuable perspective of programming language design, and of the process of program development.
* It has given me a lot of very neat computing history to ingest and learn about. There's so much about Lisp history I don't know, and I've been at it for a decade. I just discovered [another book](https://dl.acm.org/citation.cfm?id=574973) that contains a heap of Lisp.
* It has given me access to a plethora of information about computer algebra, because Lisp's history is completely tangled in it. Unlike other CAS's, most of these are open source: Macsyma, Maxima, Axiom, Reduce, ...
* It has given me interest in alternative computer and operating system architectures. The Lisp machines are like abandoned museums full of 80s technological ephemera, written by some of the most innovative folks in computing history. While Genera wouldn't be appropriate for the proverbial Common Man (TM), it has a lot of interesting ideas that I wish I had access to as a modern-day programmer.
* It has given me an interesting thing to talk to people about around the world.

Second, a little selection of some actual projects. I'm really interested in math, especially computational pure mathematics, so these libraries were (and continue to be) fun to write and play with.

* My library [CL-PERMUTATION](https://github.com/tarballs-are-good/cl-permutation) has given me a systematic and reasonable way to explore the mathematics of permutation groups, which has been helpful in solving some math problems I've been interested in since I was a kid (e.g., group element factorization).
* I am quite proud of my [number theoretic transform](https://github.com/tarballs-are-good/lisp-random/blob/master/number-theoretic-transform.lisp), mostly because it works. It's not the fastest, and doesn't use the greatest techniques for computing good moduli, but it has been a very interesting exercise for me in order to understand and make use of Fourier transforms over finite fields.
* I have a fun project that I only work on during plane rides. It's called [Formulador](https://github.com/tarballs-are-good/formulador) and it just prints math formulas as ASCII art.",1540231718.0
agumonkey,"- lack of syntax (near zero idiosyncracies[1])
- emphasis on expressiveness over bureaucracy
- linear induction (recursion over lists) was extremely powerful to train my brain into solving problems
- very different cultural landscape that is much more inspiring (lots of things I loved naturally had lisp in them, emacs, hp48, mirai)

[1] I failed an exam because I couldn't find ADA syntax to index strings .. it was backquote or something. I despise syntax so much.
",1540232731.0
berock212,I did an AI assignment in lisp and not only was it a lot easier than Java but I think part of the reason I got such a high Mark is none of the TAs could understand my code,1540239930.0
defunkydrummer,">When has Lisp made something easier for you? 

Almost always makes things easier, thanks to interactive development (including hot code reloading), the `loop` macro, etc. Particularly macros, in general, eliminate boilerplate code, which I hate with a passion.

Particular to CL, I also like that this is still a ""scripting""-like language, but with astounding execution speed.

Edit: I program since I was 7-8 years old, so that makes it 28 years doing this stuff, and i've tried or used most of the mainstream programming languages: C, C++, C#, Java, Prolog, Pascal, Delphi, x86 assembler, Javascript, Python, Ruby. Common Lisp stands totally above all of the previous ones in making life easier for the (experienced) programmer. I think only the ML-family languages should provide a comparable advantage over the mainstream languages, but then they are a totally different philosophy to Lisp. 





",1540229064.0
heisig,"I use Lisp for my [research on parallel programming](https://github.com/marcoheisig/Petalisp).  I am about as experienced in Lisp as I am some other languages (Java, C++, Python, ...), but my intuition is that Lisp makes me about 2-10 times as productive.  In other words, I could probably have spent 20 years tackling my research problems in C++ and be about as far as I am now.",1540240926.0
gepardcv,"It made my life harder, because most projects I've been on use other tools — complete rubbish in comparison to Lisp. Ignorance is bliss! :)",1540238985.0
dzecniv,"pet projects, made easier: web scraping, readline apps, DB, OOP related stuff (ah, polymorphism, multimethods…),… distributing/deploying self-contained apps, even web apps, is such a relief (compared to Python/JS). Writing code is easier (s-exps, editor plugins manipulating s-exps), the development process is less dumb (re-run, re-compile the entire app ? Meh, compile the function I am on and get compiler warnings). My [gh](https://github.com/vindarel). What it *will* make awefully easier is web dev with the [weblocks](http://40ants.com/weblocks/quickstart.html) framework…",1540239924.0
Bourgond_Aries,"It has made me realize the vast amounts of workarounds and indirection done in traditional languages (e.g. using 'patterns') to get something done. With Lisp I can specify a language that fits the problem domain that is readable, extendable, and can used as a ""language as a library"". It's wonderful.

A small project I've been working on is a game in Racket. Using memoization of OpenGL state so there's no handling of objects or anything, just a call to draw something and it's all handled for you. [Memo library here](https://github.com/BourgondAries/memo)

I also host a [website](https://gondola.stravers.net/) using Racket, beside that I use racket for various utilities. Especially doing some quick and dirty TCP or UDP hacking.

Overall. Lisp has been the enlightenment for me. I don't think (but am open to) that there's going to be anything that surpasses lisp in terms of power. The metaprogramming abilities are off the charts, and guiding a discussion toward metaprogramming is my benchmark to see if other programmers are truly enlightened. I know it sounds zealot-like, but to me it simply shows that the programmer has understood that programming is about writing the most concise yet readable and most maintainable code possible - that language itself is the ultimate abstraction.",1540282556.0
flaming_bird,Interactive and incremental debugging and development. Allowing me to change and inspect my program in real time using the same tools that I use when writing code. Teaching me a lot about functional programming and internals and implementations of object systems. Making it able for me to describe my problems in a natural way by having customizable syntax.,1540235915.0
dzecniv,"gosh, I forgot: hacking my text editor and bend it to my needs, making me dive in many subjects essential for my field. Thanks, Emacs !",1540289349.0
leodash,My projects repo almost always have a 'scripts' folder that contains Lisp code that I used to generate the code for the application in another programming languages. SLIME interaction is just amazing.,1540261164.0
blue1_,"Oh god, we are discussing parentheses again.

[examples](https://www.google.com/search?q=%22sweet+expressions%22+site%3Areddit.com%2Fr%2Flisp), [another example](https://news.ycombinator.com/item?id=1941373)",1540212361.0
defunkydrummer,">The goal of this “Readable Lisp s-expressions” project is to develop, implement, and gain widespread adoption of more readable format(s) for the S-expressions 

It implies that s-expressions are not so readable. As a person that has had a full year of professional experience in Python (actually implementing software for a bank in it) before jumping to CL, the jump to Lisp also made me realize s-expressions were just fine.

",1540228946.0
guicho271828,"It might be readable but not as easily manipulatable as S-exp.
In python I am constantly irritated by the dumb emacs binding that can't tell when the body of `if` and `else` ends nor move/kill/paste the chunk of code correctly. Languages are tools, tools are for makers, readers are important but secondary.

Edit: By the way, for me `{}`s and `[]`s are okay only if they are just the read macros that is parsed into its canonical S-exp form",1540214375.0
flaming_bird,"Python? In my Racket?

It's more likely than I thought.",1540202477.0
dzecniv,"You loose the ability to edit code by logical units. ""de-indent"" the whole if ? Easy. I mean, workarounds exist for some tasks (my [indent-tools](https://github.com/vindarel/indent-tools) or other stuff specific to languages), but they're so hacky and not powerful…

look at extensions like [lispy](http://oremacs.com/lispy/) to see what they allow",1540235579.0
Glumpz,"I honestly expected something much less readable and I would've been impressed. Even more so this is very, very readable to me and actually is quite beautiful to look at.",1540205244.0
Ihaveexpectations,What's a sweet-expression?,1540206830.0
TheZhero,"nvm i just solved

if anyone is intrested, by opening the Makefile file there's a comment sayng what to do: ""qmake-qt4 -o Makefile [commonqt.pro](https://commonqt.pro)""

i was doing that but without -o that's probably the main part, rip me",1540185935.0
spacebat,"I used to do a fair bit of calling between emacs and CL via slime, and `slime-enable-evaluate-in-emacs` was necessary. These days unless I was adding more info to the slime environment such as via presentations, I'd just have emacs run the CL repl in a simple subprocess and use that as the back end for a more domain specific buffer.",1540213655.0
flaming_bird,"> why not a Lisp Unix userland instead

Implementing a Unix userland means that Lisp will need to obey the Unix model where everything is a file (as opposed to an object), all data is text (as opposed to typed Lisp data) and the filesystem is a tree of directories and files (as opposed to, well, no filesystem whatsoever).

Implementing Unix in Lisp is a wrong approach. Implementing Lisp in Lisp is a much better idea.",1540191454.0
Shinmera,"What's the point of implementing the same terrible terminal interface, but now in Lisp? One of the points of a Lisp OS is that everything is Lisp already and you don't have different applications with each having their own brand of weird ass calling convention through the process arguments and streams.",1540191332.0
nillynilonilla,"I agree with the other wise people that it is a terrible idea, knowing something of it's extent. But sometimes it may be wise to throw caution to the wind and launch a boat, not knowing if it will reach another shore.

Also, if one was to find oneself foolishly paddling such a skiff upon the wide ocean, some improved profiling tools, in things other than the unconscionably fast sbcl, would really help.

Of course, if you invert the first question, the somewhat pointlessly entertaining answer is [yes](https://github.com/darius/awklisp).",1540201393.0
defunkydrummer,">Lisp Unix userland 

Lisp Machine OS (plural) and Unix OS (plural) are essentially contrary philosophies. 

Read ""The UNIX-Haters Handbook"" (book) for a hint on these differences.

UNIX, as a concept, looks like a retarded^1 OS once you have a good idea of what a Lisp Machine is.

The UNIX OS was born as trying to make less powerful hardware do useful stuff. Lisp Machines were born, in some way, as imagining how the most advanced workstation possible should be, and *then* trying to increase the hardware power to make such dream work effectively.

1. as in `retard`: delay or hold back in terms of progress, development, or accomplishment.





",1540229242.0
where_void_pointers,"Well, don't know if it has been done before. But, it could certainly be useful. Not so much a Lisp OS, but there are many programs in coreutils among other programs that if they could be written in a particular subset of R6RS and R7RS Scheme, they could probably help the Mes (https://www.gnu.org/software/mes) project's goal of reducing the binary seed needed to build GuixSD by reducing the number of precompiled utilities that need to be in the environment already to start building everything. In principle, if the right utilities were written in Scheme, it would only need already provided utilities to just start it and it would go over to ones it could interpret and then build quite quickly.",1540245959.0
ohgetoutnow,"If you do, please consider adding the ability to accept and emit structured data as an option across each core component.  ",1540210526.0
kazkylheku,"TXR Lisp has good support for text munging and other things. 

Suppose we wanted to write `ls`; for the `ls -l` output, we need to get the mode in the `rwxrwxrwx` format (plus the letter `d` for directory and `s` for symlink, and some cases like setuid, setgid or the sticky bit).

Getting just the basic mode can be coded like this:

    (defun mode-rwx (mode)
      (let ((rd (reverse (digits mode 2)))
            (rm ""xwrxwrxwr""))
        (reverse (mapcar (do if (zerop @2) #\- @1) rm (pad rd 0)))))

    1> (mode-rwx 1)
    ""--------x""
    2> (mode-rwx 12345)
    ""---rwx--x""
    3> (mode-rwx #o333)
    ""-wx-wx-wx""
    4> (mode-rwx #o666)
    ""rw-rw-rw-""
    5> (mode-rwx #o777)
    ""rwxrwxrwx""
    6> 

Getting the `stat` information:

    1> (stat ""."")
    #S(stat dev 2049 ino 713884 mode 16893 nlink 2 uid 500 gid 500 rdev 0
            size 4096 blksize 4096 blocks 8 atime 1540363533 mtime 1540363531
            ctime 1540363531 path ""."")
    2> *1.mode
    16893

Looking up user:

    3> (getpwuid *1.uid)
    #S(passwd name ""kaz"" passwd ""x"" uid 500 gid 500 gecos ""Kaz,,,"" dir ""/home/kaz""
              shell ""/bin/bash"")

Is it a directory?

    4> (logtest *1.mode s-ifdir)
    t

",1540364117.0
KDallas_Multipass,why can't it be Wednesday?,1540237236.0
bplipschitz,!Remindme 8 days,1540163925.0
defunkydrummer,"I'm happy with emacs' automatic code indent.
",1539983449.0
dzecniv,"Yes with Emacs: https://github.com/tuhdo/semantic-refactor it supports many languages, included CL.",1539996530.0
xach,"I don't know of one. There are some challenges in reading CL code without actually evaluating/compiling it, due to readtables and macros and such. Emacs with slime does a pretty good job but it's not as batchy or automatic as other tools.",1539967265.0
dzecniv,"mmh related, a linter: https://github.com/fukamachi/sblint 

It will catch style warnings. https://www.slideshare.net/fukamachi/sblint

(there may be less a need for a code formatter indeed, with a good editor plugin. I love [lispy](http://oremacs.com/lispy/), it does reformat indentation while you type and keeps everything balanced (it can take some time to grasp, that's normal)).",1539994719.0
mwgkgk,"This is a reasonable choice:

https://github.com/ds26gte/scmindent",1540012818.0
flaming_bird,"Discussion on /r/Common_Lisp: https://reddit.com/r/Common_Lisp/comments/9pf2nd/this_old_lisp/

Discussion on HN: https://news.ycombinator.com/item?id=18253596",1539955002.0
emacsomancer,Does using SLIME count? ;),1540139996.0
dragandj,"Hi, I'm [Dragan](https://dragan.rocks/about), the creator of [Uncomplicate](https://uncomplicate.org), a family of Clojure libraries for AI, ML, and GPU high performance computing. All libraries are [free, open source](https://github.com/uncomplicate), and they come with a ton of documentation and tutorials on my blog.

[Neanderthal](https://neanderthal.uncomplicate.org is a Clojure library for linear algebra and vectorization on CPU and GPU. 

[ClojureCL](https://clojurecl.uncomplicate.org) brings OpenCL GPU computing to Clojure that supports AMD, Nvidia, and Intel GPU. 

[ClojureCUDA](https://clojurecuda.uncomplicate.org) enables CUDA acceleration on Nvidia GPU directly from your Clojure REPL. 

Bayadera does Probabilistic Data Analysis on the GPU, from Clojure 

Fluokitten brings category theory to Clojure These libraries are quite innovative, are programmed in Clojure, and promote Clojure values of simplicity and elegance, while surpassing competitive libraries from other ecosystem in terms of speed and performance.

See some conference talks about them: EuroClojure 2016, Bob Konferenz 2017, ClojuTRE & SmallFP 2018.

While these libraries can be considered research, they are for Clojure programmers, by a Clojure programmer, 100%. Your contribution can help me proving that this is possible.

I am committed to their continued development, and to writing the guides and documentation that teach how to use them. You can help in making this sustainable by adopting a function from these libraries as your pet and sponsoring my development. Please consider contributing!",1539870081.0
defunkydrummer,">So I would like to ask what is the best use case for lisp? What kind of program or environment is it best suited for and/or has an advantage over other laungauges?

Lisp is a general-purpose language which is specialized in being general-purpose.

Lisp is the original (and still the best) *Programmable Programming Language*, thus it can be more General Purpose than others. 

So it has been used in almost any kind of situation you can imagine: Business systems, AI, CAD/CAM, Graphics, bio-informatics, simulations, web servers, GUIs, games, music composition, signal processing, spaceship autopilots, credit card systems, etc.

Let's better talk what Lisp -or at least a full lisp like Common Lisp or the latest Scheme spec-  is NOT suited very much for (note: doesn't mean this hasn't been done with Lisp too -- just that it isn't a good fit): 

- real-time systems 

- systems where low RAM consumption or low RAM usage is beneficial (but, see MiniPicoLisp)

- very low level programming 





",1539873693.0
borodust,[Autumn Lisp Game Jam 2018](https://itch.io/jam/autumn-lisp-game-jam-2018) is just a few hours away! You can try making a simple game with Lisp in 10 days as a side project :D,1539878212.0
kazkylheku,"Of course Lisp languages are general purpose. So we can refine the question as: when will a Lisp be more suitable than other kinds of general purpose languages?

Lisps are very good for manipulating tree-structured information with heterogeneous, symbolic data. If your problem domain requires, or benefits from, the processing of any custom syntax and semantics, Lisp will be of more help than other languages.  If someone said ""write a C++ compiler"", I'd reach for nothing else than Lisp. I'm not writing code to deduce and instantiate a C++ template in a non-Lisp language (let alone C++ itself); that's crazy!

Lisps are also great for exploratory and prototypical coding when the domain is not fully understood and the requirements are not clear. Some code must be written to understand how to write more code, and the solution goes through prototyping stages. Once upon a time, Lisp would have been the only game in town for this kind of thing. In the recent twenty years or so, Lisp-inspired dynamic languages have arisen which have some of this kind of advantage, though not all of it. Python is undeniably better for prototyping and exploratory coding than C, for instance. Lisp, in particular common Lisp, though is unbeaten because of the superior ability to abstract, the metaprogramming and also because it offers a path form the prototype to high performance production code.

In expansion on the first point, if some problem domain benefits from a solution that is expressed in some unknown language that doesn't necessarily exist yet, Lisp is your best bet, because Lisp can be taught to be that language, and this can happen through the prototyping process where you start small and extend. You can concentrate on the semantics to the language and add forms to it little by little, and these can integrate into your Lisp's compile time, not only as something that is processed *by* your Lisp program's run time. Not worrying about details like lexical analysis and syntax is liberating if you're doing language design: much the same way like not worrying about releasing memory is liberating if you're working with complex data structures. Lisp is to language-oriented processing like garbage collection is to data structuring: it gets the distracting stuff out of the way, so you can get right down to working with the abstract syntax and its semantics. Whatever language you need, Lisp already has the pieces in place to express instances of that language. If you can dream up these examples and write them down, Lisp will scan them to tree structure, whose processing you can think about in a concrete way. You've already hit the ground running,  without having written any code yourself to scan or parse anything.

Common Lisp is great for business code; it has a good ""numeric tower"" that handles money nicely through rational numbers. It's easy to define business objects and such, and the flexible syntax of Lisp serves well as an input language for loading data into a system, such as invoices, debits and whatever. A good project to get into Lisp might be to do some personal financial stuff.

I run my self-employment accounting using Lisp code (in my own Lisp dialect). It handles all the complexities, like capital-cost-allowance depreciation of tax-deductible assets, income tax deductions, goods-and-services tax, and whatnot. It cranks out beautiful, professional invoices in HTML + CSS + SVG logo that convert to a polished PDF, and has all the right reports I need at tax time, and for physically shuffling funds between actual bank accounts.  I add to the ledger just by adding Lisp expressions to a data file that is just loaded as part of the program, and this is committed to git.  When run, the program processes all of the data from the beginning and re-calculates the entire ledger.


",1539913882.0
rudolfo_christ,"> Please don't assume Lisp is only useful for Animation and Graphics, AI, Bioinformatics, B2B and Ecommerce, Data Mining, EDA/Semiconductor applications, Expert Systems, Finance, Intelligent Agents, Knowledge Management, Mechanical CAD, Modeling and Simulation, Natural Language, Optimization, Research, Risk Analysis, Scheduling, Telecom, and Web Authoring just because these are the only things they happened to list.
-- [Kent Pitman](http://www.nhplace.com/kent/quoted.html)

Correct me if I'm wrong but I think you put the cart before the horse. Do you want to write applications Lisp is extraordinarily suited for or do you want to know if Lisp suites your use case? ",1539859469.0
dzecniv,"and I forgot, I had good fun and success with web scraping (lquery, dexador and related).

If you know some Qt, you could try Qtools.",1539900438.0
dzecniv,"There are success stories in many fields :) http://lisp-lang.org/success/ 

also https://common-lisp.net/lisp-companies

I'm having a good time building a readline app (cl-readline), using an ORM (Mito, see also cl-dbi), and simple websites (deploying a self-contained executable is such a relief).

(my favs: https://github.com/CodyReichert/awesome-cl and https://lispcookbook.github.io/cl-cookbook/ )",1539860058.0
drcz,"although all of the other answers I've read are legit, they don't seem to help you much...  
(1) there is a path ""99 lisp problems"" which starts from trivial things like reversing and grouping list elements, and ends with solving n queens and sudoku problems.  
(2) any form of symbolic computation you are familiar with -- transforming formulas of \[some\] sentential calculus to dnf, sat solving, finding largest consistent subsets of given set of formulas; symbolic differentiation and integration (for some reasonable family of real/complex functions); expert systems (reasoning forward or backward etc); also parsers, including ones for \[some tiny fraction of\] natural languages.  
(3) (my favorites)implementing interpreters and compilers for toy (or sometimes more serious) programming languages -- starting from \[some\] lisp interpreter in \[perhaps some other\] lisp, or perhaps some flavor of untyped lambda calculus; converting \[functional\] lisp programs to cps; defunctionalizing them etc ; DSLs for talking about chess figures, electronic components, liars and truth-tellers and indirect speech ; stack-based or rewrite-rule languages, tiny virtual machines etc.  
good luck, have fun!",1539865546.0
flaming_bird,Whatever you want to write. Lisp is a general-purpose programming language.,1539862865.0
flyin1501,"`define` has two forms:

- `(define x 0)` binds `x` to 0
- `(define (f) 5)` **is shorthand for `(define f (lambda () 5))`**. It binds `f` to a function returning 5.

`(define (p) (p))` defines a function `p` that calls itself. `p` is indeed a procedure in `(p)`.

The answers are correct.",1539851201.0
flaming_bird,"To answer a part of your question:

`(define x 42)` means that `X` is now a variable and its value is 42.

`(define (x) 42)` means that `X` is now a function that accepts no arguments and the value returned by it is 42. It is equivalent to `(define x (lambda () 42))`.",1539851264.0
Didacc,"Thanks for the replies guys! I think now I get it.

In the Compound Procedures segment, it is explained that to create one you have to do as this:

`(define (<name> <formal parameters>) <body>)`

So I guess that the first `(p)` is just the name of the function and the second one is calling it.",1539935383.0
timezone_bot,"6pm UTC happens when this comment is 19 hours and 15 minutes old.

You can find the live countdown here: https://countle.com/CeJQBU6xO

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1539729844.0
stassats,Are you sure it's not the FORMAT output that's buffered? Insert (finish-output top-level) after it.,1539739072.0
xach,"How are you sending data to the socket? Here's why I ask: if you're using something like `telnet` or `nc`, it will buffer sending until you hit a new line. To avoid buffering, you could type `abc^D` and see if `abc` appears right away.",1539732177.0
theangeryemacsshibe,How are you testing that?,1539732136.0
VanLaser,Of course it was already posted here 1 day ago ...,1539725944.0
ClickableLinkBot,"##r/emacs
---------------------------------------------
^(For mobile and non-RES users) ^| 
[^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| 
^(-1 to Remove) ^| 
[^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)",1539727865.0
kazkylheku,"How did you **not** see it here; it's still on the front page by ""hot"", in the #5 position, under its original title.

",1539800553.0
flaming_bird,"I do see symbolic computation being a topic of the talk, but is Lisp used anywhere in the actual implementation? Are there any papers available that are associated with the work?",1539723520.0
defunkydrummer,">Who wants to try recording this? 

Umm... I play drums, guitar, bass and keyboards. But if I had the free time, i'd probably cover the ""Land of Lisp"" song by Conrad Barski, that's a cool song.

""simple but refined / guaranteed to blow your mind / the Land of Lisp""

",1539730288.0
cringe_master_5000,I love Tenacious D. Best band that has EVER existed.,1539829871.0
ElBroet,So .. could Rust kill the metal?,1539717104.0
Lower_Cryptographer,"A popular thing for internet communities at least used to be singing a song and overlaying all of the singers' voices. Several crap singers turns into alright singing when you combine them!

Anyway, I'm afraid that I'm far too embarrassed to do that myself :-).",1539715633.0
SlightlyCyborg,Your meme has been thoroughly processed by my brain in musical form. You win.,1539716943.0
flaming_bird,"I suggest that you should not do this. Instead use DOCUMENTATION-UTILS to set the documentation from another place of your code. This means that you can construct the docstring from any predefined template you might have.

https://github.com/Shinmera/documentation-utils",1539678760.0
phalp,"I like that it could help one to remember to document all parameters, but I'm in the habit of writing docstrings prose-style, which I prefer. In a perfect world maybe you'd have a complete prose docstring followed by a bulleted list of argument docs, but I don't think I would consistently fully-ass both.",1539714930.0
lispm,"Putting a PPRINT around a DEFUN is not a good idea. The DEFUN form will no longer be at top-level and the file-compiler won't recognize the function as a top-level form.

I would also not do the implementation inside the macro. I would write a function to do so and call it from the macro. Probably also having sub-functions implementing the various functionalities. As you wrote it, it is a wall of unstructured code.",1539676883.0
foobar56w,"If i were to do something like this, I would probably keep using standard defuns and instead make a separate DOCUMENT function that takes all the documentation.

Like this:

    (defun foo (x y) ...)

    (document foo
     :description ...
     :in ...
     :out ...)
",1539678565.0
gepardcv,The article should also have included a link to the MP3 of [_God Wrote in Lisp_](http://www.prometheus-music.com/audio/eternalflame.mp3).,1539637522.0
_my_name_is_earl_,"Actually, Holy C is God's own programming language. Rest in peace Terry Davis.",1539699353.0
VanLaser,"Also the association ""Lisp - Lambda (calculus) - (Alonzo) Church"" may have had a role in it.",1539675408.0
Shinmera,I can't even put to words how tired I am of this kind of question and discussion.,1539610286.0
zahardzhan,Lisp killer feature is resolution of the dialectical contradiction between the sign and the value - the QUOTE special form supplemented by EVAL function with which Lisp reference to itself from within itself.,1539666147.0
spacebat,Language oriented programming. See also http://www.defmacro.org/ramblings/lisp.html,1539635586.0
schemadrome,"ease of use. with lisp, it's turtles all the way down. no syntax, no syntax errors. do more with less code. lisp comes with a deep tradition of wisdom passed down from some of the brightest minds of the 20th century. there really is nothing like it. ",1539771311.0
ObnoxiousFactczecher,"For me, it's the language's ""Pareto optimality"". I can't pick a different one to improve something without something else I already have becoming worse.",1539782687.0
luismbo,Practical Common Lisp is a great one.,1539589833.0
ohgetoutnow,"- [Learning Lisp Fast](https://cs.gmu.edu/~sean/lisp/LispTutorial.html)
- [Casting SPELs in LISP by Conrad Barski](http://www.lisperati.com/casting.html)
- [Learn Emacs Lisp in 15 minutes](https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html)
- [Learn Scheme in 15 minutes](https://web-artanis.com/scheme.html)
- [Learn Common Lisp in Y Minutes](https://learnxinyminutes.com/docs/common-lisp/)
- [Common Lisp: A Gentle Introduction to Symbolic Computation](https://www.cs.cmu.edu/~dst/LispBook/)
- [sicp - MELPA](https://melpa.org/#/sicp)
- [SICP – The Abelson & Sussman book](https://sicpebook.wordpress.com/)
- [GitHub - sarabander/sicp-pdf: SICP PDF with Texinfo and LaTeX source](https://github.com/sarabander/sicp-pdf)
- [GitHub - webframp/sicp-info: Stucture and Interpretation of Computer Progams in info format](https://github.com/webframp/sicp-info)
- [Simply Scheme: Introducing Computer Science](https://people.eecs.berkeley.edu/%257Ebh/)
- [Computer Science 61A - Spring 2008 : Free Movies : Free Download, Borrow and Streaming : Internet Archive](https://archive.org/details/ucberkeley-webcast-PL6879A8466C44A5D5)
- [Scheme, Guile, and Racket: an Introduction by Craig Maloney - YouTube](https://www.youtube.com/watch?v=Kq-4nhIktes)
- [Community-Scheme-Wiki](http://community.schemewiki.org/)
- [The Scheme Programming Language, 3rd Edition](https://www.scheme.com/tspl3/)
- [Teach Yourself Scheme in Fixnum Days](http://ds26gte.github.io/tyscheme/index.html)
- [Concrete Abstractions](https://gustavus.edu/mcs/max/concrete-abstractions.html)
- [Revised(5) Scheme - Table of Contents](http://people.csail.mit.edu/jaffer/r5rs_toc.html)
- [schemers.org: Documents: Standards: R5RS](https://schemers.org/Documents/Standards/R5RS/)
",1539609087.0
sammymammy2,What lisp is it?,1539595433.0
jaoswald,"elisp? As in the extension language for the Emacs text editor?  Are you sure? That doesn't seem like a reasonable Lisp for serious CS work.

There is a reasonable amount of documentation that comes with Emacs, but it is mostly about how to change the behavior of your text editor.

https://www.gnu.org/software/emacs/manual/eintr.html

https://www.gnu.org/software/emacs/manual/elisp.html",1539610545.0
dzecniv,"The [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/) doesn't have an introductory crash course, but it should help for a data structures reference, a tutorial on CLOS, math and numbers, and other practical things. 

also https://learnxinyminutes.com/docs/common-lisp/",1539593135.0
FirstLoveLife,Play with emacs with elisp is a good start,1539594470.0
agumonkey,"Just in case you like vintage AI too, Norvig PAIP is free online",1539595195.0
nils-m-holm,"Only you would have used DEFINE instead of DEFUN and there would not have been &OPTIONAL arguments and not even strings, and you would have typed your code on as few lines as possible without any formatting. :)

E.g.:

    DEFINE ((HELLO (LAMBDA (NAME) (PRIN1 (QUOTE HELLO)) (COND
    ((NULL NAME) (PRIN1 (QUOTE WORLD))) (T (PRIN1 NAME))))))",1539548223.0
vm0661,"I worked on a teletype in the early 80's.

<old-fart>when I was your age...</old-fart>",1539544919.0
RockleyBob,"Learning Lisp now, this is how Emacs feels to me after using a full-fledged IDE. I’m starting to get the hang of all the keyboard shortcuts now, but man it is a steep learning curve.

Also, is that a QWERTZ keyboard? Wtf?",1539547598.0
Ikuyas,Brother ,1539556430.0
schottstaedt,"I was programming in the late 60's -- Fortran (or was it Basic?), 
and a bank.  I can't remember what I was typing on, or what it
felt like.  50 years of programming...
",1539624896.0
agumonkey,device came in many colors and paredit options ,1539639231.0
Aidenn0,"> But that's not a new language, it's two god-damned functions.

You missed the fact that it includes a new syntax for time constants (`20:00` is not a valid literal in common lisp).  It's a very minimal DSL, but I think it does qualify.  C++ now has custom literal formats as well, but you can change the syntax both more easily and in more ways with lisp.  For a crazy example of how flexible it is, [someone implemented C as a DSL for common lisp](https://github.com/vsedach/Vacietis).  This isn't just a C compiler implemented in lisp, but rather it modifies the lisp reader to the point where the builtin `READ` and `LOAD` functions can be used on C code.

A much simpler and real-world-useful example of a very small DSL is here:

https://edicl.github.io/cl-who/#example

The 3rd example includes the listing that it expands to; note that no non-standard functions are part of the expansion, but consecutive string constants are folded together into write-strings and yet you can use lisp's native control flow interspersed with generated html.  This happens at compile time, and is obviously not doable with functions.  When I say it's simple, I mean anybody who has been writing lisp full time for a year could make something similar in a day, and it's a relatively simple exercise to write one.

> And then proclaims that lisp is awesome because he just added a custom exponentiation operator. But that's not fair. He didn't add a new operator. Lisp doesn't even really have operators in the same sense as C++. He didn't define a new ""operator""- he just defined a function with a name that's not allowed in C++. I wasn't impressed.

Yes and no.  The lack of infix operators in lisp means that you can very easily add functions that look like native operators.  This isn't a big deal, so it's fine that you're not impressed.

> The other piece of the puzzle for me is the concept of reader macros. Everyone talks about writing DSLs in lisp, which seems like maybe they're using macros. But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers? Are they talking about different things? Does lisp's ""code is data"" property even matter if you don't exploit it via macros?

The more correct form of the advice is ""Don't write a macro when you can write a function.""  Note that this is ""write"" not ""use.""  Using macros is done all the time; I use the standard `LOOP` macro for iteration, but many people prefer the macro `ITERATE` which is provided by a library.  While implementing an iteration library entirely with functions is not impossible (consider e.g. python's itertools), it comes with both performance and usability impacts, so writing a macro for this is fine.

Some more evidence that it's not two camps of ""macros are awesome"" and ""don't use macros"" but rather exist in tension as an engineering tradeoff can be found in this quote about a specific project:

> The source code of the Viaweb editor was probably about 20-25% macros. Macros are harder to write than ordinary Lisp functions, and it's considered to be bad style to use them when they're not necessary. So every macro in that code is there because it has to be.

[edit]

RE: the ""two damn functions"" DSL, if you read all the way to the bottom of that article it points out that really lightweight DSLs in lisp end up being just lisp, the middle weight ones are mostly lisp, and only the heavyweight ones end up with very different semantics, for which it gives the example of FrTime, which is a dataflow language built on top of racket (I tend towards common lisp, as you may have noticed from my examples above, but racket has some very neat features for building languages, regardless of whether they are domain specific or not).",1539319534.0
anydalch,"The people who tell you to use macros sparingly are talking to you as someone who doesn't *know* Lisp yet - like you're uninitiated. Beginners tend to use macros in the wrong places, so the easiest advice is just to write fewer macros until they know better. But you're right, code-as-data doesn't really matter unless you do something with it, and macros among the easiest things to do.

The example of code as data outside of macros I try to give is about how easy serialization is - 'code is data' <=> 'data is code', but you're right that all of these things can be expressed in other languages, and many languages do pretty well without 'code is data'.

The line between 'writing Lisp' and 'defining a DSL and using it' is a fine one; I think that many more experienced Lispers (more experienced than myself, at least) see this as the defining characteristic of Lisp, and start to think of their workflow in terms of 'define a DSL that solves my problem' -> 'apply my DSL' rather than in terms of objects interacting with each other, like in Java/C++/C#, or in terms of functional transforms on data like in OCaml/Haskell/F#, and just like defining classes of objects or complex recursive algorithms to solve a simple problem seems silly, ""defining"" a ""DSL"" to solve a simple problem seems pretty silly.",1539313217.0
lispm,"There are much more extensive examples.

FORMAT uses a DSL for output formatter strings.

CLOS is a DSL for OOP with syntactic constructs for defining classes, methods, generic functions and more.

LOOP is a DSL for imperative iteration. ITERATE is another one.

SERIES is a DSL for stream-based computing. SCREAMER is a DSL for nondeterministic programming.

On Lisp explores some aspects of language extension: http://www.paulgraham.com/onlisp.html
You can download the book from there.

> But then, everyone (else?) says to use macros sparingly, if at all

Count the number of macros in the Common Lisp language. Even the basic form to define a function is a macro.

Writing good code requires some skills. Writing good code which writes good code requires more skills. The warning is to newbies that writing code in Lisp has to be learned first. Writing code that writes code is quite a bit more advanced and a newbie might not know when, why and how to use it.
",1539330614.0
ka-splam,"> And then proclaims that lisp is awesome because he just added a custom exponentiation operator. But that's not fair. He didn't add a new operator. Lisp doesn't even really have operators in the same sense as C++. He didn't define a new ""operator""- he just defined a function with a name that's not allowed in C++. I wasn't impressed.

I'm no Lisper, or C++er, but isn't that part of the point he's making? 

C++ was designed in a way that means you can't write C++ code to extend the C++ language, and Lisp was designed in a way that you *can* code with Lisp to extend Lisp. When you do, your added Lisp operator looks and behaves like all the rest of the language. When you add function calls in C++ they look and behave differently to operators, you would not confuse them as being ""part of the C++ language"". Your Lisp ones you can't tell that they're not a part of the language just by looking.

""*he just defined a function*"" - exactly! The thing which is ""nearly impossible"" in C++ and Python is ""just"" a triviality in Lisp,  barely worth mentioning, and so trivial it's even hard to pick out and explain. Therefore Lisp has a nicer design.

By simply being a function like everything else, your new exponentiation ""operator"" can be used to reduce a list - compare to Python where you can `a ** b` for exponentiation, but if you want to use it to reduce a list you need to use `import operator; reduce(operator.pow, myList)`, because the operator is special and different. I don't think you can add custom operators in Python so if you want your own math operation it will look different again and be a function call. Once you've defined `**` in Lisp it's not ""an operator separate from a function"" which needs special casing and special case treatment, it's just another function call, which is just like everything else in the language. So it's not special, but ""not being special"" stands out from other languages where operators are special and therefore 'off limits'.


And that ties in to your first point about a DSL - if your language is `(function <args> <params>)` then a Domain Specific Language stops being about ""how can I write my own programming language from scratch which is good for <domain>"" and starts being as simple as ""how do I name and implement functions helpful in <domain>"". Instead of being ""TradeScript++ written in C++"" which took you a month to make a compiler and interpreter, it's ""CoommonTradeScript written in Lisp"" which took you a few hours, *and* it's ""Lisp-tuned-for-trading"" which means your ""new language"" has all the power of Lisp, unlike TradeScript++ which doesn't have any of the power of C++.

Because the Lisp REPL is reading what you type as text, and parsing it into Lisp, and running it, all the time, you have access to that parser and interpreter, so why not use it? Make your CommonTradeScript look like Lisp and now you can simply read a file, evaluate it, and print the result, and .. voila, your own Lisp-language for trading with.

Could you write a C++ program which reads a C++ file and runs it? 

""but it's not a different language"" - exactly! You *could* define TradeScript++ with curly braces and strings quoted with angle brackets and then spend ages writing a parser and an interpreter and tooling to handle that .. and then have to learn to use it .. and then find desirable features and keep implementing them as you need them .. but why *would* you choose to do that when you have a Lisp parser and interpreter right under your fingers? Choose to make CommonTradeScript as a dialect of Lisp and then you can define a couple of functions and Read-Eval-Print the source file using the tooling you already know, and it's magically as powerful as Lisp without you having to add loads of features one at a time .. because it IS Lisp. So it's not a DSL, except it is tuned for trading because you made trading-specific operators, which .. are simply functions, so that was easy, and trading-specific functions, which was easy, and trading-specific .. nothing else because there isn't anything else, so that makes that easy. 

Something which is really hard in C++ is so trivial in Lisp it's almost not worth mentioning, because it's just an extension of ""coding in lisp"" and isn't really a separate language, if you don't need it to be.

And if you do want to process strings in angle brackets, you overload the part of Lisp which is reading what you type (Reader macro?) and tweak it so it can handle angle brackets. And now you have angle bracket strings. Everywhere. In all your Lisp source code, if you want. And it looks like part of the language because now it is, because you just put it there into the interpreter while you were using it, and that makes it as real as anything else. So that means it's also in CommonTradeScript. Hooray. And try rewriting g++ on the fly to extend the C++ language grammar and then use the extended language in TradeScript++. In a few minutes.

And if you *do* need it to be a totally custom language like regex, or string formatting instructions, which isn't Lisp, well parsing a custom language into an abstract syntax tree and evaluating it is pretty easy in Lisp, because once you've written a recursive descent parser (Lisp loves recursion) and turned the source into a tree (Lisp loves trees) then you can eval the nodes in the tree with Lisp functions (Lisp loves Lisp functions) .. so that was easy (easier).

Your operator isn't different from functions. Which means it's easy to add custom operators. They're not special so there isn't anything special to know or do. Your DSL isn't really different from Lisp. Which means it's easy to make DSLs. They're not special and different so there isn't anything special to know or do.

You are using a Lisp parser/interpreter so you naturally turn everything into Lisp, which means you can do a lot more than a C++ programmer, because things they think of as weird, impossible, special, months of work, are things you did without even noticing they were supposed to be hard.

You're now doing *things they cannot do* and they're not impressed *because you are making it look too easy*, and if that's not weird, what is??


I could have this all wrong.",1539325747.0
joinr,"You mentioned experience in webdev with Clojure.  Did you ever use core.async?  The 'go' macro is a good example of the power of language extension (and a pretty cool look at macrology).  The authors basically ported the communicating sequential processes from Go, features that are baked in at the language level, and extended Clojure (and simultaneously ClojureScript) to have embedded language-level support for co-routines/green-threads (goroutines) as a library.  

The result is a tiny DSL for working with CSP using channels, plus a library of functions to compose them.  The ""little language"" consists of some new forms for defining asynchronous processes amenable to ""parking"" that either run on a shared thread-pool or a dedicated thread (go, thread) along with means for defining channels (chan), and primitive operations on them (<!, !>, <!!, !!>, alts, etc.).  Using this little language, embedded in Clojure, you get the concurrency semantics of Go.  No one had to petition the language committee to add keywords to the language, update the reference compiler, etc.  They just wrote (some sophisticated) macros and (more or less) functions.

Of course the same idea exists in other forms in other dialects due to the nature of macros (and the storied histories of older lisps).  In ""On Lisp,"" Paul Graham has some great examples of extending CL to include little languages for continuations, multiprocessing (including fork/wait, and other primitives for lightweight processes), nondeterministic programming, and eventually logic programming (embedded Prolog).  Peter Norvig does similar stuff (and more!) in ""Paradigms of Artificial Intelligence Programming.""

Doug Hoyte goes ape in ""Let Over Lambda,"" using macros to redefine the default CL defmacro to enable automatic gensym syntax (similar to Clojure's, I think Clojure was inspired by it) to enable even better metaprogramming facilities.  A DSL for writing DSLs.....if you will.

Pattern matching (and to a lesser extent destructuring) is another example, that's typically found (again) at the language level in non-lisps.  In a lisp, you can define a DSL that can unify patterns with against inputs under arbitrary semantics.  Clojure has [core.match](https://github.com/clojure/core.match) .  [Odin](https://github.com/halgari/odin) is an eDSL that lets you query and transform datastructures using unification (kind of like datalog). [Specter](https://github.com/nathanmarz/specter) keeps getting attention, as a DSL for defining sophisticated reads and transforms on navigable paths within nested data structures (kind of like dynamic lenses).  There are undoubtedly analogues in other dialects, these just jump to mind.  Kris Kohlhepp's extinct blogpost [""Metacircular Adventures in Functional Abstraction:  Challenging Clojure In Common Lisp""](https://web.archive.org/web/20170109140201/https://chriskohlhepp.wordpress.com/functional-programming-section/metacircular-adventures-in-functional-abstraction-challenging-clojure-in-common-lisp/) is a pretty cool tour of the aforementioned concepts and more, using the CL ecosystem.

>The other piece of the puzzle for me is the concept of reader macros. 

Reader macros let you modify the reader arbitrarily; for lisps, this means altering even the fundamentally minimal syntax present.  Imagine redefining what ( ... ) means at read-time, or hacking the meaning of : to not only read keywords, but say (facetiously) launch a missile every time a new keyword literal is read, or not construct keywords at all, but define some other datum.  You get to control that if you have reader macros (and with control comes responsibility).

>Everyone talks about writing DSLs in lisp, which seems like maybe they're using macros. But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers? Are they talking about different things? 

There are multiple camps (Conrad Barski calls them the Lisp Guilds in ""Land of Lisp,"" although in practice they probably blend together more than separate cleanly into guilds...).  I say explore and experiment.  Caution born of wisdom is useful....but you're not going to blow up your computer by playing with macros.  Have fun and see what it's all about.

>Does lisp's ""code is data"" property even matter if you don't exploit it via macros?

As mentioned elsewhere, you can still build up expressions and eval them, primitive-like.  Macros make it much easier to do this and hook into the existing infrastructure.  To take it to an extreme (beyond macrology), you get into realms such as program synthesis and genetic programming, where processes synthesize programs as part of some exploration.  In program synthesis (like the research Will Byrd [demonstrates](https://www.youtube.com/watch?v=OyfBQmvr2Hc)  using miniKanren to implement a relational-programming version of eval (evalo) to search for possible implementations of arbitrary scheme programs) or building expressions according to some criteria - like [evolving efficient clojure.spec specs that can generate test data](https://github.com/gigasquid/genetic-programming-spec) .  Being able to work directly on the ""code"" as a datastructure makes this far simpler.  You can define operations like mutation, crossover, etc. as operations on lists.  Then eval the result.",1539378974.0
kuemmel234," If you take a look at a library like mockito (A mocking library for Java) you are getting very close to a DSL (if you aren't already there, I think it would still be a 'fluent API'). It's still just methods and classes (and Java magic), but you aren't just receiving a bunch of tools to create a mock(This one is dumb, I'm just trying to make it more obvious):
```java
MyClass foo = new Mocky.mock(MyClass.class);
Mocky.mockMethod(foo,""bar"", new Parameters(new StringMatcher(StringMatcher.ANY_STRING),..), new ReturnValue (..));
```
You get something close to a language instead. `when(foo.bar(anyString())).thenReturn(...)`. The difference between those two ways of mocking a method call is that one of them is simple to remember and could be understood by a lot more people than the other, for which you would need more knowledge about mocks. Hell, mockito is so easy to understand, I understood the purpose without ever having heard about mocking before.

In LISP you don't have to really think that hard to come up with ways to create these phrases, even such a dumb one as this: `(when (.bar foo) 'any-string (return ..))`.  You can almost always write your code  in a more language oriented design. And macros allow you to easily transpose code, so that you can create real phrases regardless of what's in them. You can't just transpose java code that easily.

So on the one hand, every LISP program can be called a lightweight DSL and on the other, macros allow you to easily create even the big ones with actual language constructs and everything, without the need of a complicated parser and such, just a bunch of macros. That is cool.",1539339595.0
kazkylheku,"TXR Lisp comes with an [implementation of the Awk language (in Lisp syntax)](http://nongnu.org/txr/txr-manpage.html#N-03D16283), which is provided entirely by a macro. That's an example of a DSL. 

The original Awk is a DSL originally written by some well-known people at Bell-Labs in C. It has its own lexical analyzer, Yacc grammar, interpreter and all the supporting routines.

In TXR Lisp, it's just a macro. All the run-time support comes from the surrounding Lisp implementation; the macro just does the stuff that makes Awk Awk: the implicit scanning of input sources, breaking them into fields, the I/O redirection, the pattern/action dispatch and all that.  It's only [500 lines of code](http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/awk.tl).

I've written lots of complicated macros and also macro systems, like the above.

Yet, I don't overuse macros.

For instance, I run all my self-employment finances using a TXR Lisp program. In that one, there are just five macros. Actually only four: the last `defsymacro` is part of the previous `defmacro`:

    $ grep macro *.tl
    money.tl:(defmacro define-relational (name binary)
    money.tl:(defmacro define-arith-predicate (name usr-package-fun)
    money.tl:(defmacro define-unary (name usr-package-fun)
    time.tl:(defmacro def-date-var (name fallback-val . date-range-val-triplets)
    time.tl:         (defsymacro ,name (range-lookup *date* ,fb ,rvt))))

The `money.tl` module overrides common arithmetic functions to work with money, and the three macros are helpers to condense the repeated definitions that are required.

In `time.tl`, the `def-date-var` macro provides a ""date-specific variable"" feature.  A global variable can be defined which has different values based on different calendar dates. Which date applies is  context dependent: which transaction is being calculated. For instance some transaction from July 3, 2017 has to use a certain tax rate that was in effect on that day; the code just has to establish the date context by binding the special variable `*date*`, and then access the date-specific variable in the ordinary way.

In this accounting system, the data entry (invoices, receipts, and whatever) is all done in Lisp syntax, but without any custom macros. E.g. an invoice is created as a variable definition whose value is a new `invoice` object:

    (defparml %inv-0013%
      (new invoice
           number 13
           provider %my-addr%
           client %abc-company%
           remit-to ""Kaz Kylheku""
           remit-days 25
           date (date 2018 2 28)
           items (list (new time-unit
                            start (date 2018 2 1)
                            end (date 2018 2 2)
                            hours 16
                            rate %rate-abc-2018%)
                       (new time-unit
                            start (date 2018 2 5)
                            end (date 2018 2 9)
                            hours 40
                            rate %rate-abc-2017%)
                         ...)))

There would be little point in condensing this any further with some sort of custom invoice syntax. It is using a macro: the *new* macro from the object system. That's terse enough. `(date 2018 2 5)` is terse enough for me for specifying a date; it's just a function. I don't mind the explicit `(list ...)` for the invoice items.

Then the invoice is recorded into the accounting system by a call to `record-invoice`, just a function:

    (record-invoice %inv-0013% ""Invoice 0013 issued to ABC Co."")


",1539376149.0
Sylph,Some of this comes down to the fine/blurry line between internal DSLs and regular APIs. Martin Fowler writes a bit about it [here](https://www.martinfowler.com/bliki/DslBoundary.html) that you may be interested in reading.,1539337343.0
justin2004,"> Does lisp's ""code is data"" property even matter if you don't exploit it via macros?

i'm sure you already know about the eval function. 

you could build a list (of ""data"") that you know is a form that could be evaluated and then just eval it.",1539347353.0
tzjmetron,"Take the Hiccup framework in Clojure:

    [:a {:href ""foo.com""} ""bar""]

That is equivalent to:

    <a href = ""foo.com"">bar</a>

This is a DSL. When it comes to Lisps, DSLs reflect not so much the syntax as the meaning of the s-expressions that is ""overloaded"" to suit the domain. For instance, in the normal context you'd consider the given Clojure snippet as a plain old vector, right? However, in the given context, it generates HTML code with the advantage that even the syntax does match somewhat with the target domain (HTML generation).",1539352626.0
defunkydrummer,">But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers?

Simply, if something can be written as a function instead of a macro (and, without increasing complexity or difficulty), then it's preferrably to use a function.  

But, when you need them, macros make *all the difference in the world*, particularly in Lisp, compared to languages that have no macro facilities at all, or languages that require a lot of effort to create a macro (i.e. convert the code to AST, then manipulate the AST using a custom lib). On Lisp, creating a macro is almost, almost as easy as writing a normal Lisp function. It's almost effortless.

>I've read multiple times about how great it is to write DSLs in lisp. This concept has captured my fascination as a way to keep complexity in check. But creating a programming language sounds like 

>But that's not a new language, it's two god-damned functions. 

That's the point. The point of having a language where the code is purely made of s-expressions, is that expressing a useful DSL usually doesn't require modifying the syntax. 

> I can write a Shares class and trade and timing-is-right functions in C++

Yes, so you would require always to instantiate a Shares object and then call the methods on the object, so the syntax is more restricted: it requires you, always, to specify the object (dot) method (parentheses) parameters. While you don't have such syntax restrictions on Lisp. 

By default all is s-expressions. 

>The conclusion of this essay is that his ""DSL"" is basically this (...) But that's not a new language, it's two god-damned functions. 

Because, for his purposes, his DSL was good enough by using some lisp functions and the default Lisp syntax for function calls. (Nothwithstanding the `20:00`, which is syntax that doesn't exist on CL originally). 

In C++ you call methods like this: 

<object instance> `.` <method name> `(`<argument> `,` <argument> `,` <argument>  `);`

In lisp you have the function calls like this: 

`(` <function name> <argument> <argument> <argument> `)`

If this suits your DSL then all nice. 
If the C++ syntax suits your DSL then all nice, you're lucky. However, unlike C++, you are not constrained by this in Lisp: you could as well write the function application as:

`(` <argument>  <function name>  <argument> <argument> `)`

or

`(` do <function name>  with <argument>  and <argument> `)`

or whatever you like, by transforming code to code, because *code is data*. This flexibilty you don't have in C++ (and many other languages) and that's what makes creating DSLs easy. And we haven't even touched symbol macros yet. The `20:00` syntax for time was probably achieved using a symbol macro.  




",1539359224.0
dwchandler,"> I've read multiple times about how great it is to write DSLs in lisp. ... But that's not a new language, it's two god-damned functions.

There's an important distinction between internal and external DSLs. Both types of DSLs are meant to allow working closer to or within the problem domain. External DSLs are new, special purpose, stand-alone languages. Internal DSLs are abstractions within a language.

External DSLs seem like the real deal but there are advantages to using internal DSLs. If you haven't handled something in an external DSL then it's not handled, and it can be difficult to work around. Conversely, internal DSLs are implemented within a language, so something that's not handled yet can be dealt with by falling back to the base language fairly seamlessly. That makes it easy to iteratively develop your DSL one god-damned function at a time, refactoring as you go.

> But that's not fair. He didn't add a new operator. Lisp doesn't even really have operators in the same sense as C++.

Yes, that's right. It's also the point. There's no need for a special class of things like operators in lisp. You can write the equivalent of * or + just as easily as you can write any other function, with no special syntax or magic. This isn't ""not fair"", it's a major strength of lisps.

> But then, everyone (else?) says to use macros sparingly, if at all. So, are there just two camps of lispers? Are they talking about different things?

Here's the problem... people hear that lisp macros are powerful and amazing, so they learn some lisp and jump into macros and use them inappropriately and cause grief. The real answer is, as a newbie, to try hard to do what you need with functions so that you learn their expressive power. Far too much of newbie macro use would be better done as functions. But some things *can't* be done with functions and you need macros, and other things *could* be done with functions but macros are better for the job at hand. But until you have experience it's not easy to tell. For an analogy, look at the advice around metaprogramming in C++ for newbies.",1539362925.0
melevy,"There's this post: https://www.reddit.com/r/lisp/comments/pg2yx/what_are_some_fun_or_useful_macros/

There's an answer which shows how to extend lisp with XML syntax which generates very efficient code.",1539373540.0
paulfdietz,"I think of this in two ways.

First, a DSL that requires a preprocessor in another language can be done with macros in lisp.   Yacc or Lex (to use two venerable examples) have equivalents in lisp that are just things you load.

Second, if you want to write a DSL, you will often find yourself wanting to embed more and more procedural logic in it.  At some point, you'll realize you just want a general purpose programming language in there.  If you had done it via macros in lisp, you have the full power of the language available.

Reader macros are a different kettle of fish.  I've avoid defining them in general because different sets of reader macros don't play well together.",1539378285.0
dzecniv,"My take on it: it's more about defining new language keywords: from `def` or `defun` to `defroute`, `defcommand` etc that would do exactly what we want.

I noticed a pattern in my application (Python):

    def name (self, request, **kwargs):
       messages = Message()
       try:
           obj = Model.…
       except:
          return JsonResponse(obj + messages)
      return JsonResponse(…)

I want to always return error messages, there is always the try/catch,… I can not refactor this with Python features (with-statements, decorators,…), but I could use a macro.

Other languages with macros have a `defroute`s, when in python frameworks there may be boilerplate.

In my Lisp app, a user creates new commands with:

    (defun name (whatever)  …)
    (replic.commands:add-command #'name)

But now I'd like to make it shorter and hide the underlying `add-command`, so I'm about to create a `defun-command`.

The Next browser does this: https://github.com/atlas-engineer/next/blob/master/next/source/command.lisp#L25",1539428393.0
dcooper8,"Here’s an example of a DSL built up
in Lisp:  

  https://gitlab.common-Lisp.net/gendl/gendl

“DSL” may be a bit of a misnomer here, because Gendl is still a general purpose language (not really “domain specific”). But it is a full-blown declarative language built on top of CL (and continuing to be a superset of CL) while offering new top level constructs not present in core CL. 

Here’s a (rough, pre-alpha) preview of Gendl’s new object browser, a web app built up completely in Gendl as well (not released in the codebase yet — and looks much better on computer than on phone at this point, not fully responsive yet):
  
   http://genworks.com/geysr-bus

(yes, there’s a rendering bug with the front axle in x3dom mode). 

The code for the tree shown there is here:

https://gitlab.common-lisp.net/gendl/gendl/tree/devo/demos/bus

(Ignore the outdated README). 
",1539630468.0
toiletrees2,r/DSLs,1540012558.0
Nyanraltotlapun,">Does lisp's ""code is data"" property even matter if you don't exploit it via macros?


Yes it is.
I have not so much of experience, but can      assure you lisp is totally different, it is magic! 
The thing with ""code is data"" is you have access and control over syntax and execution.  You get continuations as first class objects, and lots of other great stuff.
",1539333902.0
meenzu,Is there a working example based off this pattern. Would love to play around with this,1539312799.0
dzecniv,"Among other things, the new site features:

- A site generator implemented in Common Lisp.
- A gitlab pipeline for automatic deployment.
- A new responsive design based on Bootstrap and new content.
- new documentation, Portacle honored,…
- a [list of libraries](https://common-lisp.net/libraries.html), taken from the awesome-cl list (kuddos to me and Cody Reichert)
- a [list of companies](https://common-lisp.net/lisp-companies.html) using CL, taken from the awesome-cl-companies list, initiated by /u/azzamsa (kuddos)
- (and most importantly a random quote at the footer :) )

thanks and congrats to Mariano Montone and the maintainers.
",1539247873.0
dzecniv,On Hackernews: https://news.ycombinator.com/item?id=18192614,1539268712.0
svetlyak40wt,It would be nice to mention quickdocs.org in section Libraries on page https://common-lisp.net/downloads,1539260418.0
republitard,"Maybe it's not such a good idea to use JSCL to implement the ""Try Lisp Online"" demo. Just about everything I tried with it failed:

    Welcome to JSCL 0.6.0 (built on 1 May 2018)

    JSCL is a Common Lisp implementation on Javascript.
    For more information, visit the project page at GitHub.

    CL-USER> (loop repeat 5 collect 'x)
    (X X X X X)
    CL-USER> (macroexpand-1 '(loop repeat 5 collect 'x))
    (JSCL/LOOP::!LOOP REPEAT 5 COLLECT (QUOTE X))
    T
    CL-USER> (macroexpand-1 '(JSCL/LOOP::!LOOP REPEAT 5 COLLECT (QUOTE X)))
    (LET ((#:G40562 5)) (DECLARE (TYPE REAL #:G40562)) (JSCL/LOOP::WITH-LOOP-LIST-COLLECTION-HEAD (#:G40563 #:G40564) (BLOCK NIL (JSCL/LOOP::LOOP-BODY NIL (NIL NIL NIL NIL) ((JSCL/LOOP::LOOP-COLLECT-RPLACD (#:G40563 #:G40564) (LIST (QUOTE X)))) ((WHEN (NOT (PLUSP (SETQ #:G40562 (1- #:G40562)))) (GO JSCL/LOOP::END-LOOP)) NIL NIL NIL) ((RETURN-FROM NIL (JSCL/LOOP::LOOP-COLLECT-ANSWER #:G40563)))))))
    T
    CL-USER> (restart-case
    ...        (invoke-restart 'foo)
    ...        (foo () :foo))
    ERROR: Function 'INVOKE-RESTART' undefined
    CL-USER> (restart-case (error 'foo) (foo () :foo))
    ERROR: ERROR: `FOO' is not of type SEQUENCE
    CL-USER> 1/2
    ERROR: Variable 1/2 is unbound.
    CL-USER> (defstruct foobar 
    ...         (x 1 :type integer) 
    ...         (y (lambda () 1) :type function))
    ERROR: Bad slot description `(X 1 :TYPE INTEGER)'.
    CL-USER> *package*
    #<PACKAGE CL-USER>
    CL-USER> (type-of *package*)
    ERROR: Function 'TYPE-OF' undefined
    CL-USER> (defpackage :my-cl (:use :common-lisp) (:shadow :car))
    ERROR: ECASE expression failed for the object `:SHADOW'.

...and CLOS is explicitly mentioned on JSCL's GitHub page as not being implemented. 

This would be a terrible first CL experience.

Or maybe I'm just really good at guessing which corners of CL are likely to be unimplemented.
",1539328184.0
zodmaner,"Nice! Thank you for all the hard works!

The new version looks very nice, IMHO.",1539259561.0
OldShoe,Looks great!,1539264977.0
kristoft1329,"Great work!
New site looks amazing, i think it'll serve well for common lisp community",1539265638.0
defunkydrummer,"Looks very nice, nice colors, nice look.",1539275150.0
ckriesbeck,"I notice LispWorks is not mentioned anywhere on the implementations page.  Is that a failure on their part to contribute, or a conscious choice? ",1539279538.0
SlightlyCyborg,It looks great desu.,1539722324.0
demosthenex,Look at backtick and comma.,1539163461.0
kazkylheku,"You don't like `(list ...)`, looking for a shorthand. A shorthand is possible: define reader macro for `[...]`. But about that, specifically, you say: ""I want to avoid this notation.""

So how about compromise in the middle based on character count? `(list ` is six characters including the space. `[` is one character. The average is 3.5; let's round it down to 3, and define the funtion `l` so we can write `(l ...)`:

    (defun l (&rest items) (apply #'list items))
",1539196461.0
moodd,"Since the only arguments you pass to `poligon` are points, it would make sense to use `&rest` arguments.

    (defun poligon (&rest points) ...)
    
    (poligon (point 40 90) (point 67 60) (point 80 132))",1539163504.0
flaming_bird,"    (poligon (list (point 40 90) (point 67 60) (point 111 79) (point 80 132)))

This is only four characters longer than what you posted.",1539171982.0
blue-dog-blues,"Why not use something like Ranger and use Emacs as the default editor?

That way you get proper separation between tools and you can switch editors when the time is right.

I have recently switched to LEM instead of emacs for text editing and it works well.",1539047948.0
ruricolist,"If you're willing to try it the other way around, there's [Sunrise Commander](https://www.emacswiki.org/emacs/Sunrise\_Commander), which imitates MC from within Emacs.",1539118544.0
berock212,"I never knew that was a thing, it has a surprising number of features. I highly doubt anyone has written good lisp plugins for it though.",1539045629.0
ElBroet,">Clojure

^^listen ^^here ^^you ^^little ^^shit",1538881059.0
dcooper8,Tom Cruise’s Scientology lanyard has the same colors as the Clojure logo...  what does this mean?..,1538855063.0
--zt,"I didn't think this was funny until I got to the picture for Factor, and then I totally ROFLed.",1538790952.0
whism,is that dr. bronner's for emacs-lisp? lol,1538791973.0
Eno6ohng,"There should be a pile of dog shit on all pics except the CL one, then it'd be more accurate",1539549519.0
TotesMessenger,"I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:

- [/r/clojure] [Went to r\/lisp and found this gem.](https://www.reddit.com/r/Clojure/comments/9o2g16/went_to_rlisp_and_found_this_gem/)

&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",1539521352.0
ipcoffeepot,Work with Haskellers. Can confirm. ,1539530914.0
defunkydrummer,I prefer the original version (Star-trek themed.),1539191265.0
iLikeOPHeroines,Why is Khomeini there for Java? LOL... Literally burst in to laughter. What is that supposed to signal anyway? Revolutionary?,1539558855.0
rhabarba,"I am gradually trying to let Racket grow on me, coming from Common Lisp. It works surprisingly well. ",1538700684.0
Lower_Cryptographer,It sucks that Racket & Clojure programmers don't hang out here as much as CLers do.,1538744621.0
stassats,Use http://sbcl.sourceforge.net/ in the meantime.,1538690114.0
arvid,up for me 00:14 utc,1538698504.0
f0urier,"Is this something you need?
```lisp
CL-USER 104 > (function-lambda-list 'myfun)

(&key (test t))
```
",1538644865.0
giuseppemicheli,"First of all thanx for all your replies.

None of the solutions works in my environment (which should be based on common lisp)… I got no package called ""ARG"", no functions called ""function-lambda-list""; I walked over all symbols and packages I can access finding some commands (WALK-ARGLIST, for example) but I could not understand how to use them. The best I got when I found out a function called EXTRACT-LAMBDA-LIST which doesn't work when dealing with compiled functions:

(EXTRACT-LAMBDA-LIST (symbol-function 'my-uncompiled-function)) -> works fine;

(EXTRACT-LAMBDA-LIST (symbol-function 'my-compiled-function)) -> '#<compiled-function> is not of kind list.",1538652999.0
stassats,"    (function-lambda-expression (lambda (&key x) x)) 
may sometimes work, but not guaranteed.
",1538654514.0
flaming_bird,"    CL-USER> (defun foo (&key (foo nil foo-supplied-p)) (list foo foo-supplied-p))
    FOO
    CL-USER> (foo)
    (NIL NIL)
    CL-USER> (foo :foo 42)
    (42 T)",1538644233.0
flaming_bird,"Alternatively, you can use `&REST` with `&KEY` to get the whole lambda list as a parameter in your function.

    CL-USER> (defun bar (&rest rest &key foo bar baz) rest)
    BAR
    CL-USER>(bar :foo 1 :bar 3 :baz 777)
    (:FOO 1 :BAR 3 :BAZ 777)",1538644362.0
lispm,"> it is provided by a meta-object protocol, which provides a standard interface to the CLOS, and can be used to create new object systems.

which is optional and non-standard, but provided in some form in many implementations in different packages. The CLOS MOP is not a part of the ANSI Common Lisp standard. Some implementations don't provide it or only some parts of it.

Otherwise in many implementations available in a portable layer - as much as it is possible.

> The functionality belonging to this name was added to the Common Lisp language between the publication of Steele’s first edition of “Common Lisp, the Language” in 1984 and the formalization of the language as an ANSI standard ten years later.

The CLOS spec was published and accepted by the ANSI CL committee in 1988. The MOP was not accepted.

> the Art of the Metaobject Protocol, by Gregor Kiczales, Jim des Rivières et al.

not really required. It's a great book, but it is not a required read for users of CLOS. Much of CLOS programming can be done without MOP knowledge.

  (defvar p1

I'd prefer earmuffs around p1. The use of common names identifiers like p1 and pt as special variables is slightly dangerous.

    :accessor name

When do we need accessors? Actually we don't need accessors for all slots. Accessors are best used when we plan to extend the corresponding generic function or when we want to use them as functions (even exporting them from packages as functions).

    (defclass child (person)
      ())

Class without purpose and explanation.

> CLOS type (or class)

CLOS is not about types, it is about classes. DEFCLASS defines a class. These classes are also Common Lisp types with the same name.

> It is generally good practice to define a constructor:

I don't think so. I think this is entirely optional and adds no value by default. SLIME displays the initargs for a MAKE-INSTANCE. The required arguments argument is also only valid in the primitive case of a bunch of always required arguments. There are code bases / libraries which mostly don't use them. For example LispWorks' CAPI.

> default method to access any slot

could be confusing. SLOT-VALUE is a function, not a generic function.

> This form is evaluated each time it’s needed, 

When is that?

> CLOS objects are also instances of a CLOS class

Probably: CLOS classes are also ...

> The first class on the list of parent classes is the most specific one, child’s slots will take precedence over the person’s.

That's too simple. Slots with the same name are being merged.

> and all instances of the class (and, recursively, its subclasses) are updated to reflect the new definition. 

lazily

> Pretty printing

That's a typical example where we don't need to go through accessors and using slots is just fine.

    (defgeneric greet (obj &key &allow-other-keys)
      (:documentation ""say hi""))

    (defmethod greet (obj)
      (format t ""Are you a person ? You are a ~a.~&"" (type-of obj)))

This is not allowed. Lambda list (OBJ) is not congruent with the lambda list (OBJ &KEY &ALLOW-OTHER-KEYS)

> The dispatch mechanism proceeds as follows:

This is valid only for the simple case of standard method combination and all primary methods

> By default, in the standard method combination framework provided by CLOS, we can only use one of those three qualifiers

... for any given method

    (defclass person ()
      ((name
        :initarg :name
        :accessor name)    ; <-  missing closing parenthesis
      (:metaclass counted-class))

 missing closing parenthesis",1538592912.0
flaming_bird,"    ;; While reading CLOS - the Common Lisp Cookbook (extensive rewrite):
    ;; Caught NITPICKING-STYLE-WARNING: stray &nbsp;s detected. https://i.imgtc.com/Q4cdsBD.png",1538573733.0
bemrys,"No discussion of finalization, which crops up in inheritance ",1538582329.0
svetlyak40wt,"Don't know how this section looked before, but now it is great!",1538578656.0
timezone_bot,"6pm UTC happens when this comment is 11 hours and 8 minutes old.

You can find the live countdown here: https://countle.com/4JpMuX_-3

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1538549469.0
flaming_bird,"Good luck!

I've played with CL-AUTOWRAP just a little bit before, and I've used it in https://github.com/phoe/cl-lzma - perhaps you could use this code of mine as an example of successful autowrap usage in your video.",1538556031.0
Lisp-S-R-C-L-D,"I can find it in youtube ? did it the session happen ? Thank you!
PS : Your little bit of lisp are really informative and fun to watch !!",1538694887.0
dzecniv,"> how to have Spinneret placed the generated HTML files in a /public directoy

AFAIK Spinneret doesn't produce html files/there is no need to, it returns html on the fly.

Would you create a repository, so than we can try out everything ?

(Not an expert on CL web dev. I'm turning to [Weblocks](http://40ants.com/weblocks/quickstart.html), very promising and active)

Not to distract you from learning this stack, but for blogging/personal sites did u see https://github.com/kingcons/coleslaw ?",1538488828.0
bobbysmith007,"You can nest modules.  

I suggest adding `:serial t` to each module while you are learning, as this can make the whole things conceptually easier to understand and debug.  I found that not having things load the lexical order listed always confused me in the beginning.  Not a huge problem, it just helps me organize it in my mind.",1538490859.0
parens-r-us,"I’m putting together a similar stack but using snooze rather than ningle, adding a few things like a macro for adding Ajax server actions via an ajax handler in the spinneret DSL. I was toying with writing a minimal component framework (but smaller than weblocks).

Didn’t know LASS existed, so thanks for that. ",1538502492.0
tzjmetron,"Given your background, I would recommend Common Lisp (SBCL is my favourite distro). I, on the other hand, am going the other way now - dabbled in Common Lisp (love it), and am now learning Clojure for work.",1538417923.0
dzecniv,"I'll second Common Lisp, and for pointers:

- http://lisp-lang.org/ and its success stories ([music](http://lisp-lang.org/success/music/) category: OpusModus)
- [awesome-cl](https://github.com/CodyReichert/awesome-cl)
- the [Cookbook](https://lispcookbook.github.io/cl-cookbook/) (I'm pretty active on those two)
- we recently saw [Music](https://github.com/MegaLoler/Music) framework, [CL Music](https://ccrma.stanford.edu/software/clm/), [a list](https://github.com/defaultxr/cl-patterns/blob/master/doc/other-libraries.org) of audio libraries… and there may be much more.
- last: if as a beginner you're surprised about how Quicklisp works, take time to [understand its benefits](https://lisp-journey.gitlab.io/blog/why-do-we-have-to-wait-one-month-before-quicklisp-updates/) upon more traditional package managers (hint: closer to apt than to npm, fortunalety).

Have fun :)",1538428796.0
kristoft1329,"+1 for Common Lisp. It seems to be the most complete option, especially if your purpose is to learn. I find CL very enjoyable btw",1538421154.0
xugan97,"Common Lisp has a lot of good books published in the last decade: *Common Lisp recipes, Interpreting Lisp, Practical Common Lisp, Let over Lambda, Successful Lisp, Funktionale programmierung und metaprogrammierung* (German). The classics like *Ansi Common Lisp* and *On Lisp* are still good. Generally, there is better documentation, libraries etc. for Common Lisp than for other Lisps.",1538447604.0
tankfeeder,Picolisp,1538425441.0
lichtbogen,"Since you mention music let me suggest Common Lisp, which has an important tradition in musical domains: pwgl, openmusic, opus modus, slippery chicken, and others already mentioned. Cl-collider is a CL client to Supercollider in active development - a great library for live coding and interactive experimentation. CL also benefits from a large (in lisps proportions) number of libraries, places to get help, books, etc. Scheme can me useful for Lilypond, though. ",1538432869.0
Pour_Louis,"No idea, but I'm working through SICP and it uses MIT Scheme ",1538418746.0
defunkydrummer,"I love Common Lisp, for what it's worth. It seems anything is possible with it. ",1538521760.0
eccp,"You might want to check Chicken Scheme, here's a quick review of the dev workflow with Emacs and the REPL: https://www.youtube.com/watch?v=eXB3I3S3vJc",1538451468.0
mtelesha,"I would recommend Racket over anything else. 

&#x200B;

1) It is designed to help people learn Lisp/Scheme

2) Documentation is best of any language ever

3) The brain bank of the community is a who's who in Lisp

4) The library and infrastructure is the best

5) Deployment is a press of the button and I have an executable. Haven't had any surprises yet in my builds",1538452398.0
bitwiggler,Gerbil scheme hands down.,1538518379.0
justin2004,"i tried slimv briefly. 

now i just do something like `rlwrap --histsize 1000000 sbcl`   then ctrl-alt-j and and i can use vi cursor positioning, editing, have history, etc.

what am i missing by not using slimv (or slime) and this flight-recorder? i'm ready to be convinced to change my REPL ways.",1538347759.0
Shinmera,"I created one for you for now. I hope it works.

<http://gitea.tymoon.eu/shinmera/portacle/releases>",1538321440.0
dzecniv,"Not directly answering, but possibly helping a ""I don't like how to access data structures in CL so far"": you might like the [access](https://github.com/AccelerationNet/access/) library, which is consistent and generic for all data structures, and helps for nested ones. See also [this blog post](https://lisp-journey.gitlab.io/blog/generice-consistent-access-of-data-structures-dotted-path/).",1538307923.0
shostakovik,"Im not sure i understand what your asking. If you asking 'can I use :foo as a function name?' the answers yes. The other way I could interpret your question is 'can I recursivley call a function in the argument list of the function definition?' then I have no idea, but I suspect not.",1538277040.0
PuercoPop,"This is a little tricky because Clojure is a Lisp-1 while CL is a Lisp-2. So you would either have to define a function for each keyword, which seems undesirable. To one way achieve this would be to modify the reader so that when it interns a keyword it defines the corresponding function. I can't think of an easy and portable way to do. Maybe you could use Eclector make this approach work?

An ""almost there"" approach would be to take advantage that lambda forms in the function position are applied. So you could write a macro that takes a hash-table and sets up a macro for each key that expands into a lambda form that that retrieves the key with the same name as the  macro from the argument. The gist of the idea would be something like 

```lisp
(defparameter +ht+ (let ((ht (make-hash-table)))
                     (setf (gethash :foo ht) 5)
                     ht))

(macrolet ((:foo (ht)
             ;; Note the extra surrounding parens
             `((lambda ()
                 (gethash :foo ,ht)))))
  (:foo +ht+))
;; => 5

;; here with-ht would wrap the body with the appropriate macrolet
(with-ht (ht)
  (:foo ht)
```",1538288051.0
joinr,"I got partway there in clclojure.  Inside a clojure eval context,  with keyword literals, I scan the body for call sites.  From there, I construct functions (keyword accessors) bound to the function namespace (surprisingly it works).  [Here](https://github.com/joinr/clclojure/blob/master/keywordfunc.lisp)  I use this automatically inside unified-let contexts for [unified lexical scope](https://github.com/joinr/clclojure/blob/master/lexical.lisp).

This doesn't work outside of macros, needs a  custom read eval to extract arbitrary kw calls....or even better, like clojure does, allow a function protocol for anything to participate in.",1538357893.0
ProfessorSexyTime,"I thought to post this here being that at the moment, for Common Lisp

1. Only SBCL is supported at the moment

2. Using the tool only disassembles the `main` function a program. 

Maybe some of you here would be interesting in help with the support for Common Lisp, and *possibly* add support for Schemes. 

I, myself, am not knowledgeable enough yet to contribute. I certainly would like to, and maybe making use of this tool will give me the knowledge I need in order to contribute.

EDIT: Also, goddammit **doing** not going.",1538267011.0
drjeats,"> A godbolt embedded in Emacs

i luv u, professor sexy time",1538285777.0
Heinemenusch,"So flaming_bird gave you the ""right"" answer but answering your question, recursive functions will always look something like this:

1. check for end, return the result if it is
2. move closer to end (for example, process the head of the list and increment the count if it's an 'A'
3. recursively call the function with the work left to do, in this case the rest of the list

Don't use setf and setf, pass state through recursion, in your case you could have two parameters to checkA, lst and count. If check-a is called with just a list then default count to zero. Each recursion increments count if an ""A"" is found as passess that on in the recursion.

Note when I say ""increment count"" I don't actually mean that, what I mean is you would pass (1+ count) as a parameter in the recursive call.

Ideally, make sure you do all the work before making the recursive call as most CL compilers can optimise that (tail call optimisation).

Consider buying and working your way through the exercises in ""The Little Schemer"" as that's excellent for teaching the mind set.

Note also, check-a not checkA is the preferred Lisp style.",1538065513.0
flaming_bird,"It seems that your function is counting the occurrences of `a` inside a list. There is a built-in function for that, [`COUNT`](http://clhs.lisp.se/Body/f_countc.htm).

    (count 'a '(1 2 a 3 b c a 8 4 a 0 a b f i t a))
    ;=> 5",1538063930.0
kazkylheku,"First, write down a recursive **specification** of the problem. If you can't specify it recursively, how can you write the code? For trivial functions that are well-specified, the Lisp code pops out almost automatically.

How many `a` occurrences are there in a list?

1. If the list is empty, then zero.

2. Otherwise, if the list is not empty:

  a) If the first element is `a`, then the count is 1, plus the number of occurrences of `a` in the rest of the list.

  b) Else the first element is not `a`, and the count is just the number of occurrences of `a` in the rest of the list.

The cases 2 (a) and 2 (b) involve recursion: they rely on having a function to count the occurrences of `a` in a list, which is applied to the rest of the list.",1538073175.0
felis-parenthesis,"    (defun check-a (list)
      (if (endp list)
          0 ;; No ""a""s in the empty list
          ;; Otherwise
          ;; break into pieces
          (let ((nibble-off-a-little-bit (car list))
                (save-rest-for-later (cdr list)))
            (let ((little-calculation
                   (if (equal nibble-off-a-little-bit 'a)
                       1 ;We've found one ""a""
                       0 ))
                  (by-the-magic-of-recursion
                   (check-a save-rest-for-later)))
              ;; combine our little calculation
              ;; with the big magic calculation
              (+ little-calculation
                 by-the-magic-of-recursion)))))
 ",1538075581.0
ObnoxiousFactczecher,Where is output bound? Where is test bound? What is the function supposed to accomplish?,1538147396.0
kpenchev93,"The problem is not _being new to Lisp_, it's the imperative thinking. Learn the way of the functional programming with books like SICP, The Little Schemer and/or any book on FP, and you'll be very close friends with recursion.",1538259952.0
morphinism,"If this is as an exercise, then others here have given good answers. If it's for something else, just use `position` or `count`.",1538412878.0
Goheeca,"    (defun checkA (lst)
      (if lst
          (+ (if (eql 'a (car lst)) 1 0)
             (checkA (cdr lst)))
          0))",1538065158.0
tankfeeder,"my PicoLisp [code](https://bitbucket.org/mihailp/tankfeeder/src/default/cntA.l).
",1538077751.0
lisper,"What do you mean by ""proper list""?  Do you mean a vector?  If so, then the answer is: because you can't take the CDR of a vector without allocating memory.

One way to think of it is that the reason that punning cons cells to be lists is cool is that you have essentially pre-computed and cached the entire CDR chain, which lets you walk the chain very efficiently and with all the intermediate results being representable as immediate values.
",1538007346.0
kazkylheku,"What are ""real lists""? Lists made out of cons cells are real lists. Cons cells pin down the implementation. That implementation is more articulated than just ""real lists""; it doesn't take anything away. 

(Well, it does take away some forms of mutability: we cannot turn an empty list into a non-empty list in-place and *vice versa*; they are distinct kinds of objects. If an API is dictated that the list must be an object which supports insertion and deletion operations while always retaining its identity, then we can't use cons cells and *nil*: at least not directly.)
",1538009490.0
__lm__,"Well, lists built with cons cells were in lisp since its inception. AFAIK this was *in part* an historical accident due to the fact that the original machine in which lisp was developed (an IBM 7090 if I remember correctly) had the ability to store and access easily two pointers plus some tag fields.

Actually, the idea of having cons cells composed of two pointers (with all the implications, like dotted pairs that are not proper lists) was not fixed, at least in the early lisps:

>	[...] when the computer has 48, 60, or 64 bits per word, there is room for *three* pointers in a single word: and some LISP systems actually use this organization in their own special way
    (From W. D. Maurer, The Programmer’s Introduction to LISP, page 93, 1972)",1538077930.0
Aidenn0,So you just want a cons cell to disallow the CDR being anything other than of type list?,1538012820.0
ac1235,"Scheme's function signaturr syntax only works that way.

    (define (f some-arg . rest) ...)

It is very elegant and almost pattern matching like.",1538024167.0
crabbone,"Well, there's a confusion in terminology: things made of cells are called lists.  Cells are the basic building block of everything, lists are just one possible thing you can build.

To answer the ""why?"", I first need to disambiguate between ""why?"" may mean ""how, historically, did it come to be this way?"" and ""what purpose does it serve?"".

From historical perspective, Lisp wasn't supposed to be some fancy language with a lot of random stuff stitched to it, like, say modern languages with arbitrary sets of keywords, syntactical constructs and other nonsense.  In a very mathematical tradition, it was designed to answer the question: ""what would be the minimal, but sufficient way to express computation?"".  There isn't a unique way to do that, but the idea was to make it irreducible to a simpler language.

Foundational formalism of Lisp is this:

    A_1 -> C_1 ; A_2 -> C_2 ; ... ; A_n -> C_n

Where `A` is short for ""antecedent"" and `C` is short for consequent.  The computation is supposed to happen by first evaluating antecedents, and if their value is true, then evaluating the corresponding consequent, else, moving to the next pair; if consequent evaluated to true, that is the result of the computation, else, move to the next pair.

Lists, in this context, were supposed to be a symbolical representation of such a computation, it was perceived that a lot of the work a program would do, would deal with manipulating the structure of the program, and so implementing it similar to C arrays, would've been wasteful.

---

While the original design may shed some light on the rational behind this decision, it doesn't follow that we should honor the desires of the original authors and do what they wanted.  But there is a good reason to have lists made of cells, rather than C-style array, or C++-style vectors etc.  If you look deeper into the problem of describing arrays or vectors, you'll run into serious difficulties with types...  Is `int foo[10]` of the same type as `int bar[11]`?  How do you describe their types?  How will you be able to describe operations such as insertion, slicing, concatenation etc?  Bound types, sort-of, try to answer this question, but... I'm not convinced about the answer.

Another problem: the existence of arrays or vectors and Co is conditioned on our model of a machine performing computations.  It is always implied in books on algorithms and data-structures, but rarely verbalized, that the model in use is the RAM model (random-access memory).  Where, allegedly, you can create arrays of any length you like.  This model used to be a good approximation of hardware at one time... but, not anymore.  The situations where you are not able to allocate continuous chunks of memory to support arrays are more and common.  So, if you want to have some data-structure with enduring properties... probably, array / vector is not a good choice.

Both these claims, sort-of, come down to the original desire to keep things as austere as possible, to have minimal building blocks, and have less headache when it comes to combining them.  So, I believe, that the original intention stood the test of time.",1538249446.0
Goheeca,"I'm just guessing here, but I think that with cons cells it was easier to implement garbage collection in Lisp Machines back then.",1538007482.0
emacsomancer,"Lists as connected cons cells with obligatorily ""closing"" nils is conceptually interesting. It produces strictly binary-branching trees, which I find really cool (but that might just be because I'm a linguist).",1538010333.0
ObnoxiousFactczecher,"Inductive definition? Non-destructive modification? Simpler structure sharing? What exactly are ""real lists"", anyway?

[EDIT: Apparently someone dissents from my view that these features are supremely useful. Well, your loss. :)]",1538007250.0
flyin1501,"See Clojure, where lists are not built out of cons cells.

I think it it because building lists out of cons cells (ie. 2-element sequences) makes taking car / cdr really cheap, and that was a requirement in the past.

""Proper list"" is defined as a lisp-style list (ie. built out of cons cells) that properly ends in an empty list (or nil). So, proper lists by definition are not primitive. More Lisps with list defined as a generic sequence would be nice, though.",1538046650.0
VanLaser,"Actually it's even better, it looks like for 8$ you can get the Land of Lisp already :)",1537883514.0
Michaelmrose,"How about link to the actual bundle page. The Twitter link is an extra step for no reason and for me it failed to even load.

https://www.humblebundle.com/books/learn-you-some-code-books",1537915784.0
jokasx,That lisp book is awesome. Started reading it some time ago and was limint it a lot. It had already came out o  previous bundles that's how I have it. ,1537884466.0
defunkydrummer,"Land of Lisp is worth more than $463. Just the comic strips inside are worth at least $4500 (the price of LispWorks 64-bit Enterprise Edition, which is also a good buy.)

*""Back in the '80s, we showed you how to program WITHOUT ANY BUGS.""*

*""You have been found guilty... Of having side effects!!""*



",1538001754.0
,"As a budding Lisper, Land of Lisp (picked it up in this bundle) has been amazing so far. Worth the purchase.",1537900593.0
tweettranscriberbot,"^The linked tweet was tweeted by [@DealssZone](https://twitter.com/DealssZone) on Sep 25, 2018 10:28:27 UTC (0 Retweets | 0 Favorites)

-------------------------------------------------

The Humble Book Bundle: Learn You Some Code



($463 worth of eBooks for just $15)



Buy Now : [https://www.humblebundle.com/books/learn-you-some-code-books?partner=wildlings](https://www.humblebundle.com/books/learn-you-some-code-books?partner=wildlings)



\#Programming \#Coding \#Java \#Python \#Linux \#Haskell \#Erlang 

[Attached photo](https://pbs.twimg.com/media/Dn7sT30VAAAjt6u.jpg:orig) | [imgur Mirror](https://i.imgur.com/rN9dHft.jpg)

-------------------------------------------------

^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •",1537873332.0
dzecniv,"Thanks for asking ! 

Actually the site was updated 4 months ago… https://gitlab.common-lisp.net/clo/cl-site/ But nobody's even answering to issues (https://gitlab.common-lisp.net/clo/cl-site/issues) or merging easy PRs.

I think this website is doing a huge mis-service to CL.

Anyway, don't miss [lisp-lang.org](http://lisp-lang.org/), libraries on [awesome-cl](https://github.com/CodyReichert/awesome-cl) and [quickdocs](http://quickdocs.org/), and the [CL cookbook :)](https://lispcookbook.github.io/cl-cookbook/) The CL community lives here and in /r/common_lisp.",1537866828.0
flaming_bird,"The CL community lives in `#lisp` on Freenode and the [Lisp Discord server](https://discord.gg/XvVKBwe). CLF has been alive, but mostly inactive as of late.",1537865016.0
dcooper8,"common-lisp.net is overdue for an update, with auto-updating “news” section from social media.  The site volunteers have just been busy/on vacations over the summer. If anyone would like to volunteer to help, please get in touch with me. As was mentioned, gitlab.common-lisp.net is quite active, but that’s not apparent from the front page of common-lisp.net. ",1537881483.0
sammymammy2,The common-lisp.net site also hosts projects so even if the main site looks 'dead' there may be a lot of updates on the projects hosted there.,1537877775.0
kuwze,I really like [this piece of music he made](https://vimeo.com/2579694) with the precursor Impromptu Lisp.,1537739642.0
Nyanraltotlapun,It will be great to see some short summary here.,1537737394.0
emacsomancer,https://en.wikipedia.org/wiki/Extempore_(software) ,1537760704.0
Eigenspace,This challenge seems like one that lisps are particularly  well suited to tackle. I’d love to see what an experienced lisper can cook up. ,1537674520.0
stassats,What's the point?,1537712395.0
kazkylheku,"The basic idea here seems to be to make a macro which takes a nested expression, and then walks so that all of its functions are not directly applied to their arguments, but applied through a `mapcar`-like operation called broadcast. Then there are some optimization tasks around this.

We normally wouldn't do this, because `mapcar` is a linear operator. So that is to say `(mapcar f (mapcar g args))` is equivalent to `(mapcar (compose g f) args)`. Instead of chaining the projection of data through separate different functions, we can chain the functions themselves and do one projection; then we eliminate all the intermediate lists being consed up, not to mention a bunch of function calls.

The main motivation here seems to be that `(mapcar (compose g f))` will not optimize things; `g` and `f` are encapsulated in a function which is just called element-wise. So then what if we instead just leave the composition syntax as `(f (g args))` and wrap it with a macro `(mapcar-insert (f (g args))` which will then produce the `(mapcar g (mapcar g args))` behavior, but with the possibility of open-coding it. 

My question is how that `@broadcast` thing in Julia that is shown handles all possible special forms cleanly. In `Meta.isexpr(x, :call)` in `br_construct`, how can that work if `x` isn't already macro-expanded? But then if `x` comes into a macro already macro-expanded, how can a macro take arbitrary syntax as an argument; we don't want the contents of a macro call to be expanded: the macro must have the ""first dibs"" at the untouched syntax.  The recursion in `br_construct` appears to be blind also; it just maps itself over the args of the expression. What if the expression is such that some of the args look like function calls but aren't?",1537815662.0
nikofeyn,"julia is a mess, and i am tired of hearing about it.",1537721843.0
CelloAxeMurder,Been messing with this with CCL on Windows. Seems pretty stable so far. Kudos to the author.,1537323661.0
defunkydrummer,"Nice! I like the fact that there is a lot of examples included. 

These days i'm experimenting creating UIs using Java Swing under ABCL and have created some functions to help do this; but I need to write more sample code to make sure my mini-library is good enough. 

This project (FTW) does have many sample files and this is reassuring -- means that the API was comfortable enough for the creator.

The only small annoyance I see, and gives me nostalgic memories of 1999-2000 when I was a student at the university, was that one still has to define your own event loop and dispatch the received messages, just as one would do on C or C++:

For example here (taken from [the dialog example](https://github.com/fjames86/ftw/blob/master/examples/dialogs/dialogs.lisp). )

    (defwndproc find-dialog-dlgproc (hwnd msg wparam lparam)
      (declare (ignore lparam))
      (switch msg
        ((const +wm-initdialog+)
         1)
        ((const +wm-command+)
         (switch (loword wparam)
           (1 ;; text box
            nil)
           (2 ;; ok
            (setf *show-find-dialog-text* (get-window-text (get-dialog-item hwnd 1)))
            (end-dialog hwnd))
           (3 ;; cancel
            (setf *show-find-dialog-text* nil)
            (end-dialog hwnd)))
         1)
        (t 
         0)))

I would guess some extra functions or macros laid on top of FTW would help making this dispatch easy, otherwise i would guess it gets a bit cumbersome. 

Swing, fortunately, doesn't require this (just glue the event handling function to the appropiate control). On the other hand, it's java under ABCL, and i'm getting a major headache: java exceptions somehow ""break"" the swing facilities and I need to restart ABCL again...

I'm glad that there's another GUI option available, moreover one that will work with almost all implementations. Thanks /u/fjames86 . 
",1537368360.0
tsuru,Layman question: could this be used similar to how the tagged architecture in Symbolics machines worked?,1537404918.0
flaming_bird,"Make sure that your library has a defined ASDF test-op. This way, Quicklisp will be able to test your system during each monthly build.

https://github.com/edicl/flexi-streams/blob/master/flexi-streams.asd#L76",1537294856.0
bemrys,"On documentation, I look for the following:

* What is the library about? (If you are porting something from another language, don't assume I know that other library)
* Why use this library instead of existing ones? Please tell me that this adds a missing X. Don't tell me it should be faster or safer but you didn't actually check.
* Usage examples

On testing I look for:

* Does it even have tests?
* Can I look at the tests as an example of how to use it?
* Are there tests that signal errors - showing the author thought about it instead of assuming perfection?
",1537297052.0
mikelevins,"I'm interested in these posts each time you post them, but I don't apply, because there are a couple of dealbreakers in the job descriptions.

I have plenty of practical Lisp experience--more than you're looking for, in all sorts of domains from application programming to systems and embedded programming. I have substantial practical experience in GOFAI (specifically, several years of working on frame languages and knowledge-based systems at Apple).

But the job descriptions present these dealbreakers:

1. ""Work remotely but willing to travel to Seoul every two months for two weeks, or perhaps more often/a bit longer""

Can't do it, sorry. Prevented by chronic health issues.

2. ""Will relocate to Seoul before the end of 2018 (we will sponsor the working visa)""

Can't do it, sorry. Prevented by health and family-related issues.

I'm genuinely sorry I can't meet these requirements, because the job sounds very interesting, but them's the breaks.

I wish you the best of luck.



",1537281566.0
SlightlyCyborg,"Stop filtering by college degree. I have experience developing  [NLP](https://github.com/SlightlyCyborg/sentence-similarity) based on research literature & [a symbolic personal assistant](https://github.com/SlightlyCyborg/daemon) in a Lisp. I also have lived in East Asia in the past so I am comfortable with the culture and would be willing to relocate for a long period of time (as long as NK/SK relations don't ""go south"" literally and figuratively). Look into my resume and my projects (PM me for my real name). I am young (26) and highly motivated. I can/have pass(ed) a google phone screen. I am experienced with startup culture and I can get behind and strengthen the vision for a product.",1537361846.0
svetlyak40wt,@crowfeather are you working at Mind.ai?,1537251344.0
KDallas_Multipass,Saved for the future!,1537476233.0
try_another_fuck,Did you mean commonlisp experience or any other lisp could be count as lisp experience ?,1537868915.0
nils-m-holm,"Note:

     (beta-reduce '(lambda (x) (lambda (x) x)) 123)  ==>  (lambda (123) 123)

There's more to lambda calculus than straight-forward substitution. Reading about free and bound variables would be a good starting point.

Shameless plug: http://t3x.org/clc/index.html

The free chapters should be sufficient to implement the basics.",1537191675.0
flaming_bird,This thing is significant because it actually comes from a lawyer. We're (sadly) in a world where this fact is important.,1537196276.0
bjoli,"I have gone with the MPLv2 for lisp projects where I would have used LGPL for other languages. It is not really the same, but it provides an even ""lesser"" copyleft that works with the lisp model. Modifications should be licensed under the MPLv2, but it only takes files into account, not any linking terminology. 

You may link or include MPL-licensed files in any way you want as long as you give proper attribution, but when you make a modification to the file you have to reciprocate.",1537203322.0
kazkylheku,"The LGPL works fine for Lisp; it doesn't need fixing.

The situation where .fasl images are loaded to produce a running image (which is then possibly dumped) is the same like your C linker (`ld` or whatever) loading `.o` files to make a program image, which is then written out.

The LGPL allows this; it is not tied to dynamic linking. A LGPL-ed library can be redistributed as a `.a` archive containing `.o` files, which are linked by the user with the proprietary `.o` files to produce the proprietary application. The user can modify the free parts and rebuild, so they have their GPL-granted rights.

As for how you handle macros; C does actually have them, contrary to what this paper says. A C macro will expand to C code. That code then depends on the library. The sane thing is to allow the output of the macro not to inherit the copyright of the macro itself; just like the output of GCC isn't GPL-ed.  I think that needs to be spelled out in the license though.

However, there is an issue in that the code generated by the macro depends on the LGPL-ed library, and that code is incorporated into the proprietary application that the user cannot rebuild. This is fine, unless the macro is badly versioned. Badly versioned means that the generated code depends on the specific library version, and no longer works if the library is upgraded.   However, this could be an issue with the library API itself, and so code written by hand by the proprietary application developer could run into this. Macros only make things worse because they potentially rely on some internal API, which can have versioning issues even when the public API is squeaky clean.

From the licensing regard, Lisp macros differ from the C ones in that they don't survive into the running program image. That isn't any sort of problem. If a bunch of Lisp fasl's are under the LGPL, and contain macros, those macros are just sitting there under the LGPL, like all other functions. The proprietary program can call them (e.g. during dynamic compilation) like any other functions.

The LGPL says only this about macros:

*When a ""work that uses the Library"" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law.

If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)*

I.e. if you just use trivial compile-time material from a library, then you're not subject to the license: like `#define` constants, type definitions and ""small"" macros.  Oops, what is small? Lisp macros can be very big. Big Lisp macros can have small output, and vice versa. If I had to fix the LGPL for Lisp use, this is probably what I'd clarify. 

I'd clarify it by making an exception; so that is to say, I'd use the LGPL as is, but provide an exception to it which spells out that output of macros is fair game.

This has precedent. For instance, the GNU Bison parser generator comes with a ""parser skeleton"" code template, which is emitted into the generated parser. While that code template is copyrighted and GPL-ed, GNU Bison's license makes an exception for it, allowing GNU Bison to generate proprietary parsers.  They didn't have to make a BGPL (Bison GPL) for this.
",1537215345.0
svetlyak40wt,"By the way, guys, did you seen a new print-licenses library which is in quicklisp now?

Here how it works:

    CL-USER> (ql:quickload :print-licenses)
    To load ""print-licenses"":
      Load 1 ASDF system:
        print-licenses
    ; Loading ""print-licenses""
    
    (:PRINT-LICENSES)
    CL-USER> (print-licenses:print-licenses :weblocks)
    alexandria                | Public Domain / 0-clause MIT                           
    anaphora                  | Public Domain                                          
    asdf-system-connections   | MIT Style License                                      
    babel                     | MIT                                                    
    bordeaux-threads          | MIT                                                    
    cffi                      | MIT                                                    
    cffi-grovel               | MIT                                                    
    cffi-toolchain            | MIT                                                    
    chipz                     | BSD style                                              
    chunga                    | Unspecified                                            
    circular-streams          | LLGPL                                                  
    cl+ssl                    | MIT                                                    
    cl-annot                  | LLGPL                                                  
    cl-base64                 | BSD-style                                              
    cl-containers             | MIT Style License                                      
    cl-cookie                 | BSD 2-Clause                                           
    cl-fad                    | BSD-2-Clause                                           
    cl-ppcre                  | BSD                                                    
    cl-reexport               | LLGPL                                                  
    cl-strings                | MIT                                                    
    cl-syntax                 | LLGPL                                                  
    cl-syntax-annot           | LLGPL                                                  
    cl-utilities              | Unspecified                                            
    clack                     | LLGPL                                                  
    closer-mop                | MIT-style license                                      
    dexador                   | MIT                                                    
    f-underscore              | Unspecified                                            
    fare-quasiquote           | MIT                                                    
    fare-quasiquote-extras    | MIT                                                    
    fare-quasiquote-optima    | MIT                                                    
    fare-quasiquote-readtable | MIT                                                    
    fare-utils                | MIT                                                    
    fast-http                 | MIT                                                    
    fast-io                   | NewBSD                                                 
    flexi-streams             | BSD-2-Clause                                           
    global-vars               | MIT                                                    
    http-body                 | BSD 2-Clause                                           
    introspect-environment    | WTFPL                                                  
    ironclad                  | BSD 3-Clause                                           
    iterate                   | MIT                                                    
    jonathan                  | MIT                                                    
    lack                      | LLGPL                                                  
    lack-component            | LLGPL                                                  
    lack-middleware-backtrace | LLGPL                                                  
    lack-request              | LLGPL                                                  
    lack-util                 | LLGPL                                                  
    lisp-namespace            | LLGPL                                                  
    local-time                | BSD                                                    
    log4cl                    | Unspecified                                            
    metabang-bind             | MIT License                                            
    metacopy                  | MIT Style License                                      
    metatilities              | MIT Style license                                      
    metatilities-base         | MIT Style license                                      
    moptilities               | MIT Style license                                      
    named-readtables          | BSD, see LICENSE                                       
    nibbles                   | BSD-style (http://opensource.org/licenses/BSD-3-Clause)
    optima                    | LLGPL                                                  
    parenscript               | BSD                                                    
    parse-declarations-1.0    | MIT                                                    
    parse-number              | BSD 3-Clause                                           
    proc-parse                | BSD 2-Clause                                           
    puri                      | GNU Lesser General Public License                      
    quri                      | BSD 3-Clause                                           
    routes                    | Unspecified                                            
    salza2                    | BSD                                                    
    serapeum                  | MIT                                                    
    smart-buffer              | BSD 3-Clause                                           
    spinneret                 | MIT                                                    
    split-sequence            | public domain                                          
    static-vectors            | MIT                                                    
    string-case               | 3-clause BSD                                           
    trivia                    | LLGPL                                                  
    trivia.level0             | LLGPL                                                  
    trivia.level1             | LLGPL                                                  
    trivia.level2             | LLGPL                                                  
    trivia.quasiquote         | LLGPL                                                  
    trivial-backtrace         | MIT Style license                                      
    trivial-features          | MIT                                                    
    trivial-file-size         | MIT                                                    
    trivial-garbage           | Public Domain                                          
    trivial-gray-streams      | MIT                                                    
    trivial-macroexpand-all   | Unlicense                                              
    trivial-mimes             | Artistic                                               
    trivial-timeout           | MIT Style License                                      
    trivial-types             | LLGPL                                                  
    uiop                      | Unspecified                                            
    usocket                   | MIT                                                    
    weblocks                  | LLGPL                                                  
    xsubseq                   | BSD 2-Clause                                           
    ; No values
    CL-USER> ",1537251185.0
svetlyak40wt,Are there any cases when somebody was convicted of a violation of the LLGPL?,1537251045.0
kazkylheku,"This simply relies on the compiler recognizing *car*. It's meant to be processed by that compiler only.

But, so, if your compiler recognizes *car*, why would you need this definition? So that there **is** a function definition, like there is supposed to be; `(symbol-function 'car)` returns a function as required and so on. ",1537143426.0
gsg_,"Implementation tricks like this are common for languages which expose primitives as first-class functions.

It's likely that some stage of the compiler will transform any call of a primitive that matches the arity of that primitive into a built-in operation, and any other mention will be left as a reference to the `defun` of the same name. The point of doing it that way is that most calls to primitives get turned directly into efficient code (without the need for inlining), while still behaving exactly as a normal CL function with argument list checking, etc.

In particular, note that the call to `car` within the `defun` will become a primitive operation, so the `defun` is not actually recursive if compiled in this way.

A fun exercise would be to replace the definition with `(defun car (x) (funcall #'car x))` or similar and see whether CCL breaks (although it might recognise `funcall` specially as well...).",1537175209.0
lispm,"Another way to think about it is that one has a definition already and it is declared to inline the code:

    CL-USER 14 > (declaim (inline baz))
    NIL

    CL-USER 15 > (defun baz (a) (+ a 42))
    BAZ

    CL-USER 16 > (compile 'baz)
    BAZ
    NIL
    NIL

    CL-USER 17 > (baz 0)
    42


Now we use the function COMPILE with a name BAZ. It stores the function under the name BAZ. As you can see it just calls BAZ - which is the prior version being inlined.

    CL-USER 18 > (compile 'baz (lambda (a) (baz a)))
    BAZ
    NIL
    NIL

    CL-USER 19 > (baz 42)
    84

The real definition is somewhere else, for example the inline function provided earlier.",1537170155.0
flyin1501,"It depends on an existing version of itself (or another CL implementation), because it's self-hosting. That doesn't really become a circular dependency since you'd otherwise need to depend on another existing compiler anyways. It's not more circular than depending on another language.",1537158919.0
whism,"When I `M-.` on `car`, I get two available xrefs: one is the one you mention, the other takes me further into the compiler internals. :) Fun stuff",1537183255.0
MrPineappleHat,"This seems like such a neat way of achieving react-style components in a way that scales well.

Question: Are you generating content client side using clojurescript or generating static content server side? (Is there a detail I missed??) I think both approaches would work although one is arguably more static.",1537098162.0
wishhhhzzzzzzz,r/hearing,1537055675.0
nikofeyn,does anyone know of a survey of available lisps (or even ml dialects) made for running embedded systems? i am talking about something one could imagine running on the arm side of a xilinx zynq chip. i am not overly concerned with garbage collection being present or not.,1537153366.0
svetlyak40wt,"It is not ""actively updated."" I just looked at other forks and merged useful changes into the mine.

The situation with common lisp libraries to work with IMAP is very sad.

For example, the main use case for mel-base is to move all emails from one server or folder to another. Search my criterion does not work. Working with multipart emails is absent (i found an addon, but it should required some fixes and is far from being user-friendly).

There is a [postmaster](https://github.com/eudoxia0/postmaster) library by Fernando Borretti. It is built on top of mel-base, but is unfinished and unusable.

Another library which is on quicklisp – [postoffice](http://quickdocs.org/postoffice/) is 10 years old Franz's cl-imap library which doesn't work with SSL/TLS servers.

There is a fork of postoffice, which has SSL support – http://github.com/orivej/post-office/ but doesn't worked for me because it uses portableaserve's internals to establish ssl connection, but these internals are not available anymore. So, I've created my own fork and fixed this and some other problems. Here is the WIP branch: https://github.com/40ants/post-office/tree/ssl-and-other-fixes

Don't know if Orivej Desh is still interested in maintaining this CL library. This activity on Github is in Python and Go projects since 2016. But I've made a pull-request: https://github.com/orivej/post-office/pull/1

Probably I'll create a wrapper around this fixed post-office library to simplify some tasks when working with IMAP folders.",1537030530.0
stassats,"The general mistake would be developing lisp programs by running them from the command line, instead of using an advanced  environment with a REPL, like Slime. ",1537008508.0
kazkylheku,"Python conflates variable definition with assignment.

    x = 0

    function(z):
      x = 1
      x = 2

This doesn't do what you think; the syntax`x = 1` is actually a `let` that makes a local variable; it's not assigning to the global. The syntax `x = 2` is an assignment. The two look the same but do something contextually different. (Have fun writing a code walker for that ...).

There is a `global` thing to declare that `x` is the global one. In Python 3 they added a `nonlocal` because, oops, they realized that `global` accesses the global scope specifically; what if an inner function wants to assign a variable in a surrounding function?

",1537023089.0
theangeryemacsshibe,"Python and many other languages are imperative and aren't as freeform as Lisp, so you may not need intermediate variables. You'll probably end up using assignments like SETF not very frequently, since temporary values with LET and WITH-* are much easier to understand.",1537012174.0
Grue,"There are way too many differences to list.

1. Comparisons. Python has *==* and *is*, Lisp has =, eq, eql, equal, equalp, char=, string= and so on.
2. Unlike Python, strings and characters are different types of objects. A string of one character is not equal to a character.
3. The only false value is NIL which is the same object as the empty list. Unlike Python, empty string, empty array, empty hash table and even 0 (zero) are not false.
4. If you have a variable *var* that contains a function, you can call it with `var()` in Python, but you can't call it like `(var)` in Common Lisp (you might be able to in other lisps, like Scheme).
5. CLOS classes are similar to classes in Python (including stuff like metaclasses, multiple inheritance and super/call-next-method), but defining *methods* on these classes is a very different paradigm.
6. The biggest pitfall: lists in Lisp and lists in Python have similar API, but completely different performance characteristics. Lisp uses linked lists. Random access is O(n). If you need O(1) random access use arrays. Every Lisp newbie writes very inefficient programs in Lisp because they don't realize that taking nth element of a list is a slow operation.",1537019704.0
dzecniv,"When I started with CL, after a few years of Python&JS, or even before I dared start writing Lisp, I was concerned about having more operators, different ones for different data types. It is actually not a problem in practice, even more AFAIU it is one of the things that makes CL faster and SBCL to catch more type-related errors. 

Also don't be skeptical when some concepts are not here. For example, there are not really generators, we use another construct: https://stackoverflow.com/questions/32956033/is-there-a-straightforward-lisp-equivalent-of-pythons-generators

Happy to speak more about Python vs Lisp if you wish.

ps: I hope you didn't miss the Cookbook (https://lispcookbook.github.io/cl-cookbook/) and https://github.com/CodyReichert/awesome-cl :]",1537017953.0
defunkydrummer,"I got into Common Lisp immediately after two years of using Python professionally(for the banking industry); i didn't think I had any bad habits from Python, maybe because I forced myself to learn the lispy way of doing stuff. I already knew about 10 programming languages by that time, but no lispy ones.

It will be a steep learning curve because they are really different - no matter all the ""Python is an acceptable Lisp"" claims. Lisp is much more strongly-typed, in Lisp everything is an expression, macros are a big game changer, there are more low-level features, and the OOP system is world class.",1537021840.0
agumonkey,"happy lisping, I hope you enjoy it as much as I/we do, it's a gigantic park with enough places to have fun for a lifetime",1537020789.0
guicho271828,"I am spending most of the time now in python (quite unfortunately) (don't worry I always use CL for plotting) and read many shit code, mostly machine learning code, written by the others. the biggest no-no is to put everything in the `__main__` and pretend that there is no problem. Don't do that. Even if you wrote a one-time script it never is a one-time script, you or someone in the world will eventually reuse them.",1537029413.0
bjoli,"Which Lisp? If you are going to scheme you will probably end up writing non-idiomatic things using lots of set!. 

In CL that's not a very big deal, but in scheme compilers are generally better at reasoning about pure code so pure code often produces faster results. Scheme also has first class continuations, and using set! often leads to code not being multi-shot continuation safe (which is a rare problem).",1537027997.0
ProfessorSexyTime,"If you're interested, you could checkout [Hy](http://docs.hylang.org/en/stable/). Granted it's not like Common Lisp, but you might find it interesting.",1537046183.0
Grue,"Jsown also parses JSON objects into alists so your method is exactly the same. No, there's no faster way to look up something in a linked list. And if your JSON objects are small, it shouldn't matter much. However if you have an object with lots of keys, it could be more efficient to parse it into a hash table, which has O(1) lookup time regardless of the number of keys.

EDIT: actually since you're doing string comparison test, it might be possible to speed it up by interning keys into symbols, and using :test 'eql for comparison. But it will make no speed-up for hash table implementation, only for alist or plist. Also this method is bad if you're receiving arbitrary JSON or looking up arbitrary strings, because you'll just have tons of symbols filling up your memory at the end of the day.",1536996687.0
demosthenex,"I'm using cl-json and all the keys returned in an alist by the json decoder are all interned (ie: :key not ""key""). That's faster than string= for later assoc calls.",1537010125.0
bjoli,"alists will probably be the fastest for small alists, but if you are dealing with things with more than 20 keys you are better off using a hash table.

Using string= for keys is also potentially slow. Comparing strings is slower than comparing symbols.",1537005801.0
dzecniv,"A nice one, complete enough for my taste :)",1536791672.0
defunkydrummer,"Excellent article!!

>DSLs become so easy to implement, it feels like cheating.

Can be a new Lisp slogan as well...
",1536783173.0
CelloAxeMurder,It was a problem like this one that lead me to discover Common Lisp.,1536757544.0
m00natic,Hopefully r/lisp wouldn't mind some propaganda ¯\\\_(ツ)\_/¯,1536748632.0
Lisp-S-R-C-L-D,"I love the look of phases.png before paragraph 5.3 ... how did you generate it ? (please) ... I need some time for the rest to read :-)
Thank you ",1536757120.0
pinkyabuse,Looks interesting but completely unreadable on mobile. ,1536975030.0
nitasGhost,"This is the most up to date and pretty exhaustive set of instructions to get started in 2018

&#x200B;

* [http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/](http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/) \- August 2018
* [http://notes.eatonphil.com/starting-a-minimal-common-lisp-project.html](http://notes.eatonphil.com/starting-a-minimal-common-lisp-project.html) \- March 2018",1536619029.0
CallMeMalice,"PCL is a cool beast.

This said, you're in for a lot of unfamiliar territory.

I only know Common Lisp, but I guess that the workflow is quite similar, and it means major differences from the way you'd write code in C++:

(1) We sit in REPL a lot. You use REPL to write code, to test the code incrementally, to play out with its output, to inspect the data. You basically have a frozen halfway-done program that you can interact with. If you want to add a new function you don't recompile everything, you just type that in REPL(or use SLIME for excellent Emacs-REPL connection*).

(2) is also made much better with the use of restarts. Basically exceptions that you can react to without unwinding the stack, unless you decide to do so. Makes working in REPL much better, because your error is not a stack trace and halted execution now - you can inspect the data at hand or modify it (e.g. recompile a function, substitute a variable) to make program continue.

(3) You don't need to do all of it in REPL. I actually type out my code in the editor and use SLIME to send it to the repl itself. This way you write down the code as you'd normally do, but get results immediately, and you can test what you just wrote. Long C++ compilation times make me don't want to recompile it as often, which leads to more bugs that are related to me forgetting something. This doesn't happen that often in CL because I see those bugs immediately.

I will cut down my advertising now, but the picture should be clear - don't try to treat Lisp as you'd C++ - Lisp is not a good C++. It is a good Lisp.

I'd recommend Common Lisp. You can try setting up Emacs, SLIME and SBCL. I recommend Linux. If you don't want to bother, try [Portacle](https://portacle.github.io/), which is the combo above, but portable(and available for many platforms). You can also go with Vim/SLIMV, but I'm not a vim user so can't help you with that.

As for the beginner's materials, [PCL](http://www.gigamonkeys.com/book/) is a great book if you have some programming experience. It shows CL's basics and more advanced features, focusing on the practical matters.

Hungry for the metaprogramming stuff? Try [On Lisp](http://www.paulgraham.com/onlisp.html) which is a nice book about CL's macros. It is not a CL learning material. It requires you to know CL, and teaches you how to deal with macros. There are many great examples though, and the book can be quite overwhelming at times. I believe it is worth reading.

If you want to see metaprogramming from the different, non-macro perspective, try the [AMOP](https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol) (The book is not available for free though; you'd need to get your hands on it somehow. I bought a copy and it's a great book). The book tells a story about implementing Common Lisp's OOP system using CL and the OOP system itself in the way that would allow for it to be extendable.

The AMOP assumes some CLOS(Common Lisp Object System) knowledge. If you don't know CLOS, either google around to learn how it works (I believe PCL also shows some of the features), mess around with CL in REPL or try [Keene's book](https://www.pearson.com/us/higher-education/program/Keene-Object-Oriented-Programming-in-Common-Lisp-A-Programmer-s-Guide-to-CLOS/PGM262224.html). Again, that's a rare find (price to pay when you deal with Lisp, I guess) and was written before the standard came out so it can be a bit different, but I read it and I can tell you that it's the best introduction to CLOS that I've seen. Might be that I haven't seen many of those.

Either way, congratulations on your choice. Language is great. Different, a bit odd, but I love it for that and I believe learning it made me a better programmer. Simply because it opened my eyes on what language can be.",1536621251.0
defmacro-jam,Try either SBCL or Racket.,1536615594.0
jmercouris,"I would suggest Common Lisp. Most implementations are just fine, I recommend either CCL or SBCL.

Common Lisp is a multi-paradigm language, has many libraries, and an unchanging standard. Lots of useful Common Lisp code exists on the web, and it is very well documented.",1536618555.0
flaming_bird,"If you want to go the Common Lisp way, try Practical Common Lisp + Portacle.

The latter gives you SBCL + Emacs + Slime + Git + Quicklisp in a preconfigured package.

If you need any support, ask `#lisp` on Freenode or on the Lisp Discord server.",1536644609.0
death,"Common Lisp, and check [SBCL: The Ultimate Assembly Code Breadboard](https://www.pvk.ca/Blog/2014/03/15/sbcl-the-ultimate-assembly-code-breadboard/) for a teaser.",1536664489.0
mbrezu,"Your background in assembly might be tickled by the lambda papers (https://en.wikisource.org/wiki/Lambda_Papers) and Guy Steele's master thesis, which describes his Scheme compiler. Probably best to first get a little familiar with either SBCL or Racket, though.

As others have mentioned, `disassemble` in SBCL is pretty cool.

You might also want to give ""Let over Lambda"" (https://letoverlambda.com/) a try, it has some pretty cool low level-ish sections on a Forth implemented in Lisp and sorting networks, besides a general focus on Lisp macros which are, in a way, full featured compiler plugins.

EDIT: of course, ""SICP"" (https://mitpress.mit.edu/sites/default/files/sicp/index.html, there are other copies online with nicer formatting, try a few github searches for ""sicp"") is worth mentioning, as they also show how to build a virtual machine and compiler for it, all in a very Lispy world.",1536654919.0
mrnate91,"If you decide to go with Common Lisp (which I did), you'll see people telling you to read Practical Common Lisp. I found that book pretty tough to get through, and recommend starting out with [Common Lisp: A Gentle Introduction](http://www-cgi.cs.cmu.edu/afs/cs.cmu.edu/user/dst/www/LispBook/book.pdf).   
 Much more accessible; it was written in the 80's and doesn't even assume that you're familiar with *computers*. It's able to give you a really good idea of what's going on *inside* Lisp because of that. I personally thought it was a great introduction and could understand PCL way better afterwards.",1536696790.0
emacsomancer,"Somewhat tangential (perhaps) to what you're asking, but this might interest you: [A Lisp interpreter for Raspberry Pi implemented in a single ARM assembly file](https://github.com/marcpaq/arpilisp).",1536710064.0
Heinemenusch,http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/,1536648584.0
Nalmyth,"Lisp is my favourite language of all time. However these days it has culled out a lot of growth and cultured a  [not invented here](https://en.wikipedia.org/wiki/Not_invented_here) mentality.

I'd suggest starting with something simple, and using as many well built libraries as you can. If you don't find what you're looking for, build it from someone else's library and publish openly. The ecosystem needs more interest and you'll get constructive (if not rather strong) feedback.",1536616671.0
defunkydrummer,">I personally code in C, C++ and Rust, and I have a lot of background in assembly and reverse engineering, so I was thinking that a dialect supported by an AOT compiler would fit me best (Even if I don't know if it can exist due to the language design), but I wouldn't prioritize it if the other choices would be much better documented or featureful.

>What do you think would fit me best?

If you want to generate very small/brief machine language code (like, for example, for embedded development), Scheme can be the best choice since there are many implementation suited to those purposes.

If you intend to do big, complex, fast production-quality systems, to be executed on desktop/laptop/server hardware, I think the best choice would be Common Lisp. 


",1536691268.0
NeoMarxismIsEvil,"If you're not going for maximum performance, I'd pick Racket. There's a book here https://htdp.org/2018-01-06/Book/ I guess it's sort of like the Haskell of LISP.

If you need performance I think your only free choices are chez scheme or (for CL) SBCL.",1536633688.0
Bourgond_Aries,"The decision is yours: do you want a Lisp-1 or a Lisp-2?

A lisp-1 has functions and variables in the same namespace, whereas lisp-2 does not.

Secondly, do you want hygienic macros or not?

&#x200B;

I'd suggest in decreasing order: Racket, Scheme, Clojure, CL (SBCL)

Racket currently compiles to its own native (\`%#app\` ... and so on) form but I think it's being ported to Chez scheme, if that interests you. Regardless, Racket is the pinnacle of AOT compilation with its \`#lang\` directive and macros that you yourself can create and work with.

Scheme (off which Racket is based) is great, and has hygienic macros as well. However, it's less ""batteries included"" compared to Racket and lacks \`#lang\` languages.

Clojure is quite modern and has interesting functional data structures, compiles to JVM bytecode.

CL is old, and imho quite ""archaic"" if you could call it that. But it works, and SBCL is incredibly fast. It's absolutely mind blowing how fast SBCL is.",1536621514.0
tankfeeder,PicoLisp only.,1536667351.0
tarballs_are_good,How does this make Maxima “useless”?,1536561049.0
maufdez,"I just wanted to rescue the original question, disregarding the comment about Maxima, the question asked is not being answered, I do not know the answer, but some of you may know.

The original question was according to me:

***Are there any lisp-based computer algebra systems with lexical scoping, which can be used as Maxima alternatives?***",1536714391.0
read_harder,Install sbcl then add a library that adds lexical scoping.,1536579032.0
flaming_bird,"`alexandria:assoc-value` from the Alexandria library does exactly what you want.

`(alexandria:assoc-value '((a . 1) (b . 2) (c . 3)) 'b)` ;=> `b`, `(b . 2)`",1536558413.0
PuercoPop,"I like ASSOCDR  


`(cdr (assoc <item> <alist>) => (assocdr <item> <alist>`

&#x200B;

[https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#assocdr-item-alist-rest-args-key-allow-other-keys](https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#assocdr-item-alist-rest-args-key-allow-other-keys)",1536674962.0
dzecniv,"I hope this doc is clear: https://lispcookbook.github.io/cl-cookbook/data-structures.html

Also the [access](https://lisp-journey.gitlab.io/blog/generice-consistent-access-of-data-structures-dotted-path/) might be helpful. ",1536615037.0
mnp,"Try `assq`

    (assq :FIRST--NAME '((:ID . 4) (:FIRST--NAME . ""Eve"") (:LAST--NAME . ""Holt"") (:AVATAR . ""https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg"")))
    (:FIRST--NAME . ""Eve"")
",1536523429.0
heisig,"It could have been ""Lisp in Small Pieces"" (https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces).  I strongly recommend this book anyway if you intend to write a Lisp interpreter or compiler.",1536438394.0
ronaldlens,I think you mean Lisp in small pieces https://en.m.wikipedia.org/wiki/Lisp_in_Small_Pieces. It uses scheme but explains very well how lisp interpreteren compilers work. ,1536438564.0
drjeats,"For something lighter than SICP or Lisp in Small Pieces, try Make-A-Lisp:

https://github.com/kanaka/mal",1536464375.0
nils-m-holm,"15 years ago? Might have been Hakmatpour's ""LISP - A Portable Implementation"" (1989), which implements LISP in C.

Other classics would include Allen's ""Anatomy of LISP"" (1978) or Queinnec's ""LISP in Small Pieces"" (1994), which use
LISP (Allen) and Scheme (Queinnec) as their implementation language. However, they both take a rather abstract route and do not tell you much about low-level details, like garbage collection.

If you don't mind a shameless plug, there's ""Scheme 9 from Empty Space"", which contains the well-documented source code to a complete Scheme interpreter: http://t3x.org/s9fes
",1536438814.0
hubbabubbathrowaway,"Structure and Interpretation of Computer Programs (SICP) contains a few interpreter techniques (e.g. a metacircular evaluator written in Scheme), but IIRC Garbage Collection wasn't touched...",1536438351.0
defunkydrummer,"I think [this](https://github.com/3b/cl-opengl) is what you are looking for, which allows you to call the GLUT and do all sorts of stuff with OpenGL.

There are also some game-devel libs for Common Lisp, and /u/Shinmera is just working on a new one lately: 

https://github.com/Shirakumo/trial

It uses cl-opengl as well.",1536335536.0
CelloAxeMurder,"You could call libFB via CFFI, or use your Lisp's POSIX functions to interact with the device directly. e.g. (sb-posix:read/write/open/close/ioctl).",1536335695.0
KDallas_Multipass,Wait so you can write to /dev/fb0 and subsequently onto the screen?,1536345507.0
flaming_bird,"You could use CFFI to hook Lisp to an implementation in C. The API mentioned on https://github.com/centaurean/spookyhash seems trivial to use - it's literally a single function call, `spookyhash_128(data, data_length, &seed1, &seed2);`.",1536223659.0
tankfeeder,"CityHash on PicoLisp:
https://bitbucket.org/mihailp/tankfeeder/src/default/hash/

BTW, my favorite xxhash also implemented.",1536237599.0
kazkylheku,"You cannot do `(expr-evaluating-to-function arg)` in Common Lisp. The leftmost position of a compound expression must be the name of  function or else a lambda expression.

You don't have a `(lambda  ...)` expression; what you have is a `((lambda ...) arg)` expression that you're expecting to be evaluated to produce a functional value.

This is because Common Lisp is a ""Lisp-2"". This will work in a ""Lisp-1"".

There exists a wacky dialect of Lisp called TXR Lisp which is a Lisp-2 that supports Lisp-1-style evaluation.

Square brackets request Lisp-1 style; regular parentheses are the underlying Lisp-2. Thus, this works:

    1> [((lambda (f) (lambda (x) (list f x))) 'g) 'y]
    (g y)

and this gives us errors, consistent with my above explanation:

    2> (((lambda (f) (lambda (x) (list f x))) 'g) 'y)
    ** warning: (expr-2:1) ((lambda (f) (lambda (x) (list f x))) 'g) appears in operator position
    ** (expr-2:1) ((lambda (f) (lambda (x) (list f x))) 'g) does not name a function or operator

In Common Lisp, we can get it to work by using `funcall`. We just need one. This is CLISP:

    [5]> (funcall ((lambda (f) (lambda (x) (list f x))) 'g) 'y)
    (G Y)

`funcall` is just a function. All of its arguments are evaluated the same way, so Common Lisp's `(funcall x y z)` is like `(x y z)` in a Lisp-1 dialect like Scheme. Both mean: ""evaluate x, y and z, and then treat the value of x as a function which takes the values of y and z"".

(Side note: except in ANSI CL, the evaluation order of x, y and z is strict left to right, whereas in Scheme it is unspecified. That is a separate issue, not true of Lisp-1's in general.)




",1536196965.0
Goheeca,"You have to use `funcall` or similar:

     (funcall (funcall (lambda (f) (lambda (x) (list f x))) 'g) 'y)

This also works:

    (funcall ((lambda (f) (lambda (x) (list f x))) 'g) 'y)

, `(lambda ...)` as a first element is treated specially while the resulting closure object isn't hence the necessary `funcall`.",1536197836.0
thephoton,"Can you share your error message? Even if you can't comprehend it, it's likely there's somebody here who can.",1536196742.0
jaoswald,"What do you think `(list f x)` is doing in your code?

The source code of Common Lisp is read as objects like you construct with `list`, but if you want to actually make a function call, you don't just construct that list.

Furthermore, Mathematica is probably not a good model for your semantics. It has all sorts of behavior that works somewhat well for interactive manipulation of math expressions, including symbolic ones, with a highly developed set of ad hoc rules, but the semantics are only vaguely specified and often depart from Lisp practice while keeping the same names. You get a lot of false cousins in translating between them. Treating Mathematica as a reference Lisp implementation is not going to be a good approach.",1536197494.0
agumonkey,"> (funcall ((lambda (f) (lambda (x) (list f x))) 'g) 'y)

I have no clear explanation about why this works. Also, try to avoid replicating codes between languages, you will often run into corners like this. Every one of them will have slight semantic differences
",1536196942.0
adam_kruszewski,"No worries :) Take your time, we'll wait patiently :)",1536137588.0
piotr404,"Hope you are well, mate !
See you next time, when you decide, you are the boss :)",1536170342.0
flaming_bird,"Which OPTIMIZE controls are you using? STEP on SBCL works only if you have DEBUG set to a high enough value.

Add this to .sbclrc, restart SBCL and recompile your code:

    (sb-ext:restrict-compiler-policy 'debug 3 3)",1536036864.0
Shinmera,Forms that only contain constant expressions are constant-folded at compile-time. When you evaluate `(step (+ 2 (+ 3 4)))` you're really evaluating `(step 9)` because the arithmetic was performed at compile-time.,1536040888.0
Nyanraltotlapun,"So, what game it is?",1535994315.0
ProfessorSexyTime,"The site looks a little wonky on mobile, so I'd recommend some media queries for different screen sizes. I only say that specifically because I want to recommend [LASS (Lisp Augmented Style Sheets)](https://github.com/Shinmera/LASS) :P

It looks really cool. Maybe once I get my basic site up I'll hopefully have gotten Lisp down, and I can rewrite it in a Lispy way (in something like [Coleslaw](https://github.com/kingcons/coleslaw) as u/dzecniv mentioned) with LASS.",1535991462.0
dzecniv,"In Other Publishing Systems you could add Coleslaw for CL

- https://github.com/kingcons/coleslaw
- https://github.com/40ants/coleslaw-cli (from https://github.com/CodyReichert/awesome-cl#static-site-generators)

It doesn't seem to support writing in org directly.

(nice post again)",1535979691.0
Shinmera,"Just as a side note: internationally there's no way to format phone numbers uniformly. Phone number notation and length can vary wildly between countries.

Also, if the spacing between the hyphenation of digits is uniform (it isn't in your example), and you're really dealing with just numbers, then format can print it pretty easily like so:

    (format T ""~,,'-,4:d"" 123456789) ; => 1-2345-6789",1535963867.0
patrixl,"Not sure about formatting the string with hyphens but your check for the length of num is missing the length function. Right now you check if num itself isn’t equal to 10...

Try ( /= (length num) 10)",1535936689.0
lispm,"    CL-USER 109 > (defun prompt-for-phone-number ()
                    (loop with number = """"
                          when (= (length number) 10) do (return number)
                          do
                          (format t ""~%~a"" ""Enter a valid phone number: "")
                          (finish-output)
                          (setf number (read-line))))
    PROMPT-FOR-PHONE-NUMBER

    CL-USER 110 > (prompt-for-phone-number)

    Enter a valid phone number: 12

    Enter a valid phone number: 

    Enter a valid phone number: 1234567890
    ""1234567890""

    CL-USER 111 > (defun format-phone-number (number-string)
                    (apply #'format nil ""+1-~a~a~a-~a~a~a-~a~a~a~a""
                           (coerce number-string 'list)))
    FORMAT-PHONE-NUMBER

    CL-USER 112 > (format-phone-number **)
    ""+1-123-456-7890""


The direct translation of your Python code might be:

    CL-USER 113 > (let ((num """"))
                     (loop until (= (length num) 10) do
                           (format t ""Please give a valid number: "")
                           (finish-output)
                           (setf num (read-line)))
                     num)
    Please give a valid number: 12
    Please give a valid number: 1234
    Please give a valid number: 1234567890
    ""1234567890""
",1535962838.0
stassats,"You put ""with num"" instead of ""for num"", which makes it run only once.",1535969579.0
borodust,"I'm extracting general purpose libraries out of `cl-bodge`, so people would be able to reuse them w/o buying into whole `cl-bodge` framework. It all started with `bodge-ui` (high level lispy wrapper over Nuklear UI library), but now i just can't stop - there would be more: host OS functionality is already spliced out into a library, graphics and physics are going to be next.",1535889902.0
Shinmera,"I'll be on holidays in Tokyo this week, but knowing me, that probably wont stop me from working. After all, I wrote my first Lisp library when I was last there.

Most likely I'll continue work on [Trial](https://shirakumo.org/projects/trial), and particularly the [geometry clipmaps](https://reader.tymoon.eu/article/368) component of it. In specific, I want to investigate shadow mapping and halfspace fog to improve the look of the rendered scenery.",1535905913.0
dzecniv,"I'm polishing a [Weblocks](https://github.com/40ants/weblocks) application for [cl-torrents](https://github.com/vindarel/cl-torrents), i.e. a dynamic web page all in CL, and I am rewriting the CLOS guide on the CL Cookbook.

For another idea, I'm pretty excited about the [Next browser](https://github.com/next-browser/next).

ps: CL is definitely more fun than elisp or python ;)",1535889912.0
flaming_bird,"I've been working with Robert Strandh on a spellchecker in portable Common Lisp, https://github.com/phoe-trash/Spell/

And the spellchecker is for a bigger project, a service for storytellers/roleplayers to do their roleplays on.",1535869317.0
ElBroet,"I'm playing around with writing a macro for an optional Haskellian type system for Clojure (something like
    
    (hask
      (Int -> Int -> Int)
      (def add [ x y] (+ x y)))

I would say that a type restricts data to being within a certain domain,  that all restrictions can be represented as a series of predicates, and that the most powerful type system would allow any predicate be represented in a type. For run time checking this seems to be easy and is already a feature of Clojure, but I'd like to see how close this can be done at compile time, so I'm also playing around with the idea of encoding predicates into a type using sort of Prolog-esque clauses.  ",1535894724.0
defunkydrummer,">and would love some application ideas and war stories that might provide that little extra motivation to really get deep on the language. 

I have no glamorous ideas to contribute, sadly, and the tasks i'll be working the whole year in CL are as un-glamorous as they can be -- accounting data processing.

But I can give you some motivation maybe? Specific to Common Lisp in this case, and specific to a person like you that has had experience of C, Python, and C++.

First of all, the biggest difference will be working, for the first time, with an ""image-based"" system. Needs to be experienced to understand the added value. 

The other big difference is to finally have a really good, powerful macro system; and the s-expression syntax has a lot to do with it. The ""code is data"" also has to do a lot with it. Once the ""code is data""+""true macros"" combo hits you in the head, rollback to your previous mind state is impossible. **Beware.**

Once you learn the lisp macro system, the C preprocessor macros will look like horrifying abominations of flaccid power. Although they're great for winning the IOCCC. You'll never want to look at a `#define` again. 

You'll be surprised to see you can also do lots of bit-level manipulation with CL, as well as work with bit arrays with no sweat. This is surprising because apparently this is a high-level language, yet it is high-level and low-level at the same time (this becomes evident over time.) For example, you can disassemble your functions on-the-fly to find out what's going inside. You can interop with C code and even share a buffer in heap space. So if you are also inclined to the low-level, there's something in it for you too.

You'll be glad to work with a strongly-typed language; C is weakly typed, CL is very strongly typed. 

You'll be glad to say ""bye bye"" to header files and ""hello"" to an easy-to-use compilation system, which is ASDF.

The Common Lisp Object System (CLOS) will be a revelation to you when you compare it to the typical C++ object model. It might blow your mind. It did, to me. This will cause a segfault with your mind once you use it, so **Beware**, you will *not* want to go back to the C++/Java object systems.

Exception handling, using the ""Condition-Restart System"", is exemplary and gives you confidence in being able to create systems that do not ""panic"".

You'll be able to understand the whole language and it's stdlib -- it's much less surface area to cover compared C++; even for a language that in the past was described as ""huge"". 

You'll be glad to know that you can make your CL application run massively faster than an equivalent program in CPython or PyPy. 

You'll be delighted to find out that there is no Global Interpreter Lock (GIL), and that you can do concurrent programming in any way you prefer -- locks, actor model, async, software transactional memory, all is supported in CL with no sweat.

And yes, you can compile down to executable files if you want, or run your code in the JVM, or compile to other operating system or CPU, or embed into a C program, -- with minimal, minimal changes to the code. 

If you liked Python's ""pip"", you will love Quicklisp. 

If you are scientifically-minded, you'll love to know that there's a full numeric tower included as part of the standard, including complex numbers, IEEE floats, rational numbers, fixed precision and arbitrary-length integers. Calculations like `(atanh -2)` will return the correct complex number. `(/ (factorial 1000) (factorial 999))` will return 1000, not run out of precision. `(/ 10 4)` will give you a fraction: 5/2. Whoa! Amazing! *Yes, this can all be yours for FREE.* If you call within the 15 minutes you'll receive a pack of THREE industrial-strength Common Lisp implementations: Armed Bear, Clozure, and Steel Bank. 

And wait, there is more! Yes, my friend, all your dreams can become true. Common Lisp: Eternal salvation, or *triple* your money back.








",1536105235.0
dr_seuss_93,">...  love some application ideas and war stories that might provide that little extra motivation to really get deep on the language.

This thread wouldn't be complete without [Beating the Averages](http://www.paulgraham.com/avg.html]). That guy really hyped me up to learn lisp.

Also, you may be interested in [Interviews with 100x More Productive Programmers](https://leanpub.com/lisphackers).",1536039436.0
f0urier,I'm trying to add more features and remove some oddities in my pet [tool](https://github.com/fourier/mediaimport) to import media files from cameras/phones/etc to simple directory structure. ,1536255912.0
theangeryemacsshibe,"Node.js? More like Nope.js.

*shows herself out*",1535758680.0
arvid,This sub is probably not the place to get help.  I have never heard of sibilant before. you would probably get more help at https://old.reddit.com/r/node/,1535739566.0
fisxoj,"I don't know anything about sibilant, but in your instructions there's a single double quote at the end of the last line.  Is that supposed to be there?",1535760587.0
Lower_Cryptographer,"That is the most British demo I've seen in a long time. /u/baggers_ you are no longer my favourite British lisper

EDIT: I just realised that the person in the video might not be the author of the library, that is very disappointing :-(",1535733088.0
ssb_kal_el,"This is pretty neat! Before you add multi-threading though, you can probably gain some performance by making your backend deal with image data in terms of scanlines. Most video/image file formats are stored in a way that makes it easy to read consecutive rows of pixels at a time. Because of that, most compositing and rendering applications will read only a few scanlines at a time, process them and flush the output scanlines before moving on to the next line. This lets you allocate smaller fixed buffers for your inputs and outputs and lets you avoid dynamic allocation during your image processing. For your 3x3 convolution kernel for example, you can allocate a fixed input buffer of 3 scanlines and use a sliding window as you iterate down the image. For the ouput, you only need to buffer a single scanline at any given time. From a common lisp perspective, this means getting familiar with READ-SEQUENCE and WRITE-SEQUENCE on the file streams containing your image data. Good luck!",1535727797.0
Resquid,"Read the sidebar, this subreddit is for programming languages.",1535698269.0
theangeryemacsshibe,"Where can I get a Lateral Lisp image? I'd be glad to help, but I've never heard of it.",1535698421.0
paulfdietz,"\#(1 x) is not a constructor, it's a constant.  It's analogous to having written

(let ((x 2)) '(1 x)) ==>  (1 x), not (1 2)

I'm sure you could redefine what \#( does, but what is the point?",1535577636.0
lispm,"A literal vector is data and no parts will be evaluated.

If you want to create a vector with evaluated contents then you can use the function VECTOR:

A vector does not need to be quoted:

    CL-USER 80 > #(1 pi)
    #(1 PI)

But we can quote it - it makes no difference:

    CL-USER 81 > '#(1 pi)
    #(1 PI)

We can create a vector from evaluated arguments:

    CL-USER 82 > (vector 1 pi)
    #(1 3.141592653589793D0)


This is the same for lists:

    CL-USER 83 > '(1 pi)
    (1 PI)

And we can create a list with the function LIST:

    CL-USER 84 > (list 1 pi)
    (1 3.141592653589793D0)

Quasiquoted lists and vectors allow us to selective evaluate parts.",1535578623.0
stassats,"I suggest you don't invent any ""magic-let"" (disregarding that it can't work), to keep other's expectations consistent with how #( works. In general, whenever something is not the way you're expecting accept it and move on, otherwise everybody will have their own ""magic-*"" and nobody will understand each other.",1535626331.0
Shinmera,"I don't think your second example is normative. In fact, I'm astounded that it works at all.",1535578914.0
defunkydrummer,"Hi /u/joinr , so happy to see you're giving CL a try. Just my 5 cents: I've not seen too much usage of #() literals on CL, code, IMO perhaps because vectors are often used for performance reasons, and in those cases it (IMO) makes more sense to previously create the vector (using make-array) and setting up the various options -- element type, adjustable or not, fill-pointer, displacement, number of cylinders, firing order, etc etc.",1535594894.0
whism,"FWIW I got a similar itch some years back. I found I was fairly easily able to tinker with the CCL internals to change the evaluation semantics for literals of my custom data types. Obviously not portable/something you could release as a library, but fun to explore the internals of an implementation, and pretty awesome to be able to change things like that interactively.",1535713760.0
kazkylheku,"> How does it do that?

With a heaping dollop of parentheses. :)

CLIPS was a system developed by NASA to port an expert system from Lisp machines to cheaper, mass-produced hardware having less memory and CPU power.

It's a C program driven by Lisp syntax. It provides an OOP language called COOL which seems to be a unique Lisp dialect, plus an expert system shell based on Lisp expressions.

CLIPS was part of a trend in the 1980's: hack up neat stuff on Lisp machines, and then port the logic to less capable hardware using various hacks (rewrite in another language, or scaled down Lisp dialects or whatever).

CLIPS is completely different from CLISP and bears no relation to it.


",1535566337.0
flaming_bird,"Could you provide any links to that wiki page?

EDIT: Looks like it's https://en.wikipedia.org/wiki/CLIPS

EDIT2: Yes, it seems that the syntax is very similar. ""How does it do that?"" Exactly that way - the syntax example for CLIPS from that wiki page looks very similar to Lisp's standard `DEFINE` or `DEFUN` or `DEFVAR` forms.

""Is CLIPS part of LISP?"" Nope - it is also not built on top of Lisp. To the best of my knowledge, no Lisp dialect includes CLIPS as an internal part of it.",1535565175.0
m00natic,"And here's the other way around, [Lisa](http://lisa.sourceforge.net/) is a Common Lisp platform influenced by CLIPS.",1535639684.0
flaming_bird,I have successfully used Common Lisp (SBCL/CCL) with Qtools to deploy GUI applications on Windows and Linux.,1535545414.0
lispm,"With Common Lisp the best tools to develop native Windows GUI apps are with the commercial (and expensive) implementations: Allegro CL and LispWorks.

https://franz.com/products/allegro-common-lisp/

http://www.lispworks.com/products/lww.html

Those have the integration into Windows, GUI interface builder, support for the tools, etc. Startup times are no problem. One can also get time limited full versions for a trial period from both. But again, the full commercial versions are not cheap.

For example this is a Windows application written in LispWorks: [LinkExplorer](https://www.youtube.com/watch?v=fpZznfKaOgs)",1535537937.0
tangled_up_in_blue,"If I were you I’d go the painful way and do CL and either the Qt4 or Qt5 bindings people mentioned here. You said you’ve written native apps before? C# is a little different, have you used a GUI library like GTK, Qt, Cocoa, etc yet? They come with their own complications (you really have to learn how they work to build the GUI in the first place). Qt is cross platform so that takes care of that issue. CL is the most popular lisp out there so it probably has the most mature libraries for the things you want, vs Racket which I found to be a bit too new and I wasn’t crazy about the lack of options around it (mostly in regard to 3rd party package availability). CL gives you the best dev environment and the biggest package selection, and the most users should you need help. It will also have the most options on the native GUI side. ",1535569750.0
Duuqnd,"I like using Guile Scheme, but that's just what I like. I'm not sure what the standard is.",1535568477.0
sgoldkin,"https://www.gnu.org/software/kawa/index.html
",1535585438.0
maximoburrito,"Clojure would normally be the clear winner if you are looking for pragmatic lisp for the real world, but windows desktop applications is about as far as you can get from Clojure's wheelhouse. This is not because of the startup time, where those extra few ms would not be noticeable, but just because ... windows desktop. The Clojure options would probably be

&#x200B;

\- Clojure, using the Java UI frameworks... ughhh

\- Clojure on the CLR, using Microsoft APIS - you'd be far out from the mainstream Clojure experience, probably not good for someone new to Clojure

\- ClojureScript using a JS tool like electron. This is almost surely the way I'd go with Clojure, but I don't know what the gotchas are here. My guess is this is a path for suitable for an experience Clojurist

&#x200B;

&#x200B;

&#x200B;

&#x200B;",1535544317.0
not-just-yeti,"Racket is not education-oriented --  ...Well, one of its goals is to allow one to create new languages fairly easily, and one application of that is several teaching-languages (simplified schemes, where error-messages can take advantage of how certain constructs aren't allowed).  And it has its origins in education.  But it is a full, industrial-strength lisp.  A list of packages:   [https://pkgs.racket-lang.org/](https://pkgs.racket-lang.org/)

&#x200B;

Its IDE, DrRacket, is written almost entirely in racket, so certainly GUI tools and system-call-interaction are pretty well fleshed out. 

(That said: no, racket is not as widely-used industrially as Clojure or Common Lisp.)

&#x200B;",1535557185.0
defunkydrummer,"There's a language close to Lisp that has integrated support for GUI programming and has a long, dignified history: TCL (with the TK toolkit, that is: TCL/TK)

As for Common Lisp, IMO being the most poweful lisp available, there are many options there

- X11/only development using McCLIM

- the commercial alternatives: CommonGraphics, CAPI and CLIM2.0

- Qt4 (qtools) and Qt5 (ECL implementation + Qt)

- Tk library through celtk library, or through ltk 

- install ABCL (Common Lisp on the JVM) and call a java lib like swing. This should be painful.

- use Parenscript (compiles to js) and do web frontend UI",1535592990.0
Syronn,"After all of your comments it's kinda hard for me to decide between Racket and Clojure for completing my task.  
Or if i either should learn Racket first, and then jump on the Clojure train.  
Racket is known to be beginner friendly and the learning curve of Clojure is kinda steap, with the JVM etc...

I don't know what to do :D ",1535560755.0
Saikyun,If you want to create web front ends ClojureScript is probably a good fit. :) I don't know about Windows native bindings though.,1535618112.0
melevine45,"You may want to check out Corman Common Lisp, which specifically focused on Windows: https://github.com/sharplispers/cormanlisp",1535681374.0
superdisk,Skip Common Lisp for now if you're just trying to learn and do Clojure. It's a joy to use and its expressiveness makes Scheme look like garbage. Just use Swing for the desktop app and CLJS for the web UI.,1535556092.0
tcsiwula,Woohoo 🎉 ,1535500859.0
kazkylheku,"I don't want to see a presentation, let a alone be taught, by someone whose preparation consisted of going on Reddit to ask what the heck it is.

Do you?

Those students (or their parents, or scholarship funds) pay good money, for pete's sake.",1535514788.0
lbcadden3,https://en.m.wikipedia.org/wiki/Lisp_(programming_language),1535488351.0
ac1235,Did you Google first?,1535489182.0
dzecniv,"suggestions:

- http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/
- what was/is CL used for ? http://lisp-lang.org/success/
- https://en.wikipedia.org/wiki/Common_Lisp",1535551522.0
where_void_pointers,"Lisp is a family of programming languages (or programming language dialects if you view them as not completely separate programming languages). Someone already linked you a wikipedia article on them. It is an old family, starting shortly after Fortran. And it is still alive today. Major langs/dialects are Common Lisp, Scheme, Clojure, and Emacs Lisp and their variations (like Racket, which is pretty different from Scheme these days) and there are several other living ones that are still used (like [PicoLisp](https://picolisp.com)) and there are periodically new ones (like [uLisp](http://www.ulisp.com)).

Common Lisp and scheme have many different implementations of them (if you know Python, this is just like how there is CPython, PyPy, Jython, etc. except with Scheme and Common Lisp there are many many more). CLISP is just one implementation of Common Lisp. It's site is at https://www.gnu.org/software/clisp/.",1535490419.0
losthalo7,"[CLISP](https://clisp.sourceforge.io/) is an implementation of the Common Lisp language available for Unix-like (Linux, BSD, etc.) and Windows operating systems (and probably others as well).  It's written in C (the 'C' in CLISP) making it fairly portable to various operating systems and allowing it to be compiled with more or less add-on options to suit your needs.

As many Common Lisp implementations do it includes a compiler and an interpreter, allowing you to work interactively at a [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) prompt.  Memory management is by garbage collection.

You can use it to run Common Lisp software or to write your own, use it for scripting tasks or use it as a [login shell](https://clisp.sourceforge.io/clash.html) if you're brave or really love Lisp!",1535509972.0
bobthecimmerian,It's awesome to see the project still kicking.,1535480958.0
arvid,one of the authors of [The Art of the Metaobject Protocol](https://mitpress.mit.edu/books/art-metaobject-protocol),1535461625.0
Lisp-S-R-C-L-D,"~min 52    
""Computer Sciences stand on the shoulders of their predecessors not on their toes ""  if I heard well :-)",1535425449.0
g000001,"FYI,         
*An implementation of the Language Server Protocol for Common Lisp*
https://github.com/cxxxr/cl-lsp",1535394181.0
defunkydrummer,"Good work placing Lisp history comparing it to the timeframe of more recent languages (Python, Ruby).

>Common Lisp doesn’t include string interpolation. You want it? No problem, you don’t have to wait for Scala 2.10 or Python 3.6, just use a library.

Good example.

>No one’s up in arms trying to get a new revision of the Common Lisp standard to add pattern matching because you can write it as a library and get 90% or more of what you’ve get if it were built in. The language gives you enough power to extend it in a way that feels like the extension was there from the beginning.

This is something I often need to explain in Reddit forums, perhaps I should just copy/paste this paragraph!

>Get a Lisp

It should mention Portacle, really.

>I'm a programmer, photographer, dancer & bassist

Really good, worthy article!! Kudos from a programmer, photographer, and drummer.


",1535399093.0
rgrau,"I read Gabriel's this year and also thought it's VERY VERY good. +1 on its recommendation.

A refreshing book about methodologies, patterns, deevelopment practices and lisp itself.",1535400216.0
arvid,"added to the sidebar 

if using *new* reddit, see http://old.reddit.com/r/lisp",1535462077.0
arvid,">You should also begin to get comfortable looking up things in the Common Lisp language specification itself. It’s the ultimate manual for Common Lisp. It can be pretty dense at points, but can answer many questions you might have if you read it slowly and carefully. You can either use the index page to find what you’re looking for or just search on Google for “clhs whatever” (CLHS stands for “Common Lisp HyperSpec”, which is the hyperlinked, HTML version of the spec). 

Zach has online lisp search engine that includes the hyperspec: http://l1sp.org/html/

I realize you do not use  emacs/slime, but slime is already connected to the online lispwork's hyperspec, C-c C-d h when the cursor is over a word (say `remove-if-not`), will bring up that entry. If it does not exists, it will prompt you to edit the word. C-c C-d ~ then enter a `format` letter while bring up the hyperspec format for that letter.  You can also configure slime to reference a local copy of the spec and if you prefer not to leave emacs like me you can stay in emacs with the w3m text based browser.",1535469427.0
waspishly_simple,"In the article Steve warns against thinking:

*This project was last updated six years ago? That’s probably abandoned and broken.*

Which is exactly what I do do.

He says:

*The stability of Common Lisp means that sometimes libraries can just be done, not abandoned*

Which I can accept but how do I tell the difference?

For example I started using a really nice prevalence library (in memory persistence backed by flat files) but it appears to have been abandoned. How can I tell if it's ""just done"" and so safe to use, or not?
",1536138182.0
dzecniv,">  If you already use the Dash app for MacOS, it has the Common Lisp spec available.

tip: we have the same docsets in [Zeal](https://github.com/zealdocs/zeal/), a GUI doc browser.",1535439913.0
chandaliergalaxy,Good reading to do side by side with the curse of Lisp ;),1535427415.0
dzecniv,"nitpicking:

> For the compiling-into-binaries functionality I’d recommend using your implementation’s built-in support for this, or using UIOP’s wrapper around that, or using a separate library like Deploy.

Isn't it asdf's wrapper ? `build-operation` in the `.asd` and `asdf:make`: https://lispcookbook.github.io/cl-cookbook/scripting.html#with-asdf",1535445482.0
Grak47,"Thanks, I now have a road map for learning lisp :)",1536360881.0
tarballs_are_good,"4 variants of the evaluator from this blog post in Lisp, including ones that use monads like Haskell: https://github.com/jonatack/common-lisp/tree/master/talking-with-a-lisp/simple-evaluator",1535385793.0
Lower_Cryptographer,Of course pattern matching and ADTs are easily reachable through Quicklisp!,1535381384.0
kazkylheku,"Original:

    (defun evaluate (e)
        (let ((op (car e)))
            (cond ((eql op 'Val) (cadr e))
                  (t (let ((e1 (evaluate (cadr e)))
                           (e2 (evaluate (caddr e))))
                    (cond ((eql op 'Add) (+ e1 e2))
                        ((eql op 'Sub) (- e1 e2))
                        ((eql op 'Mul) (* e1 e2))
                        ((eql op 'Div) (if (= e2 0)
                                        nil
                                        (/ e1 e2)))
                        (t (error ""invalid operation""))))))))

Alternative:

    (defun evaluate (e)
      (destructuring-bind (op &optional e1 e2) e
         (symbol-macrolet ((v1 (evaluate e1)) (v2 (evaluate e2)))
           (case op
             (val e1)
             (add (+ v1 v2))
             (sub (- v1 v2))
             (mul (* v1 v2))
             (div (let ((div v2))
                    (when (zerop v2)
                      (error ""division by zero""))
                    (/ v1 div)))
             (t (error ""invalid operation""))))))

Turning the division into `nil`, which is an invalid expression, is poor.  It's arguably pointless to catch that at all.

",1535396971.0
mobius-eng,"1. Most of the code is going to break if another operation is added
2. Lisps in general have better tools to deal with this, yes, not as pretty as ADT but extendable.
3. In CL, in particular, you should rather use classes and multimethods, although it is a bit like shooting a fly with a canon.
4. You don't need `main` in Lisp - you have fully functioning REPL! The only time you write it is if you save the image.",1535394346.0
AlanCrowe,"If you specifically want a four function calculator, so that you can do 

    (eval4 '(add 2 (mul 3 6))) => 20

the code in the article is, err, well, it is close to the Haskell, so it follows the authors plan for the article, so it is OK I guess.

But one of the joys of Common Lisp is that if you can see that your project will contain a lot of interpreter code, then you can write a macro like [headcase here](http://alan.sdf-eu.org/headcase.lisp) and then go

    (defun eval4 (term)
      (headcase term
        (number term)
        ((add x y) (+ (eval4 x)(eval4 y)))
        ((sub x y) (- (eval4 x)(eval4 y)))
        ((mul x y) (* (eval4 x)(eval4 y)))
        ((div x 0) (error ""Division by zero.""))
        ((div x y) (/ (eval4 x)(eval4 y)))))

Notice that HEADCASE isn't a general purpose pattern matching macro. You don't have to quote the initial symbol in the list to stop it being a variable, because it was designed for prefix notation. Similarly a top level atom names a type, because that is useful for splitting the base case (a symbol could be looked up). The macro-expander uses constantp to spot that 0,1,t,nil, etc are literals.

Tuning macros like this is an art. They should do more than mere template filling so that they capture the repetitions inherent in a particular application. They shouldn't be too much more than mere template filling because you don't want to fall down the rabbit hole of designing a general purpose language. [headcase.lisp](http://alan.sdf-eu.org/headcase.lisp) does support nested patterns, such as (add (mul x y) z), so it might be over-complicated.",1535408861.0
republitard,">And finally, for the fun part – Common Lisp. Of course, this is not idiomatic Common Lisp by any stretch of the imagination, and the idea is to try and preserve the essence of the Haskell version whilst still being runnable Lisp. Common Lisp is, of course, a dynamically-typed language, and it doesn’t have a real equivalent of ADTs. However, the bigger discomfort, in my opinion, is that
Common Lisp’s pattern matching is almost non-existent (unlike Racket).

As I read this, I expected the CL version to be an explosion of convolution in comparison to the Rust version, but reading further down, it turns out to be not that bad at all, although it could be improved.
",1535938877.0
lispm,"Many should be able to work with images, worlds, heaps - or whatever they call it:

http://www.s48.org/1.9.2/manual/manual-Z-H-4.html#node_sec_3.10

https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/World-Images.html#World-Images

https://cisco.github.io/ChezScheme/csug9.5/use.html#./use:s98",1535376033.0
mobius-eng,"Chez. Maybe guile, but I can't remember.",1535369527.0
lispm,"> Yes, Xah can be annoying

he has been trolling comp.lang.lisp for two decades, without ever having been able to write a line of Lisp code. He is on a mission and he collected all kinds of BS quotes - without any personal experience of Lisp. This exact BS has been posted by him a zillion times to comp.lang.lisp and people had been dumb enough to discuss this. 

You can see that he has no idea about Lisp, when he talks about code formatting - while never having written any Lisp code. He claims that commands to format Lisp code does not exist. BBN Lisp did have that in its structure editor in the 60s/70s. Ca. 1980 this command in Zmacs (an Emacs written in Lisp Machine Lisp / ZetaLisp) was called something like Grind Expression (can't remember the exact command). Formatting code was called 'grinding' then. Already in the 70s there were GRIND functions which could format Lisp code. Common Lisp even comes with a code pretty printer built-in: PPRINT. I do code formatting with PPRINT all the time, for example when looking at macroexpanded code. But when Lisp programmers don't 'grind' code very often in the editor - this mostly shows that editing is done differently to what he did in his favorite environment Mathematica. Since he never used a Lisp IDE editor to write something in, say, Common Lisp or Scheme, he has no first hand experience of Lisp tools. He only tries to make sense of GNU Emacs and its support for Emacs Lisp - having a hard time figuring it out.",1535307838.0
tarballs_are_good,"These are not fundamental issues. They don’t impede work. The author just doesn’t like changes to S-expression meta-syntax.

Lisp traditionally (back in the 70s-90s) had great tooling. It still has decent tooling from commercial vendors, but the open source world isn’t as nice. We do have relatively good compilers, but it’s a real hang up for beginners to learn Emacs, Paredit, and SLIME unfortunately. I’m excited to see where Lem and Mezzano go though. ",1535306219.0
Aidenn0,"First of all, I'd say that designing a language that is to be used is an engineering problem, in that there isn't a perfect solution but rather tradeoffs.  That means that there will be problems with any useful language, and one could make the argument that they are fundamental.

&#x200B;

Secondly, when you are growing a language, keeping things in that would otherwise be suboptimal may be a good thing in terms of not breaking existing code and/or patterns.  I think all experienced lispers have things they would like to change about the language.  Actually I would go so far as to say if you don't have something bad to say about a particular language, then you just haven't used it enough.

&#x200B;

Now on to the actual article, I find his arguments to be a bit silly.  Does common lisp have too much builtin syntax?  Maybe; perhaps a matter of taste, but it's hard to argue that it's a fundamental problem since you can avoid using them.  Is dotted syntax confusing? Probably, but it's not something you encounter a lot, so even his cons/fons argument further down isn't convincing when applied to it.

&#x200B;

Are CONSes the perfect data structure for representing trees?  No, but they are certainly good enough for representing lisp code, which is the only place that they are unavoidable in the language.

&#x200B;

If the author want's to list fundamental problems with lisp, I dont think this is even a good candidate list.",1535329104.0
where_void_pointers,"I never heard of the person before and decided to read it.

I will be the first one to say that conses/pairs are not the end all be all, but they can be quite powerful. They make it easy to do things like remove/swap/etc. tails; make a circular object, and make a large variety of structures and be quite regular in the process. And there are some cool things underneath the hood in the actual implementation that can be done with them such as when they are freed by the garbage collector one can just cons them onto the head of a list of free conses that can be immediately used whenever a new cons is needed for an object (this is what picolisp does if I remember correctly). They are a simple structure that can represent nested trees. Not suitable for everything, hence why most lisps have other container types. But very good for some things.

On the syntax stuff, all the various things that break from the very regular syntax are generally macros of a sort and ultimately translate into the standard syntax (the big exception is comments which are truly quite separate and different). Syntactic sugar is what many people call them. In the lisp family of languages, some have a lot and some have very few. Do they make it a bit more complicated for code formatting code, yes. Still would say not very much compared to say python. As far as style guides, well, one could format special forms and macros the same as everything else, but for many of them, using a slightly different indentation helps make them easier to read and understand because the different sublists in them have different meanings. Overall, though, the syntax of lisps is extremely simple compared to most languages. As an example, the C code of the reader for Guile Scheme and is pretty tiny and straightforward.

Lisps are not without their flaws. Each one has some. Some are common between many lisp. And there are various double edged swords as well.",1535316452.0
Aidenn0,"Honestly, clojure/scheme/racket/common lisp are all fine for everything you mention.  IIRC startup time of cljs/node is considerably faster than jvm, so even clojure isn't disqualified.

I can personally vouch for SBCL:

* Developing under emacs (with SLIME) is amazing.  It's actually what keeps me using this stack over other languages.
* If you are willing to save an image, startup time is excellent (\~10ms on my machine)
* Several reasonable http implementations, though IMO clojure has an edge here (e.g. ring has more quality middleware than any CL web stack)",1535326500.0
losthalo7,"[CLISP](https://clisp.sourceforge.io/) is a Common Lisp implementation that starts up very quickly for scripting use and can even be used as a (basic) [login shell](https://clisp.sourceforge.io/clash.html)!

You may want another implementation for web development work, such as [SBCL](http://www.sbcl.org), there are a wide variety available for Linux.",1535306639.0
CelloAxeMurder,THE GARBAGE COLLECTOR HAS BEEN CALLED.,1535306887.0
_priyadarshan,"Thank you, very interesting.",1535006107.0
hoijarvi,"I played with it in 1980's. As far as I understand MacSyma run on it. They were OK, but I managed to crash it a few times with high memory usage conditions.
",1535038876.0
_priyadarshan,"Original file is [here, starting from page 731](https://archive.org/details/computerworld2140unse).

I am glad I have found this paper by Cornish.

I am still looking for an article I read in the 80s, probably published in Scientific American (or was it Byte or PC Magazine?) about how Lisp coders and hackers at universities were staying up all night in sheer programming bliss, completely forgetful of time, the code in their minds all day until they could get night time on a Lisp Machine.

If it rings a bell, please let me know the title or magazine. I would be happy to read it again, as it propelled my interest in Lisp since then.",1534950418.0
ambrevar,"Thank you so much for this gem!  1987... The historical hindsight is staggering!

For instance, I think most people would find this cute nowadays:

> Debugging information such as the names of the arguments of each function.

Conversely, the author has many interesting intuitions that are still rather niche today:

> You will never fully appreciate how such fragmentation limits productivity until
> you have used a single-language system.

Also the software stack seemed quite different:

> I hear people complain that they would have to learn LISP to use the Listener,
> the Explorer's command interpreter shell.

I wonder what those Explorer and Listener are.

Last but not least, ""Zmacs""!  Those were the days...
",1535098036.0
dzecniv,"Nice :)

`subseq` fails if the end limit is superior to the sequence's length. I fix this with `(str:substr 0 3 '(:foo))` (function in the `str` library, which happens to work for sequences).

To read lines from a file, I'd use `uiop:read-file-lines`.

(and there is no error handling).

(edit) for cron-like jobs, I once used [Clerk](https://github.com/tsikov/clerk).",1534851479.0
PuercoPop,"I've wrote some comments about the code in [lobsters](https://lobste.rs/s/jzmzgb/mastodon_bot_common_lisp) which I'm copying verbatim.

```lisp
we want to filter an process instead of
REMOVE-IF-NOT + LOOP we can use LOOP's WHEN clause instead.

It is better to use the most specific construct when possible, MAPCAR instead
of (MAP 'list ...). I would assume a vector if MAP was used instead of MAPCAR.

You could use the structure constructor in PARSE-RSS-ITEM to make the code less
'side-effect'ful (still imperative though nothing wrong with
that). PARSE-RSS-ITEM would look like

  (defun parse-rss-item (item)
    ""Parse an RSS item into a lobsters-post""
    (let ((guid (get-first-text ""guid"" item))
          (title (get-first-text ""title"" item))
          (link (get-first-text ""link"" item)))
    (make-lobsters-post :guid guid
                        :title title
                        :url link)))

Note that for the cases where we want to create a resource, modify it and then
return it, the SERAPEUM library has RLET[0].

If we are going to depart from the archaic -p convention for predicates lets at
least do so for a better one, which is to end the predicate's name with ?
instead of is-foo.

As a matter of style, please don't leave dangling parens :pray:. And use
uppercase letters for the format directives.

A couple of 'dependencies' where unused and can be safely removed. Note that
TOOTER is already using YASON library so it would make sense to use that JSON
library instead of CL-JSON?

[0]: https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#lret-rest-bindings-body-body

|#

(defpackage ""MASTODON-LOBSTERS""
  (:use ""CL""
        ""BABEL""))
(in-package ""MASTODON-LOBSTERS"")

(defparameter +feed-path+ ""https://lobste.rs/rss"")
(setf drakma:*drakma-default-external-format* :utf8)

(defparameter +mastodon-client+
  (make-instance 'tooter:client
                 :base ""https://botsin.space""
                 :name ""lobsterbot""
                 :key ""secret""
                 :secret ""secret""
                 :access-token ""secret""))

(defparameter +link-db-path+ #P""/Users/puercopop/links.txt"")

(defparameter +processed-links+
  (with-open-file (stream +link-db-path+
                          :if-does-not-exist :create)
    (loop
      :for line := (read-line stream nil)
      :while line
      :collect line))
  ""A collection of the previously seen links."")

(defun processed? (post)
  ""Have we already processed the POST?""
  (find (post-guid post) +processed-links+ :key 'post-guid :test #'string=))

(defclass lobsters-post ()
  ((guid :initarg :guid :reader post-guid)
   (title :initarg :title :reader post-title)
   (url :initarg :url :reader post-url)))

(defmethod print-object ((post lobsters-post) stream)
  (print-unreadable-object (post stream :type t)
    (format stream ""~A - ~A ~A""
            (post-guid post)
            (post-title post)
            (post-url post))))

(defun get-first-text (tag node)
  ""Search the XML node for the given tag name and return the text of the first one""
  (plump:render-text (car (plump:get-elements-by-tag-name node tag))))

(defun parse-rss-item (item)
  ""Parse an RSS item into a lobsters-post""
  (let ((guid (get-first-text ""guid"" item))
        (title (get-first-text ""title"" item))
        (link (get-first-text ""link"" item)))
  (make-instance 'lobsters-post :guid guid
                                :title title
                                :url link)))

(defun get-rss-feed ()
  ""Gets rss feed of Lobste.rs""
  (let* ((xml-text (octets-to-string (drakma:http-request +feed-path+)))
         (plump:*tag-dispatchers* plump:*xml-tags*)
         (xml-tree (plump:parse xml-text))
         (items (plump:get-elements-by-tag-name xml-tree ""item"")))
    (loop :for entry :in items
          :collect (parse-rss-item entry))))

(defun send-toot (post)
""Takes a lobsters-post and posts it on Mastodon""
  (tooter:make-status +mastodon-client+
                      (format nil ""~A - ~A ~A""
                              (post-title post)
                              (post-guid post)
                              (post-url post))))


(defun record-post (post)
  ""Notes that the POST has been processed by us.""
  (push setf +processed-links+
        (cons (post-guid post) +processed-links+))
  (with-open-file (out +link-db-path+
                       :direction :output
                       :if-exists :append
                       :if-does-not-exist :create)
    (format out ""~A~%"" (post-guid post))))

(defun main ()
  (loop
    :with count := 0
    :for rss-entry :in (get-rss-feed)
    :while (> 10 count)
    :unless (processed? rss-entry)
      :do
         (send-toot rss-entry)
         (record-link rss-entry)
         (incf count)))

#+entry-point
(main)
```",1534896340.0
justin2004,"> ... the argument that has been advanced for discarding Lisp in favor of C++ (and now for Java) is that JPL should use ""industry best practice."" The problem with this argument is twofold: first, we're confusing best practice with standard practice. The two are not the same. And second, we're assuming that best (or even standard) practice is an invariant with respect to the task, that the best way to write a word processor is also the best way to write a spacecacraft control system. It isn't.


It sounds like lisp never really achieved a network effect. Maybe? Some of the imperative and object oriented ones did so maybe the ""get rid of lisp"" response was more a result of that fact rather than a result of lisp being a poor tool for the job.",1534767674.0
lambda_6502,"The last line rings very true for me:
> It is nonetheless supremely ironic that the demise of Lisp at JPL was ultimately due in no small measure to the unreliability of a C program.

Lisp is a pretty decent language (it has a few warts, but what language doesn't?) but it does fall over quite hard when dealing with libraries (in my experience) and i think this is down to the inherent design philosophies of any piece of of software. i.e. OpenGL is designed by people who code in C. It is unavoidable. Even in languages like ruby and python you can see that a lot of hoop jumping has to be performed to even out the wrinkles here and there. But as those languages are also written in C it mostly works out and high level libraries take away a fair amount of the pain. But (common) lisp and its long lived REPL sessions can really tax the underlying library (or even driver) logic and put the hardware in some odd states. OpenGL was designed (I bet) with the idea of: program runs, if program f'ks up it will crash and the driver can just clean the whole damn state up in one go. In lisp, however, if something borks the developer is going to halt a thread and do some funky stuff to fix the one bit that died and then resume the thread. This never happens in C/C++ languages, right? So why bullet proof all your OpenGL code for a thing that will never happen. And so you (I) end up trying to code something and having to restart the whole lisp session because the driver got in a funny state.

And OpenGL is not the worst offender in that regard. All libraries are written in this way. 

Anyhow. apologies for venting.

/rant",1534777734.0
crashC,"Interesting (to me) is that this article is maybe 15 years old,  and the discussion of the  relevant merits and shortcomings of Lisp here don't mention very much change in Lisp during the intervening period that may have tipped the weight of the arguments one way or the other.   If change is such a constant in technology, is Lisp an exception?   Can someone offer some hindsight?   How well has JPL done without Lisp for these years?  (I remember some successes with what looked like, on TV news anyway,  pretty small development teams.)   Has Lisp been more stable than the alternatives available then?  Would that have brought significant benefits?  Which alternative would have been the best choice 15 years back?   What difference would it have made?",1534879090.0
arvid,"Lispbox is no longer maintained or recommended.

Use [Portacle](https://shinmera.github.io/portacle/); it is the modern equivalent and much better than lispbox ever was.",1534643963.0
flaming_bird,"**LispBox is dead** and at least the online version of PCL should be updated with a link to its successor, **Portacle**.",1534704219.0
solidusfullstop,"Try `M-x slime` that will take you into slime mode, which is the repl interface you're looking for. It will (probably) ask you if you want to create a new  \*inferior-lisp\* interface.  You don't.

You can also access the buffer by typing `C-x b *slime-repl [TAB] [RET]` once it's running .

​(`M-x` is ""meta-x"" aka ""alt-x"")",1535140080.0
GDP10,"I think Geiser is fantastic. I have lots of my own customizations, including the saving of history and lots of tricks with key bindings. Geiser *is* flawed out of the box, but like everything else in Emacs, you can pretty much customize it to the hilt and meet your needs.

I think it's a lot like SLIME, perhaps just lacking the lifetime and amount of contributors which SLIME has enjoyed. Really, I think Geiser is the best development environment for Emacs+Scheme hackers and SLIME is the best development environment for Emacs+CL hackers. If you want the code for history-saving, you can PM me and I'll send it to you.

I'll try to release my customizations someday, when I can properly document them.",1534743383.0
the_evergrowing_fool,"Slime is a overall better experience, also I always though geiser was buggy with Racket, I never could make it work as I wanted. For reason crashes when trying to use nanopass with it.",1534569323.0
wanderley2k,I am a beginner in Racket and sometimes is frustrating the lack of live coding support in DrRacket.  I didn’t try to run it in Emacs+Geiser but I am curious to see others feedback. ,1534562291.0
timezone_bot,"6pm UTC happens when this comment is 19 hours and 40 minutes old.

You can find the live countdown here: https://countle.com/ARVw239701

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1534285148.0
takaci,I haven't heard of this. Anyone have much experience using it? Why would I use it over portacle/emacs?,1534267100.0
gewthen,What are the differences between Lem and Portacle?,1534268106.0
dzecniv,"E. Fukamachi switched to Lem nearly exclusively: http://blog.8arrow.org/entry/2018/08/14/213428 (Chromium's translation is ok)

> I used Emacs as my main editor all the time , but I moved to lem last month.  […] In the past month I used Emacs only for a few days to write Swift. It is painful that there is no syntax highlight as expected.

> Commit has exceeded 200 in the past month […] Furthermore, it seems that momentum has not declined as rust - mode is added immediately after release.

> The good point of lem is where startup is fast.

> Since it spews dump core including expansion, startup is fast as Vim as elementary . Since it can be started quickly, I can come back and forth with the shell, so I can cooperate with the shell if necessary. For example, to use Qlot, qlot exec lemlem's REPL refers to the project local quicklisp. Because it is written in Common Lisp , both extension and Contribute are easy.

and he shares his .lem config files: https://github.com/fukamachi/.lem

",1535049790.0
americanpunk,"Sweet!

Finally got this running.  I am switching over from emacs now.  So far, good enough for day to day use.

So, now we have following components coded in (mostly) Common Lisp:

* Stumpwm window manager.
* Next web browser.
* Lem text editor.

I am really happy to be living at a time where we are starting to see lisp based tools provide some of the core functionality of a desktop environment.


",1535132922.0
KDallas_Multipass,"use usocket till you find a reason to use anything else.  As a C++ programmer, I find the CL wrappers around sockets to be refreshing.  As usocket is a wrapper around the implementation specific socket bindings, the source code might not be too useful, but the api is simple and well documented.",1534209874.0
f0urier,I would also recommend usocket. There is a simple guide on them: [https://gist.github.com/shortsightedsid/71cf34282dfae0dd2528](https://gist.github.com/shortsightedsid/71cf34282dfae0dd2528),1534235519.0
patrickwonders,I definitely second the usocket suggestion.,1534224938.0
maufdez,"I like the article, minus the affirmation that Clojure is the most promising incarnation of Lisp, I am not a fan of Clojure but I don't say that because of that, I say it because it skews the non Lisper readers to a dialect based purely on opinion, unless the author clarifies what he means by ""promising"", and shows that Clojure is in fact more deserving of that title he could have omitted that sentence or precede it  with ""in my opinion""",1534439790.0
dzecniv,Last issues of his newsletter: https://purelyfunctional.tv/issues/,1534318305.0
unxn3rd,Sorry we are starting a little later than expected... Stream will start at 9:45PM UTC... Apologies for any inconvenience.,1534196175.0
Bhima,"There's a 2nd bit here:
http://christophe.rhodes.io/notes/blog/posts/2018/beginning_an_sbcl_port/",1534065686.0
fmargaine,"Hi, these blog articles always look super interesting, but they're absolutely impossible to read on mobile, which is where I read Reddit from. Could you make the site slightly responsive?",1534068325.0
flaming_bird,Another forum page that describes TLisp: http://forums.kronosaur.com/viewtopic.php?f=8&t=8113,1533916879.0
defunkydrummer,"Hi,

Answer for ""Lisp"" = ""Common Lisp"".

Take a look at these reddit posts:

https://www.reddit.com/r/lisp/comments/8s5q7x/what_common_lisp_web_library_should_i_use/

https://www.reddit.com/r/lisp/comments/8k79iz/lisp_for_building_a_web_app_options/

Some further comments:

To be honest, for a web application, as a bare minimum you would need:

a. a web server / web server interface

b. data access library + ORM or SQL generator

c.  HTML5/CSS generator

d. JSON generator / parser

e. ""mini framework"" to route requests to Lisp functions

On the Lisp world, most web frameworks provide basically (e) plus easy connection to some libs that provide (c) and sometimes (b). 

To be honest, there are many libraries for a,b,c, and d; and most of them are easy to use, so the need for a ""big"" web framework (similar to a ""Django"" or ""Rails"") is not really too big in CL.

Examples of libraries i think are good for each of those (note -- the common lisp ecosystem is smaller compared to other ecosystems, but still there are many choices for each one -- i'm selecting only one of each):

a. a web server / web server interface

`hunchentoot` for a server, `clack / lack` as a web server interface

b. data access library + ORM or SQL generator

I like `clsql` a lot.

c.  HTML5/CSS generator

`spinneret` is nice

d. JSON generator / parser

`jonathan` worked fine

e. ""mini framework"" to route requests to Lisp functions

no choice from me yet, see URLs above. 
",1533853568.0
duncanbayne,"I've been building an educational web app with hunchentoot, cl-who and parenscript.  

It's been a pleasant experience, with the only irritation being the fact that it's impossible to compose cl-who macros  the way I'd like.  Vsevolod Dyomkin has a good writeup of the problem, and potential solutions, here: http://lisp-univ-etc.blogspot.com/2009/03/cl-who-macros.html.",1533853195.0
Gosun,"You're not gonna get many responses in favour of Clojure here, this forum is predominantly CL fans, some of which don't acknowledge Clojure as a Lisp.  


With that being said, Luminus (Clj) is pretty good. Allows you write the front and back end of a web application in a Lisp. It is lightweight, more akin to Ruby's Sinatra than Rails.",1534752780.0
Lower_Cryptographer,"Call me immature but I always found the name ""Ass-Imp"" ridiculous (I get that it stands for asset import).

EDIT: http://www.assimp.org/index.php/docs/2-uncategorised/11-faq OK it's recognised by the FAQ",1534240362.0
metayan,How about drawing massive amounts of lines in 3D – with instancing?,1533736647.0
singularineet,There's a reason people don't build hardware like this: it's slow and specialized for the wrong things. It forces many operations to be mandatory which can usually be eliminated at compile-time. It's sort of a contradiction in a funny way: the very sorts of sophisticated analysis that allow this Scheme Machine design to be done also greatly reduces the necessity for such a design.,1533666462.0
xach,"There is a highly popular HPC project called ""slurm"".",1533646018.0
capitaomorte1,How does this work?  Is there any documentation for this that I'm missing?,1533806074.0
defunkydrummer,"Really cool logo, I must say.  Looking forward for the documentation!",1533837912.0
bitwiggler,Seems incomplete. Back to using Thinatra.,1533918546.0
MWatson,"Wow, that is cool! I am a very long time Lisp programmer but haven’t yet spent much time with picolisp. Just put working through these examples on my todo list :-)",1533556943.0
sordidaugust,Yeeeeeeeess!,1533522599.0
eduol,"I think everyone who answered until now is misunderstanding the question.

The point is Lisp has *the code* represented as linked lists and the OP wants to know which perks, problems and differences would emerge in a homoiconic language (in the Lisp sense) whose code where represented as arrays.

I'm not able to give an adequate answer, though. ",1533429879.0
,[deleted],1533428543.0
geocar,"Yes! It's called ""k"" and it's not *obviously* a lisp since it uses M-expressions instead of S-expressions normally, but:

* It's homoiconic
* Functions are first-class
* Code is stored as an array (of characters!)
* [k can manipulate its own code](http://smuglispweeny.blogspot.com/2008/02/ooh-ooh-my-turn-why-lisp.html), which is an essential part of being ""a lisp""",1533450592.0
stassats,"If you want to represent the code itself as arrays (which still doesn't make sense based on the premise that it'd be easier to port or more efficient), here's some code that is stored in arrays:

    #(defun foo #(a b c) #(+ a b c))

boom, looks exactly like a ""list-based"" lisp. Change the syntax of ( to produce arrays and not lists, and it's back to square one.",1533431535.0
mysleepyself,"Your question is a little vague and I think it might be helpful to edit it with what features of arrays, lists, lisp, programming languages, etc that you're trying to get information about. Right now you will probably continue to get responses based on the various ways to interpret your question that might not really match the interpretation you have of it.

As abstract structures essentially anywhere you have a list you can use an array since you can always define one in terms of the other and to a certain extent any language that supports arrays and reads source code as arrays of characters is already homoiconic. I'd bet any problem that you can work with in a cons car cdr context you could also work with via arr[n] and concatenate type tools more common to arrays.

From my experience as far as how to view break down and solve problems in a manner natural to the language you are writing in C feels pretty array oriented. Dealing with arrays in C just feels good whereas linked lists are a bit more of a hassle.",1533435196.0
bopub2ul8uFoechohM,"The idea that Lisp is homoiconic because it uses lists is slightly wrong.  While cons can be thought of as linked lists, they are actually a binary tree.

Consider for example: (+ 1 2 3)  While this is a ""list"", this is also a binary tree:

      .
     / \
    +   .
       / \
      1   .
         / \
        2   3

This is significant because non-Lisp languages have syntax that also parses into a binary tree.  Consider the common expression 1 + 2 + 3.  This would parse into something like:

        +
       / \
      +   3
     / \
    1   2

So one way to look at the difference between Lisp and non-Lisp is that non-Lisp languages need to be parsed into a parse tree, whereas Lisp code already exists as a parse tree.  Other languages like Python can in fact manipulate the parse tree, allowing metaprogramming similar to Lisp, but the fact that you have to go through the language parser first makes it a huge hassle.  It also means you can't trivially customize the syntax -> parse tree transformation, you can only modify the parse tree afterward.",1533436498.0
casecorp,You're looking for http://www.rebol.com,1533435640.0
johnboudewijn,"I don't think it matters for portability, a linked list is  easy to implement in any language. Remember that the list representation is temporary. Lisps that care about being decently fast usually compile to bytecode anyways, at which point the list based code structure is lost.

I think the main reason for parsing the source into a list instead of an array or struct is that it's easier for macros to work with. Macros commonly add, remove, or insert items from the source tree and doing so with an array can be awkward and could require reallocating the entire array.
",1533442758.0
munificent,"I have toyed with making one for kicks.

Linked lists were clever idea from McCarthy because they let you define a *very* minimal set of primitives because you don't even need numbers. Also, being able to reuse the tail of a linked list is handy sometimes.

But most programming languages don't use single linked lists, and they aren't exactly efficient. So I spend a little time tinkering on my own lisp implementation (I called it ""visp"" for ""vector lisp"") that used fixed-sized arrays to represent lists. I got distracted by other things before I get very far with it, though.",1533484321.0
rpiirp,"The easiest answer would be to say that machine code uses arrays for both code and data. Add a ""human friendly"" readability layer complete with macros aka assembly language and we're done ;-)

On a more serious note there is for example Lua which heavily favors tables, a combination of arrays and hash maps, for its data. I sometimes ask myself how Lua would look like if it had a way to represent code as tables with a ""natural"" method to manipulate said code in semantically meaningful way. My ideas so far are too vague to explain here.

I guess there's a reason why most systems use tree like structures, which of course are just lists in Lisp, as their intermediate code representation. ASTs seem easier to refactor than ASAs.",1533440516.0
paulfdietz,You might want to look at Clojure.,1533429006.0
blaine_freelance,Is there much difference between a list and an array?,1533437302.0
crabbone,"In Julia AST is made up of nested arrays.  So, it might fit your description.

However... there are some problems with describing what arrays actually are, especially in the same terms Lisp was defined.  I.e. if your only way to construct pieces of programs is by combining pairs (or any finite number of elements), then you don't have arrays.  They become inexpressible in your language, and that is why there are problems with defining types for arrays.  The problem is essentially as follows: if your construction method allows only combining N members, then only arrays of length N can have the random access implemented in constant time (which is essentially what makes them different from lists).  Once you need an array of N+1 or more elements, you must introduce indirection, similar to how it happens with lists, essentially, creating something like a B-tree.

----

In other words, you must start your language with axiomatically introducing arrays, and this is just not how Lisp functions... so, I'm guessing, you will never have array-based lisp, but you may have something that has similar properties.",1533482722.0
lisper,">  I was wondering if a “lisp” based on arrays existed?

Did you really mean arrays, or did you mean vectors?  If you really meant arrays (i.e. with >= 2 dimensions) then the answer is no.  If you meant vectors, then the answer is ""sort of"".  Yes, there are Lisps that represent code as vectors rather than linked lists.  No, none of them have ever seen widespread use.

The best way to understand why is to write your own EVAL function that operates on code represented as vectors (of arbitrary size) rather than cons cells (which are just vectors of size 2).  It's not hard to do, and you will learn a LOT about why Lisp is designed the way it is, and why that design has survived for so long.  Your understanding will be much deeper if you do it yourself than if someone just explains it to you.
",1533485651.0
republitard,"The most popular Lisp-like language that does this is Clojure. You're right that abandoning lists makes it it easy to graft to other languages (ClojureScript is a version of Clojure that is grafted to JavaScript instead of Java).

The disadvantage of this is that programming in Clojure is a lot like programming in the language that it's grafted to, and you need knowledge of the host language and exactly how Clojure grafts to it to use Clojure effectively. ",1534049407.0
stassats,"Lisp isn't based on lists. So, any will do, e.g. Common Lisp.",1533428020.0
swatson741,I guess python or fortran with it's array slicing could be thought of like a lisp for arrays.,1533430706.0
dzecniv,"Nice guide, thanks.

maybe also: https://github.com/40ants/defmain a short helper.

Until the ""sequential"" section at least I see no difference in process and feature list with the simpler [unix-opts](https://github.com/libre-man/unix-opts/) ([cookbook](https://lispcookbook.github.io/cl-cookbook/scripting.html#parsing-command-line-arguments)).",1533206137.0
demosthenex,What a great document! Now I have to try the library!,1533231028.0
Lt_Riza_Hawkeye,"interesting that it starts out with instructions on how to install sbcl, but then assumes that after installing sbcl you also installed quicklisp",1533235648.0
coolmedium,Mega cool,1533142367.0
flaming_bird,AFAIK it uses JSCL internally.,1533154484.0
Paradiesstaub,The Go documentation has this feature since ever and it is pure awesome.,1533227710.0
lispm,"up to 0.6.4
http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/impl/clicc/0.html

0.6.5, licensed under GPL
https://github.com/plops/clicc

This is old software from the 90s. mocl is based on the non-GPL version of CLICC with extensions and ports to macOS iOS and Android: https://wukix.com/mocl

I have collected a few [German and English language papers about CLICC] (http://lispm.de/docs/Publications/Common%20Lisp/CLICC/).
",1533107898.0
FormerAct,Could someone explain me (noob in informatics) if this allow to run lisp written programs with C speed?,1533116936.0
shelvick,Link is down for me right now. Did we crash their website? ;-),1533098465.0
CelloAxeMurder,"I found this project after creating a WebAssembly program using Ferret and then giving up trying to do the same with ECL. So far porting it to Common Lisp has been going OK, but I'm surely a naive n00b. I don't think it'll be ASDF/Quicklisp-able anytime soon.",1533140374.0
unxn3rd,"Thanks to lispm for posting this /r/Common_Lisp... I was planning on posting this as well. you beat me to the punch :-) Also, just for folks to know, I am one of the organizers of AFP and the organizer of these study groups. If you have a particular suggestion for a topic that you'd like us to discuss, comment on the Youtube or free to comment here!",1533048094.0
flaming_bird,"Literate programming taken to the extreme. **ALL** source code for that project is stored in a single org-mode file, and extracted from it for compilation.",1533046561.0
SlightlyCyborg,I wanted something like this a few years back to program a robot in clojure. I ended up using firmata which wrapped the entire Arduino API in a serial protocol. This is even better.,1533052545.0
chunsj,"So, this is java or jvm based clojure-like language to c++ translator. ",1533084770.0
hsribei,How does it compare to Carp?,1533116538.0
piotr404,Fifty !,1533045446.0
timezone_bot,"6pm UTC happens when this comment is 11 hours and 36 minutes old.

You can find the live countdown here: https://countle.com/f230601mTJ

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1533018190.0
chebertapps,"start simple with the dice notation and add more features
An example progression:

- v1: parse AdX notation (1d4)
- v2: parse dX notation (d4)
- v3: parse AdX+B notation (2d8+3)
- ...
- vn: parse fudge dice or % dice or multipliers, etc.

just be sure to _take it one thing at a time_.

You could easily use regular expressions: [cl-ppcre](http://edicl.github.io/cl-ppcre/) is a solid choice.
If that's too complicated, you could make something work using [split-sequence](https://www.cliki.net/SPLIT-SEQUENCE), using a delimiter of the character ""d"" and ""+"". Both are available via [quicklisp](https://www.quicklisp.org/beta/).

Using random.org is a neat idea. good luck!",1533019842.0
Aidenn0,"Learning to write a parser is very useful.  If you aren't going to support parenthesized expressions or multipliers, then it's pretty easy just to read one character at a time:

e.g. pseudocode for parsing \[A\]dX where A is optional:

    (defun read-prefix (input-stream)
      (if (not (digit-char-p (peek-char input-stream)))
         1 ;; No leading number (e.g. d4 means roll 1 die
         (parse-integer (read-all-digits)))
    
    (defun parse-dice-notation (input-stream)
      (let ((prefix (read-prefix input-stream)))
         (assert (char= (read-char input-stream) #\d))
         (let ((suffix (read-suffix input-stream)))
           (values prefix suffix))))

read-all-digits is left as an exercise to the reader, and reads a string from the stream until a non-digit character is found.  This example lacks error handling and probably has unmatched parens, since I just typed it.

If you want to do fancy things like `3*(1d4+2)` then you'll need to learn some way of doing more complex parsing, which is good to learn eventually, but is likely not necessary for a typical die roller.

FWIW, Ironclad's strong-random is going to be just as high quality as random.org for dice rolls.  The builtin CL:RANDOM function is honestly good enough, so long as you reseed it on startup (by default it will produce the same numbers from startup in order to make debugging and testing easier).",1533062309.0
jacobb11,"Well, you could use an expression parser.  There's probably reasonable ones lying around or you could read a compiler book and learn how to do it yourself.  But I'd try to just wing it with a regular expression, as in practice just a few variations are probably all you really want.

I would also use Common Lisp's own psuedo-random number facility rather than random.org.",1533018571.0
Lt_Riza_Hawkeye,SBCL will probably have the most numerical analysis libraries available to you. There is no one right answer,1532958050.0
Eigenspace,"Common Lisp is actually pretty solid for numerical computing and interactive stuff, but the ecosystem doesn’t have as much vibrance and activity as one might like. In particular I remember looking at a lot of packages and never being quite sure if they were abandoned or just didn’t need updating in the last 5 years. SBCL is likely your best bet if you want traditional Lisp syntax. 

However I’d argue that Julia is better for interactive data exploration and its community is bigger and more geared towards that topic (its a language very focused on scientific computing, especially numeric).

Julia doesn’t look like a Lisp at first glance but it’s  actually very much along the lines of Dylan but with a numeric bent. All code is parsed into `Expr` objects which are structured in a way similar to S-expressions. Code as data can be operated on like any other data type at run time with regular functions or at compile time with macros. The language implementation itself is screaming fast too, which is important for numerics. The macros aren’t the only thing that make Julia lispy but they’re the most obvious. (By the way, there’s even a Julia package that lets you write Julia code with Lisp syntax, LispSyntax.jl and LispRepl.jl)

Whether or not one wants to call it a Lisp isn’t particularly important. It at least learned the right lessons from Lisp, lessons that it seems almost no other modern languages want to learn.

If you’re interested, the subreddit for Julia is a bit of a ghost-town but the Julia-Lang Discourse page is very active and the Slack channel even moreso. ",1533138448.0
mikeivanov,"You could try to convince yourself that R is a form of Lisp (it used to be, initially, and still sort of is -- under the hood) and just deal with it.",1532978207.0
_priyadarshan,"If this would be real, it would be quite interesting. [But it sounds more like a joke](https://news.ycombinator.com/item?id=17605954). I wish it was real, though.

> A surprising consequence of the model is that the human mind has a 44 1/2 bit address space.",1532945259.0
guicho271828,"> optimization: adding 1 to or subtracting 1 from a fixnum variable does not cons. 

What does it mean? I never saw an instance that fixnum is consing. Is it more like register assignment related issue?",1532840454.0
stassats,"sb-alien is supposed to be more type-safe, potentially at some additional cost.",1532877000.0
,[deleted],1532865592.0
xach,I don't know but an email to lispworks will make this clear very quickly.,1532824503.0
gaze,I was wondering if lispworks with their lisp or embaracadero with delphi were gonna be the last to hold out for insane prices for their IDEs for hobbyists. Looks like lispworks won.,1533738758.0
jibanes,let us know what you find out :),1532840943.0
flaming_bird,"The newest demo features McCLIM, Quicklisp, FAT32, a generational GC, and a new compiler backend.",1532792832.0
MWatson,"Wonderful!!

I have played with two previous demos, and I can’t wait to try demo 4 when I get home from my travels.

I had a hardware Lisp machine, a Xerox 1108, in the 1980s and it would be awesome to get something fun and hackable on an old laptop.",1532818682.0
Maneatsdog,"Congratulations to the Racket contributors! 

Perhaps someone from the community can comment on how important it is to have Racket-on-Chez and what will be the things to look forward for in the future?:) ",1532800276.0
Baggers_,"For those watching in first hours after upload the episode starts at 6:29. One heads up, the gpu-array for the tangent/bitangent data was totally wrong, its amazing it 'worked'. I have since fixed up the code a little and pushed a new version to github. Thanks to chat again for being awesome and appologies I didnt read you messages as often as I should have.﻿",1532556339.0
xach,No.,1532459062.0
timezone_bot,"6pm UTC happens when this comment is 2 hours and 14 minutes old.

You can find the live countdown here: https://countle.com/c226850z9-

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1532447136.0
vaulteleven,"Your twitch link is broken, the underscores are not part of the link if you click it :)",1532538278.0
lispm,"There are a bunch of CL variations. Generally the ANSI CL Common Lisp is a mid-sized version of Common Lisp. Note that the standard does not specify a full language (it does for example say nothing about garbage collection and how it interacts with the rest of the language), but a language which might be implemented in different ways or needs to be extended. Examples are new character and string types to support unicode. Another examples are conditions and streams - the ANSI CL standard does not say that they are CLOS-based. The ANSI CL standard also does not include the Meta-Object protocol - larger implementations often will have both: CLOS based implementations of conditions&streams and an extensible CLOS. Implementations usually have an extensible version of LOOP - extensions are not in the standard.

So there is a whole bunch of things one might expect in a real full Common Lisp implementations and which are not a part of the standard.

Additionally there were/are smaller versions of Common Lisp - mostly a) historically, since the CLtL1 'standard' was a smaller CL (no CLOS, no Conditions, no LOOP, ...), b) because some implementations only provide a subset of CL, when a full CL was too much work or not needed in scripting implementations, c) because an explicit subset could be compiled more efficiently.

Plus there are very CL influenced smaller languages, like the original Dylan or ISLisp.

So examples for smaller CLs are

* those who implemented CLtL1.

* the original XLisp, Powerlisp and a bunch of other small Lisp implementations

* L, a Lisp for robots

* uLisp, a Lisp for Arduinos

* CL0, a language of efficient delivery implemented by CLICC and MOCL. There is a real language documentation for it. http://lispm.de/docs/Publications/Common%20Lisp/CLICC/CommonLisp0%20and%20CLOS0,%20The%20Language%20Definition.pdf

There are many more examples of implementations which only provide parts of the language.

Probably there are a bunch of others - implementations of small CL-like languages and actual language descriptions. Some might look slightly different (Stella, CycL, ...), some are experiments, some are embedded languages in applications (one might think of Autolisp, since that was originally developed out of Xlisp, ... and some other applications with Lisp-based scripting).",1531984318.0
ruricolist,"ISLISP was standardized at the same time as CL, and CL actually added some features (e.g. \`define-symbol-macro\`) so ISLISP would be a subset of CL.",1532128326.0
defunkydrummer,">I was wondering (out of curiosity) if there existed a smaller version of Common Lisp that was to some extent accepted.

Depends on what do you want to ""be smaller"". 

If you want the language to be smaller, well, you don't need to use all features at once. For example you can choose not to use CLOS, not to use type declarations, etc. etc. etc. So less ""language surface"" to learn too.

If what do you mean is that you want a Common Lisp *implementation* that is small, perhaps CLISP fits the bill. There are even smaller ones like Eclipse Common Lisp (not to be confused with ECL, Embeddable Common Lisp). 

If what you want is a CL implementation that produces small 'binary' (image or executable) sizes, I'd hazard a guess that the JIT-compiled implementations, like CLISP, should produce pretty small images. And then there's LispWorks which has a tree-shaker that is intended to reduce image/executable sizes as much as possible (see online documentation.)

But if what you mean is a *standardized minimal subset of the CL language*, i'm afraid this doesn't really exist, and you'd be better off taking a look at Scheme or perhaps PicoLisp (which is a very different Lisp), or the lisps mentioned by lispm in this thread.

Also note that, while in the 80s Common Lisp implementations were ""big"" pieces of software, nowadays they're not big at all.

",1532389481.0
tankfeeder,"BTW, we have minipicolisp",1531978725.0
flaming_bird,"I haven't stumbled upon a CL variant that's ""to some extent accepted"". If anything, there are other Lisp dialects that are much smaller than CL, but they're separate dialects altogether.",1531980334.0
aiaor,"What advantages would a smaller version of CL have, and how would using it be different than simply using a subset of the features of CL?",1531980555.0
MWatson,"You can choose for yourself a subset to use.

I have been using Lisp languages since about 1980 and I use a subset of Common Lisp that I feel comfortable with and find very readable: I rarely use LOOP and use macros and CLOS very sparingly. 

I do the same with Haskell: use a subset, few language extensions, and a few monoxide patterns for the kinds of applications I write.

Most Scheme dialects are simple enough that I use most of the language.",1531999419.0
kdnbfkm,"There's always the bug-ridden lisp500.c or xlisp.

Xlisp doesn't have a built-in debugger so the program ends with the smallest typo in the REPL and is missing some macros/functions so it won't run many pre-existing programs, and xlisp has an alternative object system not the CL standard CLOS/MOP. However xlisp is easy to compile and doesn't require extreme configuration or system compliance to compile... (hint: use the unix Makefile).",1531978682.0
bjoli,"> Like in my mind on the scheme side of the lisp family there’s like RxRS as the small language and Racket (among others) as the big one.

Rnrs is more like the standard base of scheme, which many builds on. Chibi scheme would be something like chibi that is easy to embed and uses very little resources. Racket isn't really the big brother of scheme, but really just a language that builds on scheme.

We are many that prefer other schemes, since even though racket is flashy and all that, it still lacks a lot of things. Proper threading and things like a proper object system (whatever they are using now is very much java whereas guile has something a lot more CLOS)",1531984733.0
flaming_bird,"1. I have successfully built and deployed multiplatform Qt4 applications using Shinmera's qtools and I enjoy that toolkit.
2. I don't know what rofi is, so I can't really help you with that one.",1531921034.0
andy128k,"cl-gtk2 is great library to write GTK+ applications. I had used it to create [my application](https://github.com/andy128k/PassStorage/tree/common-lisp) for managing passwords. Unfortunately it supports GTK+2 only.

Another option is to use [GObjectIntrospection](https://github.com/andy128k/cl-gobject-introspection) to invoke g\* libraries.",1531928527.0
sammymammy2,If looks are irrelevant go McCLIM,1531924746.0
defunkydrummer,">Is CL really bad/complicated for GUI programs? Is there not a simple way to build a GUI ala Racket?

For what it's worth, for very simple stuff (like what you mention, for example) I used the `ltk` library, which allows you to build GUIs using the TK toolikt (from Tcl/Tk) from Lisp. It's very easy to use and it has a useful documentation. 

This requires you to install a Tcl distribution, which is probably already installed in your computer. 

It's just an option, of course there are more options mentioned in this thread and which *should* be even better (McCLIM, Qt), but I just wanted to say that I found LTK fine for simple UIs. 
",1531933585.0
ObnoxiousFactczecher,"Personally I'd love to see an [IUP](http://webserver2.tecgraf.puc-rio.br/iup/) binding, potentially with Cells integration. That would be really nice. Definitely going to have a go at it once there's some free time (hahahaha ^(*cries in the corner*))",1531943320.0
Aidenn0,"A native GUI project is probably \*not\* the best first project.  That being said, for simple gui programs ltk is pretty doable.  Qt4 (as others have mentioned) has a reasonable story as well.

The GTK story is bad, partly because the GTK API is so terrible -- I was trying to write my own adapter where I would wrap just the API calls I was using, and I discovered a function that returns a handle.  Sometimes the handle is owned by you, sometimes the handle is not (it depends on the parameters).  Properly automatically managing resources that behave like that is not fun.

If you are dead-set on GTK, I have an experimental wrapper that works by launching a mono service linked with GTKSharp and it sends commands across a socket.  It's slow, but works surprisingly well (tab completion including parameter names for every single api call), but even working with a complete API in a runtime with introspection, I found new things to dislike about GTK's API (Some classes have a method named ""New"" which is obviously distinct from the keyword ""new"").",1531942022.0
timezone_bot,"6pm UTC happens when this comment is 20 hours and 49 minutes old.

You can find the live countdown here: https://countle.com/-222791wiB

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1531861814.0
paulfdietz,This is why we need package local nicknames.,1531962435.0
flaming_bird,"Lisp has no exceptions, it has signals.

A workaround I thought of: if you know the names of the packages that create name conflicts, you can create a custom handler function that will rename one of the packages to resolve the conflict, and then call `QL:QUICKLOAD` again, until it finishes without signaling an error.",1531849988.0
blue1_,"You don't have to necessarily use everything you read in *On Lisp*, but as a course in heavy macrology it is quite interesting (probably this same comment applies, to an even greater degree, to *Let Over Lambda*).

Another book worth considering IMO is *Common Lisp Recipes*. Less mind bending, but also the only recent text dealing with ""practical"" matters.",1531847824.0
charlieb,It was a real mind-opener so I found it useful for the intellectual exercise but I don't think I've directly used anything from the book.,1531850884.0
defmacro-jam,"Ignore whether other people find it of value.  Read it.  Do any exercises you find.  Make up your own mind on its value.

I for one, enjoyed it.  ",1531847365.0
flaming_bird,"I have read it and enjoyed it. It's good to take Graham's opinions with a big pinch of salt, but the knowledge he passes through that book is worthwhile in my opinion.",1531848009.0
mobius-eng,Also for some CL wizardy I'd recommend The art of metaobject protocol.,1531894506.0
jaoswald,"I happen to enjoy On Lisp. Some people have legitimate criticism of some of Graham's style, but those are generally minor.

Another excellent book is Paradigms of AI Programming. Not really about AI.",1531877555.0
CallMeMalice,"On Lisp is a course in writing Common Lisp macros. The book goes over different macro types. Each chapter starts with some motivation (why you would want such thing), and then shows how to implement such a feature in CL.

Some of the macros can get quite advanced, especially if you don't have prior macro experience.

However, macros are not necessary to write programs in Lisp. They can make things simpler, more elegant or faster, but you can use other abstractions (although they might be less elegant or require more code).

If you want to learn macros, read it. If you don't, well... still read it. If you don't like it you can always put it back on the shelf. I definitely think that this book is worthwhile.",1531858615.0
waspishly_simple,"Back when it was out of print I paid over £100 for a slightly dog eared copy from Australia.

And I consider it worth every penny. A thoroughly enthralling read.

Even though I don't write macros very often I found it really useful in understanding the macros I did use and how they worked, particularly the ""with-*"" style macros which always felt a bit magical.",1533130680.0
dzecniv,"And to get some style of Arc into CL, there's https://github.com/malisper/Clamp

> Arc is an amazing programming language because of its brevity and
succinctness, but at the same time, it lacks some of the most basic
features of a programming language. It has neither a debugger nor a
module system. Common Lisp on the other hand has many of the
fundamentals that Arc lacks and much more (restarts, reader macros,
etc), but lacks the conciseness of Arc. Clamp is an attempt to bring
the powerful, but verbose, language of Common Lisp up to the terseness
of Arc.",1531734492.0
zck,"I'm one of the Anarki contributors, although I haven't done much with/in it recently. My pitch for Arc is ""for what it does, it's very well designed."" This may seem like damning with faint praise, but it's really impressive how many things make the language pleasant for the programmer.

AMA, I guess, keeping in mind I didn't create this language -- my biggest contribution is writing a unit test framework for it that, as much as possible, doesn't suck.

EDIT: also check out [tryarc.org](http://tryarc.org/), a site which lets you, well, try Arc. It goes up and down; I'm not sure why because I don't run it.",1531685705.0
flaming_bird,Previous discussion: https://www.reddit.com/r/lisp/comments/8bshzw/lisp_jazz_aikido_three_expressions_of_a_single/,1531637013.0
aitatxi,I think this is already in the sidebar.,1531568116.0
Duuqnd,C and Lisp is all you need my dude.,1531605013.0
kuwze,I wonder how it compares to [Bondi](https://bondi.it.uts.edu.au/).,1531610093.0
luksamuk,"Can't say I dived too much onto it, but I'm a little careful when it comes to use a Lisp-like language with so many extra tokens. I can see Clojure references there, but the `<`, `>` and `$` symbols remind me too much of C++ and PHP, so it seems visually heavy and cryptic to me.",1531751840.0
_priyadarshan,"The fork seems far ahead of the original repository.

See also [about page](https://sirherrbatka.github.io/cl-data-structures/l_1.html#3489153149077281077).",1531489785.0
defunkydrummer,"I loved the man declaring `
(optimize (safety 0))` next to the rocket...

I thought Scheme would be ""you call the continuation that longjmps you to back when the dragon was a little baby....""",1531485917.0
theangeryemacsshibe,"I didn't think [https://toggl.com/blog/build-horse-programming/](https://toggl.com/blog/build-horse-programming/) was very funny. ^(TL/DR: the pleb observer: ""hahaha (((((((((((((((( i'm funny!!"")

The dragon thing was from another bad comic, which didn't have Lisp. I hope I covered all the big dialects with this.",1531475269.0
republitard,Why is Python in there but not its close cousin GW-BASIC?,1531905515.0
stassats,"If \*todo-list\* isn't exported by the TODO package which is used by the current package, then you'll have to prefix the package name.",1531413322.0
flaming_bird,I don't understand what's going on based on your description. Is your code published anywhere?,1531413402.0
dzecniv,"glad to hear you fixed your issue. A possible gotcha: the use of `make-instance 'todo` may (will?) bring problems if used from another package than the one defining the `todo` class. I suggest to define and export a constructor function: 

    (defun make-todo (description &key priority etc)
      (make-instance 'todo …))

",1531420669.0
kazkylheku,"Just stop using packages; leave everything in CL-USER and be happy.

Or else, use *just one package* for all your stuff.

Are you working in a large team? Or redistributing an API for wide re-use?

One-package-for-your-stuff is just fine for redistributing a framework, even a large one.
",1531417040.0
defunkydrummer,"""todo-list"" will be understood as the todo-list that is on the current package. This is the expected behavior.",1531418887.0
Grue,Finally a slime version compatible with Emacs 26?,1531398493.0
unxn3rd,original post was on /r/common_lisp from lispm. I thought some folks on the general lisp reddit might be interested in it as well.,1531281450.0
parens-r-us,FYI documentation can be found inside the tarball: [https://sourceforge.net/projects/series/files/series/series-2.2.11/series-2.2.11.tar.gz/download](https://sourceforge.net/projects/series/files/series/series-2.2.11/series-2.2.11.tar.gz/download),1531312056.0
understanding23,"zzzZZZZZ

Too much talking about crap that doesn't matter. The presenter should assume that his audience are not idiots and do the demo accordingly. Anything else and the only people he'll attract will be idiots.
",1531296916.0
dzecniv,"> As the ambitions of RDF and XML have expanded to include things like the Semantic Web, the limitations of this lightweight schema language have become evident. Accordingly, a group set out to develop a more expressive schema language, DARPA Agent Markup Language (DAML). Although DAML is not a W3C initiative, several familiar faces from the W3C, including Tim Berners-Lee, participated in its development. 

Is it implemented in Lisp ? hard to find.

http://www.daml.org/publications/cite.html

> Q:
>    How can I generate DAML from Common Lisp programs?
> A:
>    Use [Wilbur](http://wilbur-rdf.sourceforge.net/) ... 

unmaintained since 2010.",1531219489.0
Aidenn0,"This is a pretty good macrology example.

It's probably good to note that [Alexandria] implements these macros already though, as not everyone will know that.

[Alexandria]: https://common-lisp.net/project/alexandria/draft/alexandria.html#Macro-if_002dlet",1531190481.0
shelvick,Swiping right.,1531003820.0
xach,https://www.xach.com/misc/lambda.html,1531000540.0
arvid,"should have gone for the y-combinator tattoo

http://blogs.discovermagazine.com/loom/2008/02/17/y-combinator/",1531055035.0
kpenchev93,And I was wondering what tattoo should I have next...,1531049445.0
maufdez,"Nice to see my blog there, I actually published 13 parts, I've had some problems with my computer but I plan on continuing with the series, until I have a compliant RiveScript interpreter. I hope more people get to my blog thanks to this publication, it is currently followed steadily by only about 40 people, which means it could be more engaging.",1531184232.0
dangerbird2,"Common Lisp is pretty top-notch when it comes to error handling. Unlike most languages, including Clojure, thrown exceptions (""conditions"" in lisp-terminology) do not unwind the call stack. The [handler-bind](http://clhs.lisp.se/Body/m_handle.htm) macro allows the program to recover from an error at the stack level where the error is thrown. By contrast, a static error handling system like C++, Java, or Lisp's [handler-case] (http://clhs.lisp.se/Body/m_hand_1.htm#handler-case), which unwinds the stack to the nearest try-catch clause in scope. This is particularly useful when live coding with a repl or Emacs, where a thrown condition brings up an interactive debugger that lets you fix the error and continue program execution without losing the stack frame (unlike GDB or similar debuggers, this functionality is built into the language environment, letting you evaluate code within a debugger breakpoint)",1530824404.0
defunkydrummer,"Common Lisp has *exemplary* error handling, not just among the Lisp-family languages, but among programming languages in general.

Take a look at the ""conditions and restarts"" chapter of the ""Practical Common Lisp"" book (available online for free) and judge by yourself.
",1530825753.0
defmacro-jam,"As the other commenters have mentioned, Common Lisp is probably your best bet.

The Common Lisp Condition System has, as far as I can tell, the best thought out ""error handling"" system currently available. For a nice introduction, check out the [chapter about it in Practical Common Lisp](http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html) -- and the [Common Lisp Cookbook](https://lispcookbook.github.io/cl-cookbook/error_handling.html).",1530826025.0
joinr,"I'd recommend downloading [portacle](https://portacle.github.io/), firing it up, and entering something like

    (nth 10 :a)

Into the repl.  That'll toss an error at you.  The error frame that pops up is interactive, and you can dig down into previous frames, look at locals, etc., and choose an restart if you'd like.  

CL + slime (and the bevy of tooling portacle bundles) places CL pretty damn high on the list of ""any"" languages and error handling.",1530837686.0
ac1235,All those CL answers didn't understand the original post and only read its title.,1530890569.0
mobius-eng,"If you only look at error messages check [DrRacket](https://racket-lang.org/). Otherwise, I second Common Lisp, but it cannot be implemented on JVM without a performance hit (check ANSI-compliant [ABCL](https://racket-lang.org/)).",1530825500.0
olaeCh0thuiNiihu,"It sounds like you're asking for a language with good error reporting in the standard library, not good error handling in a language.  I haven't encountered a Lisp with exemplary error reporting (compared to, say, Python tracebacks or LLVM compiler messages), but the Common Lisp language has very powerful error handling.

Error handling is part of the language, error reporting is part of the implementation.",1530834081.0
phalp,"> with its nested syntactical consistency, must make writing a Lisp environment that meets either Elm or Hejlberg's standards nightmarishly hard.

Macro writers are in a position to sabotage the error message quality. Very important to realize that as you write a macro, even if bad input will get caught by the compiler later, you have the power to make errors clearly reported or not.",1530830883.0
WhatImKnownAs,"Regarding the concerns in that article about Clojure's runtime error messages being poor, normal Lisp implementations are better. Types and preconditions are generally checked (unless you specifically `(declare (optimize (safety 0)))`). You wouldn't expect to see an OS exception due to a bug in your program. The messages tend to be useful, and as a bonus, as others have pointed out, Common Lisp error handling is really useful, there are often restarts that allow you to hack past the problem and continue.

Stack traces tend to be quite useful, since you'd be seeing the state at the level of your program, not the underlying implementation (although variables may have been optimized out, of course). In the best environments (Genera, LispWorks, probably others), the objects listed in the trace can be picked up, inspected and modified.

Compile-time error reporting varies more, I think. It really depends on much trouble has been spent in the compiler implementation to check and report problems in source code terms.",1530865544.0
waspishly_simple,"> writing a Lisp environment that meets either Elm or Hejlberg's standards nightmarishly hard.

Reading the Elm article you linked: Common Lisp (+Slime+Emacs) does that already.",1531131346.0
bobbane,"Support.  Some applications can't wait for the open source fairy to fix bugs or performance problems.

I have no experience with LispWorks, but if you are a paying customer of Allegro, and you submit a complaint about anything:

* your issue goes to the head of the line
* you will likely receive a patch within days
* the fix will be in the next release

There are a few software companies whose support is worth paying for.  In my experience (\~10 years ago, unfortunately), Allegro is one of them.

My only connection to them is as a former customer.",1530812716.0
lispm,"You might want to check a rough overview yourself:

http://www.lispworks.com/products/features.html",1530774973.0
CelloAxeMurder,Once I had a dream that I had perpetual LispWorks enterprise license. It was very nice dream. The documentation even came in paper books.,1530820916.0
waspishly_simple,"I don't use either but I have looked several times (hundreds of pounds for a crippled hobbyist license is a bit shit).

The reasons I would pay, but not that much and not for crippleware are: the IDE (although it is a bit clunky), a supported x-platform CLIM, stable and supported libraries.

But none of those are worth the price to me as a hobbyist.

I mean just compare what you get in the free version of say JetBrain's IDEA and the crippled version of either commerical CL that you have to pay at least several hundreds for, and if you change platforms, even from 32->64 bit, you have to buy a new license.

If my living depended on it I might pay.",1530791418.0
understanding23,"Substantially worse performance and lack of features that matter (Lispworks and Allegro got native threads that could take advantage of multiple processor cores, without a GIL, years after SBCL) .",1530797077.0
kdnbfkm,"Funny, I was just thinking of issues like this. Generally speaking you would expect professionally made proprietary software to be superior because they could steal from open source and add private enhancements.

It might not work out that way in every case in the real world, and much open source is copyleft...

A large enough open source project can have the manpower to do big things but that could be stolen too... It won't always be that easy, what if the archetecture is difficult to integrate with?

And why should there even be Open Source, as we know it that is?",1530816073.0
xampf2,This threads reada more like /r/trees than /r/lisp.,1531105788.0
flaming_bird,Re-added because of a HN discussion at https://news.ycombinator.com/item?id=17439171,1530515693.0
,"Cool, I was looking for something just like this!",1530527325.0
ac1235,Everybody reading their blog.,1530507141.0
understanding23,"I think it's safe to say that they didn't know what they were doing re: Common Lisp. It should be obvious to anyone that reads the code.

The reason they went with CL is probably PG rather than previous experience and familiarity with the language. 
",1530535740.0
sucharyan,"Source code: https://github.com/reddit-archive/reddit1.0

On their transition from Lisp to Python: https://redditblog.com/2005/12/05/on-lisp/",1530509121.0
yugoplast,"I believe that was the reason for reddit being successful. Paul Graham advertised reddit on the cover page of his website with a laconic ""Reddit is written in lisp. Kabo isn't"". PG had a huge fanbase of avantgarde nerds at the time, thus frontloading reddit with the most interesting people from slashdot who loved each other. Digg, at that time on its way to the biggest website on earth, could not compete in terms of sophistication in links and debate. I can't remember who or what ""kabo"" was. ",1532965975.0
,[deleted],1530501865.0
timezone_bot,"10am PDT happens when this comment is 16 hours and 47 minutes old.

You can find the live countdown here: https://countle.com/kub215504j

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1530317530.0
mac,"Is the first episode available anywhere?
",1530363674.0
thelolrus,Alternatively: [https://www.twitch.tv/events/Yh7I84GuTSKRNZ6oKg1g3Q](https://www.twitch.tv/events/Yh7I84GuTSKRNZ6oKg1g3Q),1530328984.0
CzerwonyCzarodziej,"I’m pretty new to Lisp, recently I installed SBCL and seems that Windows is second class citizen. Is there any explanation for this? Should I Maybe choose some other compiler?",1530312754.0
aitatxi,"Could someone elaborate on this?

> enhancement: SB-COVER instrumentation for x86[-64] has signficantly less overhead. The performance penalty for 64-bit code has been measured at around 30% slower than uninstrumented code as contrasted with slowdowns in excess of 100% previously. ",1530293473.0
metroholografix,"Can someone elaborate on the macOS fixes, what was the issue and how it was solved?

I'm assuming these bugs are relevant:

https://github.com/lispgames/cl-sdl2/issues/105

https://github.com/borodust/trivial-gamekit/issues/24

stassats commented on the first bug report:

    (let ((pthread (sb-sys:int-sap (sb-thread::thread-os-thread sb- thread:*current-thread*))))
      (setf (sb-sys:sap-ref-lispobj pthread #xb0) sb-vm:*control-stack-end*
            (sb-sys:sap-ref-lispobj pthread (+ #xb0 8))
            (- sb-vm:*control-stack-end* sb-vm:*control-stack-start*)))

it's not clear what the issue is just from this? macOS expects certain
values to be present in a thread's stack?",1530304250.0
Baggers_,For the first few hours the episode will be at https://youtu.be/Zv_0U5kVIf8?t=9m34s,1530135957.0
Lisp-S-R-C-L-D,"The music and the light effects ... let's party !!! :-)  
thank you",1530147928.0
thelolrus,"No lisp code is public yet, sorry. You may know me from the ""Comfy lisp coding"" video I posted here once. :)

[http://dailyprog.org/\~kenster/](http://dailyprog.org/~kenster/)

I stream on twitch also (if the vid is not live anymore, I may be streaming part 2): [https://www.twitch.tv/kingherring/](https://www.twitch.tv/kingherring/)

Please donate (CC or paypal): [https://streamlabs.com/kingherring](https://streamlabs.com/kingherring)

TinyCDN github: [https://github.com/kennymalac/tinycdn](https://github.com/kennymalac/tinycdn)",1530121279.0
thelolrus,For anyone still interested in this there is a part 3 I'm doing today [https://youtu.be/-JWVx-W0rmA](https://youtu.be/-JWVx-W0rmA) or [https://www.twitch.tv/kingherring](https://www.twitch.tv/kingherring),1530289480.0
ws-ilazki,"I had a TRS-80 CoCo when I was a kid, I think my grandfather got it cheap when the local Radio Shack was clearing out some old stock to make way for newer versions.  Anyway, the two things I still remember strongly about it:  1) the keyboard was awful, and 2) It had some form of BASIC on its ROM, listed as version 1.0, and I will remember my hatred of it forever.

It wasn't any particular issue with the language itself, really, it was hate for the line editor, which was awful.  I forget if it was a lack of backspace or no way to move the cursor, but I remember that any time I made a mistake anywhere in a line — which happened often, thanks to the horrible keyboard and being a poor typist — I had to start over, re-typing the entire thing.  It was super frustrating and took away a lot of my desire to experiment with the language.  Later on I got access to a Commodore 128, which had line editing, and it made a huge difference; I was on that thing constantly making terrible spaghetti-code programs and enjoying every moment of it.  

The point I'm getting at is, I wonder if this lisp had a better editing environment?  If so, it might have been really appealing to me as a kid if it did.  I wanted to learn and do so much with that computer but it felt like it was fighting me at every turn.



",1530114266.0
f0urier,"~210$ full price to modern money, not that expensive actually!",1530085906.0
kazkylheku,"Not available thru Radio Shack. Now there is a shocker!

The Shack narrowly escaped being a Lisp vendor.",1530109290.0
hoijarvi,"There was a an implementation for Commodore64 called ComLisp. I played with it a little, it was OK for experimenting with the language. ",1530116755.0
MrWoohoo,I don’t think the Coco counted as a TRS-80. The TRS-80 was a Z-80 based machine whereas the Coco was an entirely new computer that was built around the 6809.,1530088537.0
awesley,"Did it ever ship?   Back then, I was anxiously waiting for some TRS-80 Color Computer software (I think it was an OS and assembler) that never shipped.",1530107700.0
waspishly_simple,"I'm surprised no-one else had said this.

For a beginner it's consistency (and a simple syntax).",1530082185.0
Captain___Obvious,"A month?  Try the first few chapters of SICP:

https://sarabander.github.io/sicp/

https://www.youtube.com/playlist?list=PLB63C06FAF154F047",1530081410.0
lispm,"The code-as-data experience makes a real difference. This enables and makes it easy to use Lisp interpreters, Lisp compilers, macros for incremental code generation, interactive development, ...",1530083379.0
dajoy,"Working with lists and trees, of data and code.",1530078304.0
defunkydrummer,">I'm starting as an undergrad in Web Development in a month, and I was wondering on how to spend my time until then. I already use Emacs, so Lisp is an obvious choice. But I looked into other options, especially Python. So I must ask: what specialty of Lisp differentiates it from other languages, especially from a beginner point of view?

(defparameter *lisp* common-lisp) ; please assume Common Lisp when reading ""Lisp"" here.

You asked ""what makes it easier for a beginner to learn"", and I'd say that Lisp isn't particularly easier than other languages to learn, mainly because it is also massively more powerful than many other languages. Now, it does have some important pluses for easier learning:

- *Everything* is an expression. 

- There are almost no silly restrictions that would require workarounds or kludges. To put an example of such a silly restriction, long ago Java didn't allow you to use `switch` statements on strings. Modern silly restriction: Go doesn't support generics (nor exceptions, nor macros, nor...) -- thus requiring workarounds or kludges instead.

- The syntax is exemplary uniform. 

- It is thoroughly documented (see the Common Lisp Hyperspec)

- There are many well-written tutorials and books

- It is a truly interactive system, you can add compiled functions to the ""live"" system on the go, and thus build your system as you write it. 

- The thing ""just works"" without having to know and install a plethora of tools. Perhaps the only tools you'll need to know are Quicklisp and ASDF -- both of which already come installed in Portacle and in some Lisp distributions. And they are a piece of cake to use. 

>what specialty of Lisp differentiates it from other languages, especially from a beginner point of view?

Lisp source code is also data, thus Lisp code can easily manipulate lisp code at runtime, compile time, or even read time.

This makes metaprogramming trivial, instead of a cumbersome operation (as in other languages that do support metaprogramming). Having easy/trivial metaprogramming opens a lot of new doors. This also means that metaprogramming isn't an obscure ""don't touch it"" feature, but a bread-and-butter capability of the language.

Many of the ""functions"" in Lisp's ""standard library"" are actually macros. In other words, many operations in the Lisp language are built on metaprogramming, and thus, also using metaprogramming, you can extend the language in many directions.

Thus, this allows you to produce concise and/or maintanable source code, since you can adapt the programming language to your needs.



",1530116377.0
mwgkgk,"I think a good mindset is to try and be the best programmer there ever was. Which means using appropriate tools for each job. Python is chosen as a beginner language in numerous universities, and the webdev scene is humongous. So expect to have a smooth sailing and a million stackoverflow posts for the tiniest problems.

People using lisps are either romantic or have learned some kind of lisp in an academic environment. So expect a lot of edges to be the opposite of smooth, as these people have no problem dealing with them.",1530076904.0
eccp,"* In Lisps the difference between data and code is blurred, which is different from other languages such as Python
* Less syntax rules
* Lower barrier to write simpler programs, eg.  no `System.out.println` just to print something to the screen",1530081007.0
dzecniv,"mmh I'd say the image-based, REPL-based experience. When I discovered the ipython repl I was hooked, and a Lisp repl is way superior (specially in Common Lisp). You can write a function, compile it (that's right, compile one function, with `C-c C-c` in Emacs&Slime), have a feedback (a warning, or a debugger that pops up), and then try it in the REPL. Whereas in Python, you first need more tooling (flycheckers etc), you must have a way to run your code (a main function if it isn't a script), add a breakpoint if you want to stop in the middle of your program, and re-run it when you change the code. When an error occurs in Python, search for it manually, or improve your tooling (compilation mode in Emacs,…). In Slime, press `v` in the debugger and you get dropped on the line.

It's faster and less boring to develop in Lisp :)

Also, Lisp is a compiled language, so we can build an executable for any type of application, even a web app that ships its webserver, making it straightforward to deploy. Whereas in Python, you can sometimes but generally not. ",1530096386.0
revberl,"Recursion. You could say the same about most languages that use linked lists pervasively. It's just really natural to eat a list with a recursive function and it helped me really *get it*, where previously (my prior experience having been a not-very-good Java class in high school) I had only a sort of tenuous grasp.",1530675381.0
theangeryemacsshibe,"I found templating using [CL-WHO](https://edicl.github.io/cl-who/) a great experience. I wanted a similar tool in Python before I learnt Lisp, and being able to intertwine (Lisp) code and HTML was a dream come true. Before that, I used jinja2 which required you put `{% blocks %}` in your HTML which meant I had to learn that specific language, which was quite ugly. CL-WHO even compiles the HTML generation to Lisp, making it incredibly fast.

Here's a quick example of a HTML/CL-WHO macro. I think it looks quite nice:

    (defmacro card (title &body body)
      `(htm ;; Flip the macro expander back into HTML ""mode"".
        (:div :class ""card"" ;; In this specific context, .card creates a ""card"" on screen.
         (:h3 (esc ,title)) ;; Put the escaped string `title` in a <h3>.
         ,@body))) ;; Splice the rest of the card in.",1530083171.0
shostakovik,"im blanking on the name, but theres a style of programming thats driven.by specifications. If you dont find another solution you could try that.",1530126018.0
timezone_bot,"6pm UTC happens when this comment is 19 hours and 5 minutes old.

You can find the live countdown here: https://countle.com/knCY213893

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1530053670.0
CalamumAdCharta,Thank you for doing these!,1530081232.0
dzecniv,For CL and text representation: https://github.com/cbaggers/draw-cons-tree,1529947164.0
osztyapenko,How is this nicer than the sexpression itself?,1529946307.0
__lm__,This could be an interesting didactical tool to show that “code is data” and how cons cells works.,1529946902.0
GDP10,Very neat! I wish more tools existed like this for other data-structured languages.,1529955366.0
bagnalla,"Here's something similar I made a while back: https://bagnalla.github.io/sexp-trees/

It's web based and interactive (try mousing over a node or click-dragging the image) but doesn't support single quote characters like in the OP's example.

edit: this one is also pretty cool http://ympbyc.github.io/s-exploration/",1529993003.0
death,"    (ql:quickload ""consix"")
    (consix:game)

Visualizes conses of a degenerate form :)",1529996351.0
friedbun,"Looking at the [code](https://gitlab.com/joolean/gzochi), I'd guess the project is autotools based. So you'll need to run autogen.sh first. Then you can run configure as that should be created by autogen.sh and **then** you can run make to build it.",1529946391.0
kolloid1,"I just downloaded gzochi and there ***is*** a configure file. So I just did the usual configure/make sequence and it compiled ok. It will ask you for a couple of libraries which you should install beforehand. BTW it wanted a SDL library. I had SDL2 installed but it was no good, it wanted SDL1. I didn't test yet, though.

It seems to work only with GNU guile, which is a Scheme variant. I have seen no references to other language interfaces in the manual.

I'm a linux user. I have no idea about how to compile and run this on a Mac :-(

Tom",1530012476.0
svetlyak40wt,"By the way, if somebody wants to try this tutorial and don't want to manually setup all dependencies, he/she may eval this in the REPL:

    (ql-dist:install-dist ""http://dist.ultralisp.org/"")",1529926459.0
dzecniv,"Weblocks is a web framework, created circa 2007, that allows to write dynamic web applications in full Lisp, without a line of Javascript. It is based on so called widgets, that are rendered server-side and updated on the client, and it was also based on continuations (they were removed in this branch, at least for now). It was quietly being forgotten but it is being fixed, refactored, documented and simplified by /u/svetlyak40wt since a year or so. 

The old Weblocks website: https://common-lisp.net/project/cl-weblocks/

",1529924870.0
dzecniv,"Other isomorphic web frameworks I know are Haskell's [Haste](https://haste-lang.org/docs/), Nim's [Karax](https://github.com/pragmagic/karax), Ocaml's [Heliom](http://ocsigen.org/eliom/), Python's [Nagare](http://www.nagare.org/), of course Smalltalk's [Seaside](http://seaside.st/) and [a couple more](https://github.com/vindarel/awesome-no-js-web-frameworks).",1529925051.0
_priyadarshan,"Thank you. I know of Weblocks since its inception, although I never tried it. I was wondering, what is lost with the disabling of continuations, in respect to its features and functionality?",1529931551.0
WarWeasle,You can read the relevant chapters in [Paradigms of Artificial Intelligence Programming](https://github.com/norvig/paip-lisp).,1529616627.0
xach,"LispWorks has the KnowledgeWorks inference engine with prolog compatibility, and [the docs are pretty good](http://www.lispworks.com/products/knowledgeworks.html).",1529614398.0
lispm,"There are a bunch of Prolog implementations and the commercial Lisps Allegro CL and LispWorks both offer one.

Originally Prolog was added to Lisp for two main reasons:

a) so called Expert System shells often included logical reasoning and often based on Prolog. It got combined with Frames, Rules, ... and other paradigms. LispWorks' Knowledgeworks is basically one. In Germany years ago a shell Babylon was developed. The source is still available ( http://ema-xps.org ), which also included a Prolog.

b) The other reason was to use Prolog in Natural Langauge Programming , especially in parsers and reasoners for that.

Newer reasons were to have it as a component in the semantic web for query and reasoning. Franz also has it to be used with their graph database.",1529649182.0
tankfeeder,"PicoLisp has buildin PiLog as part of engine:

https://software-lab.de/doc/tut.html#pilog",1529733897.0
tmfom,[The Reasoned Schemer](https://mitpress.mit.edu/books/reasoned-schemer),1529620578.0
kuwze,There is [WAM_cl](https://github.com/TeamSPoon/wam_common_lisp) in case you are interested.,1529676708.0
guicho271828,"https://github.com/guicho271828/cl-prolog2
is an lisp-implementation-independent, and also prolog-implementation-independent library for using Prolog from lisp.

I used this in writing a preprocessing phase of ALIEN classical planning solver.
https://github.com/guicho271828/alien",1529758950.0
ObnoxiousFactczecher,"Just a possibility, perhaps you could use Screamer to implement an inference engine without doing a lot of the low-level drudge? Or read PAIP as suggested. Hell, read PAIP in any case. There's also CL-UNIFICATION you could perhaps use.",1529759160.0
__smh,"Allegro Prolog is included in the free downloadable ""Express"" version of Allegro CL.

The thing a Prolog engine brings to a procedural language like Lisp is not a database.  It would be silly to use Prolog to write a program that has a zillion rules associating employees with their phone numbers -- real databases do that better.  Rather, good Prolog programming style is definitional programming.  Prolog rules often have the intention that a frob is a this and that, and execution of the program proceeds by searching through a tree of possible matches until it finds a complete solution.  For example, a mathematical system might define a rule for identifying and parsing quadratic equations as:

    (<-- (quadratic $equation ?x ?a ?b ?c)
      (= $equation (= (+ (* ?a (^ ?x 2)) (* ?b ?x) ?c) 0)))

The elegance of this rule (ignoring the obvious requirements of canonical ordering of the equation) is that it can be invoked and succeed with variousof the 5 variables bound, or partially bound, and variables still unbound or themselves having unbound components can be unified later in the search, with the relational requirement propagated backwards.  This rule (here unfamiliarly expressed in prefix) is definitional, that a quadratic equation is this thing with these parts satisfying these relations, much more compactly and readably expressed than a pile of nested if-then-else procedural mashup.
",1530092310.0
stassats,"I doubt many people are actually doing that. I see approximately zero reasons to use prolog from within lisp (or prolog at all, for that matter). ",1529616537.0
xach,"Practical Common Lisp is really good, and Paradigms of AI Programming is deep and dense and good stuff.",1529597896.0
am-i-mising-somethin,"There is a sister subreddit called r/learnlisp

But [Practical Common Lisp](http://www.gigamonkeys.com/book/) is the go to for first timers",1529598061.0
flaming_bird,"This is the third post in a row that suggest Practical Common Lisp. Really, it's a **very** good book.

As for an environment, [Portacle](https://portacle.github.io/).",1529601643.0
joinr,"Fyi, [Lumo](https://github.com/anmonteiro/lumo) is gaining traction in clojure land, particularly for scripting, lightweight, quick start use cases.

Portacle is awesome for cl stuff imo.

Aside from additional practical common lisp recommendation, I thought [common lisp recipes](https://www.apress.com/us/book/9781484211779) provided some really useful applied information.",1529646916.0
dzecniv,"I recommend to not miss the [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/), but it doesn't really teach the basics. It's more on getting started (setting up an environment, knowing the package manager), and recipes.

Very nice video series: [little bits of lisp](https://lispcookbook.github.io/cl-cookbook/). And more: https://github.com/CodyReichert/awesome-cl#learning-and-tutorials

ps: oh yeah CL is more lightweight",1529602384.0
ponkanpinoy,"I've read three books, all very good. [Land of Lisp](https://nostarch.com/lisp.htm) is a well-written and engaging introduction to the language and concepts via writing games. [Practical Common Lisp](http://www.gigamonkeys.com/book/) is an excellent technical reference, it's my go-to when I need a refresher on `loop` and `format`, plus the practical exercises are actually practical. The macro section is also very good. [Paradigms of AI Programming](https://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910) gets into all the sorts of things you can do by manipulating symbols, which could have some carry-over into your Ruby work. Among other things.",1529604556.0
defaultxr,"If you want something like a scripting language, [Newlisp](http://www.newlisp.org/) seems pretty good, though it is its own lisp dialect, not a Scheme or a Common Lisp implementation. If you want a Scheme, [Guile](https://www.gnu.org/software/guile/) may be one to look into, since I believe it's meant for scripting as well. And Racket is probably good for scripting-type stuff too, I would imagine.

Common Lisp seems better suited for longer-running programs rather than what scripts are typically used for, but it is possible to compile a Lisp program as a binary, I believe, in which case it should start up and run much faster. But I don't have any experience doing that myself yet, so I can't say much about it.",1529603770.0
chebertapps,"when you get to writing scripts: from what I have heard, you will want to check out [cl-launch](https://www.cliki.net/CL-Launch) and/or [roswell](https://github.com/roswell/roswell). 

Sorry to say I haven't used much of either of these, but but Roswell seems similar to how Ruby or Python work, so it might make you feel more at home.",1529602153.0
fisch003,"If you like Clojure already but you want something for scripting, give ClojureScript a try. [Planck](http://planck-repl.org) on Linux or macOS will give you an instant start-up ClojureScript repl, run scripts, etc.",1529622748.0
psyhofreak,"For scripting, I really like ecl. The start-up time is pretty reasonable, it will ignore a shebang line (I'm not sure if they all can..), and for frequently used stuff it can emit/compile a C version of your program.

    $ time ecl --eval '(quit)'
    
    real	0m0.109s
    user	0m0.069s
    sys	0m0.020s",1529640239.0
TheTriskaidekaphobic,"The Land of Lisp is a great beginners guide to Common Lisp, most of it should transfer pretty well to Closure. It teaches the basics and a little beyond by teaching you how to program games. It starts with a simple Guess the Number game and moves into more complicated games, the main one being a Text Adventure.

http://landoflisp.com/",1529656921.0
hydandata,"These two will get you quite far, second is written with explicit goal of supplementing PCL.
http://www.gigamonkeys.com/book/ commonly known as PCL.
http://weitz.de/cl-recipes/

Good CL programming style and general programming mastery:
https://www.amazon.com/Paradigms-Artificial-Intelligence-Programming-Studies/dp/1558601910 usually referred to as PAIP

If you like OO, I would definitely check out:
https://www.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894",1529703155.0
waspishly_simple,"By ""lightweight"" if you mean ""doesn't require you to fire up an entire JVM to get it working"" then yes, CL is lightweight. If  you mean it any other way, no CL is not lightweight.

Racket's good for a beginner, and it comes with a much friendlier development environment than the default for CL.

Personally I prefer CL because it's more ""technical"". CLOS is an example. Racket is more like the C# of the Lisp world (not in anyway being derogatory there) whereas CL is more like C++ (whilst at the same time being nothing like C++ really.) But then I only progamme for fun these days.

Others have recommended Practical Common Lisp. I found it to be an ""okay"" book but not one I really rave about. To ""get it"" you will have to genuinely study it.

I enjoyed Paradigms of AI Programming by Norvig, but mainly because I was interested in how early (simple) AI programs worked. The big advantage is that he only uses Common Lisp without any other libraries at all and he takes you through the evolution of a programme rather than starting from the finished thing.

I also enjoyed reading On Lisp, it's what made what's so very different about Lisps in general and CL in particular when compared to blub languages click for me. Let Over Lambda is the spiritual second volume of On Lisp and well worth reading.",1529905581.0
,[deleted],1529620521.0
tufflax,"The only thing holding Clojure back for scripting is the startup time. But you say

> Ruby is just much simpler and readable and suitable for this case.

Simpler? I don't think so. Readable? You'll get used to it, and Common Lisp is not much different. Suitable? Yeah, the startup time is bad.

> I heard that CL is more ""general-purpose"" so I will be able to completely replace ruby with it (except my work of course, hehe).

Clojure is general-purpose too.",1529625939.0
flaming_bird,"Hey! Common Lisper here.

>    A stable, active, healthy, (large?) community

`#lisp` on Freenode, also a Lisp Discord server.

>    smooth (linux) tooling for web, server, mobile-native

What exactly do you mean by tooling?

AFAIK Common Lisp is not strong on the mobile platforms, though there has been some successful work to port Embeddable Common Lisp + Qt5 to Android.

>    single-source, multiple targets (for the targets above)

If I understand you correctly, Common Lisp can provide you with that. The whole fact that standard code works on all conforming implementations, no matter if it's SBCL, CCL, ECL on weird CPU architectures or OSes or ABCL on JVM, is a pretty big feat of CL.

>    figwheel-like interactivity

D'oh. Lisps are where the interactivity actually started. (: Common Lisp is a very good example of that - you write your program incrementally, function by funciton.

>    immutable data

In Common Lisp at least, data is mutable because the programmer should be able to mutate it if he considers it a good choice and also not to mutate it if he considers it a good choice. Hence, simply don't use mutating operators, and your data is now considered immutable.

>    non-JVM

A lot of Common Lisp and Scheme implementations are **not** based on the JVM.

>    static types

Lisps are usually dynamic, but [Carp](https://github.com/carp-lang/Carp) is an exception. Additionally, you can write statically typed chunks of code in Common Lisp - you simply add type declarations everywhere possible and let your compiler deduce the rest.",1529535055.0
dzecniv,"Hi, converted Common Lisper here.

> A stable, active, healthy, (large?) community

CL is very stable, and that's a relief. As a consequence libraries are stable. Browsing around, you might find strange that a given library wasn't updated in three years, doesn't have bug reports and has less than 100 commits. But that library may be one of the most downloaded of Quicklisp, and just works.

The package management system is stable and sane too. It seems strange at first that Quicklisp gets updated once a month. Thinking about it as Debian's apt rather than npm helps seeing the point. We don't upgrade *one* library, but a system, that was built against a given set of libraries to check if they work together. I'm only thinking of a Haskell package manager that does that. It's also straightforward to work with another version of a library if needed, and there are more tools.

I find the community healthy, active and large. I like (and like to advertise) the [Awesome-cl](https://github.com/CodyReichert/awesome-cl) list and the [Cookbook](https://lispcookbook.github.io/cl-cookbook/). They should help a newcomer. Don't miss [Quickdocs](http://quickdocs.org/) too.

> smooth (linux) tooling for web, server, mobile-native

Discussion on libraries for the web: https://www.reddit.com/r/lisp/comments/8s5q7x/what_common_lisp_web_library_should_i_use/ We didn't mention CL to JS compilers. But if you dream of building a dynamic webapp in a good Lisp environment, without JS, go check the ongoing work on Weblocks :)

> figwheel-like interactivity

So if you're talking about interactivity when building a webapp, Weblocks might be somewhere there. When I refresh the page after a code change, I don't loose my data. We're in a running Lisp image after all. Also some notes on [skewer and trident-mode for emacs](https://lisp-journey.gitlab.io/blog/is-there-something-like-figwheel-for-common-lisp/), that may be building blocks towards figwheel.

> non-JVM

no JVM, and possibly no npm (unlike clojure[script]).

> static types

CL is dynamic, but does a lot more type inference that other popular dynamic languages. It either catches errors, or prints warnings. Continuously compiling functions (it's a `C-c C-c` away) and trying out code quickly is also a bug catcher. CLOS's method dispatch helps too.

---

Vim experience is said to be good.

You have choice of database libraries (clsql for you ?).

*edit*: http://lisp-lang.org/ to get thrilled and a list of success stories of course. Also https://github.com/azzamsa/awesome-lisp-companies",1529537811.0
funkinaround,"With respect to Racket:

* A stable, active, healthy, (large?) community
   * Maybe one useful metric for how active and large a community is can be judged based on how large their package ecosystem is. You can take a look at Racket's [package ecosystem](https://pkgs.racket-lang.org/) and maybe see if what you think you may need is covered.
* smooth (linux) tooling for web, server, mobile-native
   * I have not attempted to do web development in Racket. However, it seems to be supported and [documented](https://docs.racket-lang.org/continue/index.html). With regards to mobile native, I think Racket at least [supports Android](https://www.infoq.com/news/2016/10/racket-67-android-apps)? I have not tried to use it.
* single-source, multiple targets (for the targets above)
   * At least for the development I have done (console and GUI programming for desktops), Racket has this covered. Same source and is able to run on Linux, MacOS, and Windows with no need to reconfigure anything
* figwheel-like interactivity
   * Racket has a REPL that will let you interact with running programs. From my understanding, it is not as nice as Common Lisp's.
* immutable data
   * Immutability is largely the default for Racket data structures.
* non-JVM
   * Check, although I personally love the JVM and am baffled why that's an issue.
* static types
   * There's an entire language called typed/racket that offers static typing",1529552423.0
leodash,"For immutable data, you can look at [FSet](https://github.com/slburson/fset).",1529545173.0
grewil,"I started with Emacs Lisp because it’s so easy to get started with. Good debuggers, repl, docs, all you need integrated and right out of the box in Emacs. It’s easy to evaluate stuff as you type too. But ClojureScript and PicoLisp are great too, and why not give Racket a go?",1529570598.0
djeis97,"Just to add my piece, if you’re coming from vim I’d definitely check out spacemacs. It basically configures everything for you and most vanilla vim bindings and a lot of simpler ex commands just work, and you can very easily enable support for tons of emacs packages through the configuration layers system.

As a side note, apart from your dislike of the JVM what’s you’re issue with ClojureScript being too attached to Clojure?",1529545138.0
bitwiggler,"Here is a really good read [https://fare.livejournal.com/188429.html](https://fare.livejournal.com/188429.html)

from someone who has managed a critical component of Common Lisp for some time.

A lot of good insight to the offerings of different lisps.",1529557145.0
dzecniv,"Also interesting to watch: http://shenlanguage.org/

- optional lazy evaluation
- static type checking based on sequent calculus, one of the most powerful systems for typing in functional programming
- optional type checking
- pattern matching
- built-in prolog
- runs under CLisp, SBCL, Clojure, Scheme, Ruby, Python, the JVM, Haskell and Javascript
- reported to [run on Android](https://chatolab.wordpress.com/2017/12/26/shen-programming-language-for-android/).",1529580569.0
lisper,"Take a look at:

https://github.com/rongarret/BWFP

It's the beginning of a textbook I was writing a while back.  It's far from complete, but it does have step-by-step instructions for how to get an interactive CL-based web development environment up and running.",1529537196.0
paulfdietz,"Common Lisp or possibly Racket.

Any time you are plugging together existing components you'll have dependencies, but using asdf/quicklisp these are pretty transparent.  I'd worry more about anti-dependencies (you cannot use systems FOO and BAR at the time time because they step on each other in some global namespace), of which there are occasionally some in quicklisp.",1529579299.0
timezone_bot,"6pm UTC happens when this comment is 20 hours and 8 minutes old.

You can find the live countdown here: https://countle.com/-qy210450Q

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1529445089.0
dzecniv,"IMO you can't be wrong with Hunchentoot.

Some notes on the state of web development, discussing libraries and other areas (how to deploy, etc):

- https://github.com/LispCookbook/cl-cookbook/issues/105
- https://stackoverflow.com/questions/1275547/how-can-i-do-web-programming-with-lisp-or-scheme/42838145
- https://lisp-journey.gitlab.io/web-dev/

I quickly tried Caveman and found it frustrating (trivial things are tedious), and had a good little experience with [Snooze](https://github.com/joaotavora/snooze) (by the author of Sly, Yasnippet and all).

I still dream of writing a dynamic web app in a good environment, without javascript, and it's becoming true with the ongoing work on [Weblocks](http://40ants.com/weblocks/quickstart.html) (a new quickstart with widgets upcoming). I have a couple web apps working, but that's still very alpha.

ps: can you believe that we can build self-contained executables of our web app, containing its web server, and so that it's straightforward to deploy ? That's unimaginable in say Django.",1529404045.0
RPZX77,"What's the story with the [State of the Common Lisp Ecosystem, 2015](http://borretti.me/article/common-lisp-sotu-2015) link in the side bar? It starts out with a section on web development.  I wonder what the state is 3 years later.  Maybe the we should delete the link in the side bar if it is outdated?",1529463133.0
pobbly,Look at the work of this guy https://github.com/fukamachi ,1529383655.0
defunkydrummer,"If you just want to use a web server directly, take a look at Clack and Lack which provide an API over some Lisp web servers.

If you want frameworks, take a look at:

- Caveman2 from Eitaro

- Radiance from Shinmera

- Lucerne from Fernando Borreti (eudoxia0)

- Reblocks (rewrite of weblocks)

- Uncommon Web (UCW)

These last two are continuation-based. IIRC there's nothing like that outside the Lisp/Scheme world..

If you want a bare-bones framework take a look at Ningle from Eitaro. I have added a tiny bit of functions to Ningle to make it easier to use, you can find it under the name of ""Ninglex"".



",1529642240.0
xach,Please consider using named-readtables. It's pretty easy to use and makes managing custom readtables much nicer for the maintainer and user.,1529347668.0
Bhima,This title is terrible.  You should really consider deleting this submission and making a new one with a better title.,1529345864.0
Joh11_,can someone explain what it refers to ? ,1529322999.0
ac1235,"Comman Lisp is a Lisp-II.
This means that functions and values do not share the same scope. It is hence possible to have a function and a variable of the same name.

    cl> (defun f (x) x)
    cl> (defvar f 5)
    cl> (+ f 1)
    6
    cl> (f (+ 2 2))
    4

You see if we use f as a function it uses the defun definition and if we use f as a variable we get the associated value of 5.

But what if we want to use the f function as a value to be passed to a higher order function? Well then we have to use the FUNCTION macro to explicitly mark that.

    cl> (mapcar f '(1 2 3))
    Error: f is 5 and not the function f
    cl> (mapcar (function f) '(1 2 3))
    (1 2 3)
    cl> (mapcar #'f '(1 2 3)) ;; sharpquote sugar
    (1 2 3)

Bonus: those function values can be stored in variables of course and they can be called using FUNCALL.

    cl> (defvar x #'f)
    cl> (funcall x 5)
    5",1529133604.0
flaming_bird,"There is no function named `FUNCTION` in Common Lisp. If anything, there is a special operator named `FUNCTION`[1]. Its purpose is to translate from Lisp data into function objects, that is, objects of class `FUNCTION`[2].

Evaluating the form `(function car)`, which is, calling this operator with a single argument that is a function designator, returns the function object associated with that function designator in the lexical environment. That object is not readable and prints out as `#<FUNCTION CAR>` on most implementations. A function designator may be a symbol or a list `(SETF symbol)`.

Evaluating the form `(function (lambda () 42))`, which is, calling this operator with a lambda form[3], returns the anonymous function object associated with that lambda form. That object is not readable and prints out as `#<FUNCTION (LAMBDA ()) {1001935FDB}>` on my implementation.

Because the `FUNCTION` operator is used so commonly, there is a special macro created for it to be a shorthand. Instead of writing `(function car)`, you can write `#'car`, and instead of writing `(function (lambda () 42))`, you can write `#'(lambda () 42)`.

A slightly different but related trick is the macro called `LAMBDA`[4], thanks to which you can also write `(lambda () 42)` - it expands right into `#'(lambda () 42)`.

* [1] http://clhs.lisp.se/Body/s_fn.htm
* [2] http://clhs.lisp.se/Body/t_fn.htm
* [3] http://clhs.lisp.se/Body/s_lambda.htm
* [4] http://clhs.lisp.se/Body/m_lambda.htm",1529133599.0
psqueak,Just wanna say that I love your videos and really appreciate your work for the lisp community :D,1528924215.0
Baggers_,episode starts at 10:50,1528923780.0
lisp-is-noice,"Thank you !! Couldn't attend it ... wrong time zone.
I am right now studying cffi and sb-alien.   

I am stuck with some functions (maybe pointer of function or callback functions ?) that I should give back to a c code). 

It is so far interesting to see the difference between :  
 - the cffi definitions that seems to limit the declaration of :pointer type to the minimum , leaving the hard work of memory allocation to the foreign-function-calls and   
 -the sb-alien definitions of alien objects that mix first the :pointer and the :type first (as in C) to later ease the use during the calling sequence.

",1528956964.0
maufdez,"Excellent episode, a lot of useful information for someone starting with CFFI. One interesting thing you can do with CFFI is to load [assembly code and run it](https://stackoverflow.com/a/18941269/4500302), which could be useful, of course it would be completely dependent on your processor type, but I think it is a nice trick.",1528990247.0
timezone_bot,"6pm UTC happens when this comment is 19 hours and 35 minutes old.

You can find the live countdown here: https://countle.com/S206997HoB

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1528842274.0
Baggers_,I need to get better at announcing these sooner again :p,1528842446.0
txel,This [MIT OpenCourseWare](https://www.youtube.com/watch?v=2Op3QLzMgSY&t=106s)  is a monumental option... ,1528732778.0
chebertapps,"[Little Bits of Lisp](https://www.youtube.com/watch?v=m0TsdytmGhc&list=PL2VAYZE_4wRJi_vgpjsH75kMhN4KsuzR_)
isn't a course but its a good video series intro to Lisp.",1528730512.0
dzecniv,"I like this one, it's a good show case of the guy developing [Potato](https://github.com/cicakhq/potato), a Slack-like software, in Common Lisp and ClojureScript. He demonstrates what he likes about the stack, pretty good. https://www.youtube.com/watch?v=bl8jQ2wRh6k",1528754298.0
flaming_bird,"I don't know video tutorials other than some of the Common Lisp streams that Baggers and Shinmera and other people tend to post around here or /r/Common_Lisp sometimes. They aren't really tutorials, but more like livecoding videos.

For books, you could use http://www.gigamonkeys.com/book/ - it's an awesome book that will get posted here sooner or later anyway.",1528727968.0
bulletvoter,"This guy posts good stuff to youtube. https://www.youtube.com/channel/UCMV8p6Lb-bd6UZtTc_QD4zA
",1528743244.0
VanLaser,"I recently bookmarked these, but had no time to actually watch them: https://www.youtube.com/channel/UCYg6qFXDE5SGT_YXhuJPU0A/videos

They seem promising though, going through (some of) the exercises from the PCL book.",1528755039.0
antflga,"When I started learning lisps I wanted videos too, and unfortunately other than talks given on lisps, there aren't really a whole ton.

The good news is I think because of lisps I figured out videos are a really inefficient way to learn.

Find a good lisp book of your choosing, open a repl, read through and toy with the examples yourself.

Best way to go by far. (Imo)",1528761492.0
eprozium,Udemy has one: https://www.udemy.com/lisp-programming-language/,1528733128.0
parens-r-us,"Unless you really need a video course, you should read Practical Common Lisp for a good introduction. ",1530402270.0
blue1_,"Read a book, it's a much more efficient way to use you time. Look at the sidebar of this page.",1528797987.0
mmontone,"Smalltalk.  Like Lisp, it is image based, supports interactive development, has a very simple and uniform syntax. Its integration with graphical tools and GUI in general is great too.",1528731710.0
forthdude,"Forth! Especially on small, embedded systems, the instant feedback makes iterative development a real joy",1528774043.0
DGolden,"Prolog. enjoy yes. any good at? maybe not so much.  Was just reminded of its existence recently as a startup was just [advertising a prolog job](/r/prolog/comments/8n72rr/software_engineer_database_job_data_chemist_ltd/) in my home town, which is ...unusual.  I'm not qualified, but it made me fire up swipl to have a play.  Yes I know you can embed a toy prolog in lisp (and vice-versa) relatively easily. But it's different enough from lisp in character, and there are real non-toy implementations like there are real non-toy common lisps / schemes.

",1528726601.0
TheTimegazer,"Rust!
Its standard library is incredibly well designed, and the memory guarantees means I've never felt as confident in my code as I do with Rust",1528700456.0
chunsj,Smalltalk (Squeak),1528763935.0
okflo,[Factor](http://factorcode.org/) - unfortunately the community around factor seems to stall...,1529228687.0
friedbun,"Truthfully, Javascript as it is so moldable under a good eye.",1528692086.0
f0urier,"APL(particularly Dyalog APL), as a mind-blowing intellectual experience; c++ for total control and performance while still having abstractions (classes and templates)",1528696463.0
ska80,Idris,1528703186.0
flaming_bird,"Erlang is very fun to program in, with its Smalltalkesque object system and swarms of tiny processes.

Other than that - Java, as much of a pain it tends to be. It's surprisingly fun to bring ideas from Lisp back into Java, even if they are 10x-50x bigger in size as a result.",1528706994.0
defunkydrummer,"I used to truly enjoy Python, but I haven't used it since I switched to Common Lisp. 

All through my life i've enjoyed C: it puts you in control and runs fast.

I thought Prolog was the coolest thing ever, when I tried it for the first time. I need to give it a deeper look.


",1528738877.0
smatija,"C, I like small languages.
",1528697261.0
dzecniv,"I don't enjoy Python any more, the Lisp syndrome hit me :(  I'm tired of the language and its ecosystem. I'm lurking into [Nim](http://nim-lang.org/) and its [Karax](https://github.com/pragmagic/karax) framework (recently used to rewrite the nim forum), but can't say much about it.",1528714779.0
flexibeast,Perl5.,1528700322.0
sammymammy2,"haskell is cool, types are cool.",1528702010.0
Someuser77,"Haskell. Clojure. Modern C# is pretty decent for OO languages. Rails/Ruby for quick proofs of concept. Python for BI/Analytics. 

Learning Rust and Julia at some point. ",1529416964.0
tangus,"Ruby.

I think I will enjoy programming in Nim once they get rid of that ""copy all composite objects"" stupidity.",1528694428.0
kazkylheku,"I enjoy C, if it is related to Lisp internals.

Pretty much hate every moment of working in anything other than Lisp or C.
",1528728436.0
AlexKotik,"Recently I've took a look at F#, which is basically OCaml on .NET framework with some interesting pipe like operators.",1528726446.0
fedekun,"I work with Ruby (and Rails) and it's just great.

The only downside is that you have to deal with people not knowing how to properly use a dynamic object-oriented language, given Ruby is very permissive, but it's still worth it. Things like rubocops and styleguides make it better at least.",1528739215.0
ws-ilazki,"Perl and Ruby.  And Lua...sort of.  Underneath the syntax difference, Lua has a Scheme-y feel to it that I like, but I get frustrated at having to implement even the most basic FP stuff from scratch to use it how I want.  Plus the lack of macros means you can't add features to it outside of changing the language itself, and the language developers only care about OOP syntactic sugar.  I still like the language well enough, but that taints it a bit because I find myself either copy/pasting boilerplate or reinventing the FP wheel whenever I use it. 

",1528698698.0
Asgeir,Elm and C !,1528703581.0
duncanbayne,"Ruby, and increasingly Go (for the sorts of things Go seems to be good for).  And C + Z80 Assembly when I have the time to indulge my retro-programming habit.",1528716761.0
ClickHereForBacardi,"Elixir. Its AST-access feels almost Clojuresque, and the qualities inherited from Erlang are just pure gold.",1528738231.0
dk_jackdaniel,CEPL is a very cool project utilizing modern OpenGL in a very Lispy way. Check out https://github.com/cbaggers/cepl . Author is also a very kind person who is eager to help (he streams videos about the engine [and other lisp-related things]).,1528695049.0
Shinmera,"cl-opengl is the bindings library to GL. It supports all the latest GL calls and is everything you need to directly interact with GL. You'll still need a library to handle the window and context creation for you, but there's plenty to choose from there like cl-glfw3 and cl-sdl2.",1528711313.0
SoraFirestorm,"I used cl-opengl in my last GL-in-Lisp project. I'm still pretty n00b at GL though, so YMMV. [Here's a link to it, in case you're interested at all.](https://gitlab.com/RobertCochran/shadowvard-engine)",1528693774.0
n2kra,"I'm assuming since it's a layered FFI, OPENGL- VERSION is behind? 
Is FFI / grovel capable of updating GL-UNIMPLIMENTED-FUNCTIONS during development or forking",1528709168.0
ilowry,"Have you tried using sly-default-lisp instead of prefix-arg?  You may need to add ccl to the list of known lisp implementations first. It is how I did it with slime:
 
    ;; CCL (ClosureCL)
    (setq u:*ccl-home*  (concat u:*home* ""Library/CCL/""))
    (setq u:*ccl-init*  (concat u:*shared* ""ccl-init.lisp""))
    (setq u:*ccl-exec*  (concat u:*ccl-home* ""ccl/dx86cl64""))
    (setenv ""CCL_DEFAULT_DIRECTORY"" (concat u:*ccl-home* ""ccl""))

    ;; SBCL
    (setq u:*sbcl-home* (concat u:*home* ""Library/sbcl/""))
    (setq u:*sbcl-init* (concat u:*shared* ""sbcl-init.lisp""))

    (setq-default slime-lisp-implementations 
      `((sbcl  (""/usr/local/bin/sbcl"" ""--userinit"" ,u:*sbcl-init*) :coding-system utf-8-unix)
         (ccl   (,u:*ccl-exec* ""-n"" ""-l"" ,u:*ccl-init*) :coding-system utf-8-unix)))

    (defmacro define-slime-lisp (name)
      `(defun ,name ()  (interactive)  (let ((slime-default-lisp ',name))  (slime))))

    (define-slime-lisp sbcl)
    (define-slime-lisp ccl)
",1528658964.0
sammymammy2,"> 
> (defun sly (&optional command coding-system interactive)
>   ""Start a Lisp implementation and connect to it.
> COMMAND designates a the Lisp implementation to start as an
> \""inferior\"" process to the Emacs process. It is either a
> pathname string pathname to a lisp executable, a list (EXECUTABLE
> ARGS...), or a symbol indexing
> `sly-lisp-implementations'. CODING-SYSTEM is a symbol overriding
> `sly-net-coding-system'.
> Interactively, both COMMAND and CODING-SYSTEM are nil and the
> prefix argument controls the precise behaviour:
> - With no prefix arg, try to automatically find a Lisp. First
>   lookup `sly-lisp-implementations', using `sly-default-lisp' as
>   a default strategy. Then try `inferior-lisp-program' if it
>   looks like it points to a valid lisp. Failing that, guess the
>   location of a lisp implementation.
> - With a positive prefix arg (one C-u), prompt for a command
>   string that starts a Lisp implementation.
> - With a negative prefix arg (M-- M-x sly, for example) prompt
>   for a symbol indexing one of the entries in

Pass the string as the first argument to the function.",1528632829.0
vermiculus,There's a port of clojure to .NET,1528632039.0
shizzy0,There is [IronScheme](https://github.com/leppie/IronScheme/blob/master/README.md).,1528641883.0
NLeCompte_functional,"I have not looked at this personally, but Bigloo is a Scheme compiler than can apparently compile to C or CLR/JVM bytecode: http://www-sop.inria.fr/mimosa/fp/Bigloo/

There was a release in Jan 2018, which is more promising than these things usually are :) ",1528640067.0
defunkydrummer,"Your best bet seems to be IronScheme. 

Clojure's ecosystem depends directly or indirectly on many JRE/J2SE classes, thus is not fully available on ClojureCLR, thus code written for ClojureCLR will thus be bound to that platform and viceversa. Unless you're perfectly fine with that, of course.

IronScheme is R6RS conforming so it's based on a firm standard.

",1528739157.0
duncanbayne,"I created this from bhyde's excellent https://github.com/bhyde/heroku-buildpack-ccl64, extending it to use Roswell.  That way it should support any Roswell-supported Common Lisp implementation; I've tested CCL and SBCL.

Feedback very welcome; I'm still learning my way around Common Lisp.",1528443135.0
dzecniv,Thank you ! Gonna be much helpful.,1528458237.0
kazkylheku,"Doh? The Usenet group `comp.lang.dylan` exists.

https://groups.google.com/forum/#!forum/comp.lang.dylan
",1528605941.0
AlexKotik,"I was thinking that Dylan programming language is pretty much dead, isn't it?",1528629126.0
g000001,"details:

[https://groups.google.com/forum/#!topic/dylan\-lang/WCRu714YBHQ](https://groups.google.com/forum/#!topic/dylan-lang/WCRu714YBHQ)",1528435123.0
bitwiggler,Nice swagger parser in there.,1528659290.0
stassats,"(cffi:foreign-symbol-pointer ""free"")

(cffi:foreign-symbol-pointer ""calloc"")",1528369617.0
waspishly_simple,"foreign-alloc / foreign-free ?

https://common-lisp.net/project/cffi/manual/html_node/foreign_002dfree.html",1528359473.0
kazkylheku,"The reference is filled with examples of some Algol-inspired language that looks like Pascal, with `BEGIN` and `END` blocks and `:=` assignments and whatnot, but with C-like declaration syntax like `DOUBLE X, Y;`, and even labels like `FOO:` with `GO TO FOO;`. Yet it makes frequent references to Lisp: Lisp data types and conses and such.

The list processing seems to be bolted on. Symbolic expressions may appear in GTL programs as sort of string literals in double quotes. E.g. `CAR(""(A . B)"")` which produces the atom `A`.

Variables that are Lisp objects are declared using the `SYMBOL` type. There appears to be some support for implicitly coercing values such arithmetic values to `SYMBOL` type, which causes some sort of boxing to take place.

It seems vaguely similar to defining a `symbol` class in C++ for Lisp-like objects, with various constructors and conversion operators.

Didn't scan far enough in the manual to see whether an `EVAL` function and such are defined.

Anyway, in summary, this really seems to be an Algol dialect with some Lisp-like computation bolted on in the form of a library and a bit of syntax. It is not a Lisp.",1528255446.0
idownvotetheassholes,"Hope all is well, keep being awesome!",1528317740.0
,The example given of metaprogramming is just the use of first class functions.,1528238947.0
defunkydrummer,"How can it be a ""tribute to Lisp"" if there **isn't a single code example written in Lisp**, be it the original Lisp or a backwards-compatible dialect like Common Lisp. All examples are in either Scheme (which has significant differences with the original Lisp) or Clojure (which diverges fundamentally from all prior lisp/scheme dialects).

Disappointing.



",1528213205.0
dzecniv,"Do you work with Common Lisp ? (I'm interested to fill up https://github.com/azzamsa/awesome-lisp-companies)

ps:

> Even though you will not find LISP among popular, mainstream languages,

To be positive (and self-realizing?), we might recall not so bad figures:
- ""Lisp"", whatever is under this name, and I believe it is mostly CL, is 27 on the Tiobe index, above D, Erlang, Clojure, Scheme, Lua, Julia, Haskell,… (Tiobe index may, 2018 https://www.tiobe.com/tiobe-index/)

Though I won't say Lisp is popular, sure…",1528212687.0
smatija,Did you check guile scheme? One of its main design goals is cooperation with C.,1528143489.0
rgrau,"Welcome dear lurker :)

As you mentioned Lua, there's a farily recent Lisp that translates to lua called [fennel](https://github.com/bakpakin/Fennel). It's very new, and not standard or anything, but maybe you can give it a shot.
For embedding you can try [ECL](https://common-lisp.net/project/ecl/) (never tried it) or [Gnu Guile](https://www.gnu.org/software/guile/) depending on your CL/Scheme taste. 

I'm sure there are many more options, but I'd say these ones are viable solutions for your needs. ",1528143591.0
,[deleted],1528155281.0
satanpenguin,"I have read good things about Chibi Scheme. Its intended purpose is embedding and is presented as a library without dependencies to make it easy to use. http://synthcode.com/scheme/chibi.

Edit: grammar. ",1528144170.0
90hex,"Hi there, I’ve been embedding newLISP in various apps for the past few years with excellent results. Tiny DLL/C-lib (300kb), very fast and very very lispy (more so than Racket, CL and Scheme), FFI, excellent standard lib. Author is very responsive. Highly recommended.",1528301444.0
Aidenn0,"Other people have mentioned reasonably good things, but consider also librep, which was/is a bit of a toy, but supports the sawfish window manager, so does get regular use.  It has some configure options to minimize it, but I do not know what the cross\-compilation story is \(which would help with porting\).

It comes with a header file to allow implementing lisp fuctions directly in C, and also has an FFI for explicitly calling C from lisp.

It's no speed demon, so would \(like lua or python\) be used for glue code.

\[edit\]

Link: [https://github.com/SawfishWM/librep](https://github.com/SawfishWM/librep)",1528170763.0
drjeats,"You should probably check out Scopes.

Docs: http://scopes.readthedocs.io/en/latest/

Screencast demos: https://www.youtube.com/watch?v=v4waNsi5Urg&list=PLWVpbdR2y12c3q_sjbFx3ptSyjEqus4ec

The syntax is primarily indentation based, but it's a sugar for s-exprs.

It's sort of the inverse of what you're asking. Less of a thing you embed, and more of a primary language. But it's designed to interop well with C libs (you can import headers directly). It doesn't emit C code, rather it emits llvm IR and JITs it. The guy who makes it is a demoscener, hence the screencast about shader programming.

May not ultimately be what you're looking for, but if you like Lisp and PLT and graphics you'll find a lot there to appreciate.",1528186096.0
defmacro-jam,Have you looked into [**Embeddable Common Lisp**](https://common-lisp.net/project/ecl/) or [**Racket**](http://racket-lang.org/)?,1528244165.0
Tramboi,"Conclusion: So I decided to go with Chibi Scheme despite its little portability problem, Which I fixed myself (one afternoon of multiword arithmetic implementation, I love using C libs, not writing C!), and now I'm going to try integrating it to my projects. Already found a bug but my scripting is not mission\-critical, so I'll go with it. The maintainer seems responsive and nice, so let's see how it goes from here !",1528656143.0
kwitcherbichen,"Have you looked at these?

* [Chez Scheme](https://scheme.com/) (Now open source)
* [Chicken Scheme](https://www.call-cc.org/)
* [FemtoLisp](https://github.com/JeffBezanson/femtolisp)

",1528166673.0
understanding23,"Stick with Lua which is designed for embedding.

Nothing in Lisp-land compares.",1528143491.0
defunkydrummer,">Would macros still be possible?

The compile-time macros would work just fine.

The problem is that you will be killing a significant part of the power and fun in Lisp.

>hello world is almost always well over 1MB

If you want extremely small ""hello world"" programs, use assembly. Seriously, you don't even need math libs, memory management, etc etc for a ""hello world"" program. Just use assembly, load the string and hand it over to the operating system output routines. Executable size should be a few *bytes*.

For real-world, complex applications with big codebases, i'd hazard a guess that most CL implementations will produce an acceptable executable size.

In any case, if you use the commercial LispWorks^TM implementation, it includes a tree shaker to bring down the image/executable size. [Documentation](http://www.lispworks.com/documentation/lw50/DV/html/deluser-50.htm). 

[Apparently, it can remove the compiler if needed.](http://www.lispworks.com/documentation/lw50/DV/html/deluser-147.htm#95989)





",1528084787.0
lispm,"Similar question: https://www.reddit.com/r/lisp/comments/8nt95a/small_executables_in_lisp/

> It seems like every lisp compiler out there creates standalone massive executable files

Besides the compilers which do not, like mocl. Which are not widely used.

https://wukix.com/mocl

> Does this already exist?

Yes, there are probably around 5-10 Lisp compilers developed since '82, which can do that. Their purpose was memory efficient application delivery. For that, compromises were made - often the language is only a subset of CL - large enough for some implementations - sometimes it was an inhouse compiler for just one major application.

An example for an inhouse system is the Gensym G2 application. http://www.gensym.com/platforms/g2-standard/
It's actually written in a Common Lisp subset and uses an inhouse Lisp to C compiler.

Since the market is very small and the purpose is mostly 'delivery of applications', they remained exotic.",1528095884.0
kazkylheku,"> *Would macros still be possible?*

A0: Yes they would because macros are compiled code in your program, not requiring compilation or interpretation in order to perform their transformations.

A1: No,  because they would be meaningless. The purpose of a macro is to parse an input form and generate code, which requires interpretation or compilation. If you took out the interpreter or compiler, the macros have no back end to handle the code they are writing.



",1528087597.0
bitwiggler,"Use a treeshaker, or just avoid CL, and use any of the lisps that target C ",1528085124.0
huangho,"I don't know what counts a a 'Lisp' for you, but a hello world in Chicken Scheme is 28kB on my system. It dynamically links with libchicken, though.",1528122710.0
bitwiggler,"Gerbil Scheme makes nice ""smallish"" binaries.

bw|bw\-15mbp|2.1.10:\~\> more test.ss

\(export main\)

\(def \(main\)

  \(println ""hello world""\)\)

bw|bw\-15mbp|2.1.10:\~\> gxc \-exe \-static test.ss

bw|bw\-15mbp|2.1.10:\~\> ls \-lhd test 

\-rwxr\-xr\-x 1 bw \_developer 5.3M Jun  4 10:18 test

bw|bw\-15mbp|2.1.10:\~\> strip test

bw|bw\-15mbp|2.1.10:\~\> ls \-lhd test

\-rwxr\-xr\-x 1 bw \_developer 4.7M Jun  4 10:19 test

bw|bw\-15mbp|2.1.10:\~\> ./test

hello world",1528132837.0
WalkingOnFire,"The last time I tested statically linking ""Hello World"" with Chicken Scheme was about 600KB using musl libc.

[edit] With no eval and was a 32bit binary.",1528208829.0
CelloAxeMurder,"    ~$ ros run -L sbcl
    * (defun hello () (format t ""Hello, world!~%""))
    HELLO
    * (sb-ext:save-lisp-and-die ""hello"" :toplevel #'hello :executable t :compression t)
    ~$ ls -l hello 
    .rwxr-xr-x 12M meh  4 Jun 12:01 hello
    ~$ time ./hello 
    Hello, world!
    real	0m0.168s
    user	0m0.140s
    sys	0m0.021s

It's already pretty small with a Lisp that includes eval though. In the age of Electron, your users will love it!",1528131967.0
flaming_bird,"I've googled something that seems like a full context: https://gist.github.com/agumonkey/777c2a289aa3afc2d814b38adbf5da9b

> I'm sure each of us could design a better language than Common Lisp is
turning out to be, and that each of those languages would be different.
My taste is close to RPG's, I think: in general, I like primitives that
I can build with better than generalizations that I can specialize.
However, Common Lisp is politics, not art.  If we can come up with a
single language that we can all live with and use for real work, then we
will have accomplished a lot more than if we had individually gone off
an implemented N perfect Lisp systems.

The paragraph seems pretty self-explanatory.",1528000408.0
jaoswald,"Hard to say for sure without context, even a time or place.

But I would point out that Common Lisp was a case of various parties, including rival implementors, coming together under some pressure from defense funding agencies to hammer out a standard normalizing variations in existing behavior without necessarily innovating or improving things very much.

Aesthetics were explicitly a criterion in decision making, but not the primary one.",1527989138.0
,[deleted],1527999467.0
zodmaner,"Wow, I didn't know that the WebAssembly text format (.wast file) syntax looks so similar to s-expressions. ",1527969981.0
Shinmera,"You can use ASDF straight up with no extra libraries or applications needed to dump your image. Integrates better with the rest of the ecosystem too, I'd say. Just add the following lines to your system definition:

    :build-operation ""program-op""
    :build-pathname ""my-executable-name""
    :entry-point ""my-package:my-start-function""

And then `(asdf:make :my-system)` from a fresh instance. Works for CLISP, CCL, CMUCL, LW, SBCL, and SCL out of the box.

ASDF's mechanism is also extensible. See for instance [Deploy](https://shinmera.github.io/deploy), which adds extra handling for external shared libraries.",1527976786.0
dzecniv,"Thanks for sharing.

I learned that ASDF allows to build an image in this subreddit too and this is how I do: https://lispcookbook.github.io/cl-cookbook/scripting.html#with-asdf",1527993580.0
lispm,"For SBCL, which is the implementation used - Common Lisp is a language with zillions of implementations and different ways to create executable. If it's only supporting one implementation in a very specific way, which is fine, best not call it 'Common Lisp'.",1527966302.0
guicho271828,"The author compares ""Programming OR approach"" and ""Modelling OR approach"" and claims that going former is more suitable for Lisp (or whatever). I have a contrary opinion.

OR is not only about domain-specific solvers (""software packages""). It provides solvers for a very generic framework, such as SAT or Integer Programming, which many problems can be converted into. They are mostly NP-complete so there are polynomical reductions between them. Furthermore, it is easy to add additional constraints in generic solvers so that the problem suits your needs. This greatly reduces the implementation time.

I believe the problem with OR is that its accessibility is still low. Not many people would choose OR as the first choice for solving the problem at hand. At the same time OR is a domain specific language and lisp is good at making it. Why not provide a wrapper? So my answers are these libraries...

* https://github.com/guicho271828/cl-sat
* https://github.com/guicho271828/cl-smt
* https://github.com/guicho271828/cl-prolog2

More ideas to follow are IP solvers and MiniZinc interface.",1528016716.0
Lisp-S-R-C-L-D,"For modelling there are some free tools that are quite interesting for low budget users. Here is a small list with their equivalents:
 And I of course will miss some and do not cover CFD,FEM applications.  

Yes it is somehow very promissing to have a look at lisp for such applications in Modeling.  
Maxyma -> MAxima (free) was the reference in Symbolic manipulation that lead Canadians to do Maple   

There are for example works around Meta-Modelica dealing with the manipulation of models and data of models written in Modelica language code. These concepts are targeting it seems what is done in CLOS on a larger scale. A equivalent of Modelica in Lisp is a dream.  

A lot of work is done in design protocols or ontologies of design that very probably will converge to Lisp for proof of concepts of tools that will be implemented in other known languages :-(   

Free| commercial | example application
:--|:--:|--:
Scilab, Octave, NumPy |  Matlab  | matrix algebra and related task in control, .... 
Scilab-Xcos | Matlab-Simulink, ... | block diagram like simulation and some physical port like simulation  
OpenModelica | AMESim, Dymola,SimulationX, MapleSim ... | System Simulation, some say 1D simulation, Physical Port simulation
Maxima (in Lisp !!!), Sympy | Maple, Mathematica |Symbolic Manipulation and more.

Edit : Table Building and comments I wanted to add",1527992852.0
dzecniv,"Project linked in the article: https://github.com/mck-/Open-VRP ""Vehicle Routing Problems"".

also

- https://kuomarc.wordpress.com/2012/01/27/why-i-love-common-lisp-and-hate-java/
- https://kuomarc.wordpress.com/2012/02/02/why-i-love-common-lisp-and-hate-java-part-ii-code-examples/
- https://kuomarc.wordpress.com/2012/02/13/why-i-love-common-lisp-and-hate-java-part-iii-macros/

and deploying to Heroku, comparing with Ruby: https://kuomarc.wordpress.com/2012/05/13/12-steps-to-build-and-deploy-common-lisp-in-the-cloud-and-comparing-rails/",1527994938.0
flaming_bird,"Common Lisp is an image-based language, like Smalltalk. This means that applications carry around a whole Lisp image.

But - AFAIR, if you want to, you can install ECL system-wide, use it as a library, and create executables that depend on libecl.so. Maybe jackdaniel from `#ecl` on Freenode will be able to provide you with more information.",1527875438.0
f0urier,LispWorks has a tree-shaker which allows to strip down unused code from the delivered binary.,1527879044.0
lispm,"There are some compilers which do that. For example the commercial mocl compiler, based on the no-longer maintained CLICC compiler.

https://wukix.com/mocl

Compiled applications start lower than 100kbytes IIRC.

There are some others, including non-published private&proprietary CL compilers - typically used for application delivery. These compilers are either not widely used or even only used for one application.",1527881562.0
svetlyak40wt,SBCL is able to generate (compressed) binary about 14M.,1527956135.0
jaoswald,"[https://scholar.google.com/scholar?cluster=9401075773831565841&hl=en](https://scholar.google.com/scholar?cluster=9401075773831565841&hl=en&as_sdt=0,33&as_vis=1)

shows many links for Postscript versions of the document.

[http://bauhh.dyndns.org:8000/clim\-spec/index.html](http://bauhh.dyndns.org:8000/clim-spec/index.html)

is a semi\-Wikified version \(you can contribute annotations\)",1527686879.0
n2kra,Did any of the commercial CLs that provided CLIM have online doc(ment examiner)?,1527728200.0
timezone_bot,"6pm UTC happens when this comment is 19 hours and 26 minutes old.

You can find the live countdown here: https://countle.com/OG200334fi

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1527633191.0
djeis97,Awesome!,1527686897.0
_priyadarshan,"Thank you, Little Bits of Lisp is a very enjoyable series. You have a knack to deliver complex concepts in a straightforward, inspiring and instructive way. Thanks.",1527782028.0
dzecniv,"Nice idea of yours :) The easiest solution to get started in two clicks is [Portacle](https://portacle.github.io/), a portable and multiplaform build of Emacs, nicely customized, shipping everything needed to start writing CL right away.

See also https://lispcookbook.github.io/cl-cookbook/editor-support.html",1527614658.0
XxZozaxX,"Emacs.

why not ?!
it is written by lisp and has it is own lisp (emacsLisp), also, it is the best IDE over all IDEs.",1527633537.0
f0urier,"Depending on ""which lisp"". If you have Java background you can try Crojure and its IDE https://cursive-ide.com/
For Common Lisp Portacle was already mentioned, as an alternative for learning purposes you can try to download LispWorks Personal Edition http://www.lispworks.com/downloads/index.html",1527616052.0
flaming_bird,"For beginners: DrRacket for Racket and its various Schemes, Cursive for Clojure, Portacle for Common Lisp.",1527618970.0
namesandfaces,"Racket's DrRacket is a pretty nice up and going experience.

https://racket-lang.org/",1527634980.0
defunkydrummer,">I was taught Java at university and would like to learn lisp.

Note: If switching from Java to (Common) Lisp, these will be the biggest differences to learn/overcome: 

- Metaprogramming and homoiconicity. The usefulness of it will slowly become more and more obvious.

- In Lisp, everything is an expression.

- On Java, things are compiled, then run. You write code that is read on compile-time, compiled, then excecuted. On Lisp, you can write code that executes either on read-time, compile-time, or runtime (your choice). 

- Java runtime has limited functionality. The Lisp runtime includes the Lisp compiler itself, which is transparently available at runtime. 

- Java is strictly OOP in a style close to C++. Lisp is multi-paradigm, so you'll first write code in procedural imperative style, then perhaps in functional style. 

- Lisp's OOP (""CLOS"") is based on multiple dispatch and method combinations. It is startlingly different to Java OOP and very exciting to learn. 

- Don't be tempted to apply all the typical ""Design Patterns"", since some of them attempt to create functionality that is already there in Lisp.

- The conditions-restart system goes beyond what Java exception handling can do, and it's very interesting (and good) to learn. 

- Lisp is dynamic all the way. This means that it was intentionally designed for doing things like redefining functions or redefining classes while the code is running. 

- Lisp functions support multiple return values natively. This isn't evident at first, because they are only used occasionally when needed.

- In general, there is no type erasure at runtime with Lisp. Types stay there at runtime. 

- In some cases, Lisp is even more strongly typed than Java. 

- There are more equality operators than Java. It is useful to understand their differences.

- Some tutorials give the impression that we do everything using lists. On Lisp, there are arrays, hashes, vectors, and everything, so don't feel like everything has to done with lists. And also, regarding lists you'll find there are different usages of lists - alists (association lists), plists (property lists), trees, etc.


",1527715764.0
sgoldkin,Get Clozure CL. It has its own editor (which is basically Emacs) and you won't have to mess with slime or anything else. (https://ccl.clozure.com/),1527623809.0
,Corman Common Lisp is a reasonable choice and free.,1527632366.0
fedekun,"Being a Vim user, I found out [Spacemacs](http://spacemacs.org/) has pretty great default support for Common Lisp. Just install SBCL (or any other implementation) and that's it. It takes some time to get used to it but once you get to know Spacemacs it's almost better than Vim, if only it wasn't so slow!",1528234440.0
Aidenn0,"I'm curious as to why LZ4 was chosen for compression.

zstd is usually far better for line compression as the work is more symmetric relative to the compression ratio \(lz4 uses more CPU time at compression than zstd at a given compression ratio\).  LZ4 makes sense for cases where decompression time is more important than compression time, which is usually not the case for ephemeral data.",1527623196.0
fisxoj,I see fixes like this and wonder... Are some people using this language at a level way above me? Likely yes!,1527600788.0
defunkydrummer,"While the dawn of the computing world is menacing this formerly sacred job, while *yesterday* things were as usual: world hunger, no cure for cancer, no cure for Electron, and NPM still going down every month, *today* the big flame of creativity and human goodness brings us another release of that Lisp powerhouse, the mighty, formidable, beautiful ~~Clozure Com~~Steel Bank Common Lisp!!

Most of us, the humans that have only visited briefly the Land of Lisp, perhaps are not worthy of such goodness delivered here to our hard disks. Finger lickin' good, this implementation. 

>bug fix: redefinition of method combinations now does the expected thing; generic functions using that method combination have their effective methods lazily recomputed according to the new definition of the method combination. (Reported by Didier Verna at ELS 2018)

Excellent.",1527617242.0
lispm,You also need to use the same processor architecture. Linux ARM 64bit won't run on Linux x86 64bit. Especially since SBCL usually compiles to native code.,1527534459.0
CrumbsofPiety,"hah never heard of save-lisp-and-die, I love it",1527532932.0
sammymammy2,"Yes, that is the exact use-case for that. It's BSD-style and public domain, so no need to provide source code.",1527531754.0
OverlordGearbox,"While we're here, allow me to ask the opposite question. Can I `save-lisp` on a Linus distro and then run that image on windows?",1527541262.0
guicho271828,"Well, I believe Java's GCs are much more sophisticated than those in most Lisps, e.g. have concurrent/parallel GC, optimized by paid specialists, and have some interesting algorithms like colored pointers in ZGC.

Then, would I choose Java? Hell no.",1527375475.0
LegionPharma,">Java

>has first class functions

>no

Weren't lambda expressions added in Java 8?",1527367529.0
DecentSatisfaction,Is the site dead? ,1527402187.0
kpenchev93,"Lisp and Java shouldn't even be put in the same sentence. And Java has lambda functions from version 8. As Linus Torvalds said, ""Java, what a horrible language"". ",1527369045.0
melloyagami,Really interesting. Thanks for sharing,1527411374.0
pouar,"In case my server ends up going down again

https://svgshare.com/i/6pg.svg

this file is about 1/3 bigger than the one on my site though as this site uses gzip instead of brotli",1527438045.0
anaerobic_lifeform,"Thank you, ABCL developers.",1527624888.0
HighMaxFX,"JShell is a REPL, available for Java 9. ",1527671120.0
olaeCh0thuiNiihu,"To be fair, most of Java's problems comes from the average programmer that uses it, and not the language itself.",1527374229.0
Aidenn0,Try `export SBCL\_HOME=/usr/lib64/sbcl` before running sbcl,1527228886.0
stassats,"You have to set SBCL_HOME.

We could tweak the build process to accommodate slackbuild, but the slackbuild people need to contact us to ensure it's actually incorporated into the slackbuild. ",1527241879.0
kdnbfkm,Can you `ln -s /usr/lib64/sbcl/ /usr/lib/sbcl/`? Might need to `mkdir -p /usr/lib` also.,1527227870.0
morphinism,"Ah, coincidentally I was just installing SBCL on a new slackware system myself. The users above are correct: Slackware is ""multilib\-ready"" by default, and so installs 64\-bit things to `/usr/lib64`, but SBCL will look for it's core image and other info unde`r /usr/lib/sb`cl.

Exporting the proper environment variable will work, but the slackbuild also adds a file to `/etc/profile.d` that exports the proper `SBCL_HOME`, which I believe is sourced upon login, so you might just need to reboot/logout.",1527522581.0
timezone_bot,"6pm UTC happens when this comment is 21 minutes old.

You can find the live countdown here: https://countle.com/XwO197116t

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1527010704.0
Shinmera,"The easiest way to do this is to add a reversal route that forces the port to 443:

    (define-route force-port :reversal (uri)
      (setf (port uri) 443))

To be clear about what the `:port` configuration value does: when Radiance computes the [reversal domain](https://github.com/Shirakumo/radiance/blob/master/defaults.lisp#L185), it will try to match the incoming request's values and only falls back to using the configured value if there is no request around. This can still be important, for instance if you're generating cached pages from the REPL where there is no request context.

The reason why it converts everything to http in your setup is because the proxy turns the incoming requests into plain http, and Radiance doesn't know about it.

~~The ideal way to do this if you want to keep the ability to serve both http and https links would be to set an additional header in nginx that passes the protocol on to Radiance, and then use that in `uri-to-url` transformations. I don't currently see a convenient angle on that aside from overwriting `uri-to-url` itself however, so perhaps a change in Radiance is necessary. I'll think about it.~~ `uri-to-url` now automatically considers `X-Forwarded-Proto` and proxied setups should now work as intended from the get-go.

Alternatively you could tell Radiance to serve on two ports, one for https, and one for http, and then proxy both separately, but that would be kind of silly.

Either way, for your purposes the above route should do the trick.

Also, in the future I can probably respond to issues better and faster if you report them [on github](https://github.com/Shirakumo/radiance/issues).",1526972418.0
patrixl,"Just to summarize the latest update thanks to Shinmera’s quick action, the uri-to-url function will now check for the X-Forwarded-Proto header as well when deciding which port to set. ",1526998105.0
garethnelsonuk,"Would love some feedback on this from longtime lisp-type people.

I'm purposefully NOT following some of the lisp orthodoxy with this thing, the goal is to be something like ""python with s-expressions and macros"" more than yet another scheme clone.",1526929834.0
circlesock,"Is there some meme I'm missing? I don't get the reference here and it's clearly not Armed Bear Common Lisp.  Or is this just holds-up-spork territory?

>> Why bears?
>
> BOW!!!!
>",1527216518.0
herbadah,There's a lisp with similar goals called [carp](https://github.com/carp-lang/Carp).,1526928208.0
eudoxeea,Author here. Please let me know if anyhing in the README is underexplained or could be worded better!,1526919157.0
grimscythe_,That's the first time I see a statically typed Lisp. Impressive work! ,1526931891.0
tealeg,Very interesting.  I look forward to seeing where this heads. ,1526928072.0
akkartik,I ended up reading one of [the Cyclone papers](http://www.cs.umd.edu/~mwh/papers/cyclone-cuj.pdf). But it's not clear to me what operations are harder with region-based allocation. Do you have any examples that actually exercise the allocator itself? Say involving linked lists or trees (since this is a Lisp)?,1526962285.0
davazp,"Very interesting indeed. 

I have thought about this a bit.

GC doesn't seem to take benefit of request-response pattern in a lot of software today.  Regions (as pools where you can allocate memory)  seems common in non garbage collected languages.

Bringing those into the language itself sounds very promising.

Great job! I will follow the progress of this. ",1526974253.0
Eigenspace,Very cool! I know very very little about manual memory management so it would be neat to learn it in the context of a lisp.,1527011386.0
Aidenn0,Is the only way to move data from one region to another to copy it?  Rust is more complicated at least partly because lifetimes can be promoted implicitly; it seems in Interim that any function that returns a heap\-allocated value would have to take a region as a parameter?,1527016909.0
aiaor,"What if Interim becomes eternal?  Would it then have eternal interimity?
",1526966831.0
jsjolen,"Hi! fast-http is a parser so it's not a HTTP client, but it might be used to build one! Dexador uses fast-http and is a HTTP client :-).",1526847188.0
lisp-shell,"Hey everyone!

SHCL is my first real lisp project. It’s not ready for real use, but I thought I’d share it with you all any way. Enjoy!

Edit:
I guess I should probably say a bit more about it.

About four years ago, I decided to start learning Common Lisp. I wanted to try doing something interesting with reader macros, and I was annoyed by how clunky spawning sub processes could be in most languages. I decided I would try using reader macros to make spawning subprocesses fluent. A few hours later I had a prototype that I was happy with. When I tried to add more advanced features (pipelines, process substitution, file descriptor redirects, etc.) my hacky prototype fell apart. I moved on to other experiments and put my Shell-in-Lisp experiment away.

Except, I couldn’t stop thinking about it. Spawning processes really sucks in everything except shells. Want a pipeline? It’s easiest to just invoke /bin/sh, pass it a string to evaluate, and try to escape any user input you want to include in the command. That wasn’t very satisfying to me. It’s too easy to mess up! The alternative sucks, too. Assembling a pipeline yourself is a bit awkward.

So, I kept coming back to the Shell-in-Lisp experiment. Each time I had higher aspirations. At some point I just decided to stop screwing around with toy shell-like languages and implement the POSIX shell language itself. The rest of the story is in the git history.

At this point, SHCL is sort of a POSIX Shell compiler. At macroexpansion time, it can fully parse a string containing a shell expression and translate it into an appropriate Common Lisp form. If you want native code for your shell expression, your lisp compiler can carry it the rest of the way. With a simple reader macro, it’s easy to create the feeling that POSIX Shell and Common Lisp had a baby.

It’s been a really fun project, and I’ve gotten to experiment with some fun ideas. I never really thought of it as anything more than an opportunity to experiment, so some of the code is a bit... well, interesting. For example, the [data package](https://github.com/bradleyjensen/shcl/blob/master/core/data.lisp) is probably a bit hard to follow, but it sure was fun to write. It’s also turned out to be pretty useful.

Anyway, I’m going to keep working on it. I just figured you all might find it interesting. I’ll happily take feedback on my code. Just remember that this is my first “real” project in Common Lisp and my primary goal is having fun with the language.

If for whatever reason you want to join me in this crazy project, I’ll happily take pull requests.",1526776495.0
bendudson,"Neat! I was recently looking for something like this before deciding to write my own,  and came across a similar project: Lish https://github.com/nibbula/lish which has some similar features. 
Perhaps the best features of both could be merged,  or at least some ideas exchanged. ",1526830681.0
rpiirp,"Did you look at the classic [Scheme Shell SCSH](https://scsh.net/about/about.html) by Olin Shivers et. al.?

""Scsh has two main components: a process notation for running programs and setting up pipelines and redirections, and a complete syscall library for low-level access to the operating system, i.e. to POSIX, the least common denominator of more or less all Unices, plus widely supported extensions such as symbolic links and BSD sockets. Moreover, scsh provides an awk facility for pattern-directed computation over streams of records, a rich facility for matching regular-expression patterns in strings, event-based interrupt handling, user-level threads, a futuristic module system, and an interactive environment.""

I've been on the lookout for a Common Lisp version of SCSH for a long time.",1526896269.0
losthalo7,Have you already had a look at [CLaSH: Clisp As a Shell](https://clisp.sourceforge.io/clash.html)?,1526833067.0
dzecniv,"Also [clesh](https://github.com/Neronus/clesh) ? (a continuation of [shelisp](http://dan.corlan.net/shelisp/)) It provides essentially a `!` bang syntax to type in any shell command, and various ways to mix Lisp in.

(exciting project :) )",1527000919.0
dptd,"As a Java programmer you are already familiar with programming in general. In such situation I recommend you Peter’s book - Practical Common Lisp. It’s available for free online. You may think about buying a dead-tree version or making a donate if Peter’s work will help you.

http://www.gigamonkeys.com/book/

If you want play around with Lisp (MIT Scheme) while learning programming in general give SICP a try. Available for free.

https://mitpress.mit.edu/sites/default/files/sicp/index.html",1526672442.0
Puddingsurfer,"While Land of Lisp is a pretty fun book to read, I'd recommend you start with [Practical Common Lisp](http://www.gigamonkeys.com/book/) instead. It's a well-written introduction to Lisp, and the small projects in between give you  an idea how everything comes together.

As for your editor, [Portacle](https://portacle.github.io/) gets recommended quite a lot, and should be very beginner-friendly. I have never tried it myself though, I go with [Spacemacs](http://spacemacs.org/) + SLIME + SBCL.",1526672846.0
defunkydrummer,"Another recommendation for Practical Common Lisp.

Also: 
>But very interested in Functional Programming 

Note that Lisp is multi-paradigm, not centered on functional programming. 
",1526672650.0
flaming_bird,"> But very interested in Functional Programming 

Common Lisp is multi-paradigm so you can commonly find iterative, declarative and object-oriented constructs in it. If you want something that restricts the programmer towards the functional constructs, you could try Racket, various other flavors of Scheme, or Clojure.",1526673010.0
kazkylheku,"Try [Common Lisp: An Interactive Approach](https://www.cse.buffalo.edu/~shapiro/Commonlisp/commonLisp.pdf)

Very nice book. It was the better part of a decade old when I started learning from it in around 2000. At that time, it was printed only. Some years later, Shapiro made the above PDF available.

This book goes from the ground up.  It starts with the basics: then has a big section on ""Pure Lisp"" programming (the functional stuff), another section on ""Imperative Lisp"" and also covers object-oriented programming with CLOS.

This book introduces packages early on, and has a good coverage of some details of read syntax and how different spellings of the same symbol can correspond to the same one, and what ""interning"" is and such.

The book carefully avoids being tied to any implementation of Common Lisp.


",1526709382.0
defunkydrummer,">I've found book ""Land of Lisp"" by Conrad Barski M.D. but probably this is wrong way

Hi /u/akhambir, now I have more time to reply.

This is a very beautiful book that is very motivating to learn Lisp. I actually got the final motivation for learning Lisp by looking at some of the comics there. I think Conrad Barski must be one of the nicest people in the world.

However, I think Practical Common Lisp is much more efficient (i.e. gets you there in less time), and easy to understand. 

>But very interested in Functional Programming

You can do functional programming in lisp, but the real fun and the real power is in that Common Lisp is perhaps the most ""multi-paradigm"" of all languages. 

Yes, functions are first-class objects in CL, you have map, reduce, apply, etc. 

However, IMO if you are really a fan of functional programming, perhaps you might want to explore the latest trend/fashion, which is functional programming of pure functions (side effects constrained) coupled with a very powerful type system coupled with type inference, coupled with powerful static-time type checking. That is, the Haskell language.

Note that Lisp and Haskell are polar opposites -- the idea in Haskell (& similar languages) is that a program is closer to a mathematical proof, and that everything should be laid down on source first, then verified, and only afterwards converted into an executable, then run. If there are errors at runtime, you're screwed and need to start all over again (write->compile->execute). 

While Lisp, is for ""creating living organisms"", like the Alan Perlis quote. That means your program, while running, can be evolving, be modified, etc. There isn't a strong separation between creating, modifying, and executing the code.

Another difference is that, for a Lisper, a program should ideally be expressed on the most natural, direct way. Rather than doing the workarounds needed to implement the desired program P in language X, you modify language ""Lisp"" so the desired program is the closest as possible as the language in which program P would be ideally expressed. Think of this, for it is a very powerful concept.

",1526690070.0
zeekar,"Bear in mind that functional programming and ""most traditional"" Lisp are different goals. The design of Lisp has always had its functional aspects, to be sure, but it has never had any pretense of being a pure functional language. 

For a more purely functional language with Lispy syntax, I recommend Clojure, which also lets you take advantage of Java libraries you may be familiar with. Or if you want to stick even closer to classical Lisp syntax (PARENTHESES AND NOTHING BUT!), Scheme/Racket might be the way to go.

You could also look at Scala (to stay on the JVM) or Haskell for some grounding in pure functional programming that's not Lispy.
",1526674118.0
likes-beans,"SICP (on the sidebar) aka ""Structure and Interpretation of Computer Programs"" for functional programming in lisp (scheme).

To do the code examples, I would recommend a simple scheme distribution (i.e. [chicken scheme](https://www.call-cc.org/) or [chez scheme](https://cisco.github.io/ChezScheme/). Scheme is not yet _as_ practical as common lisp, but it is much simpler and better designed.

If you are a Java programmer, you'll like common lisp's CLOS or chicken's COOPS. They are some very nice object systems, and I like them better than Java's take on object orientation.",1526848127.0
waspishly_simple,"Land of Lisp is a \*really\* bad book for a beginner to use.

There are two families of ""traditional"" Lisp: Scheme and Common Lisp. The differences are a bit esoteric so pick one and go with it. The most modern incarnation of Scheme is Racket, see r/Racket

If you're interested in Scheme I suggest ""How to Design Programs"" or if you are comfortable with a more advanced texts then there's the classic ""Structure and Interpretation of Computer Programs"" \(SCIP\): not strictly a Scheme book but one of the authors is a Lisp pioneer and they chose Scheme as the language for the book. The big advantage of Scheme is that you don't have to learn Emacs. Also books in the ""The Little Schemer"" series, which are useful for both Scheme and Common Lisp \(but not so much Clojure\).

If you're interested in Common Lisp I suggest ""Practical Common Lisp"" \(PCL\) by Peter Siebel or, if you have any interest in early/simple AI, ""Paradigms of Artificial Intelligence Programming"" \(PAIP\) by Peter Norvig. Further reading would include ""On Lisp"" and ""Let Over Lambda"".

Given your background with Java and interest in functional programming \(neither Scheme nor CL support functional programming particualry well\) then consider Clojure: a modern Lisp that runs on the JVM and interoperates with Java, e.g. you can use Swing from a Clojure program. It is a functional programming language \(you have no choice \-it's less general paradigm than Scheme or, especially Common Lisp\) and has functional data structures sewn into its fabric. ""Clojure for the Brave and True"", ""Clojure Programming"", ""Programming Clojure"" and ""Web Development with Clojure"" are books worth considering.",1526883025.0
stylewarning,"There were a few gaffes. The for-loop expansion was close but wrong. The Lisp pseudosyntax for the macroexpansion isn’t valid. The term “variable” was used instead of “symbol” sometimes.

Overall I found it very difficult to on-the-fly explain these concepts in sub-10 minutes to a very general audience. But I hope this video was at least more substantive than the last. They’re concepts I definitely wish were a little more well known. :)

Feedback welcome!",1526682398.0
pbewig,Look at [http://www.gigamonkeys.com/book/](http://www.gigamonkeys.com/book/). It's a well-regarded online book that shows you how to install Lisp on your system and get started programming with it.,1526660625.0
flaming_bird,"> Or should I just learn a more modern language like C or C++?

Lisp is as modern as they are.

Use a combo of Portacle and Practical Common Lisp, as mentioned by other people. If you run into trouble, fire up an IRC client and go to `#lisp` or `#clnoobs` on the Freenode network.",1526667531.0
Paradiesstaub,"If you are searching for something easy and well integrated go with [Racket](https://racket-lang.org/) and DrRacket as IDE \- this is the easy route.

A typical Common Lisp setup would be:

* [SBCL](http://www.sbcl.org/) Lisp
* [Emacs](https://www.gnu.org/software/emacs) as Editor, [here](https://github.com/caisah/emacs.dz) some examples  of Emacs config files
* With the [Melpa package manager](https://melpa.org/#/getting-started)
* And the [SLIME](https://melpa.org/#/slime) package for Common Lisp
* Plus the [Smartparens](https://melpa.org/#/smartparens) package
* And [Quickload](https://www.quicklisp.org/beta) as Lisp package manager

The learning curve is quite high. You will learn a lot, it might often be frustrating. Maybe there are easier ways, but something like the above list is what most people use.",1526659962.0
defunkydrummer,">What compiler or text editor should I use? And how do I use it?

Easiest choice is to download and install Portacle. This installs everything you need including a Lisp ""implementation"" (SBCL). Then, you need to get familiar with SLIME and Emacs, but there are already tutorials for those two.

",1526672728.0
mmontone,http://articulate-lisp.com/,1526682638.0
kazkylheku,"You can use CLISP directly. Run CLISP and you get an interactive listener with editing and history recall.

You can edit files outside of that using whatever editor you like, in another window.

From CLISP, you can load  a file using the `load` function, like this: `(load ""myfile.lisp"")`.

If you edit the file, you can load it again using the same command.

Tip: in CLISP, if you get entangled in some error exception, perhaps a nested one, just use `:a` to abort to the top level again

Don't worry about compiling; you don't have to compile functions or files in order to learn Lisp.

Compiling is just for faster loading of larger programs, faster execution, and, above all, for turning programs into reverse-engineer-resistant, proprietary gobbledygook so you can get paid.
",1526706990.0
GoodPolitician,[Also old but a not a bad place to start. ](https://opensourceforu.com/2011/06/lisp-tears-of-joy-part-1/),1526659028.0
lisp-is-noice,"I usually start with a (    :-)

but seriously  :
 * Portacle to get a system running fast and
 *  find a small project to do by yourself in order to drive your motivation and get into practical issues .. could be different for others but for me it helped a lot.
",1526697045.0
HoboJuiceyJuice,"Hi fellow Lisp newbie! 

I don't know if you're dead set on Common Lisp or not. If not, I had a great time starting out with Structures and Interpretations of Computer Programs (SICP) using the Racket language (a lisp dialect) and the Dr Racket IDE. SICP uses Scheme but it's no problem at all to get it to work with Racket. I chose Racket because DrRacket made it really easy to get started with minimal hassle. I think there's a lot of carryover as a beginner from learning any lisp dialect if you want to move onto another dialect later. Also, I think SICP was just one of the best texts on programming I had ever read. I'm learning Common Lisp now and I appreciate learning the fundamental skills in a more minimal language before moving on to the awesome behemoth that is Common Lisp. 

But if you're set on Common Lisp I second all the recommendations for Practical Common Lisp. It's a great overview of the language. Although it does lack exercises in case your looking for a book that you work through rather than read.

Edit: Sorry, I missed that you seem to be looking for newer material. SICP and PCL (especially SICP) are pretty old now but I think they both hold up very well so it shouldn't be an issue.",1527149340.0
longoverdue,Racket.,1526699795.0
reddittidder,"For me, as a complete beginner the following was the path of least resistance:

* Download [Common Lisp: Interactive Approach](https://github.com/rigidus/lisp-doc/blob/master/Shapiro-Common-Lisp-An-interactive-approach.pdf)
* Download [CLISP](https://clisp.sourceforge.io/) for your OS.
* Fire Up CLISP and go through every exercise one by one from chapter one. It starts with extremely simple concepts (e.g., it introduces Lists in chapter 8!) but it is important that you do not skip anything. Read the preface (you really should.)

 Stay away from emacs if you can, it will frustrate the shit out of you if you haven't used it before and distract from the purpose of learning Lisp.  Play with the language, you will enjoy the process and feel confident with every single simple exercise.

At least I loved it when I was trying to play around with Lisp.

You can move on to Practical Common Lisp after that. Once you feel comfortable, you can download Portacle or SBCL or what have you and go nuts.

Good luck!

",1527089613.0
kdnbfkm,"Install Emacs if you haven't already. Try using it and learn a few of the keyboard cords, this might take a few weeks to get used to...


Emacs has a dialect of lisp builtin but is different than Common Lisp. However you mostly don't need to use that other dialect.


See if your Emacs has ""slime-mode"" pre-installed. If not you will want to instal it yourself. When editing files with a .lisp file extension a default emacs installation will do some automatic indentation but slime's indentation is nicer.

Press `M-x` (ESC then x) then type in ""slime"", press ENTER/RETURN. If that doesn't work then do the following: Press `C-x b` and type in *scratch* or otherwise find the scratch buffer. Copy & paste the following into *scratch*.


    ;;Add this to your emacs init:
    ;; load emacs 24's package system. Add MELPA repository.
    
    ;; Added by Package.el.  This must come before configurations of
    ;; installed packages.  Don't delete this line.  If you don't want it,
    ;; just comment it out by adding a semicolon to the start of the line.
    ;; You may delete these explanatory comments.
    (package-initialize)
    
    (when (>= emacs-major-version 24)
      (require 'package)
      (add-to-list
       'package-archives
       ;; '(""melpa"" . ""http://stable.melpa.org/packages/"") ; many packages won't show if using stable
       '(""melpa"" . ""http://melpa.milkbox.net/packages/"")
       t))
    
    
    (custom-set-variables
     ;; custom-set-variables was added by Custom.
     ;; If you edit it by hand, you could mess it up, so be careful.
     ;; Your init file should contain only one such instance.
     ;; If there is more than one, they won't work right.
     '(package-selected-packages (quote (sml-mode slime))))
    (custom-set-faces
     ;; custom-set-faces was added by Custom.
     ;; If you edit it by hand, you could mess it up, so be careful.
     ;; Your init file should contain only one such instance.
     ;; If there is more than one, they won't work right.
     )

Then press `C-j` with the cursor after the pasted part. You might need to add that code snippet to one of the emacs init files (i.e. $HOME/.emacs a file not the directory .emacs.d/ create file if not there).


You might have to exit all emacs windows/tabs/etc and restart... Actually this part is tricky... My installation ignores that that file...


Anyways after activating that snippet in *scratch* and before logging out! Try `M-x` ""package-install"" then enter ""slime"". This might be wrong and take some stumbling around and reading guides on the internet, but keep trying!


That may or may not be how I did it. Maybe not... Another thing to try is download https://beta.quicklisp.org/quicklisp.lisp and load file with your lisp compiler/interpreter (i.e. clisp, ecl, sbcl) outside of emacs. Some instructions should come up and a few lisp commands will need to be typed in.",1526766930.0
technomancy,Original game author here; happy to answer any questions.,1526666008.0
basic-gongfu,"I believe the idea is that CLOS couldn't know what kind of API you want for creating instances, using keyword arguments for all slots isn't much of an improvement over `make-instance`. I'd recommend adding whatever constructors you want with custom parameter lists and mapping that to `make-instance`. Just make sure to keep them clean of any initialization logic besides parameter mapping, that kind of code is better to kept in `:initform`s or `initialize-instance` methods since it allows user code to drop down to using `make-instance` as needed.",1526604072.0
lispm,"btw.

    (apply 'foo (cons a b))

is just

    (apply 'foo a b)",1526604631.0
death,"The [Keene book](https://www.amazon.com/Object-Oriented-Programming-COMMON-LISP-Programmers/dp/0201175894) advises to write such ""constructor"" functions, and at that time this conservative advice made sense.  If you want to expose a traditional looking interface, that hides the fact that you're using CLOS internally, then it's a good idea to define a `make-foo` function.

Nowadays, CLOS is widely supported and accepted.  Therefore, you may want to expose the fact that you're using it to the user, which in turn may want to do things like subclass or define new methods.  Then, it's better to just expose the class's name and let the user instantiate objects using `make-instance`.

Of course, in certain cases you may want to provide convenience syntax to create instances, but that is another matter.",1526641595.0
flaming_bird,"You can write a constructor in form of

    (defun make-foo (bar baz quux)
      (make-instance 'foo :bar bar :baz baz :quux quux))

Such things are pretty often used in Lisp whenever you do not want to use the standard MAKE-INSTANCE functionality.",1526667619.0
kazkylheku,"`make-instance` is a generic function. By passing the `myclass` symbol to it, you're calling its `symbol` method. That specialization calls `(find-class 'myclass)` to fetch a class object: an instance of a *metaclass* and then recurses: it calls `make-instance` on the object returned by `find-class`. 

In other words, the class you defined is itself represented by an object: an instance of a *metaclass*. That object can be retrieved using `(find-class 'myclass)`.  This object supports a`make-instance` method for creating instances of the class that it represents.

You can take this object and pass it around; some piece of code somewhere can call `(make-instance param)` where it doesn't know what class `param` is.  Classes being instances of meta-classes, means that the Factory Pattern is unnecessary. To have a factory which makes several related objects, we just need a list (or other collection) of several classes; and call `make-instance` on them.

",1526767652.0
leodash,"Since you're from Clojure, I'd suggest [Spinneret](https://github.com/ruricolist/spinneret) over CL-WHO. It is closer to Hiccup, for e.g, to generate id/class using selector syntax.",1526593733.0
dajoy,[Artanis](http://lists.gnu.org/archive/html/artanis/2018-05/msg00001.html),1526595356.0
patrixl,"My own path was Hunchentoot, realizing I was hand rolling a lot of code to load modules and make my app modular, which led me to wookie, which led me to Radiance as a full web app framework. I don’t regret it, but my needs were quite complex. And I wouldn’t understand Radiance as much without having been through these steps. ",1526599301.0
quakerquickoats,"Caveman2 

[https://github.com/fukamachi/caveman](https://github.com/fukamachi/caveman)",1526595444.0
svetlyak40wt,There is another useful library — LASS. It is a CSS generator. ,1526615881.0
mikeivanov,"I'd recommend the Ningle/Clack/Hunchentoot stack, CL-WHO and perhaps Parenscript.",1526596810.0
theangeryemacsshibe,"Hunchentoot is good for running the server, CL-WHO for generating HTML and Parenscript for any JS generation is good. Iirc these recommendations and some usage examples came from a book called *Lisp on the Web* and is available free (if you provide an e-mail address to the publisher).",1526592939.0
mini_eggs,"I like wookie for cl, paired with other common libs like yason, cl-who, cl-mysql, parenscript, whatever!",1526611232.0
hardwaresofton,"I desperately wanted to use CL for a recent project, but I couldn't find a library that combined both threading and asynchronous (libev/libuv) approaches -- from what I can tell approaches based on hutchentoot do threading, and libuv/libev based projects are single core, leaving you to coordinate at a higher level.

Couldn't figure out whether I [woo](http://wookie.lyonbros.com) or [caveman](https://github.com/fukamachi/caveman)  (though caveman has more things in it) was better.",1526620459.0
quackyrabbit,Checkout Racket's sublanguage: [web-server/insta](https://docs.racket-lang.org/continue/index.html?q=web%20applications) ,1526622088.0
minasss,"Wow, thank you for pointing out so many options!
A long rainy week end is coming and now I know how to invest some of this free time :)

Lately at work I have been using Flask and I like the micro framework approach so I think I will use Ningle(x) over Woo web server (no CPU intensive project so libev based event handling is enough)

After evaluating what to use to handle web requests I will have to investigate:  
 * testing  
 * what to use for persistence: I am thinking about a document based db like mongodb, are there libraries which are non blocking and that play well with event based systems?  
 * packaging and deployment: lately I have been using Docker and compose and I like this approach but I am open to more ""lispy"" solutions  
 * CI/CD  
 * logging and monitoring

I think I will have a good week end :D 
Thanks again!

Edit: bullet list",1526624309.0
Shinmera,"I'm biased, but I like [Radiance](https://shirakumo.github.io/radiance-homepage/) for the backend. I prefer to keep my frontend logic as minimal as possible, so I just write plain JS for that.",1526633440.0
GlassGhost,"https://www.youtube.com/watch?v=rMqo3lgxe7o  
Creating Serverless Applications with ClojureScript and Firebase: Jake McCrary",1526646902.0
arpunk,You could also try [LFE](https://github.com/rvirding/lfe) or [clojerl](https://github.com/clojerl/clojerl) and [cowboy](https://github.com/ninenines/cowboy) as HTTP server. Both languages target the Erlang virtual machine.,1526686644.0
dzecniv,"A curated and opinionated set of web frameworks and other libraries: https://github.com/CodyReichert/awesome-cl#web-frameworks

I quickly tried Caveman and Ningle, I find them clunky and inconsistent (like how to get query parameters), then Lucerne seems sanier but less developped. They all need additional packages to ease debugging (clack plugins like clack-errors). I quickly tried Snooze and it felt better. Declaring routes and parameters is like regular functions, so there is less ceremony than in Caveman. It has built-in debugging parameters, it doesn't need clack-errors.

But they are ""only"" backends, I'd love to write a dynamic web app all in Lisp, without separating back and front. Here comes Weblocks, in the same field as Ocaml's Eliom, Haskell's Haste, Nim's Karax, which is being updated here: https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst This quickstart works very well, I have two little apps working on it. It's (also) very alpha, but full of promises :)",1526650158.0
flaming_bird,"I came because of its unusualness, I stayed because of its usefulness.",1526548733.0
patrixl,"Got annoyed at newer languages constant changing syntax and standard libs, Haskell’s unreadable syntax and design, which is also constantly changing, or the annoying boilerplate or instabilities or other languages. ",1526532008.0
waspishly_simple,"Because there were lots of things I kept wanting to do because they were ""obviously"" the right thing to be able to do  but were either impossible or horrible kludges.

For example passing a function into another function. Isn't that an obvious thing to need to do? Clearly not to C or C++'s or Java's designers.

How about defining an add operator for adding a complex number to a float? Do I define it on the complex number class, the float class or on some random third class called Math? Aren't all of those answers obviously wrong? Again, not for the designers of C++ and Java.

I once asked Stroustrup if he regretted C++ and he said not. I guess the book royalties and speaker fees and fame (infamy?) help assuage any guilt :-)",1526549862.0
sammymammy2,"Because I was young and naive and listened to strange people on the Internet.

pls save me",1526560112.0
defunkydrummer,">why did you decide to learn Lisp?

Ok, serious answer now.

After about 22 years of programming, having used most mainstream languages, I had some warning signs. First one was, years ago, reading the greenspun quote that says:

>""Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.""

I didn't understand the reasons why, but I took note. I had always been interested in peculiar languages, having tried a bit of Forth and Prolog in the past. Prolog blew my mind off, so I was eager for repeating such an enlightening experience. 

Years later, I found a post announcing the Land of Lisp book, whose website [has a fascinating comic](http://landoflisp.com) which motivated me to dig more into Lisp. I was in stitches with that strip, particuarly the part where C++, Java, Python et al are depicted as weapons or vehicles.

I wasn't new to a ""dynamic"" programming language, being already quite experienced in Python. However, after reading the Wikipedia articles on Lisp and Common Lisp, and the famous Paul Graham article, and the first chapters of ""Practical Common Lisp"", it was very clear to me that this was potentially the most powerful and flexible programming language i've ever found.

First, i was totally convinced by metaprogramming as implemented on CL. The benefits and usefulness were obvious to me immediately. Second, the conditions-restart system. It was the obviously elegant way to handle exceptions. The Land of Lisp comic was right: ""*Back in the eighties, we showed you how to program without ANY bugs!*""

But in particular, reading about CLOS blew my mind, and after understanding multimethods and method combinations, it became completely clear how wrong was the typical (i.e. Java) approach to OOP, and how CLOS was the salvation, the purification of prior sins.

Moreover, the whole philosophy of CL was  giving the programmer maximum control, maximum flexibility. This is also my philosophy too. I was sick of finding many new languages based on the premise that the programmer is a baby that needs to be put into a playpen. 

Thus, I had to set myself on the task of learning Common Lisp, no matter how hard it could be. This was the programming language for me.",1526563065.0
GNULinuxProgrammer,It was a mandatory part of my CS curriculum and emacs.,1526532171.0
S_Nathan,"For me, Eric S. Raymond is at fault.  First, he is sometimes quoted saying that
learing Lisp will make one a better programmer, even if one does not use it
much.  This being due to an enlightenment when one finally gets it.  Second, I
read a bit of The Art of UNIX Programming.  It features a case study on Emacs
(and thus, Emacs Lisp).  All of this sounded very interesting to me (a staunch
vim user at the time).

So I gave Emacs a try and used it as a good excuse to learn some (Emacs) Lisp.
It was all fun and games, but elisp does have its limitations, especially when
it comes to using it outside of Emacs (hint: don’t!).

One thing then led to another (some CL, some Clojure, very little Scheme), and
here I am now, writing Common Lisp code for a living and loving it.

PS: Yes, there were all sorts of reasons to get into Lisp, but I guess everyone
gives them, so I’ll not bother you with the usual suspects.

EDIT:

What Raymond did *not* mention though, is that learing Lisp  not only enlightens
you, but spoils your character.  I couldn’t bear using lesser languages
anymore.  Even Scheme is beginning to fall into this category for me.  So beware
of what you are getting into, dear reader!
",1526567744.0
theangeryemacsshibe,Cause RMS did it.,1526540871.0
holomorphish,"I learned it out of spite. My older brother suggested I try it, based on the fact that I'm a mathematician, which in his eyes makes me some kind of space alien. (I always tell him that I'm the normal one, he's just an idiot. He agrees about the second part.) I was hoping that it would suck and then I could rub it in his hipster face. I could make fun of him at family gatherings for years with this!

So I checked out the Little Schemer from my uni library and I haven't been the same since.",1526571833.0
zck,"Paul Graham's writings. I was also just getting into Emacs, so that helped -- I assume.",1526575595.0
donaldfisk,"The first non-trivial program I wrote composed melodies.   I wrote it in Basic, as it had better string-handling than Fortran.   A colleague pointed out that as what I was writing was artificial intelligence, I should look at Lisp.   So I bought a copy of Winston and Horn, first edition.   This was in late 1981.   I didn't have a computer to run it on until the following year, when I had access to Portable Standard Lisp.

Many years later, I wrote a similar program (this time with harmonic accompaniment, and outputting to a MIDI file) in Common Lisp as a hack day project, which had to be completed within 24 hours.
",1526591070.0
defunkydrummer,"Why? Because of reading this:

""DRIVEN TO THE BRINK OF SANITY BY THE CONSPIRACY'S FALSE REALITY AND THE PRESSURE OF A CRUMBLING WORLD?? THEN THIS MAY BE FOR YOU!!

You might be SO OUT OF IT that YOU DON'T EVEN KNOW WHO JOHN MCCARTHY IS. Even worse, you may not care! Of course, there's considerable pressure to keep you from caring whether you care or not, and it's so much easier to just let that Java keep you slowed down ... you're used to it... you can take it... it's a living ... you'll just go on about your job ... doing what you're told... ...because everything we say from here on out is going to sound like UTTER INSANITY to you; at least, if you're NORMAL it will... 

...uh...

...you are NORMAL, aren't you?

WAKE UP!! Snap out of it! REPENT!! QUIT YOUR JOB!! LISP OFF!!! ... if only for a second, that's all we're asking. 

Then you can go back to sleep, or to Hell. 

THE QUEST: 

SOMETHING FOR NOTHING 

THE GOAL: 

WORLD WIDE LISP 

SubPurposes: 

TO END DEATH, TAXES, HUNGER, WAR, DISEASE, ELECTRON, NODE, and JS 

""As long as we don't use Lisp, we are not free."" -- John McCarthy

THE WEAPONS:

THE POWER OF METAPROGRAMMING, HOMOICONICITY, and CLOS""

[original source](http://www.subgenius.com/pams/pam2p2.html)",1526530670.0
berock212,"For me it was the reputation lisp had of being this amazing programming language that will change how you think about things and the idea that there's lisp geniuses that are brilliant people who love to work in lisp. I had to see why it had such a reputation. 

Edit: spelling",1526569992.0
HoboJuiceyJuice,"In undergrad I worked in a lab doing biostatistics and machine learning in R. After undergrad I was looking for ways to step my game up for grad school. I heard that R was partly inspired by Scheme and that I could write better R if I knew Scheme. So I got SICP and started doing that. At the same time, I was also trying to improve my machine learning skills and got really interested in good old-fashioned AI accidentally through that. Then I saw that most of the best textbooks on gofai used Common Lisp. So I started working through Norvig's PAIP. Now I'm hooked. The process of creating things in lisp is so enjoyable and I don't want to go back to stat scripting in R again. In undergrad I thought I knew exactly what kind of research I wanted to do but now I am consumed with uncertainty. Thanks lisp.",1526570982.0
richardjdare,"Lisp had been at the back of my mind for many years as I'd heard so many respected tech people talk about how good it is, but I never got round to learning it.

What really motivated me was finding out about Lisp Machines. After I actually had a go on Symbolics Genera and was blown away by it I knew I had to learn Lisp properly. I wanted to make things that were like Genera.",1526573370.0
SoraFirestorm,Learned because of Emacs. Didn't sit right with me to not know at least some fundamentals of how it worked so that I could do at least rudimentary extensions on my own. Then I fell in love.,1526580194.0
basic-gongfu,"Two words, Paul Graham.

They even tried to teach it to me at university; just looked weird to me, couldn't see why you would want to do something like that. Prolog on the other hand just clicked, go figure. But the more languages I learned, the more I got used to being proven wrong when it came to things that looked weird on first blush. And right around then, PG started making a lot of noise about Lisp; saying things that I knew to be true from first hand experience and suggesting that Lisp offered another level of power. Still took me 5 years or so from that point until I was fluent in the language, I'd spend a couple of weeks hammering on it until I got tangled up in my macros and then take a step back to regain some sense of sanity. C worked the same way for me, step by step; gradually gaining enough experience and confidence to move freely without making a mess. Despite being as different as languages can be, I still find them to be more like each other than any other.",1526585181.0
azzamsa,"The first time I know Lisp, is from RMS article ""How I do my
computing"". I know that Stallman is a smart person (even bit
controversial). Because of his cleverness I start wondering why such
smart person love lisp ( at that time I had no idea what is lisp). I
start searching ""Lisp"" in search engine. I landed in Common Lisp
Foundation website, which doesn't contain so much thing. That
day I go with PCL for week and stopped at chapter 2. because I don't
really get it (I think because that time I still have very basic
understanding of programming).

Some months past. I wondering again. In what language my time should
be invested. I want to learn very deep to it's internal. So I really need
the language that I love to keep me motivated.

I remember Stallman compliments about lisp. I took a time to learn
what is lisp. Then I find lisp article from ESR and PG. They are
really smart hacker. So I decide to go with lisp.

I suspend all my learning in Operating System. Then I jump deep to
programming languages. At first, I take Common lisp with PCL as a
guide. Then I move to Scheme. I stop learning lisp that month cause I
had lot university task (which was in Java).

Jump again to guile. Then I think I want to make big project with
Lisp. I find many big project use Common Lisp so I pick Common Lisp
and stick with it until now.

I do all my university project at my fifth semester with Common
Lisp. :)

Now I am learning Python. Because I don't find any startup/company
here (Indonesia) using Common Lisp. I felt hard at first to leave
Common Lisp and start learning python. But it's okay. Both of them are
just a tool to put in your toolboox.

Even if you work with other tool. You have to learn the *best*
possible tool you can use. even you don't use it at work. It's give
you other view and understanding of thing you never get with basic
tool.

*Before jumping into Common Lisp. I asked many advice and opinions
from present Lisp hackers. Thanks for their patient and kindness to
response me. They are very kind*",1526692523.0
dzecniv,"I'm coming from Python and JS, I write web apps and I am frustrated by lots of things, I had appreciated a lisp and a live environment with Emacs Lisp so I had the intuition CL could help. Of course I was hooked by the old fame. After a harsh initial period, which hopefully should be easier now with some better doc (CL cookbook, awesome-cl, etc) and new projects (Portacle), it delivers.

First thing firsts, I am tired of Python (the language) limitations. For example, context managers are cool, but I can't do what I want, and I often wanted to do more. It's also a special construct, with its own class, constructor, rules, etc. There is space for better refactoring constructs. This is naturally fixed by Lisp macros, which are a simple element of the language. Python's code is clear, but editing it is boring, and the language and the indentation make good tooling difficult. I spent time implementing an emacs package to navigate more easily through indentation, I searched for packages to navigate more intelligently (go to beginning of defun, go to next statement,…), but I realized this is fighting against the language. This is all natural in lisp (specially after I learned lispy-mode). I am bored switching between a terminal and my editor to run a python repl or run my tests. I couldn't do all this inside emacs, and anyway a local webserver is typically run in a terminal and it restarts at each code change. This has always been better with a Lisp REPL. I can run the unit tests I am in right away (C-c C-c, with Prove), when I contributed a little bit of code to Elpy which didn't work anymore some months later.

Python the platform… it is slow and I feel it even on my little projects. SBCL compiles to machine code. We can't even build an executable O_o Let alone one of a web project… we can build self-contained executables of a web app in CL, it will contain the production server and even an interpreter and the debugger (which other lisps do not do). I can rsync the binary to my VPS and run it. That simple. I can ship software to non-programmer clients. Well, the joys of a compiled language, with more stuff. 

Let's speak about the ecosystem. I hadn't realize before but it is way saner and it allows to do more with less. About deployment, in Python you use the django dev server, then what do you peak between apache's mod_wsgi, mod_python, gunicorn, uwsgi, also whitenoise, rednoise, etc ? In CL you development with a the production webserver, you compile your app with it, you deploy with it, it runs and is accessible right away. Then pip seems to be nice, but for deployment, given there is no standard way to package all the dependencies (maybe platter ? But who speaks about it ?), everybody uses pip install on production, then you can get dependencies mismatch and installation errors *even if you pinned your dependencies*, if a dependency didn't pin its owns well enough you're screwed. Think of Quicklisp as apt that delivers a set of libs that work together.

And Python and its libraries are not stable. You need work to upgrade to python 3, to upgrade django and all the rest. If you don't you can have dependencies problems. And the thing is I don't want to do that in my personal projects, I have application code to write thank you very much. 

The JS ecosystem is all worse, the JS frameworks again worse. What does CL offer for the web ? Well, hard question. I didn't try Parenscript or JSCL and I don't plan to, I'm betting on web frameworks that don't rely on JS: https://github.com/vindarel/awesome-no-js-web-frameworks Ocaml's Eliom (a pain to install, compile and deploy AFAITried), Haskell's Haste and others (no thanks), Nim's Karax (yeah, excited about that one, but it's all very very much alpha), Clojure and ClojureScript (no thanks ! They're relying on the JS ecosystem too much and well, this lisp can't do as much as CL so I'd rather learn more), a couple others, and CL's Weblocks, which is being worked on here: https://github.com/40ants/weblocks/blob/reblocks/docs/source/quickstart.rst The goal is to development a dynamic webapp in our usual, consistent and good development environment. I got it working, I'm not advanced enough to really judge its limitations and all this may be against history but I have to try and at least I'm not alone :]",1526560931.0
maufdez,"Every couple of years I look for a programming language to learn, the requirement is that it has to be different, so I can learn something from it, about 6 years ago (I think) I started studying options for a language to learn, I found Lisp in an article when I was investigating Python, and it sounded so cool that I decided to learn that instead. I'm glad I did, I learned more from Lisp than from any other language. Citing myself [""There are two types of persons, lispers and the rest, since the rest is cdr then lispers are the car.""](https://twitter.com/MauricioFdezF/status/514070362795950080)",1526579836.0
ccQpein,"The word Lisp appears several times in a special period of my learning programming processing. So I thought, why not try to learn it, maybe it is fun. And, yes. It is fun to me.",1526580901.0
tsuru,"I learned that Mirai was written in Lisp and that took me down a rabbit hole of Lisp and 3D graphics history.
",1526602325.0
eitectpist,I was working on my first nontrivial JavaScript project and found myself hacking things together using closures often. I was interested in learning more about this style of programming and stumbled across a book called Let Over Lambda that sounded relevant based on it's title. From there I fell down the rabbit hole.,1526692780.0
Bourgond_Aries,"Always hated that I couldn't do something in an intuitive manner in other languages. Stuff like ""design patterns"" are just band-aids on language flaws. This paragraph both resonates and inspired me at the time...

""Macros are the single greatest advantage that lisp has as a programming language and the single greatest advantage of any programming language. With them you can do things that you simply cannot do in other languages. Because macros can be used to transform lisp into other programming languages and back, programmers who gain experience with them discover that all other languages are just skins on top of lisp. This is the big deal. Lisp is special because programming with it is actually programing at a higher level. Where most languages invent and enforce syntactic and semantic rules, lisp is general and malleable. With lisp, you make the rules.""",1526708143.0
Paradiesstaub,"Because Lisp has a minimal syntax and is at the same time maximal powerful. This trait combination is always special. We love and seek for it in art, relations, writing, math – it is a characteristic of true things, and Lisp has it too.

It's not really possible to remove some syntax of Lisp without loosing a major strength. At the same time adding more syntax wouldn't gain the programmer anything.",1526719189.0
bitwiggler,"Been using Allegro CL so long, I forget that other languages have come and gone.",1527470696.0
,[deleted],1526537463.0
patrixl,Not sure about Common Lisp implementations but Picolisp has ] which does exactly that. ,1526531808.0
kazkylheku,"This is an obsolete approach called the ""superbracket"" which was featured in some Lisp dialects in the 1960's. 

The superbracket had to match with its mate. So that is to say, `]` would close everything back to the closest outstanding `[`, like this: `[defun foo () (... (... (...   ]`.

Today, you aren't working with punched cards; you can just hold down `)` so that it autorepeats, then stop when the editor indicates balance. If you overshoot by a few parens, backspace until the editor shows balance.

Love the `))))))`. It's a lot more convenient than:

                      }
                    }
                  }
                }
              }",1526570569.0
flaming_bird,"You could theoretically do it with macros if you override the reader macro `#\# #\(`.

I consider this to be a wrong idea though because it cripples editing capabilities, such as simple paren-matching and S-expression jumping. In case you have code like `(foo (bar (baz)))` when your cursor is at the beginning of `(BAR`, you can no longer jump to the end of this S-expression to quickly type something like `(quux)` so the resulting code is `(foo (bar (baz)) (quux))` because, all of a sudden, you have `(foo (bar (baz}`.",1526555620.0
donaldfisk,"Yes, but I don't see the advantage of doing it.   Editors count parentheses for you.   They also indent your code, so if it doesn't like up properly you can tell that something's wrong.
",1526590287.0
yugoplast,"Interlisp used "">"" (in the years around 1980). This turned out to be not very practical, because only beginners used it, and they fucked up more with "">"" than "")))))"". ",1527665863.0
dzecniv,"If you're annoyed by the parenthesis, I suggest to have a look to some editor plugins (for emacs): http://wikemacs.org/wiki/Lisp_editing My favourite, after a dubitative period, is lispy-mode now. It allows structured editing and movements.",1526557027.0
quakerquickoats,"if one appears to maintain too many closing parens, perhaps one should consider refactoring.",1526595996.0
borodust,"Huge number of closing parens is a strong code smell. It hints there is a need to decompose the form further. 

Plugging it with superbracket is like using a perfume to hide the stench.",1526572741.0
flaming_bird,Duplicate of https://www.reddit.com/r/lisp/comments/8jy866/lisp_the_quantum_programmers_choice_computerphile/,1526562430.0
technomancy,So I mean... this has nothing to do with quantum computing? Kinda disappointing.,1526666573.0
gcross,"I know that this is off-topic and I am prepared to be downvoted for asking this, but is there some context I am missing for why /u/Godd2 is getting so many downvotes just for asking what appear to me to be genuine questions?",1526530913.0
Godd2,"> homoiconicity - where the language itself is written as a data structure that you can represent in that language.

I still don't see how this is special to lisp.  Lisp programs are strings, and so are Java programs, but no one says that Java is homoiconic even though Java has Strings.

What test can be run which Lisp passes and Java fails which betrays Lisp's homoiconicity?

Or is homoiconicity not well-defined?",1526517714.0
defunkydrummer,"You're doing God's work, Shinmera & the Shirakumo team.",1526488763.0
CelloAxeMurder,Thanks for all the effort you put into this project. Looking forward to trying out Sly later.,1526488599.0
mini_eggs,"Oh killer -- great job. 

This fixed the not opening issue I've been seeing on Ubuntu 18 as well.",1526490025.0
agambrahma,Awesome that you’re supporting `sly` now!,1526504012.0
sleinen,"""Anatomy of Lisp"" by John R. Allen is a book that I personally enjoyed a great deal. It goes into quite a bit of architectural/implementation detail, but I think it should appeal to someone with a background in mathematics. Of course since it's from 1978 it misses lots of things that were added to Lisp \(and its implementations\) since then, but that may not be too important for your quest at this stage... have fun!",1526471277.0
lispm,"If you look at some of the Scheme reports, they also contain a semi-formal semantics of the language. There should be some literature about that:  ;-)

http://library.readscheme.org/page2.html


There are also works about semantics in Lisp, or functional/applicative subsets of Lisp.",1526486412.0
waspishly_simple,"I suggest: ""Church's Lambda Calculus"" and ""Church's Thesis Functional Programming"" as initial searches to get you started. 

""Purely Functional Data Structures"" by Chris Okasaki is an interesting book and was fundamental in the design of Clojure, a modern Lisp built on the JVM.",1526466819.0
Anhanguera,It's gonna be hard learning about a programming language without also learning coding... The MIT textbook for compsci intro (or smt like that) is based on Lisp (Structure and Interpretation of Computer Programs). ,1526466646.0
jaoswald,"McCarthy was not really coming at Lisp from a purely mathematical direction. Of course, his Ph.D. was in mathematics, and he had read enough to have ""lambda"" in mind as the marker for an anonymous function, but he had not followed that to its conclusion but instead was pragmatically pursuing symbolic and list programming (which was very abstract for the time, but so was FORTRAN.)

http://jmc.stanford.edu/articles/lisp/lisp.pdf

That he was using symbolic manipulation to do things like differentiation is not really mathematical in the sense I think you mean.

Even McCarthy's paper ""A Basis for a Mathematical Theory of Computation"" http://www-formal.stanford.edu/jmc/basis1.ps is from 1961 and mentions ALGOL and other alternatives as well as Lisp and is somewhat removed from Lisp.

I suspect you will be more interested in the mathematical formulation of programming language semantics. https://en.wikipedia.org/wiki/Semantics_(computer_science) That took more than a decade to arise from these thoughts.",1526480198.0
sgoldkin,"Alonzo Church's Lambda Calculus.  (see also:  Combinatory Logic  -- Schönfinkel and Curry).  Also, Structure and Interpretation of Computer Programs by Harold Abelson and Gerald Jay Sussman with Julie Sussman.  Available free online:  http://mitpress.mit.edu/sites/default/files/sicp/index.html",1526497836.0
atonal174,You're asking for programming language semantics. You really should be asking this in /r/racket.,1526469390.0
flaming_bird,"See Touretzky's book on Lisp - https://www.cs.cmu.edu/~dst/LispBook/

It describes Common Lisp from the initial perspective of a non-programmer. It could be helpful for you.",1526471184.0
flaming_bird,"Nope, we can't stop you.

Also see https://github.com/brown/swank-crew for a LPARALLEL-less solution based on SWANK.",1526450299.0
kevisazombie,Honestly sounds like a good idea. Ansible is all YAML driven. Lisp s-s-expressions would probably be better for the task.,1526451261.0
dzecniv,Also find a pretext to use your Weblocks :),1526470052.0
morphinism,"I would never want interfere with this! A language on top of CL that covers the feature set of [HCL](https://www.terraform.io/docs/configuration/syntax.html) and ansible is something I have been daydreaming about myself. 

It might also be quite nice if it were ASDF-aware in order to make provisioning your infrastructure with lisp systems especially fluid.

If you embark on this project I would love to contribute if I have the time.",1526492169.0
tryptych,"Check out clojure's pallet for inspiration too -- I never got to use that in anger and it's now sadly dead, but it looked like exactly what I was after when I was stuck with chef.",1526463531.0
flaming_bird,"Also see Erlangen for CCL:

http://mr.gy/blog/erlangen-intro.html

https://github.com/eugeneia/erlangen",1526485038.0
rudolfo_christ,Yes.,1526452323.0
minusmakes,https://www.reddit.com/r/HomeworkHelp/,1526458761.0
Shinmera,"If you're doing this for the purposes of logging, you might want to look at [verbose](http://shinmera.github.io/verbose/), which should gracefully handle logging from arbitrary threads.",1526486173.0
flaming_bird,"It seems that you want to bind SWANK's special variables that hold the connection object inside your GUI thread as well. Look at the special variables inside the SWANK package, and look at the code from which the error is produced - you should figure out which variable is set to NIL where it should be set to a connection, and once you can do that, use the keyword arguments to BT:MAKE-THREAD to make a default binding of that special variable.",1526450137.0
borodust,"I'll try to be around for questions, but should just work (I've used it for the last jam game with no probs)",1526419532.0
bsd_lore,"Thank you for reminding me. That is a very important page, I would dare say precious, to any Lisper.

It is not a rare human tendency to rewrite history, and personally I feel that is fine as one's personal way of relief of some sort, as long as other more sober, straight versions are also found. It is a pity so many times antagonism and resentment lead one to diverge from brilliant realities, to create one's own at any cost.

PS: One could see interesting comments [here](https://web.archive.org/web/20121107150708/http://danweinreb.org/blog/rebuttal-to-stallmans-story-about-the-formation-of-symbolics-and-lmi) and [here](https://web.archive.org/web/20121107150522/http://danweinreb.org/blog/why-did-symbolics-fail)",1526388821.0
lispm,"If It Works, It’s Not AI: A Commercial Look at Artificial Intelligence Startups by Eve M. Phillips

https://www.ifis.uni-luebeck.de/~moeller/symbolics-info/ai-business.pdf


Symbolics, Inc.: A failure of heterogeneous engineering
Alvin Graylin, Kari Anne Hoier, Kjolaas Jonathan Loflin, Jimmie D. Walker III

https://www.ifis.uni-luebeck.de/~moeller/symbolics-info/Symbolics.pdf

",1526400938.0
XxZozaxX,"hmmmm.

where did I see this blog before ?",1526385505.0
GDP10,"Wow, very enlightening stuff. I've been reading a lot more and more about computing history lately and it seems that we're in a terrible quandary today largely because of an ignorance of history. Or because of a misrepresentation thereof.

Very valuable post, once again. Thank you.",1527980259.0
,[deleted],1526403674.0
jaoswald,"Unfortunately the late Dan Weinreb's blog is gone, but Feedly preserved this snapshot:

> Rebuttal to Stallman’s Story About The Formation of Symbolics and LMI

> 28 Dan Weinreb's blog / by Dan Weinreb

/ 1,537 days ago

> Richard Stallman has been telling a story about the origins of the Lisp machine companies, and the effects on the M.I.T. Artificial Intelligence Lab, for many years. He has published it in a book, and in a widely-referenced paper, which you can find at http://www.gnu.org/gnu/rms-lisp.html.

> His account is highly biased, and in many places just plain wrong. Here’s my own perspective on what really happened.

> Richard Greenblatt’s proposal for a Lisp machine company had two premises. First, there should be no outside investment. This would have been totally unrealistic: a company manufacturing computer hardware needs capital. Second, Greenblatt himself would be the CEO. The other members of the Lisp machine project were extremely dubious of Greenblatt’s ability to run a company. So Greenblatt and the others went their separate ways and set up two companies.

> Stallman’s characterization of this as “backstabbing”, and that Symbolics decided not “not have scruples”, is pure hogwash. There was no backstabbing whatsoever. Symbolics was extremely scrupulous. Stallman’s characterization of Symbolics as “looking for ways to destroy” LMI is pure fantasy.

> Stallman claims that Symbolics “hired away all the hackers” and that “the AI lab was now helpless” and “nobody had envisioned that the AI lab’s hacker group would be wiped out, but it was” and that Symbolics “wiped out MIT”. First of all, had there been only one Lisp machine company as Stallman would have preferred, exactly the same people would have left the AI lab. Secondly, Symbolics only hired four full-time and one part-time person from the AI lab (see below).

> Stallman goes on to say: “So Symbolics came up with a plan. They said to the lab, ‘We will continue making our changes to the system available for you to use, but you can’t put it into the MIT Lisp machine system. Instead, we’ll give you access to Symbolics’ Lisp machine system, and you can run it, but that’s all you can do.’” In other words, software that was developed at Symbolics was not given away for free to LMI. Is that so surprising? Anyway, that wasn’t Symbolics’s “plan”; it was part of the MIT licensing agreement, the very same one that LMI signed. LMI’s changes were all proprietary to LMI, too.

> Next, he says: “After a while, I came to the conclusion that it would be best if I didn’t even look at their code. When they made a beta announcement that gave the release notes, I would see what the features were and then implement them. By the time they had a real release, I did too.” First of all, he really was looking at the Symbolics code; we caught him doing it several times. But secondly, even if he hadn’t, it’s a whole lot easier to copy what someone else has already designed than to design it yourself. What he copied were incremental improvements: a new editor command here, a new Lisp utility there. This was a very small fraction of the software development being done at Symbolics.

> His characterization of this as “punishing” Symbolics is silly. What he did never made any difference to Symbolics. In real life, Symbolics was rarely competing with LMI for sales. LMI’s existence had very little to do with Symbolics’s bottom line.

> And while I’m setting the record straight, the original (TECO-based) Emacs was created and designed by Guy L. Steele Jr. and David Moon. After they had it working, and it had become established as the standard text editor at the AI lab, Stallman took over its maintenance.

> Here is the list of Symbolics founders. Note that Bruce Edwards and I had worked at the MIT AI Lab previously, but had already left to go to other jobs before Symbolics started. Henry Baker was not one of the “hackers” of which Stallman speaks.

 > * Robert Adams (original CEO, California)
> * Russell Noftsker (CEO thereafter)
> * Minoru Tonai (CFO, California)
> * John Kulp (from MIT Plasma Physics Lab)
> * Tom Knight (from MIT AI Lab)
> * Jack Holloway (from MIT AI Lab)
> * David Moon (half-time as MIT AI Lab)
> * Dan Weinreb (from Lawrence Livermore Labs)
> * Howard Cannon (from MIT AI Lab)
> * Mike McMahon (from MIT AI Lab)
> * Jim Kulp (from IIASA, Vienna)
> * Bruce Edwards (from IIASA, Vienna)
> * Bernie Greenberg (from Honeywell CISL)
> * Clark Baker (from MIT LCS)
> * Chris Terman (from MIT LCS)
> * John Blankenbaker (hardware engineer, California)
> * Bob Williams (hardware engineer, California)
> * Bob South (hardware engineer, California)
> * Henry Baker (from MIT)
> * Dave Dyer (from USC ISI)

http://danweinreb.org/blog/rebuttal-to-stallmans-story-about-the-formation-of-symbolics-and-lmi

",1526381145.0
bsd_lore,https://web.archive.org/web/20120909104608/http://danweinreb.org/blog/rebuttal-to-stallmans-story-about-the-formation-of-symbolics-and-lmi,1526389348.0
chebertapps,small pointer: check out quickproject and [this blog post](https://xach.livejournal.com/278047.html) for some insight,1526277282.0
piotr404,This video is great: [Common Lisp - How to Start a New Project](https://www.youtube.com/watch?v=SPgjgybGb5o) . I guess it fits perfectly with the title of your post.,1526280241.0
stassats,Just open a file and start writing code without overthinking it.,1526293794.0
eslr,Have a look at Quickproject: https://www.xach.com/lisp/quickproject/,1526277395.0
Shinmera,"From tinkering to a project or library it's really just a matter of writing a small `asd` file that lets you load the system through ASDF or Quicklisp and manage dependencies that way. I typically copy-paste the same `asd` file and adapt it to the project specifics. Something like this `project-name.asd` sample file:

    (asdf:defsystem project-name
      :author ""My Name <myname@mydomain.com>""
      :maintainer ""My Name <myname@mydomain.com>""
      :version ""1.0.0""
      :license ""MIT""
      :homepage ""http://github-or-whatever.url/to/project""
      :description ""Some short description""
      :serial T
      :components ((:file ""package"")
                   (:file ""other-file"")
                   (:file ""documentation""))
      :depends-on (:whatever
                   :dependencies
                   :here))

Expressed in this are my own ideas for how to structure a project, which you are free to ignore: a separate `package.lisp` file for the `defpackage`, and a separate `documentation.lisp` file for all the docstrings. The rest of the code goes into files as appropriate for the project. Note that both the `asd` and your `lisp` files should be in the same directory, and typically that directory will be for that project only.

Also good to have are a `LICENSE` copy and a `README.md`, if you care about sharing your code with other people, rather than just developing it for your own purposes.",1526288546.0
_errata_,"If you want pointers, you might want to look into C. 😎",1526350340.0
,[deleted],1526305063.0
defunkydrummer,"My quick 0.1 cents of advice:

1. You'll be more comfortable using some IDE, quickest thing to install and use is **Portacle** which is basically SLIME+Emacs+SBCL+Paredit+Quicklisp, ready to use. 

2. Don't split your work into packages at the beginning; just concentrate on everything working correctly and smoothly first. Leverage Lisp's interactivity; 30% of Lisp awesomeness is interactive development. 

3. Once you get a good amount of code (say, >=2000 lines?), then you might want to split it onto packages (*if it makes sense.*). One conventional way is to use one .lisp file per package, and to have a file (""package.lisp"") that defines all packages (defpackage this, defpackage that...)

4. Then, write your .asd (ASDF system definition) file, that defines your project as a system and specifies the compilation order of your .lisp files; as well as specify the required dependencies. You don't need to be a master in ASDF, just start by following a sample .asd file to see how it's done.

5. If everything is done correctly, then you can start a new REPL and use `asdf:compile-system` to check compilation is OK. Or, `ql:quickload` which would ensure the dependencies are there.

You don't really need ""roswell"" nor any other tool. You don't really need quicklisp either, but it's nice. ",1526311641.0
crabbone,"Few years ago I wrote this to get my friend up to speed at CL: https://github.com/wvxvw/sudoku-solver This is, like you asked for, an example project with minimal effort put towards usual aspects of a bigger project: documentation, unit tests, system definition.

Not saying it is perfect, but it's fairly small to be able to comprehend it all at once, and not contrived like many examples for the sake of example, although, it's not the best Sudoku solver :)

----

To reflect on your other questions:

> But as you go on in Project Euler, some of the questions build on each other, or you might find that pieces of code you wrote for another problem are relevant to your current one. Do I separate that code out into packages, with each package being a file? Do I need to start reading up on ASDF? How do I express a dependency between my current problem based code and the utility library I extracted out from a previous solution? Should all of this work correctly in the face of quicklisp as well?

Packages are complicated, but if you are doing your project in order to get a hang of it... well, there's no way around that, you'll have to use them in order to reuse your code.  You will need to read about ASDF.  Perhaps Gradle is the closest of the modern tools and technologies you listed to ASDF, but there are still a lot of differences.  My understanding for the reasons of ASDF existence is that `require` was not well-suited for real-life package management.  While ASDF improved that aspect, it, if compared to modern tools like Bundler (Ruby), NPM (Node.js), Cargo (Rust) etc. doesn't fulfill all the duties one would expect from it.  Quicklisp, while it builds on ASDF addresses some of those problems.  Again, if your end-goal is to understand how CL infrastructure works, making sure your package will work well with Quicklisp is worthwhile.
",1526304283.0
paulfdietz,"You first start by seeing what else has already been done, so you can start from something other than zero.",1526303539.0
amirouche,"There is no \*pointers\* in CL!

:D",1526290193.0
svetlyak40wt,"I'll add some opionated tips here.

**Use SLY instead of SLIME**

It is more consistent and have nice features, like access to any REPL's
results by it's number.

http://joaotavora.github.io/sly/#A-SLY-tour-for-SLIME-users

And if you are using named-readtables, then this SLY plugin will be
useful too: https://github.com/joaotavora/sly-named-readtables

**Use ASDF's package inferior system**

And one package per file. Here is example system definition:

    (defsystem app
      :name ""app""
      :version ""0.0.1""
      :class :package-inferred-system
      :author ""Alexander Artemenko""
      :licence ""BSD""
      :description ""Example site.""
      :pathname ""src""
      :depends-on (""app/app""))

After that, put your source files into the ""src"" subdirectory. For
example, your ""src/app.lisp"" should start like that:


    (defpackage #:app/app
      (:nicknames #:app)
      (:use #:cl
            #:f-underscore
            #:anaphora)
      (:documentation
       ""A web application based on Weblocks."")
    
      (:import-from #:app/utils
                    #:setup-logging)
      (:export
       #:main))
    (in-package app/app)
    
    
    (defun main ()
       (setup-logging)
       (do-some-staff))

Pay attention, to "":use"" and "":import-from"" definitions. ASDF will
figure out dependencies from them and you don't need to write these
dependencies explicitly in your ""app.asd"" file. This all works if your
add to your system's declaration "":class :package-inferred-system"".


**Use Roswell**

- to setup different Lisp implementations (SBCL, CCL, etc);
- to install lisp scripts from the github;
- to create command-line scripts and build binaries.

https://github.com/roswell/roswell

**Use Qlot to not clutter your system and pin dependency versions**

The most important feature is that with Qlot you can pin dependencies
and commit this information into the project's reporitory as qlfile and
qlfile.lock.

The second important feature - Qlot allows to use dependencies not only
from Quicklisp, but also from any VCS, like the Github.

Here is how the qlfile might look like:

    ql :all :latest
    # mito from quicklisp 2018-04-30 is broken under the CCL:
    # https://github.com/fukamachi/mito/issues/30
    ql mito 2018-03-28
    
    github log4cl 40ants/log4cl
    github log4cl-json 40ants/log4cl-json
    github cl-prevalence 40ants/cl-prevalence
    github lack 40ants/lack :tag with-patches
    github defmain 40ants/defmain :tag v0.3.0
    github cl-info 40ants/cl-info :tag v0.1.0
    github cl-telegram-bot 40ants/cl-telegram-bot :branch clos-everywhere
    github cl-yandex-metrika 40ants/cl-yandex-metrika
    github weblocks 40ants/weblocks :tag v0.29.0
    github weblocks-ui 40ants/weblocks-ui :tag v0.7.0
    github weblocks-lass 40ants/weblocks-lass :tag v0.2.0
    github weblocks-parenscript 40ants/weblocks-parenscript :tag v0.3.0
    github weblocks-navigation-widget 40ants/weblocks-navigation-widget :tag v0.4.0
    
    github slynk joaotavora/sly
    github slynk-named-readtables joaotavora/sly-named-readtables



Also, Qlot will install all dependencies into the local ""quicklisp""
subdirectory and many projects' dependencies will not interfere with
each other.

https://github.com/fukamachi/qlot


**Before writing your own library**

Search it at http://quickdocs.org
",1526284263.0
theangeryemacsshibe,You tried to get free internet points. You failed. Good job.,1526158719.0
berock212,Is this purposefully bad? Because if it is then it's excellent,1526334270.0
gslyon,"My apology to /u/xach, it was not my intention in any way to lessen Quicklisp, on the contrary.

I just found that post on UnixHumour. I thought some people, appreciating the ""Unix Haters handbook"", would find that funny, as I did, as it seems originated from a teenager-mindset, toying with Unix and Lisp at the same time.
",1526371878.0
dzecniv,"No idea, but I invite you to blog about your experience building a Qt app :)",1526131487.0
Shinmera,"Several things:

* With Qtools, simply printing an instance of a QObject normally will reveal its Qt class. Eg: `(print (q+:make-qpushbutton))` => `#<Qt::QPushButton ..>`. 
* Qt classes are not native CL classes, so `class-of` won't help you. You can access a QObject instance's class with `qt::qobject-class` if you absolutely need to.
* Any Qt function that is prefixed by `set-` can be accessed more idiomatically through `setf`. To use your first call: `(setf (q+:host-name (db w)) ""localhost"")`
* I doubt any of this has anything specifically to do with CommonQt (and even less Qtools). I'm afraid I have no advice other than to either strictly translate some tutorial, or to try it with C++ first to make sure there's nothing interfering.",1526159584.0
samth,You might like [http://docs.racket\-lang.org/html\-parsing/index.html](http://docs.racket-lang.org/html-parsing/index.html) and [http://docs.racket\-lang.org/webscraperhelper/index.html](http://docs.racket-lang.org/webscraperhelper/index.html),1526049826.0
Sun_Kami,"Check this out: https://stackoverflow.com/questions/15838749/web-scraping-with-scheme

Here's a starter for Guile: https://lists.gnu.org/archive/html/guile-user/2012-01/msg00049.html",1526039410.0
understanding23,"Given that Javascript and run of the mill web-dev jobs pay more, the salary is preposterous if you're not already a native Korean (meaning you plan to stay/retire in Korea). 

I suggest the salary be increased, substantially if they want to find someone who knows what he's doing. To me this job means substantial paycut (60% less than what I make now) and then moving to a foreign country and sticking
with that said paycut even though I don't plan to retire there.

I don't see how any Americans/Europeans who are good engineers would be interested in this.",1526047520.0
Aidenn0,Pay seems quite low; does the job come with significant equity?,1526016867.0
cube-drone,"> ""Still Hiring for a Dream Position""

> 80K",1526079089.0
cracauer,"I want to applaud Indeed for clearly stating the initial salary expectations. That's much better than a later surprise after you have already invested energy.

Whether it is enough or not is a completely independent question. Few here have lived in Seoul. We don't know whether there is equity. If you actually want to live in Korea a paid move is very valuable.

If you figure it is too low after looking into details you can always start haggling. It involves some self-selling, but then what doesn't?",1526206023.0
SlightlyCyborg,"I applied. I don't care about the salary, I just want the awesome job! I am American, but I've lived in Asia and enjoyed it.",1526264899.0
whism,"I would expect at _least_ twice that salary, plus equity...",1526151883.0
lucasecp,"I'm kinda of fit in this position. But, i'm finishing college only next year soo...
",1526037065.0
stassats,"That's not really a question about lisp, but programming language theory, isn't it?

Anyhow, (zerop (length sequence)) works on any sequence.

And don't forget to consider sequences that can be adjusted in length. How will vector-push-extend work if the empty vector is NIL?",1525964615.0
nsiivola,"Couple of considerations to come mind immediately:

ONE: Having a single type requires you to decorate operations. Consider:

     (add-to #<List size=0> elt) => #<List size=1>
     (add-to #<Set size=0> elt) => #<Set size=1>
     (add-to #<Vector size=0> elt) => #<Vector size=1>

That works nicely, but what kind of object should

    (add-to #<Empty> elt)

return? Meh. So you end up with something like:

    (add-to-vector #<Empty> elt) => #<Vector size=1>

I prefer the undecorated version. If the type matters it should be declared or enforced otherwise.

TWO: Your types also get more complex because all collection types end up more or less looking like:

    (deftype foo () `(or empty real-foo))

...and then anywhere you have a 'foo' you have to be careful to use only operations that work both on 'real-foo' AND 'empty' on it until you've verified that you really have a 'real-foo', leading to more complex code. (Or you constrain all objects that can be empty to share the same interface, which you probably don't want, because not all operations make sense on all sets/collections.)

Finally, since this is a hypothetical programming language you're speaking about, you could just as well define

    (equal? #<Vector size=0> #<Set size=0>) => true

if you wanted. I'm not sure that's a great idea, but I suspect it is better than making all empty types actually the same.
",1525980151.0
kazkylheku,"Not only that but whereas there is only one empty list, there can be multiple empty string objects. The way out (partially) of this seemingly difficult question is to look at equality. String equality requires the `equal` function. If we use `eq` or `eql` on strings, then `""abc""` isn't necessarily the same as `""abc""`; if we use `equal`, then they are. And under `equal`, there is effectively one empty string. Only mutation will reveal otherwise: that we can mutate some `""abc""` to `""abd""` and another `""abc""` either follows suit, or stays the same.

As far as the ""common null"" goes, there are situations in which it makes sense; like if you want certain generic properties to hold.

In the Lisp dialect called TXR Lisp, I generalized the classic list operations over other sequences:

    1> (car ""ab"")
    #\a
    2> (cdr ""ab"")
    ""b""
    3> (cddr ""ab"")
    nil

Many of the operations implicitly *nullify* the result so that *nil* comes out instead of the empty sequence of the same type.

    4> [mapcar succ ""abc""]
    ""bcd""
    5> [mapcar succ """"]
    nil

This *nullify* function is explicitly available as `nullify`:

    6> (nullify ""a"")
    ""a""
    7> (nullify #(3))
    #(3)
    8> (nullify #())
    nil
    9> (nullify """")
    nil

In many situations you don't want this.

    10> (remq #\a ""a"")
    """"

It's not entirely a clean concept; pragmatics prevail. Mostly the nullification occurs in function that are classically list-only.

Like you say, tradeoffs, tradeoffs.

OOP structs can actually implement a nullify method.

    1> (defstruct foo ()
         (:method nullify (me) :poop))
    #<struct-type foo>
    2> (new foo)
    #S(foo)
    3> (nullify *2)
    :poop

Structures that implement [`car`, `cdr` and `nullify`](http://nongnu.org/txr/txr-manpage.html#N-035F2D99) can be used as list-like sequences.
",1525931356.0
terrybland,"Here's a concrete example. https://en.wikipedia.org/wiki/Unit_type says

    In Common Lisp the type named NULL is a unit type which has one value, namely the symbol NIL. This should not be confused with the NIL type, which is the bottom type.

https://en.wikipedia.org/wiki/Bottom_type says

    In subtyping systems, the bottom type is the subtype of all types.

Accordingly, if there's a single empty set (nil) common for all collection types, as I'm proposing, does this mean that the unit type would be a subtype of all collection types? And is this a standard way of handling collection types in type theory?
",1525988804.0
djeis97,"I can see why you might like that, but personally I’d prefer talking in terms of an abstraction instead. Instead of trying to unify the empty collection objects of a variety of types, why not instead have an `empty` predicate that works for every type implementing your collection api? Now you still don’t have to worry about the different values used to represent an empty collection, but you haven’t lost the actual type information if you do need to go look at it later. Instead of trying to unify parts of the types themselves, unify the common parts of their APIs in an abstraction.",1526228133.0
Weird_Tolkienish_Fig,Amazing that you can do that with Lisp.,1525908384.0
SlightlyCyborg,Hi Baggars. I want to make a voxel game in lisp. What libraries do you recommend?,1526265233.0
bsd_lore,"Belated happy birthday, and congratulations on your new job!",1526371092.0
stassats,If it's based on Scheme why isn't it called SchemeKit?,1525772794.0
finnw,Any relation to [this Lispkit](https://en.wikipedia.org/wiki/Lispkit_Lisp)?,1525802384.0
dangerCrushHazard,How could this be integrated into iOS apps ?,1525865094.0
glass_ants,That was a really neat read. Thank you for sharing!,1525750132.0
theangeryemacsshibe,I cannot find the Lisp. Where is the Lisp?,1525686871.0
jsjolen,"So it's built upon cl-cont, doesn't that usually bring with it issues regarding restarts (and the whole condition system in general)?",1525525038.0
flaming_bird,Duplicate of https://www.reddit.com/r/lisp/comments/8bshzw/lisp_jazz_aikido_three_expressions_of_a_single/,1525499752.0
amirouche,The paper version https://github.com/amirouche/neon/blob/master/doc/MOCHA2018/preview/neon-mocha-2018-preview.pdf,1525291486.0
MWatson,Looks interesting - please let us know when it is ready to experiment with,1525349179.0
dk_jackdaniel,"Advice for op wrt future questions:

1. indent your code properly (according to agreed standards)

2. have descriptive title of your query on reddit (and else)

3. do not ask questions for university assignments you should do yourself

4. read http://catb.org/~esr/faqs/smart-questions.html

Advice for helpful helpers: op will learn much more if he solves the task at hand himself.",1525274001.0
flaming_bird,What is SWAP1? It's not a standard Common Lisp function.,1525262555.0
Akka47,"I wish you good luck with your job man, keep it up",1525225708.0
piotr404,"Wish you all the best, mate !

Long live the Gang",1525283961.0
jaoswald,"You should write the new or changed definition into a source file, then use an editor keystroke to send that definition to your Lisp implementation to be compiled and loaded, then continue or retry execution.

Restarting or continuing is a choice based on the semantics of your change and state of the program: will it work? It's not about style. Keep in mind that even when you keep source in sync, it is possible to do things at the REPL that will not be reproduced from a cold start. As with many other powerful tools, the speed of development is sometimes a shortcut, and doesn't come with a guarantee that you are doing the correct thing.

Tl;dr you should be using SLIME or the equivalent.",1525178551.0
flaming_bird,"Lisp is an interactive programming language and the debugger is there to serve you whenever it is entered. If you use it for interactive programming, so fixing the errors while the error is there, then retrying the call, then you're using the debugger for exactly what it was designed for.",1525188172.0
defunkydrummer,"People die everyday from terrible diseases,  protests around the world claiming justice, violence subjugates the defenseless, neighbor countries on the brink of war; still, despite all the evil and sad things in the world, there is a bright flame of joy and freedom, for there is a small team that -ripping through all this mess- still has the will, the power to bring out a new SBCL version, at time intervals so brief, you would think heaven has just been eval'd on earth.



",1525143844.0
patrickwonders,"Wow! Great work everyone!
",1525294377.0
anaerobic_lifeform,How is it related to Armed Bear Common Lisp?,1524993267.0
borodust,"Hi! [trivial-gamekit](https://github.com/borodust/trivial-gamekit) is designed to be trivial to use to create simple things :) Also, check out [lispgames wiki](https://github.com/lispgames/lispgames.github.io/wiki) for more or less complete information about current state of lisp gamedev.

P.S.: [Lisp Game Jam 2018](https://itch.io/jam/lisp-game-jam-2018)",1524947595.0
,http://xelf.me/guide.html < always looked like fun to me. CLIM is also usable for game creation.,1524970926.0
berock212,What's processing? It's not easily Googleable,1524978397.0
sammymammy2,"Sketch, CEPL both exist.",1524989819.0
shizzy0,"Arcadia, a Clojure for Unity, is worth investigating. ",1524943939.0
kevisazombie,"Clojurescript will get you up and running immediately with web layer rendering technologies.

The following is a viable engine
https://github.com/alexkehayias/chocolatier",1524950904.0
dk_jackdaniel,My second live coding session with McCLIM. This time about Gadgets.,1524914318.0
okflo,"Thanks, great stuff! ;)",1525093605.0
bendudson,"I think you may have too many parentheses

(not (homer)) 

Will treat 'homer' as a function and try to call it,  then use the result as an input to the function 'not'.

(not homer) 

Looks up the value associated with the symbol 'homer',  and calls the function 'not' with the value as an input. 

If your list S contains lambda functions,  so symbol 'homer' refers to a lambda function, then in common lisp you need to use 'funcall'

(not (funcall homer)) 

It looks like this might be some other lisp though,  as it uses 'equal' rather than 'equalp'. 
",1524636368.0
jmercouris,What makes it similar to lisp? Supporting very basic live editing? Apparently it is written in Coffeescript,1524608745.0
flaming_bird,"Okay, that's a fun system, where's the Lisp?",1524610878.0
Shinmera,This guy has been spamming this link over various subreddits in an attempt to garner attention. Please ignore it. It has nothing to do with Lisp.,1524673527.0
davidedc,"This guy has been posting this link to appropriate subreddits in order to have his project known. He never claimed that this was done in LISP, just a similarity to cloxp and LISP residential systems. Please keep an open mind, comment if you like and don't like but pleae don't troll.",1524674855.0
davidedc,"as the title specifies, correctly, it's not similar to LISP. It's similar to LISP residential systems. For a modern example, see cloxp. More mentions here http://fizzygum.org/docs/fizzygum-for-lispers-and-smalltalkers/",1524638843.0
davidedc,"it's actually LISP itself that supports live editing (pretty much the whole idea is that one can make REPLs in LISP is one line) and function redefinition. The implementation of the image concept is completely independent, in fact some LISP residential systems don't use the image solution.

If ""inspired by"" for you doesn't imply ""like""-ness, then OK, for you it's ""inspired by"" then.",1524661458.0
Shinmera,"Please report problems [on GitHub](https://github.com/portacle/portacle/issues) in the future. This is not the right place.

As for your issue, desktop files are to be used from your file manager. They are not scripts. However, the desktop file simply runs the `portacle.run` file, which is a script that can be run from the console.

It's likely that the actual crash is related to [issue 68](https://github.com/portacle/portacle/issues/68) which has been addressed in a hotfix release. You can find that on the issue page too.",1524608712.0
rgrau,"Haven't tried portacle, but usually the .desktop files are not to be run from the console. 

If clicking does nothing, try opening the file (it's all text), and find out the command it'd be running.
",1524593075.0
flaming_bird,"Send some mails to LispWorks. They administer the group, they should be able to respond the best.",1524610819.0
chuchana,Wouldn’t it make sense to ask on that list whether someone on it kept an archive?,1525015536.0
bsd_lore,"Unfortunately [gmane](http://dir.gmane.org/gmane.lisp.lispworks.general) is still pretty broken.

The oldest preserved article seems from 2005:
http://article.gmane.org/gmane.lisp.lispworks.general/4402/

The newest is from 2016 (probably around that time gmane broke):
http://article.gmane.org/gmane.lisp.lispworks.general/14017/

Perhaps somebody could (gently) spider those pages and put them back in mbox format.

A loss if pre-2005 archives would be lost for good.
",1524731870.0
agambrahma,"A bit painful, but it's possible to get at the archive index using the Wayback Machine: https://web.archive.org/web/20060715070312/http://news.gmane.org:80/gmane.lisp.lispworks.general/

(but individual articles aren't cached, so have to open them separately)",1533188618.0
dzecniv,"- second talk, lang-os: https://github.com/7c6f434c/lang-os zero doc, zero readme… (enjoyable sources like [shell.lisp](https://github.com/7c6f434c/lang-os/blob/master/lisp-os-helpers/shell.lisp))
- and BIP: http://stk-hamburg.com/
- [Lisp in a startup: the good, the bad, the ugly](https://european-lisp-symposium.org/static/2018/dyomkin.pdf) (by vseloved from Grammarly, Franz Inc).",1524604101.0
sammymammy2,"I would like to wish for a cool bomb effect based on shaders and *not* static images, pretty please!",1524591930.0
timezone_bot,"6pm UTC happens when this comment is 11 hours and 3 minutes old.

You can find the live countdown here: https://countle.com/4RW6182666

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1524552970.0
metayan,Maybe upload to YouTube?,1525805036.0
kruhft2,"They told me after 15 years of programming I could't get my P.Eng. when I applied in Alberta, requiring me to do more 'time' to get my P. Eng. so I could legally call myself an engineer.",1524515514.0
jsjolen,">Luke Gorrie (Australia - Sweeden - Switzerland)

Aah yes, the well known country of Sweeden ;-)

Also I'm not only here to tease, these interviews are really good reading :-).",1524510074.0
kazkylheku,"Vladimir Sedach:

> *No one has yet invented a good way to write “one-liners” in Lisp. I would love to replace my Unix shell with a Lisp REPL someday.*

I have, thank you very much. Hey, what's the biggest .c file here?

    $ txr -P '(find-max (glob ""*.c"") : (opip stat .size))'
    lib.c

What's user `sshd`'s login shell?

    $ txr -e '(awk (:set fs "":"") ((equal [f 0] ""sshd"") (prn [f 6])))' < /etc/passwd
    /usr/sbin/nologin

No really, what's user `sshd`'s login shell in non-stupidese?

    $ txr -P '(getpwnam ""sshd"").shell'
    /usr/sbin/nologin

I've [ventured into the Code Golf StackExchange](https://codegolf.stackexchange.com/search?q=%22TXR%22) a bit:

",1524538244.0
stassats,https://github.com/robert-strandh/mcclim/issues would be the appropriate place to ask.,1524484870.0
dk_jackdaniel,"Demos have some issues, because McCLIM have issues. Please report them at the project repository page. Regarding project contributions with copyrighted material it is a free open source software – you may freely modify it until it preserves the license and copyrights (you can't remove those). Such contributions will be accepted.",1524515426.0
stassats,"That's not exactly confined to Qt, but a general property of the CLOS implementation in SBCL (and many other implementations.) Upon first invocation of a method the compiler is invoked to optimize the dispatch, and the compiler is slow. If you use TIME you can see if anything is being compiled.

commonqt performs some additional initialization for new subclasses on top of that.",1524485350.0
Shinmera,How are you measuring this? Are you measuring compile-time or run-time? What makes you think any files are being loaded at all?,1524467853.0
davazp,"If you need help with Lisp, you can also try the Brazilian Lisp community. 

https://lisp.com.br/

seems up to date and they can probably help you better!",1524321627.0
wwwyzzrd,"What implementation are you using?

Assuming sbcl, here is the relevant stack overflow:

https://stackoverflow.com/questions/14171849/compiling-common-lisp-to-an-executable

This will produce a relatively fat executable with your program in it.",1524325489.0
flaming_bird,"What exactly do you want to compile? Do you have a program written in a .lisp file that you want to execute? Do you mean Common Lisp, or some other lisp dialect?",1524319810.0
dzecniv,"This ? https://lispcookbook.github.io/cl-cookbook/scripting.html ""building self-contained executables""",1524332761.0
t-sin,"If you use roswell, `ros build foo.ros` is probably useful.
https://github.com/roswell/roswell/wiki/Building-images-and-executables",1524357008.0
Anhanguera,Eu falo Portugues e Ingles e entendo o suficiente para te ajudar a traduzir se quiser. O que exatamente voce quer fazer?,1524384684.0
lucasecp,"I'll anwser in portuguese since this will be easier for him.
Quando voce criar um programa, voce deve executar o seguinte comando (pode ser em uma funçao ou executar no REPL do proprio lisp): 

      (sb-ext:save-lisp-and-die ""nome-do-executavel""
      :executable t
      :toplevel 'main) ;; sua funcao principal.
Dessa maneira ele compila o necessario do lisp para executar o programa o que acaba ficando meio grande.
Existe uma maneira de importar apenas o seu programa como executavel, porem, o usuario que for utiliza-lo precisa de um core do lisp ja previamente no seu computador e eu nao lembro de cabeça como faze-lo.
",1524763612.0
lispm,"> I'm not seeing why `*L*` should not be a list.

The value of your `*l*` is a list, but `*l*` itself in source code is a symbol. The error is about the value `*l*`, not the value OF `*l*`.

> I can confirm that `*L*` is (in some sense at least) a list: (typep `*l*` 'list)

You only confirm that the value of `*l*` is a list. Not `*l*` itself:

    CL-USER 37 > (type-of '*l*)
    SYMBOL

> Clearly I'm missing something, though, whether some minor mistake of syntax or some fundamental misunderstanding of how macros work.

The first basic general rule: if you compute with values then write a function and if you want to compute with source code then write a macro.

This means: your code should not be a macro, but a function:

    CL-USER 42 > (defun ct2 (m) (reduce #'+ (mapcar #'(lambda (ro) (count #\. ro)) m)))
    CT2

    CL-USER 43 > (ct2 *l*)
    5
 
If you define it as a macro - well, let's look at your code: Here I use LispWorks, but you should be able to inspect the stack in other implementations, too:

The first and most important thing is to check the macroexpansion:

    CL-USER 61 > (pprint (macroexpand-1 '(ct2 *l*)))

    Error: *L* (of type SYMBOL) is not of type LIST.
      1 (abort) Return to top loop level 0.

    Type :b for backtrace or :c <option number> to proceed.
    Type :bug-form ""<subject>"" for a bug report template or :? for other options.

As we see, the error already happens during macro expansion. Let's look at a quick backtrace:

    CL-USER 62 : 1 > :bq

    ERROR <- MAPCAR <- FUNCALL <- MACROEXPAND-1 <- EVAL
    <- CAPI::CAPI-TOP-LEVEL-FUNCTION <- CAPI::INTERACTIVE-PANE-TOP-LOOP
    <- MP::PROCESS-SG-FUNCTION

So the error happens in MAPCAR. The macro expander calls your MAPCAR. We are in the ERROR frame, let's move to the MAPCAR frame:

    CL-USER 63 : 1 > :n
    Call to MAPCAR

Now we check the frame call:

    CL-USER 64 : 1 > :v
    Call to MAPCAR {offset 449}
      FUNCTION           : #<anonymous interpreted function 406000083C>
      LIST               : *L*
      SYSTEM::MORE-LISTS : NIL

So the MAPCAR got called with a function and the symbol `*l*` (and not a list). How can that happen?

Let's look at your code, but indented:

    (defmacro ct2 (m)
      `(+
        ,@(mapcar #'(lambda (ro)
                      (count #\. ro))
                  m)))

 So the macro should return a form like (+ 5). Since there is a ,@  the MAPCAR is called by the macro.
The second parameter is m. What is the value of m? The value of m is the symbol `*l*`.
Remember you try to count during macro expansion. Your program is not running, but the macro expander.
That means that m has a value : the source code, not the value of the source code.

Let's confirm that:

    CL-USER 66 > (defmacro ct2 (m)
                   (format t
                           ""~%the value of m is: ~a~%the type is: ~a~%""
                           m (type-of m))
                   nil)
    CT2

    CL-USER 67 > (macroexpand-1 '(ct2 *l*))

    the value of m is: *L*
    the type is: SYMBOL
    NIL
    T

So the macro sees the source code, but not values. You would need to retrieve the value - if that is actually possible:

With SYMBOL-VALUE we can get it from a global variable:

    CL-USER 69 > (defmacro ct2 (m)
                   `(+ ,@(mapcar #'(lambda (ro) (count #\. ro)) (symbol-value m))))
    CT2

    CL-USER 70 > (macroexpand-1 '(ct2 *l*))
    (+ 5)
    T

So that works. But it is still problematic. This won't work and there is no way to make it work:

    (let ((l1 (list (make-array 5 :initial-element #\.))))
      (ct2 l1))

Above defines a local lexical variable L1. But if we compile the code, the macros are expanded and the code is not yet running. That means that then the variable L1 has no value and there is no way to get it - since it has not been computed yet - we are only compiling now. The macro CT2 tries to compute a value at macro expansion time and wants the value of l1 - but there is no value...





",1524206571.0
kazkylheku,"The `ct2` macro receives the symbol `*L*` itself as an argument, not the symbol's value. Your `(mapcar (lambda ...) m)` is equivalent to `(mapcar (lambda ..) '*L*)`, because the `m` variable holds the symbol itself, not the list stored in the `*L*` variable.

If your macro's argument `m` is expected to be the name of a variable which holds a value, you can use `(symbol-value m)` to access that value.

    (defmacro ct2 (m)
      (let ((m-value (symbol-value m)))  ;; (eval m) is also possible, but not using eval is a good way of avoiding eval
         `(+ ,*(mapcar (lambda (ro) ...) m-value)))

If the macro is used in file-compiled code, that macro expansion will take place during compilation. So we have have to ensure that the variable is defined inside the compiler itself, like this:

    (eval-when (:compile-toplevel :load-toplevel :execute)
       (defparameter *L* (list ...))

By default, file compilation in Common Lisp doesn't evaluate what is being compiled; so a `defparameter` that is compiled is translated and dumped into the object file, but doesn't actually come into effect. In this case it has  to since the macro needs it during expansion.

(Some macro forms do evaluate during file compilation, which is because their expansion contains an `eval-when` similar to the above; the `defmacro` form is like this.)",1524193841.0
waspishly_simple,"I think the main problem you have is that the first rule of macros is to use a function if you possibly can.

ct2 clearly could have been a function and indeed you've tried to use it as if it were.

Perhaps a closure is what you really wanted your function ct2 to produce?

Something like:

    (defun ct2 (l)
      (lambda ()
       (+ (mapcar #'(lambda (ro) (count #\. ro)) l) )))

(The other problem you are going to have with your macro is with name clashes: look up gensyms and hygienic macros).",1524221073.0
unused_alias,Is this kind of like a blend of shell and Lisp similar to Eshell?,1524188201.0
khv90,"It seems to me it should be called rash instead of lsh.  Not that I'm trying to bash the name, but just that lsh can be mistaken for Ish and cause some people to forget the name and have to look it up.",1524483844.0
metroholografix,"Assuming the strstr() that blows up on SBCL, gets called on CCL too, did you try debugging it there (break on it) and seeing what the actual string is?

It might illuminate what that string is and where it's set.

Another way to quickly bypass this issue would be to map the NULL page but that's no longer
possible on osx afaik.
",1524145077.0
bsd_lore,Thank you /u/Baggers_. I look forward to what you'll come up with at the Lisp gamejam.,1524234095.0
mathrick,"The link you pasted just points to the #sbcl archive, which is colossally unhelpful, given it will be out of date in a matter of hours. https://irclog.tymoon.eu/freenode/%23sbcl?to=1524155553 is at least stable.",1524177289.0
,[deleted],1524153915.0
rgiar,any idea what mode he's using to show the whitespace under cursor and in the selected region? it looks a lot better than vanilla whitespace mode,1524115179.0
rgiar,Fantastic idea. Thanks. ,1524137297.0
defunkydrummer,"This is fantastic, the PDF is a wealth of knowledge. I'm right now enjoying the details on the CLASP implementation, page 59.",1524075771.0
zodmaner,Nice. Hopefully the videos are up soon as well. Lots of interesting talks this years.,1524072658.0
sammymammy2,"I'm happy that ELS always has such cool talks which are on a level that I can comprehend while still being advanced.

I prefer this a 1000x to ""Monads and Gonads."" (not trying to be smug against JS, I just took that as a 'common level of conf. talk')",1524073927.0
Fibreman,Omg Sacha Chua is speaking! Her work in the emacs community is fantastic.,1524078199.0
timezone_bot,"6pm UTC happens when this comment is 3 hours and 50 minutes old.

You can find the live countdown here: https://countle.com/_Nca178562

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1523974199.0
jakelaboss,"Hmm, since Ubuntu 17.10 is on Wayland I really don't know how it configures the keyboard. For X11 you could change your .xmodmap, if you'd like to try a pure X11 env",1523935435.0
rudolfo_christ,This doesn't help? https://static.loomcom.com/genera/genera-install.html#org1c2b3f9,1523947553.0
mathrick,"I guess one part of the ""pico"" is not explaining what your code is for? Vast savings for sure, much like cutting the ""f"" out of ""def"". ",1524085472.0
GDP10,I'm a bit confused... what is this?,1524078161.0
tankfeeder,"this is variation of this one:
https://jedisct1.github.io/minisign/",1524123255.0
iprog4u,Thank you for more excellent work.  Much love for Picolisp!,1524800770.0
eql5,"Since I did port my tool ([EQL](https://gitlab.com/eql), ECL only) from Qt4 to Qt5, I have some experience to share:

* if you only use traditional `QWidget` stuff, there is not much of a difference (Qt4 is still fine there)
* if you use `QML`, there is a BIG difference, since the current `QtQuick2` (the successor of `QtQuick1`) has been almost completely rewritten, and many features that you want/need in `QML` are only available with `QtQuick2` (and a recent Qt5, like Qt5.10)

The Qt community is split over `QML` usage (it can be used on the desktop, too). Personally I almost hated it (many years ago), but I have come to love it now (but mostly referring to mobile apps).

P.S. Please don't spell it QT: for Qt users, this is like writing LISP instead of Lisp.",1523897298.0
friedbun,"My guess would be that the bindimgs simply haven't been updated yet to support Qt5 
. Shoot the author an e-mail or write a ticket in the issue tracker kindly asking when it's going to support Qt5. Best way to get an answer.",1523865770.0
Aidenn0,There are no smoke bindings for Qt5.  CommonQt uses the smoke bindings.,1523916539.0
stassats,Because nobody has made it support Qt 5.,1523875634.0
defunkydrummer,"To the OP: In 2018 the easiest way to get started is to download and install [Portacle](https://portacle.github.io/), no other step required -- no configuration, no installing more tools, no need to install IDE or compiler or anything.

Easier than the steps on the article -- which will only give you q Lisp REPL.",1523894110.0
Baggers_,I'd love to see more good docs but I feel this one falls rather short. Recommending people use an editor without any real integration and without quicklisp is not giving any kind of a representative view on the language.,1523981212.0
woofr-owner,"I'm going to sound like ""old man shakes fist at cloud"" here, but getting started with Common Lisp just isn't that hard:

1) Install Emacs.  (Learn the minimal required to use it -- you'll pick up the rest that you need as you go.)

2) Install CCL or SBCL.

3) Install Quicklisp.

4)  Install Slime.

5) Start hacking.

Sure, things like Portacle bundle these together, but there is real value in understanding the components of your development environment.  When something goes wrong, you'll be able to fix your configuration much more quickly than if you're using a black box.
",1525095742.0
stassats,"(csv-parser:do-csv-file ((fields num-fields) file :limit 1 :skip-lines 4))

will give you row 5.",1523876145.0
anaerobic_lifeform,"Using indentation helps a lot, IMO:

    (function (junction (hibou x (narwhal y n) z)
                        foo
                        bar)
              control)
",1523791557.0
svetlyak40wt,"Use cl-arrows system. With it, your code from example will be:

    (-<> (narwhal y n)
         (hibou x <> z)
         (junction foo bar)
         (function control))

",1523791537.0
guicho271828,google arrow macros. there is a CL version,1523787166.0
svetlyak40wt,"For me, arrow macro is specially useful, when I need to make a few subsequent getf call to take a value from a nested data structure, received from some API. ",1523806670.0
BusFactor1Inc,"The parser is pretty cool if you read it.  

It tells you which line the unclosed paren is on.",1523785326.0
WhatImKnownAs,"At first glance, I would try to use Lisp macros directly, i.e., `macro` is `defmacro`, and you would just invoke them during transpilation (using `macroexpand`). Then it doesn't matter what the internal representation of the macro body is.",1523795428.0
BusFactor1Inc,I figure it will be useful to rewrite the Unix kernel (Plan9 really) along with the userland.,1523780028.0
bjarneh,"> First you compile nokolisp.asm to nokolisp.exe. Then you do (in (open 'boot.lsp)), then you start (*main-loop*), which errors and recompiles and then you (make-exe). And then you have noko.exe.

> There was some elegant way to do all this shit, but I cant remember what it was.",1523817953.0
theangeryemacsshibe,"I think `(assert (equal (something 42) ""?""))` would work better.",1523752831.0
chebertapps,"Assert wraps a form, and causes an error if the form evaluates to NIL.

    (assert (string= (SOMETHING 42) ""?""))

No need to quote `42` or `""?""` since they evaluate to themselves anyway.",1523752839.0
paulfdietz,"The third argument to the ASSERT macro is a list of places that are assigned to if you decide to continue after an assertion failure.  This mechanism makes ASSERT rather heavyweight (setting up restarts and such), so SBCL internally uses something it calls AVER which does not admit continuing after a failure.",1523753258.0
QuirkySpiceBush,"Interesting. I was thinking about my own habitual pursuit for arts/disciplines that are popularly equated with:

* compact rule sets
*  “ultimate” expressions of truth or practice
* some form of enlightenment conferred by its pursuit, 
* meta-level concerns in relation to other discplines in their category
* a bit of a reputation for grandiose claims ;-)

My list started with: Lisp, [Systema](https://en.wikipedia.org/wiki/Systema), and [Dzogchen](https://en.wikipedia.org/wiki/Dzogchen).",1523566366.0
ruricolist,"An interesting paper. I wouldn't say I disagree with it, but I find it interesting that someone could arrive at a perspective so different from my own. If such a thing as ""classical programming"" is possible, surely that's Common Lisp -- old, complex, formally codified, with an idiosyncratic vocabulary and a community invested in historical continuity.",1523574944.0
sososojacques,Wow that's a list of things I have been doing for years. I have to read this paper.,1523616165.0
ebzzry,"If it pertains to Common Lisp, I would have disagree with the aikido part. In my opinion, if there is a martial arts system that CL more closely resembles, it would be something like Krav Maga or Combat Sambo.

Common Lisp, like those martial arts, allow you to use whatever techniques necessary, in order to get the job done. Aikido, on the other hand, works in idealistic environments. It works, as long as the conditions are conducive. However, it falls apart when confronted with an opponent who is going to use all the tools available to win.",1531753560.0
flaming_bird,"`""# #""` is a *literal* string. Modifying literals in Common Lisp is undefined behavior.

Variable bindings have nothing to do with that. `(defvar *foo* ""bar"")` defines a variable named `*foo*` but the *value* bound to that variable is an *immutable* string `""bar""`.

Use `(copy-seq ""foo"")` to create mutable strings.",1523467660.0
defunkydrummer,"For what is worth, if it helps you, here is a possible implementation I just hacked.

    (defun yeah (x y size)
      ""true if coordinates satisfy condition for # symbol""
      (or (eql y 0) ;square box
          (eql y size)
          (eql x 0)
          (eql x size)
          (eql y x) ;diagonal
          (eql y (- size x))))

    (defun print-thing (size)
      (loop for y from 0 to size
            do
            (loop for x from 0 to size
                  do
                  ;; print appropiate character
                  (write-char
                   (if (yeah x y size) #\#
                       #\Space)))
            ;;newline
            (terpri)))


It works correctly. Call with size = 9 for example.


",1523480122.0
defunkydrummer,"Hi Dr. /u/PuercoPop 

I don't usually have time for watching full videos, would you please tell us in short and in advance:

- how full-featured is this Lisp?

- which is the target machine?

- which language is the compiler implemented in?

- is it including GC? (I ask because many such posts show what is really a very simplified Lisp with no GC at all)

- is it compiling directly to machine lang, or is it using a bytecode-to-JIT strategy?

Kind regards,

Your friend in lisp, in the year of the npm plague,

defunky.
",1523477753.0
iprog4u,Another fine example.,1524801011.0
kazkylheku,"
There is almost no optimization whatsoever; something has to be left to a future milestone. However, I indulged a little and did some work to have the `case` family of macros turn into hash-driven jump tables:

    1> (disassemble
         (compile-toplevel
            '(caseq x (a ""eh"") (b ""bee"") (c ""cee"") (d ""dee"") (e ""ee"")
                      (f ""eff"") (g ""gee"") (h ""eich"") (i ""eye"") (j ""jay"") (k ""kay""))))
    ** warning: (expr-1:3) unbound variable x
    data:
      d00: x
      d01: #H((:eql-based) (k 10) (j 9) (i 8) (h 7) (g 6) (e 4) (c 2) (b 1)
              (f 5) (a 0) (d 3))
      d02: ""eh""
      d03: ""bee""
      d04: ""cee""
      d05: ""dee""
      d06: ""ee""
      d07: ""eff""
      d08: ""gee""
      d09: ""eich""
      d0A: ""eye""
      d0B: ""jay""
      d0C: ""kay""
    funs:
        0: gethash
    code:
        0: 04020002 frame 2 2
        1: 79000200 getv v0000 d00
        2: 24020201 gcall v0001 0 d01 512
        3: 01010000
        4: 00000200
        5: 48000024 if v0001 36
        6: 00000201
        7: 540B0201 swtch v0001 14 16 18 20 22 24 26 28 30 32 34
        8: 0010000E
        9: 00140012
       10: 00180016
       11: 001C001A
       12: 0020001E
       13: 00000022
       14: 30010102 movsr t01 d02
       15: 44000023 jmp 35
       16: 30010103 movsr t01 d03
       17: 44000023 jmp 35
       18: 30010104 movsr t01 d04
       19: 44000023 jmp 35
       20: 30010105 movsr t01 d05
       21: 44000023 jmp 35
       22: 30010106 movsr t01 d06
       23: 44000023 jmp 35
       24: 30010107 movsr t01 d07
       25: 44000023 jmp 35
       26: 30010108 movsr t01 d08
       27: 44000023 jmp 35
       28: 30010109 movsr t01 d09
       29: 44000023 jmp 35
       30: 3001010A movsr t01 d0A
       31: 44000023 jmp 35
       32: 3001010B movsr t01 d0B
       33: 44000023 jmp 35
       34: 3001010C movsr t01 d0C
       35: 44000025 jmp 37
       36: 30010000 movsr t01 nil
       37: 10000001 end t01
       38: 10000001 end t01
    instruction count:
       30
    #<sys:vm-desc: 8409e90>
",1523143380.0
kazkylheku,"Shipped: [TXR 191](http://www.kylheku.com/cgit/txr/)

Compiler [is here](http://www.kylheku.com/cgit/txr/tree/share/txr/stdlib/compiler.tl?id=txr-191).",1523491984.0
DGolden,"Not exactly sure what you mean, but actually there is/was [outer parentheses free repl](https://www.cliki.net/outer-parentheses-free-repl).  Don't really like it myself.",1523061149.0
VanLaser,"If it's aesthetically displeasing, use an editor that lets you color those parens in an almost-background color (i.e. treat the problem at the same - aesthetical - level) :P",1523105215.0
ClickHereForBacardi,The good news is that you can have Lisp almost entirely without parens. The bad news is that Dylan is practically a dead language.,1523062642.0
leodash,"When I played around with Haskell, I do feel like it is kinda like a Lisp without parentheses minus all macros and stuffs. You might want to give it a try. I went back to Lisp because I can't stand the compile time.",1523071984.0
parens-r-us,Maybe you should try Julia? Interop with python is a nice bonus. ,1523112291.0
winterdumb,"Would you feel better if n were quoted, as in elisp

    (set 'n 10)",1523067292.0
,[deleted],1523113457.0
stassats,"How do you suppose it's going to work? Wait, don't tell me ""With a semicolon!""

You are trying to modify lisp without really understanding it. Surprisingly, that's quite common.",1523061208.0
kazkylheku,"`define` in Scheme is named wrong. `def`-anything should be a construct  for use in top-level forms primarily, for extending a global/pervasive environment that isn't tied to any scope.

The symbol `let` could be used for a block-scope non-enclosing definer:

    (begin
      (let x 3)
      ...
      (let y (* x 4))
      ...)

It's trivially distinguished by the argument of `let` not being a list, but an atom suitable for use as a variable name.

Naming is important; I feel that this sucks less now.",1523080509.0
bobbane,"Interlisp-D had something close to what you want, I think.

You could type

     (define n 10)

in the REPL and it would work like any Lisp.

You could also type

     define (n 10)

and it would do the same thing.

That REPL was aggressively helpful - it would only present a form to the underlying reader when it was complete.  The reader would kick off when you typed the final closing paren of either form - no newline required.",1523066177.0
dzecniv,"Not sure what you mean, but http://shenlanguage.org/ ?

also https://github.com/malisper/Clamp CL with Arc's terse syntax.",1523098888.0
xach,"See Rob Warnock's ""outer-paren-free repl"" - https://www.xach.com/rpw3/articles/search?q=opfr",1523105861.0
kuwze,You might be interested in [this awesome library that automatically inserts parentheses by pjb](https://www.informatimago.com/develop/emacs/emacs/pjb-cl-magic.el).,1523130325.0
lispm,"This is actual code written in RLISP.

'symbolic procedure' is something like a DEFUN. One can recognize functions like NULL and CAR. SETQ is := . End of expression is the semicolon. PROG is something like BEGIN. PROGN is << >>.

Many more examples at:

https://sourceforge.net/p/reduce-algebra/code/HEAD/tree/trunk/packages/

    symbolic procedure solve!-for!-corrections(c,fhatvec,fvec,resvec,vset);
    % ....;
      if null vset then
        for i:=1:number!-of!-factors do
          putv(resvec,i,
            remainder!-mod!-p(
              times!-mod!-p(c,getv(alphavec,i)),
              getv(fvec,i)))
      else (lambda factor!-level; begin
        scalar residue,growth!-factor,f0s,fhat0s,v,
          degbd,first!-time,redc,
          predicted!-forms,max!-unknowns,solve!-count,number!-of!-unknowns,
          correction!-vectors,soln!-matrices,w,previous!-prediction!-holds,
          unknowns!-count!-list,poly!-remaining,
          prediction!-results,one!-prediction!-failed;
        v:=car vset;
        degbd:=get!-degree!-bound car v;
        first!-time:=t;
        growth!-factor:=make!-growth!-factor v;
        poly!-remaining:=c;
        prediction!-results:=mkvect number!-of!-factors;
        redc:=evaluate!-mod!-p(c,car v,cdr v);
        solve!-msg1(c,fvec,v);
        solve!-for!-corrections(redc,
          fhat0s:=reduce!-vec!-by!-one!-var!-mod!-p(
            fhatvec,v,number!-of!-factors),
          f0s:=reduce!-vec!-by!-one!-var!-mod!-p(
            fvec,v,number!-of!-factors),
          resvec,
          cdr vset); % Results left in RESVEC.
        if bad!-case then return;
        solve!-msg2(resvec,v);
        residue:=diff!-over!-k!-mod!-p(difference!-mod!-p(c,
              form!-sum!-and!-product!-mod!-p(resvec,fhatvec,
                number!-of!-factors)),1,car v);
        factor!-trace <<
          printsf residue;
          prin2!* "" Now we shall put in the powers of "";
          prinsf growth!-factor;
          printstr "" to find the a's fully.""
        >>;
        if not polyzerop residue and not zerop cdr v then <<
          w:=atsoc(car v,predictions);
          if w then <<
            previous!-prediction!-holds:=t;
            factor!-trace <<
              printstr
                 ""We shall use the previous prediction for the form of"";
              prin2!* ""polynomials wrt ""; printvar car v >>;
            w:=cdr w;
            soln!-matrices:=car w;
            predicted!-forms:=cadr w;
            max!-unknowns:=caddr w;
            number!-of!-unknowns:=cadr cddr w >>
          else <<
            factor!-trace <<
         printstr
            ""We shall use a new prediction for the form of polynomials "";
            prin2!* ""wrt ""; printvar car v >>;
            predicted!-forms:=mkvect number!-of!-factors;
            for i:=1:number!-of!-factors do
              putv(predicted!-forms,i,getv(fvec,i));
                % Make a copy of the factors in a vector we shall overwrite.
            make!-predicted!-forms(predicted!-forms,car v);
                % Sets max!-unknowns and number!-of!-unknowns.
            >>;
          solve!-msg3();
          unknowns!-count!-list:=number!-of!-unknowns;
          while unknowns!-count!-list and
             (car (w:=car unknowns!-count!-list))=1 do
            begin scalar i,r,wr,fi;
              unknowns!-count!-list:=cdr unknowns!-count!-list;
              i:=cdr w;
              w:=quotient!-mod!-p(
                wr:=difference!-mod!-p(poly!-remaining,
                  times!-mod!-p(r:=getv(resvec,i),getv(fhatvec,i))),
                fi:=getv(fvec,i));
              if didntgo w or not polyzerop
                difference!-mod!-p(wr,times!-mod!-p(w,fi)) then
                if one!-prediction!-failed then <<
                  factor!-trace printstr ""Predictions are no good."";
                  max!-unknowns:=nil >>
                else <<
                  factor!-trace <<
                    prin2!* ""Guess for a("";
                    prin2!* i;
                    printstr "") was bad."" >>;
                  one!-prediction!-failed:=i >>
              else <<
                putv(prediction!-results,i,r);
                factor!-trace <<
                  prin2!* ""Prediction for a(""; prin2!* i;
                  prin2!* "") worked: "";
                  printsf r >>;
                poly!-remaining:=wr >>
            end;
          w:=length unknowns!-count!-list;
          if w=1 and not one!-prediction!-failed then <<
            putv(resvec,cdar unknowns!-count!-list,
              quotfail!-mod!-p(poly!-remaining,getv(fhatvec,
                cdar unknowns!-count!-list)));
            go to exit >>
          else if w=0 and one!-prediction!-failed and max!-unknowns then <<
            putv(resvec,one!-prediction!-failed,
              quotfail!-mod!-p(poly!-remaining,getv(fhatvec,
                one!-prediction!-failed)));
            go to exit >>;
          solve!-count:=1;
          if max!-unknowns then
            correction!-vectors:=
               make!-correction!-vectors(resvec,max!-unknowns) >>;
        if not polyzerop residue then first!-time:=nil;
        return multihen1(list(residue,
                                growth!-factor,
                                first!-time,
                                fhat0s,
                                f0s,
                                vset,
                                solve!-count,
                                correction!-vectors,
                                unknowns!-count!-list,
                                resvec,
                                v,
                                degbd,
                                soln!-matrices,
                                predicted!-forms,
                                poly!-remaining,
                                prediction!-results,
                                fvec,
                                previous!-prediction!-holds,
                                one!-prediction!-failed),
                                t);
    exit:
          multihen!-exit(first!-time,resvec,t);
      end) (factor!-level+1);
",1523175221.0
Aidenn0,[UCB Logo](http://people.eecs.berkeley.edu/~bh/logo.html),1523573932.0
kazkylheku,"Here is a possible approach, using TXR Lisp, in which we can write a macro called `autolet` without having to implement a full blown code walker.

`autolet` automatically inserts a `let` around your code which defines every free variable in that code.  This is considered in context; a variable is not free if that code occurs in a broader context where the variable has a lexical binding.

Basic demo:

    1> (autolet
         (set x 42)
         (inc x)
         (push x y)
         (list z y))
    (nil (43))

So inside `autolet` you just write code as if you were working in some computer-science-flunk-job language like Awk, Perl or Python: assign to any variable symbol you invent, or evaluate a symbol, and it comes to life with an initial value of `nil`.

Expansion:

    2> (sys:expand '(autolet
         (set x 42)
         (inc x)
         (push x y)
         (list z y)))
    (let (z y x)
      (sys:setq x 42)
      (sys:setq x (succ x))
      (sys:setq y (cons x y))
      (list z y))

Now suppose we make `z` a bound variable, and also introduce another variable `w` that is also bound, but inside the form. In both these cases, `autolet` correctly ignores the variable:

    3> (let ((z 42))
         (autolet
           (set x 42)
           (inc x)
           (push x y)
           (let ((w 84))
             (list w z y))))
    (84 42 (43))

In the expansion we see that only `x` and `y` are identified and treated:

    4> (sys:expand '(let ((z 42))
         (autolet
           (set x 42)
           (inc x)
           (push x y)
           (let ((w 84))
             (list w z y)))))
    (let ((z 42))
      (let (y x) (sys:setq x 42)
        (sys:setq x (succ x))
        (sys:setq y (cons x y))
        (let ((w 84))
          (list w z y))))

The `autolet` macro is merely this:

    (defmacro autolet (:env macenv . exprs)
      (let ((expr ^(progn ,*exprs)))
        (tree-bind (expan free-vars free-funs bound-vars bound-funs)
                   (sys:expand-with-free-refs expr macenv)
          ^(let ,free-vars
             ,expr))))

I haven't exposed and documented the `expand-with-free-refs` function for public use, though.
",1524082992.0
GNULinuxProgrammer,"I also find any symbol such as parenthesis, quote, backtick etc visually noisy. It's not a huge issue, but I prefer whitespace over special characters. So, Dylan's or Julia's syntax is preferable to say that of scheme or elisp. But as an emacs user, I have no hard feeling, lisp is lisp.",1523089677.0
svetlyak40wt,What is the idea of the project?,1523114167.0
dk_jackdaniel,"regarding ECL: why :spawn communication style doesn't work for you?

you may try this patch for swank to make :fd-handler work: https://github.com/slime/slime/pull/412 (see comments).",1523010279.0
defunkydrummer,"Ask /u/lispm, his personal website is hosted on a ODROID-XU using LispWorks. He might have some advice for RPi.",1523021349.0
KDallas_Multipass,hop on irc,1523032648.0
patrickwonders,"I've had good luck with CCL on Arm, but I haven't used CL-SDL2 on Arm (but I have used CL-OPENGL and a number of other CFFI things). But, I'm not sure what's up in your case.",1523042489.0
flaming_bird,This sounds like an autowrap bug. File an issue at https://github.com/rpav/cl-autowrap because that is an obvious type error.,1523014837.0
bitwiggler,"Lispworks and Allegro both support threads on ARM64.
",1525406373.0
timezone_bot,"6pm UTC happens when this comment is 19 hours and 54 minutes old.

You can find the live countdown here: https://countle.com/5I170435CZ

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1522793142.0
ninejaguar,"Thanks!  This is an excellent version of the ANSI Common Lisp Standard Draft PDF.  It really helps makes sense of the document, and it's now much easier to navigate.  

I had to click on the Bookmarks ribbon icon on the left side of the MS Windows version of Adobe Acrobat Reader to see sidebar contents.  

Another way would be to select the View>Show/Hide>Navigation Panes>Bookmarks menu item.

If drilling down using the sidebar contents doesn't help, then one could still search the PDF using the Windows Acrobat Reader Ctrl+Shift+f key-combo or use the Edit>Advanced Search menu item.  Then, one could enter search parameters to build on-the-fly indexes of search results.  The search results consist of search keywords found throughout the PDF that are listed along with neighboring text on either side of the keywords to help give context so that one can zero in on the page of interest.  

If one happened to know the Common Lisp keyword to look for in the ANSI Common Lisp Standard Draft PDF, one could enter something like ""Syntax: digit-char"" (without the quotes) when searching with the Ctrl+Shift+f key-combo.  That would show the exact page where the ""digit-char"" function was defined in the ANSI Common Lisp Standard Draft PDF.  Naturally, the same could be done with any function, macro...etc., by using the ""Syntax: symbol name"" search pattern (without the quotes) in the ANSI Common Lisp Standard Draft PDF.

It's quite useful when searching PDFs that don't have sidebar Bookmarks, like most versions of Steele's ""COMMON LISP The Language, Second Edition"".  Luckily, someone's made a version that has sidebar Bookmarks:

http://filonenko-mikhail.github.io/cltl2-doc/

The Acrobat Reader Ctrl+Shift+f key-combo Common Lisp symbol name search pattern for functions, macros, ...etc, using the ""COMMON LISP The Language, Second Edition"" PDF downloaded from the link above would be something like, ""[Macro] with-open-file"" (without the quotes).",1522990692.0
basic-gongfu,"Cool stuff. I would trade the mess we're in for a future based on Lisp machines any day. Didn't have a speaker nearby so I ran the whole thing through the Tube's automagic subtitle-thingy which helped put the video into context. I have a feeling that machine learning, while improving on what came before as far as practical results go; will never go beyond random epic failures without less discrete systems to back it up.",1522771424.0
Someuser77,Also... Comkey 816 style phone. My dad's house is still wired with them from the 70s. Cool!,1522801091.0
CelloAxeMurder,Did the Symbolics machine have sound hardware?,1522905528.0
agumonkey,lovely,1522775804.0
kazkylheku,"Lisp seen here: https://www.youtube.com/watch?v=ZBKCNTe71bw&feature=youtu.be&t=888
",1523149577.0
maldio,"Fun fact, [Symbolics.com was the first .com domain registered, back in March 1985](https://en.wikipedia.org/wiki/List_of_the_oldest_currently_registered_Internet_domain_names)",1523559133.0
steloflute,Simple and easy-to-understand implementation! Tail call optimization in Schemy.cs is also good. See also my Lisp implementation (Arcadia): https://github.com/kimtg/arcadia,1522718109.0
metroholografix,"The usim emulator in this project is tied to X11 and has dropped support for OSX/Windows through SDL which is available in the original release: http://www.unlambda.com/cadr/

Not sure why they did that as SDL is far superior to raw X11 but it won't go down well for OSX folks since XQuartz is garbage.",1522705245.0
kevisazombie,This is fascinating. Would it be possible to configure a field-programmable gate array (FPGA) to match the CADR configuration?,1522723923.0
agumonkey,oh zwei source too... time to spam #emacs,1522742597.0
bsd_lore,"[Project home page](https://lm-3.github.io/)

[Github account](https://github.com/lm-3)",1522685374.0
bsd_lore,"Very cool, thank you.",1522685246.0
azzamsa,Cool. I think we don't have CL podcast yet ;),1522745992.0
defunkydrummer,"This is great, are you mantaining this page? Trés bon!",1522784442.0
cracauer,"Today I have an easier time convincing mortals that compile-time computing is strictly required for long-term usable software, and that at the time of this writing Lisp is the only language supporting a useful form of compile-time computing.

There is, however, a bit of a problem in that a program that has used compile-time computing to *keep every single assumption in one place*, looks pretty ugly and is hard to read.

%%

For starters, in Lisp, if you *kept every single assumption in a single place in the code* you have quite a bit of macroexpansion going on where in the source code where casual reading leaves it unclear when exactly that code runs and how deep macro nesting is. Our tools can be used to evaluate step by step, but even those do not really visualize different evaluation times.

To the casual person that I convince of the advantages of compile-time computing this can leave the impression that you end up with ""equally unreadable"" code as before. It becomes difficult from there to explain how much more *expressive* the new hard-to-read code is. *Expressive* meaning that single, small changes in there are all that is needed for correctly changing major functionality (left over from assumptions that you made in a best effort at code writing time, and that turned out differently).

%%

I got into the habit of classifying typical code in different languages this way:

* writable (perl can be here)

* readable (most languages when used ""correctly"")

* changeable (only Lisp right now, at least if you want performance, too)

%%

The hard-to-read nature of Lisp code that is heavy on compile-time computing (backticks and commas galore) puts a bit of a dent into making people jump on the latter.",1522603281.0
defunkydrummer,">Recently, we regularly see people (usually also within the Lisp community) who have the perfect explanation as to why Lisp is not as popular as it deserves to be, namely that there is not even a single free implementation that works on all operating systems, and that has all the required libraries that languages like Python and Ruby have for web programming, etc

Since today we do have many multi-platforms free implementations, i guess this article is old. But I agree with Robert Strandh's final statement: 

>I mostly don't care how popular Lisp is. I am not using Lisp in order to score better in a popularity contest. I am using Lisp because it is the best programming language I know for the kind of programs I write. I don't think there is anything particularly or seriously wrong with Lisp.

It's almost like a manifesto. Well said. ",1522606771.0
Shinmera,"Check out the [platform table](http://sbcl.org/platform-table.html) to see what is officially supported. I've personally used it to deploy user applications for AMD64 on Linux, OS X, and Windows, and have not encountered any issues.",1522574248.0
cracauer,"Good, no question. Even on my Raspberry Pis I can always fire up SBCL, with SLIME and whatnot. Nice little Lisp machine, there.

Windows is a bit behind, sometimes. It is so different that it breaks easily on Unix-tested changes, and Unix people often don't have Windows around to test, or suffer from that insane Windows usage scheme that doesn't allow you to just ssh into a lightly extended Windows machine and compile SBCL.",1522602408.0
,I'm running it on OpenBSD and it works great. Same on FreeBSD.,1522573929.0
ikbenlike,"I run it both on Windows and Linux. It gives an instability warning on Windows, but I haven't encountered any issues yet ",1522580099.0
republitard,"After years of using it on Linux and Windows, I couldn't get SLIME to work with SBCL on OSX. I don't remember what the error was, I just installed CCL instead.
",1522658666.0
defunkydrummer,"For what it's worth, i run SBCL under Windows 7 Enterprise and Windows 10, with no problems yet. ",1522680505.0
lispm,"+ | [CAPI](http://www.lispworks.com/products/capi.html) | CLIM (Franz) | [CLIM (Lispworks)](http://www.lispworks.com/products/clim.html) | [McCLIM](https://common-lisp.net/project/mcclim/)
---------|----------|----------|----------|----------
Owner | LispWorks | Free | LispWorks | Free
License | Proprietary | ? | Proprietary | GNU Library General Public License
Source | No | [Github](https://github.com/franzinc/clim2), [Github TOS](https://gitlab.common-lisp.net/mcclim/gramps-clim2) | No | [Github](https://github.com/robert-strandh/McCLIM)
Documentation | [User Guide and Reference](http://www.lispworks.com/documentation/lw71/CAPI-M/html/capi-m.htm) | [User Guide](https://franz.com/support/documentation/10.1/doc/clim-ug.pdf) | [User Guide](http://www.lispworks.com/documentation/lw71/CLIM/html/climuser.htm) | [Spec](http://bauhh.dyndns.org:8000/clim-spec/index.html), [Manual](https://common-lisp.net/project/mcclim/static/documents/mcclim.pdf)
Object System | CLOS | CLOS | CLOS | CLOS | CLOS
Lisp | LispWorks | Allegro CL, TOS: CCL+SBCL | LispWorks | SBCL, ...
Standard | proprietary | CLIM 2 | CLIM 2 | CLIM 2 + Extensions 
GUI Backend | Windows, Mac, Gtk+, X11/Motif | X11/Motif | X11/Motif, Windows | X11
Native platform look and feel | very much | some | some | X11/McCLIM
Actively maintained | Yes | no new features | no new features | community
IDE | Yes | not much | not much | various tools
GUI designer | Windows, Gtk+ | No | No | No
Gadgets | Many | Some | Some | ?
Highres display | Yes | No | No | ?
Presentations | No | Yes | Yes | Yes",1522520603.0
dk_jackdaniel,"CAPI doesn't work outside of LW, so if you want to create free software with it – you can't. If LW goes out of business, then you have no ability to maintain your software or port it to other platforms either. CLIM on the other hand has a specification and a free implementation. If you have time you may even write your own implementation of it or to fork one of the existing ones. As of the look and feel – you may devote your time to help with improving existing CLIM implementations.

That said CAPI is convenient way of writing graphical applications and works very well in its domain (that is propietary applications). Many people seem to be very pleased with it.",1522512644.0
bsd_lore,"If you are interested in testing CAPI, you could have a look at this [CAPI cookbook](https://t-cool.github.io/capi-cookbook/index.html) (Only few parts are in English though).

[Github repo](https://github.com/t-cool/capi-cookbook)",1522598336.0
sammymammy2,Looks better.,1522508716.0
JaumeGreen,Sounds a really interesting problem the one you are tackling. Good luck. ,1522525840.0
svetlyak40wt,Interesting. Do you have some product already?,1522570791.0
stassats,"SBCL doesn't really use ""only 4GB of 8GB"". That will happen if you produce that much garbage. Which would be a problem for a game either way. So if your game has 8GB gigabyte of assets that are always there and not modified, then it won't need 16GB of memory. Only the ""live"" consed/collected set might require more memory. That's the idea behind a generational collector. But there are always ways to defeat a garbage collection scheme.",1522498210.0
Bhima,">Another post was removed with a similar topic

Yes, and let's please have this discussion without goading each other into personal attacks and other histrionics.",1522490059.0
theangeryemacsshibe,You can play with SBCL's garbage collector to make it less annoying with large amounts of memory: http://john.freml.in/sbcl-optimise-gc,1522462311.0
gschroder,"http://www.paulgraham.com/carl.html

It is possible to load a chunk of data into memory and access it out of reach of the GC. This can be useful when working with the graphics card requires the data be laid out a certain way.",1522519327.0
cracauer,"It is unclear to me what those 4 GB are supposed to be. Lisp heap? Mapped data? Code?

It sounds like you are asking for the program to waste memory.

As for the other question: yes if you stop consing (allocating memory, only using preallocated memory) then you won't GC either. That is entirely realistic, QPX ran that way for a while.

You have, on the other hand, not posted enough information to figure whether you will have a GC problem in the first place.",1522602752.0
stassats,"When in the repl bufferr, do C-h v slime-repl-input-history",1522446008.0
CelloAxeMurder,"Basically my dream job is to work on a team of lisp coders. If I ever get there though, this we'll be awesome!",1522447692.0
death,"I, too, moved to a ""hybrid"" way of using Quicklisp. I cloned the git repositories for the libraries I use into `~/quicklisp/third-party`. I wrote [ql-gitify](https://gist.github.com/death/2fb6218858c6212ebea052f2e3d4f0b3) to help do that. It's been a while, but I think you should first clone the `quicklisp-projects` repository into that directory.",1522450376.0
dzecniv,Nice. Gonna wait a bit before ranting about the lack of docs.,1522457045.0
xach,I think qlot is intended to solve a similar problem.,1522752169.0
chebertapps,"Sorry I don't know much about dealing with large amounts of memory in Lisp.

If you want something in between what you have a and C++ implementation, you could try employing memory pooling, pre-allocation, and other similar techniques to avoid garbage collection altogether. I suspect the code would be structured similarly to how the C++ version would.
 
Seems like you might have already thought of this, and if so, I'd like to know if this doesn't work for some reason, for my own learning.",1522410476.0
flexibeast,Have you already tried [ECL](https://common-lisp.net/project/ecl/main.html)?,1522413489.0
bsd_lore,"I wrote this in a recent comment, let me repeat it here, as I am really pleased with ccl.

If you use macOS, you could give [Clozure Common Lisp - CCL](https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12) a try.

Downloading it from the App Store (link above) will also install a nice editor and debugger.

So, you could delay using Emacs+Slime to later.

I recently rediscovered CCL, I am *exceedingly* pleased with it.

I find it a nice development environment, and easy to learn.

By the way, [this complete GUI application](https://itunes.apple.com/us/app/picture-window/id507262984?mt=12) was developed with ccl. [Source code is available on GitHub here.](https://github.com/Clozure/dpf)",1522416071.0
stassats,If that's your attitude then you can go back to C++.,1522417602.0
dzecniv,"I tried to install it, this is how far I went: https://www.reddit.com/r/programming/comments/883vzs/old_reddit_source_code/dwi2mfz/",1522365977.0
dk_jackdaniel,This may shed some light why it was rewritten in Python: http://www.aaronsw.com/weblog/rewritingreddit,1522411070.0
Anen-o-me,Awesome!,1522387348.0
defunkydrummer,"I would heartily recommend Practical Common Lisp, which also is free ([you can read it online at the site of the author.](http://www.gigamonkeys.com/book/))

Also, please download [Portacle](https://portacle.github.io/), which is a lisp IDE complete with Lisp implementation (SBCL), so you can focus on learning instead of configuring stuff.

IMO, beware of some books which do everything with plain lists and don't want to use the other Lisp data structures: alists (association lists), plists (property lists), hash-tables, structs (records), and of course vectors and arrays. I'm afraid that Land of Lisp, while perhaps being *one of the most adorable programming books ever made*, makes this mistake.

As for comments like  

>Learn Racket (or Scheme, or Clojure) instead of Common Lisp because this, that and that...

Consider that the main difficulty in learning any lisp dialect is to understand how to better leverage a language where:

- the language itself is programmable (though macros)

- and code is also data (that is, source code is also data that can be easily manipulated by the source code)

This difficulty *will* be there no matter if you use Common Lisp, Scheme/Racket, Clojure, etc. And, if anything, macros are easier to write in CL. 



",1522274683.0
wmblathers,[Practical Common Lisp](http://www.gigamonkeys.com/book/) is an excellent intro to CL.,1522273081.0
hiroki802,"How about this one?
http://lispcookbook.github.io/cl-cookbook/",1522270259.0
scumwun,How about Land of Lisp? https://github.com/clojurians-org/lisp-ebook/blob/master/Land.of.Lisp.pdf,1522273542.0
kevisazombie,"There are many paths for learning lisp. The barrier to entry is finding a lisp development environment that is easy to setup and get productive in immediately.

In general ""scheme"" dialects are minimalist versions of lisp and have a smaller learning curve. Alternatively, ""common"" lisp implementations are more robust with more features to grasp.

For Scheme, I would recommend racket scheme: https://racket-lang.org/
It will get you writing and executing lisp immediately.


Most lisp dialects pair well with the Emacs text editor. This is because Emacs its self is written in a lisp dialect Emacs-lisp

Emacs can be pre-configured to an excellent lisp development environment. 

Portacle: https://portacle.github.io/ is an out-of-the-box emacs configuration for editing common lisp. That will get you up and running with common lisp

",1522277308.0
maufdez,"Hi, I too am an Electronics Eng. And I have dabbled into many different languages, I think Common Lisp is the best one so far (for me that is). When I started I started with Land of Lisp, which is a good book, however afterwards I read Practical Common Lisp and I feel any of those books is great to start, and the second one is available online for free, though I recomend to buy the printed copý. I would also suggest not to just read but start playing with it, and for that you want to use portacle unless you know your way around EMACS and want to get your hands dirty. When I started doing my own stuff I found the hyperspec to be very valuable, and I also found a good [quick reference](http://clqr.boundp.org/). There is a learnlisp subreddit where you can ask questions, also there is always people in freenode willing to help, I don't remember the channel names, but I think you can find them in the side pannel.
I hope this helps.",1522270312.0
bsd_lore,"For tutorials, you could look at the sidebar on this subreddit.

For tools, if you use macOS, you could give [Clozure Common Lisp - CCL](https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12) a try.

Downloading it from the App Store (link above) will also install a nice editor and debugger.

So, you could delay using Emacs+Slime to later.

I recently rediscovered CCL, I am *exceedingly* pleased with it.

I find it a nice development environment, and easy to learn.

By the way, [this complete GUI application](https://itunes.apple.com/us/app/picture-window/id507262984?mt=12) was developed with ccl. [Source code is available on GitHub here.](https://github.com/Clozure/dpf)",1522313094.0
ClickHereForBacardi,"Search Github for ""lisp koans"" or ""clojure koans"". It's a really neat and interactive way to get acquainted with the language you choose.

Edit: It does require you to go look at docs yourself. It's worth it though.",1522268981.0
kbfats,"I recall enjoying this Andrew Plotkin game back in the day: http://ifdb.tads.org/viewgame?id=zj3ie12ewi1mrj1t

Play it in a browser: http://iplayif.com/?story=http%3A%2F%2Fwww.ifarchive.org%2Fif-archive%2Fgames%2Fzcode%2Flists.z5",1522290613.0
rmrenner,"My personal path: I got into common lisp through exercism.io. It's not a tutorial site in and of itself, but the exercises gave me quick, automatically-checkable tasks in the language to guide my learning.

Exercism is more suited for the purpose of learning a new language than Project Euler, because the tasks aren't supposed to be particularly difficult or illustrate a deep mathematical principle. But on the other hand, the exercises aren't really tailored to the particulars of common lisp, so you're not going to get anything that requires you to learn the more advanced features of the language. I haven't done all of the Lisp Koans, but they seem better suited for that.

Practical Common Lisp and Land of Lisp each have their strengths and are worthwhile to look through, but when you have the fundamentals down, you should check out [Paul Graham's ""On Lisp""](http://unintelligible.org/onlisp/onlisp.html).

It's pretty advanced, but it was the book that really helped me grasp the point of macros: what differentiates them from regular functions and all of the surprisingly deep implications of that. When lisp proponents talk about lisp being a mind-expander, the stuff this book covers is often what they're referring to.",1522309125.0
sgoldkin,"https://www.amazon.com/Little-LISPer-Daniel-P-Friedman/dp/0262560380/ref=sr_1_1_twi_pap_1?ie=UTF8&qid=1522374950&sr=8-1&keywords=the+little+lisper

",1522372321.0
Rajarshi1993,"Hey everyone!

Thanks for all the comments and suggestions. [defunkydrummer](https://www.reddit.com/user/defunkydrummer) and others have made great suggestions. i think Practical Common Lisp is a great place to start, so I am working on it now.",1525555967.0
Paradiesstaub,"Learn Racket Scheme, a Lisp dialect. [Here is a great tutorial](http://docs.racket-lang.org/guide/index.html). Why? Lisp is great but there are a bunch of things with awkward names and questionable defaults. You can think about Scheme as an improved/cleaner Lisp.",1522271295.0
timezone_bot,"6pm UTC happens when this comment is 4 hours and 57 minutes old.

You can find the live countdown here: https://countle.com/oij1659176

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1522155748.0
soundslogical,Just getting into lisp finding your past streams very entertaining and informative also - I'll try to catch one live next time! Keep it up.,1522274705.0
sammymammy2,"Well, just do

    (defmethod update-id ((o order) (id integer) ...)

> 
>  A type declaration is valid in all declarations. The interpretation of a type declaration is as follows:
> 
> 1. During the execution of any reference to the declared variable within the scope of the declaration, the consequences are undefined if the value of the declared variable is not of the declared type.
> 
> 2. During the execution of any setq of the declared variable within the scope of the declaration, the consequences are undefined if the newly assigned value of the declared variable is not of the declared type.
> 
> 3. At the moment the scope of the declaration is entered, the consequences are undefined if the value of the declared variable is not of the declared type.
> 
> 

Look at all that undefined behaviour! I reckon it's a good idea to do both, since SBCL will be able to do some nice type inference for you with declare and declaim but I'm not sure it can do that for check-type. edit: Unless check-type gets optimized away or something like that...

Anyway, check-type is the safe bet here.",1522147883.0
stassats,"(check-type id integer) is safer, since it's actually specified to check the type. declare is just an optimization hint, SBCL treats it as an assertion, but some other implementations just blindly trust it, so it's even less safer than not specifying anything on such implementations.

On SBCL, declare is faster since it's not required to produce a continuable error, which allows it to be a bit more compact.

Now, this is lisp so you are not actually making anything more safer, since your non-integer will fail when you try to use it.

The only exception is when you delay using that integer, for example, by storing it in a database. Or it's an API and you want the error to be caught earlier before it propagates down the stack.",1522151152.0
lispm,"Neither CHECK-TYPE nor DEFMETHOD are declaring types. If implementations do that, it's their own non-standard behavior.

The exact effects and benefits of declarations depends on the implementation, and additionally typically on the compiler settings (speed, safety, compilation-speed, space, debug, and also sometimes on implementation-specific compiler settings).

Thus the question is difficult to answer without context. SBCL will use declarations very different compared to CCL or LispWorks, for example. Depending also on the compiler settings.
",1522151360.0
patrickwonders,"SBCL will optimize based on the 'declare' or the 'ftype'.
CCL will only optimize based on the 'declare'.

Me, I prefer all three if it's critical or [1] and the with-expectations macro from here: https://bitbucket.org/tarballs_are_good/policy-cond",1522188978.0
conseptizer,"Easier to do on paper than on a blackboard. :)

(And surprisingly, I find it easier on paper than on a screen.)",1522136527.0
donaldfisk,"I didn't know Tommy Cooper knew Lisp.   Decades ago I wrote Lisp in the Turbo Pascal editor.   I incremented at each open parenthesis, and decremented at each close parenthesis, and if I didn't get zero I knew they weren't matched


    (DEFINE EXPT
    1

      (λ (X N)
      2  3   2

        (COND ((= N 0) 1)
        3     45     4  3

              (ELSE
              4

               (* X (EXPT X (- N 1)))))))
               5     6      7     6543210
",1522515098.0
ClickHereForBacardi,It's interesting how many libuv systems are mostly C. Including NodeJS.,1522181107.0
can3p,"Interesting, thanks for sharing. What is the process for submission of new packages? Does package manager have a hard dependency on chez scheme?",1522150983.0
metroholografix,"I  didn't try the package manager, as I don't really do scheme,
but this sort of stupidity [1] that I see more and more often
 needs to be called out:

curl -L http://ravensc.com/install | scheme

Judging from this alone, I can safely assume that the rest of the program
will be terrible in terms of taking into account security -- which in this day and
age should be near the top of the requirements list -- and indeed, spending
a few seconds going over the source validates that assumption.
It manages to be worse than Quicklisp, which is -- still -- pretty terrible to begin with [2].

[1] HTTP is a protocol that's trivially attacked [Mitm] and there are frameworks
that let even the most technically-challenged perform such attacks with
a minimum of time and effort.

[2] This was closed some time ago, but it's still a gaping hole as you can see
below: https://github.com/quicklisp/quicklisp-projects/issues/1128

    $ git clone https://github.com/quicklisp/quicklisp-projects/
    Cloning into 'quicklisp-projects'...
    remote: Counting objects: 10155, done.
    remote: Compressing objects: 100% (54/54), done.
    remote: Total 10155 (delta 36), reused 122 (delta 32), pack-reused 10028
    Receiving objects: 100% (10155/10155), 1.81 MiB | 5.09 MiB/s, done.
    Resolving deltas: 100% (1898/1898), done.
  
    $ egrep -Ri 'http://|git://' quicklisp-projects/ | grep source.txt | wc -l
        100

That's 100 projects that Quicklisp pulls down over trivially man-in-the-middled protocols
and stores centrally, to later distribute to victims who probably don't know
this is taking place.

Package managers that work chewing-gum-and-duct-tape style are a dime a dozen.
Package managers that respect their users and try to solve the problems in the domain
__correctly__ are sorely absent.",1522111956.0
guenchi,"Our goal is use the scheme in engineering. This requires: 1. Efficient execution efficiency. 2. Efficient c language ffi

so that's why chez.",1522152171.0
bitwiggler,"why not Gerbil?
",1522268857.0
WhatImKnownAs,"That looks quite interesting. However, there's not a single comment in the code, and it is full of hacks. It's like solving a series of logic riddles, just to learn how to read this code.

Maybe you could add some high-level explanations of the tricks you've pulled here.",1522100086.0
defunkydrummer,That was great fun to look at!!  ,1522178950.0
BlueFlo0d,"I've tried to write some doc to explain the fun.

[wiki](https://github.com/BlueFlo0d/CSP/wiki/Implementation-details)

Will add more later.

However I found implementing evcon. function kind of hard... Even though this system is theortically Turing complete now, I want to implement it using reasonable times of CPP scanning, just like other parts.. Really hope some genius to join in.

**Update** haha I underestimated my intelligence. I've implemented cond. Currently it is not short-circuited however, will fix it later(and really want some companions)",1522245528.0
rudolfo_christ,I have wet dreams about these..... :),1522071126.0
lispm,"> How to make two popular CL implementations fall over with just a little bit of simple math.

How to not understand two popular CL implementations. They don't fall over. They throw an error on FP overflow. If you don't like that, disable it.

You need to understand the math.

(expt +e+ 1000)  is either +infinity or a FP overflow error, depending how your language/implementation is configured. Assume that it is +infinity.

(+ 1 +infinity)  is +infinity.

(/ 1 +infinity) is 0.0d0.


Example: how to tell SBCL to not throw an error, but return +infinity:


    * (expt 2.7182818284590452353602874713527d0 1000)

    debugger invoked on a FLOATING-POINT-OVERFLOW:
      arithmetic error FLOATING-POINT-OVERFLOW signalled

    Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

    restarts (invokable by number or by possibly-abbreviated name):
      0: [ABORT] Exit debugger, returning to top level.

    (""bogus stack frame"")
    0] 0

    * (sb-int:get-floating-point-modes)

    (:TRAPS (:OVERFLOW :INVALID :DIVIDE-BY-ZERO) :ROUNDING-MODE :NEAREST
     :CURRENT-EXCEPTIONS NIL :ACCRUED-EXCEPTIONS NIL :FAST-MODE NIL)
    * (sb-int:set-floating-point-modes :traps '(:INVALID :DIVIDE-BY-ZERO))

    * (expt 2.7182818284590452353602874713527d0 1000)

    #.SB-EXT:DOUBLE-FLOAT-POSITIVE-INFINITY
    *
",1522054854.0
phalp,"A bit of a troll title, no? e^1000 is a big number around 231080957811190927269310943118483284648496845439628381252911541331943555697329212210172013971626240946988971751394837672615850148618263638353131386962373575159518819874308635067341309329249874178479566038914832646621137284333772314459034100053876949811722656280844471657984507140868872074738112013547919968047188518048212155498448337702206623211349884261431354161075265369049027518481664577556287008022255053265819995218943355184256. You may as well request big floats as a feature, but why post like something is broken and we could help?",1522021596.0
stassats,"Find an implementation which uses 80-bit floats from x87, and hurray, no more lethal falling over simple bits of math.",1522026441.0
kazkylheku,"1.   Lisp reciprocal idiom: (/ 1 X) -> (/ X)

2.  2.7182818284590452353602874713527 is way too many decimal digits for a double float. The IEEE 754 64 bit double only guarantees the preservation of 15 decimal digits.


",1522087753.0
SoraFirestorm,Okay... have you reported this to the respective upstreams?,1522020539.0
agambrahma,"FWIW, Lispworks does just fine:

    CL-USER 1 > (defconstant +e+ 2.7182818284590452353602874713527d0)
    +E+
    
    CL-USER 2 > (defun sigmoid (x)
                  (/ 1 
                     (+ 1 (expt +e+ (- x)))))
    SIGMOID
    
    CL-USER 3 > (sigmoid 1000)
    1.0D0
    ",1522125586.0
exquisitus3,You did not mention which is this 'correct result' returned by Ruby or Racket.,1522410689.0
arvid,"Paul Graham has a schemer's point of view. Or better yet an 80's lisper's POV (of which I am one). It was idiomatic but is no longer as `loop` and CLOS dominate today. ANSI Common Lisp ignores Loop and barely touches on CLOS.   That said Graham writes good clear even sometimes beautiful code.  PCL is nice and more attuned to today's style but it does not get across the beauty of lisp. For me, Norvig's PAIP is timeless and is the style I try to emulate. 

Also the reference section in the back of ANSI Common Lisp is really good and gives concise good explanations. ",1522031673.0
xach,"I started with it. But the more I learned Common Lisp, the less I liked ANSI Common Lisp.",1522024596.0
jockc,It's my favorite lisp book.   Nice reference section too (esp. the short section on FORMAT),1522018896.0
defunkydrummer,">Hey guys, I've been reading a lot of books on Lisp 

Have you read Queinnec's Lisp In Small Pieces? I'm going to buy that one someday.
",1522027798.0
majstro0xff,How about land of lisp?,1522044170.0
lispm,"You can start with both, but Racket is actually a specific implementation, originally based on Scheme. Since there is a lot of educational and research use of Racket, it's generally good for learning. But some of that is a bit opinionated. There is a lot of stuff to learn and this can keep you busy.

Common Lisp OTOH is less opionated and not so much based on research from the last 20 years. It's also a language with multiple implementations. Common Lisp implementations currently don't have a large university sponsor (like Racket), though CMU  for example was that in the past. But Common Lisp has various free implementations which are actually community driven (like SBCL) and people still experiment with new implementations (CLASP for example for the the LLVM). Additionally Common Lisp has two large and expensive commercial implementations which are generally in quality and practical features a bit above from what you can find otherwise in Lisp or Scheme.

To learn some newer stuff I would recommend Racket, but Common Lisp brings a different perspective with a lot of capabilities.",1521974533.0
chunsj,"It will be different problem whether you would like to use one as a tool for building some other system or as a tool for experimenting. Racket is not that performant compared to common lisp implementation like SBCL. To me - application in automated trading and analysis - though Racket or other Scheme is more clean language, I have to choose SBCL because performance is important. ",1521970071.0
foobar56w,"You could try writing a small utility program using both languages. The program should be fairly small, but still be able to perform some task that it meaningful to you. This will improve your motivation.
Writing it in both languages will help you choose the one you prefer.

This approach has worked well for me in the past. The last one I did fetched a few web pages and extracted some information (using simple regexes, not a parser).  ",1521965297.0
SSID_Vicious," I would say go for Scheme. If you go that route you can use the venerable SICP, or books like Concrete Abstractions or Scheme And The Art Of Programming. 

Common Lisp also has a few good books like the book by Touretzky, 
Common Lisp: A Gentle Introduction to Symbolic Computation, or the book by Norvig that recently became available for free, Paradigms of Artificial Intelligence Programming. But I do think that Scheme is the better option for learning Lisp. Switching to Common Lisp should be relative straightforward afterwards.",1521977483.0
smatija,"It doesn't matter much with which one you begin, since once you know one you will be able to learn the other in few hours.

As first language racket is probably a bit easier.

Also consider maybe learning Guile, it has really interesting approach to continuations.",1521964763.0
nuntius,"If you like application areas where C/C++ dominate, then go for Common Lisp, probably SBCL or ECL.

If you like areas where Python/Ruby dominate, then go for Racket.

If you aren't sure, then go for Racket.  Fewer decisions to make, easier to get started.",1521998037.0
FrankRuben27,"I only dabbled with Racket, but I'm jumping between CL and Scheme(s) since long - today using both in friendly co-existence with different use-cases for my preferred implementations. So take whatever I say with a grain of salt.

pro CL: Emacs/slime & CL image-based development is eye-opening and extremely productive in case it fits the problem at hand and once you spent the up-front effort to be able to use it. Also CL is significantly more pragmatic, features like the loop macro or the fast format options can again be huge time savers. Centralized and very detailed documentation with the [CLHS](http://clhs.lisp.se/). [SBCL](http://sbcl.org/) has very good optional type checking and it can produce really quick code, if required.

pro Scheme: More elegant, quite a bit smaller and hence quicker to grasp (the first might not exactly be true for Racket). Having different implementations can even be an advantage, in case you want/need to use *one* language e.g. for Java/.Net/scripting/fast executables/... (still expect time to be spend to fight with the implementation incompatibilities).

pro Racket: can very well be used without Emacs. Huge feature set with very interesting extensions, driven by a leadership both  larger and more focused than CL or any other Scheme. Once the switch to Chez Scheme is complete, performance should become more competitive.

And yes, once you've learned one, switching to the other will be much simpler - but you'll still spend *some* time to learn the differing libraries and ecosystem.",1522000379.0
dzecniv,"If you choose Racket, you might miss interactive development, since DrRacket  chose to not go this route, CL is famous for its repl and Geiser may lack some features compared to Slime/Sly (interactive debugging?).

You might miss practical libraries. Judge with these CL resources:

- [CL Cookbook](https://lispcookbook.github.io/cl-cookbook/)
- [Awesome-CL](https://github.com/CodyReichert/awesome-cl)
- http://lisp-lang.org/",1521988180.0
,[deleted],1522017828.0
aeQua-cai5ieQuaR,"Each has a fantastic document that the other lacks an equivalent of:

* *How to Design Programs* : Racket
* *HyperSpec* : Common Lisp

",1522160836.0
bjoli,"as a scheme guy, I would prefer racket. However: racket's threading situation is pretty bad",1521990432.0
defunkydrummer,"Want another answer? If you want to learn how a Lisp language feels like, go for Racket/Scheme, since it might be simpler to learn. Although i'm not so sure -- i think the most difficult concepts for learning lisp is how to apply metaprogramming and the ""code is data"" philosophy. And here the difficullty will be same in Scheme or CL. 

However if your aim is to create an application (be it web server, standalone, etc) that has the potential to grow or be used for serious purposes, it will be easier to start with Common Lisp, since it has *everything* needed for that.",1522028820.0
parens-r-us,"I have used both, and prefer CL for the interactive development, CLOS, conditions, and slime.

Racket falls short for me on debugging for the most part. Everything else about it I like, and the documentation is good for the most part, but some sections descend quickly into academic jargon.",1522065987.0
crabbone,"Common Lisp, even though Wikipedia may tell you otherwise, is an older language (its official birth date is just the date of when the standard was accepted, the language itself is a codification of various other Lisps that existed for a couple decades prior to that).  Scheme is a revisionist attempt to fix some problems in Lisp and to try some new things.  In my view, some things they tried made Scheme a better language, but others weren't so great.

So, I'd say, that if you are interested in historical aspect, Common Lisp would be better, but if you are interested in a language more open to experimentation with the language itself, then Scheme would be better.

About ten years ago, when I discovered Lisp for myself, I made a big mistake not asking this question.  I was deeply confused about Lisps, and in particular about Emacs Lisp and Common Lisp.  Web search would often give me results for Emacs Lisp instead of Common Lisp, and it was hard to tell them apart.  So, that's another thing to be mindful of.",1521965974.0
mdaniel,"JFC, who interleaves languages like that? The context switching going from one paragraph to another is brutal. There is also `---` if you wanted to be polite and visually separate the two posts contained within this one post",1521902585.0
stylewarning,"So, to be abundantly clear, this is specifically for Scheme and not Common Lisp?",1521950952.0
kazkylheku,"Another github repo (of millions) with no actual **code** or anything.

> **Why Lisp?** ... Due to it's [sic] venerable age, there is an enormous corpus of code to draw from.

Except next to none of it will run under Lua or Erlang, even if ""Lisp flavored"".

Off topic!",1521903041.0
dangerCrushHazard,What is this? ,1522061994.0
kbfats,Is AE-2.0 compatible with Zombo.com?,1521832707.0
Baggers_,Looking forward to it!,1521808317.0
egbulmer,How does the theme work? Does one get announced or is it okay to come up with something beforehand? ,1521854969.0
Inaimathi,I'd better start training for this...,1521855937.0
Baggers_,"I was a bit dissapointed with the fps we achieved this time, so I have moved a bit of the work to the gpu and we are now at 88fps with 15000 actors on screen. 

These numbers are going to drop a fair bit when we do anything non trivial in the actor's update step so I'd still like to take a few more passes through this and get us to at least 20k actors.

It's going in the correct direction though. Thanks to everyone who hung out in the chat, always lovely to see you all.",1521677304.0
CelloAxeMurder,Love this series. Thanks for all the effort you put into it,1521700444.0
Rodkor,"Lovely stuff, keep em coming",1521744593.0
Zamarok,..link?,1521638053.0
WhatImKnownAs,"The general idea in Common Lisp is that the programmer doesn't need to deal with the details of character encoding; You just specify the correct `:external-format` when you open the file. 
Ideally, the BOM should be one of those details, but often isn't.

On LispWorks, [you just say :UTF-16](http://www.lispworks.com/documentation/lw71/LW/html/lw-202.htm#16299), and it handles the BOM. On many other implementations, you need to handle it, but that's not hard: UTF-16 is typically available in big-endian and little-endian varieties; open the file with the big-endian UTF-16 external format, read a character, if it's BOM byte-reversed, close and reopen in little-endian.

Your instinct is probably right, and many people have coded these gyrations before, but I don't off-hand know of any.",1521503446.0
sammymammy2,"The easiest thing here would be to take the C library and write a binding for it. Read the file in as '(unsigned-byte 8), convert however many bytes into a c-array and pass that along to the CFFI-defined function.

EDIT: You might want to look into cl-autowrap if you want an easy solution.

EDIT2:

OK, this is what I did:

I installed uchardet and uchardetlib-dev.

I generated the .spec-files with cl-autowrap and loaded the library with CFFI (I think only .spec-files are needed to use the lib so I can send you those if you give me your platform details).

This is how far I got:
    
    (let ((lisp-array (alexandria:read-file-into-byte-vector ""my-file))
    	       (ut (uchardet-new)))
    	   (autowrap:with-alloc (c-array :unsigned-char (length lisp-array))
    	     (print lisp-array)
    	     (loop for i from 0 to (1- (length lisp-array)) do
    		  (setf (autowrap:c-aref c-array i :unsigned-char)
    			(aref lisp-array i)))
    	     (print (uchardet-handle-data ut c-array (length lisp-array)))
    	     (print (uchardet-data-end ut))
    	     (uchardet-get-charset ut)))
    
    #(35 32 85 112 100 97 116 101 100 32 52 47 50 56 47 49 51 32 49 50 58 48 57 32
      80 77 32 98 121 32 77 105 110 101 99 114 97 102 116 32 49 46 52 46 55 10 35
      32 118 105 99 116 105 109 32 110 97 109 101 32 124 32 98 97 110 32 100 97 116
      101 32 124 32 98 97 110 110 101 100 32 98 121 32 124 32 98 97 110 110 101 100
      32 117 110 116 105 108 32 124 32 114 101 97 115 111 110 10 10 195 165 195 164
      195 182 10) 35 32 85 112 100 97 116 101 100 32 52 47 50 56 47 49 51 32 49 50 58 48 57 32 80 77 32 98 121 32 77 105 110 101 99 114 97 102 116 32 49 46 52 46 55 10 35 32 118 105 99 116 105 109 32 110 97 109 101 32 124 32 98 97 110 32 100 97 116 101 32 124 32 98 97 110 110 101 100 32 98 121 32 124 32 98 97 110 110 101 100 32 117 110 116 105 108 32 124 32 114 101 97 115 111 110 10 10 -61 -91 -61 -92 -61 -74 10 
    0 
    NIL 
    ""UTF-8""
    #.(SB-SYS:INT-SAP #X7FFFE8017368)

So it's UTF-8 but I don't know how the BOM thing works.",1521573219.0
tending,"Any possibility you could expound on what you mean about Gerbil modules being single instantiation and this enabling higher performance? Does racket let you instantiate multiple instances, which I assume would just let them have independent global state? I don't see why that would cause a slowdown -- it just means a module is more like a C++ class than a C++ namespace.",1521389903.0
can3p,"Nice to see a package manager as part of distribution. From what I see, in it's current form it only supports github repositories. Is there a plan for centralised discovery platform/repo? And do you plan to support any sort of version pinning for packages?",1521543192.0
bsd_lore,"Very nice.

In the site's [about page](http://www.ulisp.com/show?1AA6), he mention ""For example, this site is running on a Wiki written in Lisp.""

Does anybody know if the source for that is available somewhere?",1521277401.0
Shinmera,[I never asked for this](https://www.youtube.com/watch?v=CXpuRIZzJog),1521120037.0
defunkydrummer,"Lisp topic #1 on HN. Maybe today hell freezes, stay tuned.

Perhaps Shinmera is *the chosen one*, the one that -with the help of the Shirakumo team- will liberate the programming world from these ages of obscurity, cargo cult programming, left-pad and pinkie-promise. ",1521130536.0
bsd_lore,"Congratulations to Portacle, for being (at the moment) #1 entry, at https://news.ycombinator.com/item?id=16591592.

Thanks to /u/Shinmera for giving us such a good tool!

A nice exposure for the Lisp community as well.",1521115199.0
waspishly_simple,Any chance of a 32 bit Windows version?,1524470516.0
lisper,"Worth reading the followup too:

http://blog.rongarret.info/2009/04/some-perspective-on-destroyed-career.html

(I'm the author of both pieces.  AMA.)",1521127121.0
defunkydrummer,">My colleagues were using C (K&R in those days) or Pascal. C++, Perl, 
Java, Python, etc. didn't exist. When all those modern languages are 
out of the picture, Lisp rocks.

I've used Java and Python professionally for years and I can firmly say Lisp *rocks* compared to them. Oh yeah! No experience with perl, though. 

>Once upon 
a time Lisp had a long list of features that no other language had (GC, 
full numeric tower, CLOS, incremental development, macros) 

Well, it's 2018 and almost no OOP language has the power, features and flexibility of Lisp's CLOS, except for Dylan, 
and Julia. 

It's 2018 and the kind of fully flexible  interactive development where the running system can be updated at will (i.e. redefine/recompile a function or redefine a. class *while the code is running*) *and* it is also image-based, is AFAIK still only available in Lisp and Smalltalk. This gives enormous productivity.

In fact, in his web page, Ron Garret aka Erran Gat (the OP) illustrates how this feature was crucial for NASA's Deep Space 1 project:

>In 1994 JPL started working on the Remote Agent (RA), an autonomous spacecraft control system. RA was written entirely in Common Lisp despite unrelenting political pressure to move to C++. At one point an attempt was made to port one part of the system (the planner) to C++. This attempt had to be abandoned after a year. Based on this experience I think it's safe to say that if not for Lisp the Remote Agent would have failed.

>(...)The Remote Agent software, running on a custom port of Harlequin Common Lisp, flew aboard Deep Space 1 (DS1), the first mission of NASA's New Millennium program. Remote Agent controlled DS1 for two days in May of 1999. During that time we were able to debug and fix a race condition that had not shown up during ground testing. (Debugging a program running on a $100M piece of hardware that is 100 million miles away is an interesting experience. Having a read-eval-print loop running on the spacecraft proved invaluable in finding and fixing the problem. The story of the Remote Agent bug is an interesting one in and of itself.)

>The Remote Agent was subsequently named ""NASA Software of the Year"".",1521119454.0
akssri,Lisping has more or less made my Python 'wildly incomprehensible' too (okay... that's probably just me).,1521122719.0
kuemmel234,"Gave me a bit of a chuckle. It's 2018, I work part time for a company and I am forced to write Java and hate it (and the competition is even closer these days with all the functional tools).

I'm probably going to graduate next year and the only reason I am going to look for a different full time job is that I want to code in another language and an interesting tech base (there's a lot of companies using clojure here). ",1521193426.0
fouric,"Thank you for sharing! I'm a devoted Lisper, and now that you brought it up, I can begin to see this complacency creeping in to my attitude about programming.

Question for you: the productivity gains (or even straight-up advantages over Lisp) that you noticed - do you think that perhaps they could have been partially or mostly caused by the massive library advantage that other languages have over Lisp? For instance, as someone who's written a non-trivial amount of Python code over the past few years, I can confirm that, while it's much less powerful and expressive than CL, it has libraries for *everything*.",1521224506.0
shittingChristCopter,seems more like the author is a poor programmer than anything to do with Lisp itself,1521117787.0
dzecniv,TXR looks impressive but it's hard to grasp.,1521131693.0
kazkylheku,"lambdas are working:

* lexical closure
* optional vars with ""present-p"" indicating variables and rest params.
* any/all params can be special variables, properly handled.

Session:

    1> (compile-toplevel '(lambda (*stdout* : (a 42 a-p)) (prinl (list a a-p) *stdout*)))
    #<sys:vm-desc: 9b0b568>
    2> (sys:vm-execute-toplevel *1)
    #<intrinsic fun: 1 param + 1 optional>
    3> (with-out-string-stream (s) [*2 s 1])
    ""(1 t)\n""
    4> (with-out-string-stream (s) [*2 s])
    ""(42 nil)\n""
    5> (disassemble *1)
    data:
      d00: :
      d01: t
      d02: prinl
      d03: list
      d04: *stdout*
    code:
        0: 88000014 close t03 2 20 2 1 nil v0000 v0001
        1: 00020003
        2: 00010002
        3: 02010200
        4: 26020101 movsr v0002 d01
        5: 4000000A ifq v0001 d00 10
        6: 02010100
        7: 26020000 movsr v0002 nil
        8: 2CA90001 movrsi t01 42
        9: 26010001 movsr v0001 t01
       10: 0C030000 dframe 3 0
       11: 86000104 bindv v0000 d04
       12: 18020002 call t02 d03 v0001 v0002
       13: 02010103
       14: 00000202
       15: 64030104 getv t03 d04
       16: 18020001 call t01 d02 t02 t03
       17: 00020102
       18: 00000003
       19: 10000001 end t01
       20: 10000003 end t03
    nil

Special var `*stdout*` not clobbered:

    6> *stdout*
    #<file-stream stdout b7716fac>

The `close` instruction creates a closure, puts it into register `t03` and then branches to 20.  When we execute this VM, that's how we get the closure returned: the `end t03` tells the virtual machine loop to return a value out of register `t03`, and since it's not in any higher level loop, it terminates.

The closure's entry point instruction pointer is aimed at word 3 in the instruction vector. A variable-length list of destination operands is stored there. These operands receive the aguments. In this case `v0000` and `v0001`.

**I see a dirty little bug**; we are not allocating a frame size of 3 but only of 2, even though there is a `v0002` variable corresponding to `a-p`, oops!

Instructions 4-9 handle the defaulting of the optional argument and the `a-p` indicator in `v0002`. First we set `v0002` to `t` (coming from `d01`): assume that the parameter is present.  We then compare the argument to `d00` which holds the colon symbol `:` that indicates missing arguments. If the comparison is false, we skip to instruction 10: we are done. Otherwise we proceed with instruction 7: we falsify `a-p` by moving `nil` into it. `nil` is a pseudo-operand denoting register `t0` which is read-only and always holds `nil` and so it is shown as `nil` in the disassembly: **this is inspired by MIPS!**. And we set the default value by wastefully moving 42 into `t1` and then `t1` to `v0001`.


The `end t01` instruction is the end of the closure. If it happened to be `end t03`, an optimizer could collapse the two `end` instructions into one!  The closure compiler could do this; it could compile the interior of the closure first, and then re-use its output register for the `close` instruction so that the two `end` instructions match, and hence elide one of them.

The `dframe` is where the dynamic environment is extended with a new frame. The subsequent `bindv` then binds `*stdout*` in this extended environment. Here we have **dirty bug #2**: the `dframe` is not terminated by a matching `end`.  The `end t01` is the wrong one; so **that** is where the dynamic env is popped and the original `*stdout*` is restored; then control falls onto `end t03` which ends the closure. But that's the wrong register. The wrong return value is concealed by the `with-out-string-stream` macro which imposes its own return value: the contents of the string stream.
",1521227982.0
github-alphapapa,"Sorry, I just discovered TXR yesterday and have only read a little bit of the manual, but I'm confused: I thought TXR already had a VM and bytecode compiler.  What is going on here?  :)",1527313374.0
defunkydrummer,"> It has modern Lisp syntax like Clojure

I think you mean ""alternative syntax like Clojure""",1521047897.0
GDP10,How does this compare to [LFE?](http://lfe.io/),1521060902.0
metroholografix,"""Modern Lisp syntax, like Clojure"" guarantees that I won't try out your project. I'm not interested in anything that breaks compatibility with syntax that has stood the test of time, for no actual benefit besides being hip.

The idiotic syntax changes and the potent Java smell -- together with premature optimization -- are among the things that keep me away from Clojure. I could stomach Java if I really had to, but the syntax changes are inexcusable. When you're been writing Lisp for some time, parentheses disappear. Throwing brackets into the mix feels like a constant slap in the face that takes you away from the flow.",1521045182.0
jazzandpython,"I wish you the best, a Clojure like lisp to use on the beam would be awesome.",1521212666.0
keymone,"""Modern Lisp syntax, like Clojure"" is the only kind of lisp i can ever imagine working with. erlang is nice too. best of luck to the author(s).",1521077141.0
anaerobic_lifeform,"This is really interesting. But note that I consider the ""modern"" adjective to be overused, and unfortunate because it needlessly implies other Lisps are not modern; as far as I am concerned, this negatively impacts how I might perceive your work (which is unfair, I agree).

Also, how does it compare to http://joxa.org/ and http://lfe.io/?

Will try to install and test, nice work.",1521020559.0
flaming_bird,I see that your language has multiple improvements and differences over Lisp Flavored Erlang.,1521020488.0
A_guy_from_Germany,BTW thanks for this series.,1520869350.0
Fibreman,Bummer I was actually trying to get around and watch this one live. Oh well there will be more. Hope your mate's talk goes well!,1520908881.0
piotr404,"See you next week, then !",1520936609.0
Gravybadger,"Running a lisp image as root... What could go wrong, eh?

sudo -H -u <nonprivilegeduser> /usr/bin/ccl --load myscript.lisp



",1520731913.0
crabbone,"What's the end goal? Are you simply trying to start swank server after the system boots? If so, `/etc/rc.local` isn't a good place to do that. At least because it may be executed multiple times during boot, depending on your booting options.

If the system is Raspbian, I think it's a systemd system, so, write a systemd unit instead, if it's an initd system, put a script in `/etc/init.d/` and so on.",1521526936.0
KDallas_Multipass,"This likely has something to do with the environment that is available with scripts are run at startup.  The rule of thumb is that $PATH isn't available unless you've made pains to make it so, so provide explicit paths to everything.  Like pass the full path of the ccl init file as a the command line arguent for ccl in the script",1520881069.0
njordthe,"youtube mirror
https://www.youtube.com/watch?v=OBfB2MJw3qg",1520640027.0
lunkdjedi,"You really want to maintain your separation of concerns. The NN should be the only thing managing the weights and internals of the network itself. 

In order to maintain a 'smallish' and reasonably computable NN, you probably want your GA to pick a subset of inputs to feed in to the NN. I was using various transformations of noisy data in an effort to smooth out the inputs. Simple Moving Averages for instance. 

By keeping the NN kinda of small you can evolve a larger population with your GA to pick the best inputs that score the best 'fit' and use the top scoring NN.

This is all very computationally expensive, and finding the boundary for what's the right size of the NN and the GA population is a lot of trial and error. Your first approaches are research and really aren't to find the best answer, but to ensure you have organized your various components together properly. 

Once you're satisfied with the software, you can try scaling out, that's when the real fun begins. With so many moving and dynamic parts, it's really hard to trust the results, especially with all the noise and entropy of the real world. ",1520512519.0
deong,"Well, you can just do it directly. Let's say you have a network with 4 input nodes, 4 hidden nodes, and 1 output node, fully connected between each layer. That means You have 4^2 weights in the first layer, and an additional 4 weights to the output layer, so you need 20 weights total to represent the network.

Ok, so use a GA that operates on real encodings and just have the individuals be 20 floating point numbers. Or use a GA with a binary encoding, given each weight *k* bits of precision, and have a bit string *20k* bits long.

That said, there are really better ways to train a neural network. Stochastic gradient descent works really well on neural net learning. Why take a nice differentiable function and optimize it using a method that ignores the gradient you have handy? GAs can be useful in helping learn architecture or other types of structure, but if you have a known network that just needs weights, it's not what I'd reach for.",1520575231.0
__lm__,"Evolving an artificial neural network using genetic algorithms or other evolutionary methods is something that is already present in the literature. A quite old survey (1999) is [evolving artificial neural networks](http://www.cs.bham.ac.uk/~xin/papers/published_iproc_sep99.pdf), but I think that it could still be useful. In general, for topics like this I suggest to search in google scholar instead of the “standard” google.",1520578062.0
cricket_observer,"I am not well versed with Common Lisp.

But I did a similar project for my course 10 years ago. However everything was in Matlab. You may read Multi-Objective optimization by Kalyanmoy Deb or another book by Coelho Coelho.

However if this is not a classroom project I suggest you don't use GA for weight optimization. Because it is quite slow compared to gradient based methods unless your NN is gigantic.",1524247791.0
xach,"`(quicklisp-quickstart:lisp)` ought to be `(quicklisp-quickstart:install)`.

If you don't provide an ordering in the `defsystem`, one will be provided for you, and there's a risk that it isn't the ordering you want. It is better to use `:serial t`.

",1520436612.0
lisp-student,"Thank you, this is one of the clearest explanation about setting up a minimal project I have read.

Please, gives us more.",1520443924.0
cl-macro,Think you very much for this good tutorial.,1520497487.0
duikboot,"Very clearly written, I would love to see more.",1520498822.0
tazjin,"Cool!

Minor note, I believe that `(ql:add-to-init-file)` is available in the system after running the Quicklisp installer so the user doesn't need to stop their Lisp in between those commands.",1520589880.0
kazkylheku,"""Minimal QuickLisp"" is hardly ""minimal Common Lisp"".",1520612529.0
Baggers_,Recording: https://youtu.be/CtAmBBd5Wrw?t=12m54s,1520459674.0
defunkydrummer,"Yay! An update of my favorite IDE bundle!

Shinmera for president!",1520353607.0
Najaokwecan,Doing gods work,1520366327.0
,I'm intensely curious as to how you're generating the images in this blog post.,1520972254.0
dzecniv,"FYI Roswell has a website generated from the wiki: https://roswell.github.io/How-to-distribute-your-software,-not-library,-on-Quicklisp-ala-python-pip.html

and related, IMO worth linking to, ways to help distribute software with debian packages or homebrew: https://github.com/CodyReichert/awesome-cl#interfaces-to-other-package-managers",1520287605.0
CelloAxeMurder,"Assuming you have Quicklisp installed: 

    CL-USER> (ql:quickload '(""clsql"" ""clsql-sqlite3""))
    To load ""clsql"":
      Load 1 ASDF system:
        clsql
    ; Loading ""clsql""
    To load ""clsql-sqlite3"":
      Load 1 ASDF system:
        clsql-sqlite3
    ; Loading ""clsql-sqlite3""
    (""clsql"" ""clsql-sqlite3"")
    CL-USER> (use-package :clsql)
    T
    CL-USER> (connect ""foo"" :database-type :sqlite3)
    #<CLSQL-SQLITE3:SQLITE3-DATABASE foo OPEN {1002E07A13}>
    CL-USER> (execute-command ""create table foo (bar text, baz date)"")
    ; No values
    CL-USER> (execute-command ""insert into foo (bar, baz) values ('help', date('2018-01-01'))"")
    ; No values
    CL-USER> (query ""select * from foo"")
    ((""help"" ""2018-01-01""))
    (""bar"" ""baz"")
    CL-USER> 
    ",1520226328.0
scmlinux,"CelloAxeMurder, thank you for your reply. It's come to my attention that the GNU CLISP project has not been updated for some time and currently doesn't have a maintainer. Could you please recommend a CL interpreter that Quicklisp works in too?",1520264236.0
defunkydrummer,">Bonus points if it has simple examples of its usage too.

CLSQL is [well documented](http://clsql.kpe.io/manual/), and it's usage is basically:

0. Make sure you have installed the correct ""database backend"" for the RDBMS system you are going to use .

1. Make sure you can establish a DB connection. Then, there are three ways you can use CLSQL.

a. By creating your own queries (strings with SQL statement) and executing them, with (execute-command), (query) and others.

b. By using ""Functional SQL"" to create SQL statements based on CLSQL operators. This allows you to programatically create SQL statements in a clean way. See sections III and IV. 

c. By using it for object-oriented development, similar to an ORM (object-relational mapper). See sections VI and VII. ",1520279094.0
kazkylheku,"The `block` is a red-herring; it is not the basis for why `defun` allows recursion.  The basis for `defun` functions being able to self-recurse is that `defun` plants the function into a global binding.

So that is to say, **very** loosely (but accurately for our purposes) speaking:

    (defun name (args ...) body) --> (setf (symbol-function 'name) (lambda (args ...) body))

When `body` evaluates, and a call to the function occurs, by that time the function is already installed in the binding.

What the `block` allows is for early returns in the function, which occur in procedural programming styles:

    (defun foo () (return-from foo 42) (notreached))


",1520191949.0
akrumbach,"There are two implementation methods I am familiar with for control-management special forms like `(block ...)`, based on whether you use continuation passing style, or a virtual machine [SECD/4-stack] ""under the hood"". I'm assuming from your inspiration that it doesn't fully match either definition; I'll give both answers and let you decide which might be more useful.

In CPS, `(block ...)` and similar indirect-control forms are best implemented within the evaluator as tagged (named) continuations.  

In a stack machine implementation, you will likely need to ""hardcode"" the special form as a virtual machine primitive.",1520169238.0
drcz,"(Sorry for my scheme'ish manners)

I think what you ask for is a Y combinator; for example:

    (((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (arg) ((g g) arg))))))
      (λ (fac)                                                                                                                                                                 
        (λ (n) (if (= n 0) 1 (* n (fac (- n 1)))))))
    5)

should evaluate to `120` in your lisp if you got the scoping right, and

    ( ((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (a1 a2) ((g g) a1 a2))))))
     (λ (concat)
        (λ (xs ys) (if (null? xs) ys (cons (car xs) (concat (cdr xs) ys))))))
     '(q w e) '(1 2 3) )

to `(q w e 1 2 3)`.

And it can be embedded so

    ( ((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (as) ((g g) as))))))
       (λ (mapfac)
         (λ (xs)
          (if (null? xs)
              '()
              (cons (((λ (f) ((λ (x) (x x)) (λ (g) (f (λ (arg) ((g g) arg))))))
                       (λ (fac)
                         (λ (n) (if (= n 0) 1 (* n (fac (- n 1))))))) (car xs))
                     (mapfac (cdr xs)))))))
     '(1 2 3) )
     
yield `(1 2 6)`, and you can do mutual recursion as well.

For more details definitely check out ``Unfolding Recursive Function Definitions Using the Paradoxical Combinator'' (http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.116.5425&rep=rep1&type=pdf).

However from the examples above it should be clear that this method it is not the chepaset one wrt number of reductions, so you'd be better with ""hardcoding"" `block`/`letrec`/named `let`...

There is yet another soultion though, using a second environment: traditionally it was called `topenv`; the difference between `env` and `topenv` is the former contains bindings (ie results of applications of `lambda`s) while latter contains definitions (results of `defun`s). You pass `topenv` around just as you do with `env` and whenever you evaluate a symbol, you first check `env` and then `topenv`.

So there are plenty of possibilities.
My experience with writing LISP in C is that you'd be better with implementing a virtual machine (SECD-like) and writing a simple compiler, just as /u/akrumbach suggests. But that depends on what your needs and aspirations are.

Anyway, good luck!",1520172033.0
defunkydrummer,"Thanks RJ for this post; i'm currently reading about the memory model used by uLisp, since it targets devices with really little RAM. ",1520020579.0
,I think that 1:36:43 begins a very nice breakdown of a small modification that non developers can kind of follow with and non lisp developers can find relatable and intriguing.,1520782704.0
sickofthisshit,At least this version uses emacsclient. I saw one that launched an independent Emacs instance which misses the point,1519825095.0
anaerobic_lifeform,"I bet there is a word in German to express the intense, mixed feelings I have with respect to that beautiful logo.",1519828902.0
Joh11_,.dmg files are macOs specific right ? Is there a linux version ? ,1519837345.0
,I don't know why I never thought of doing this. I'm looking forward to the Linux version. I think it will allow me to use Jupyter notebooks.,1519858257.0
maufdez,"This is cool, too bad it does not work on Windows afaik, for those in windows I would suggest installing [Auto Hot Key](https://autohotkey.com/) and then using [EWOW](https://github.com/zk-phi/ewow), it does not open emacs, but it gives you a lot of its functionality almost anywhere on windows.",1519838200.0
reddit_clone,"Nice. 

But it is not allowing me to drop it on the 'Services' icon. What gives?

(I am using Sierrra) Run it with elevated permissions somehow? ",1519838293.0
JohnMcarthysLisp,"I’ve got WIP pull request on github to add support for Linux. I need some eyeballs on it, especially since I wrote it without testing it in Linux and because bash it’s been a while since I’ve got my bash on. Thanks an adavance 🙏 ",1520002229.0
,I have this book. Some of the stuff in here changed me as a programmer. Great book.,1519718461.0
arvid,added to the Free Books section of the sidebar ==>,1519735955.0
intelligent_cat,"shame it's a poorly OCRed one, has it been proofread?",1519682888.0
parens-r-us,"Had a look at the contents, pretty excited to dive in to this! I've been tinkering with Prolog too so should have some decent crossover.",1520586304.0
lucasecp,There's any way i can convert c-string back to common Lisp?,1519586251.0
akssri,"TLDR; Yann Le Cunn, who is now considered to be one of the great grandfathers of Deep Learning, wrote/maintained, along with his collaborator Leon Bottou, a Lisp for doing ML until the early 2010s (before jumping ship to Lua, and now Python). The history of Lush is even more awe-inspiring. It traces its roots all the way back to before the last AI winter (when symbolics died). It appears it survived multiple fad-eras in ML too: ANNs, SVMs, PGMs, and has had active contributions from people who are considered 'rockstars' in Machine Learning today. Also see,

http://lush.sourceforge.net/credits.html",1519531466.0
Shinmera,"The bird cam is a new addition, providing you with revolutionary stream entertainment: you get to watch two budgies, being birds, live!

Basically this is now an animal stream with code on the side.",1519498290.0
Shinmera,"Just trust the user not to shoot themselves in the face. Lisp is not a language made to restrict users.

Learning that is quite liberating.",1519314435.0
Baggers_,"From the spec: [defconstant](http://clhs.lisp.se/Body/m_defcon.htm) 

And the bit that likely matter to you here.

> If a defconstant form appears as a top level form, the compiler must recognize that name names a constant variable. An implementation may choose to evaluate the value-form at compile time, load time, or both. Therefore, users must ensure that the initial-value can be evaluated at compile time (regardless of whether or not references to name appear in the file) and that it always evaluates to the same value. 

And remember that:

> The consequences are undefined if there are any bindings of the variable named by name at the time defconstant is executed or if the value is not eql to the value of initial-value. 

You may also want to look into alexandria's `define-constant`

[edit] the 'P.S' in the question really changes the nature of the question, your alternate option is not equivalent to the original. I'm a bit hazy on the implications of the details I quoted from the spec above, but try the following and more experienced lispers can tell me what I've done wrong here:

	(eval-when (:compile-toplevel :load-toplevel :execute)
	  (defun foo (x y)
		(+ x y)))

	(defconstant +x+ 5)
	(defconstant +y+ 8)
	(defconstant +z+ (foo +x+ +y+))
",1519313850.0
paulfdietz,"You can cloak a variable in a symbol macro so it isn't a 'place' that can be assigned to.

(defparameter obfuscated-variable-name-for-+x+  <initial-value>)

(define-symbol-macro +x+ (identity obfuscated-variable-name-for-+x+))",1519337904.0
kazkylheku,"> *Everything followed by a (?) is up for discussion*

OK

> *this isn't supported*

?

> *I wouldn't mind if +z+ instead of an evaluated value is something that would be replaced everywhere by the expression (foo +x+ +y+).*

    (define-symbol-macro +z+ (foo +x+ +y+))

",1519313905.0
xach,"Douglas T. Crosher, a CMUCL hacker who went on to make Scieneer CL, discussed it on sbcl-devel some time ago. https://sourceforge.net/p/sbcl/mailman/message/34821303/",1519240541.0
jsjolen,Yes. But I am also too bad at this stuff to do it :-).,1519247173.0
defunkydrummer,"I'm currently thinking on creating such a thing over the last days, however what I have been thinking wasn't CL->wasm but rather a Lisp dialect that resembles CL in syntax.

Currently the CLASP implementation creates LLVM code and this code can be readily compiled to WASM by using Emscripten, although i don't know if anybody has tried this. We don't know how big would the resultant binary file be, though.

* solution: tree shaking? 

Then you could use ECL to compile CL to C which can be then readily compiled to WASM (at least two C->wasm compilers available right now), but again we don't know how big would the binary be. Also, as far as I understand, the compilers that do C to wasm provide a very limited C library. 

* perhaps a stripped-down (feature-restricted) ECL would manage smaller binaries? 

Additionally, there is a project that translates JVM bytecode to WASM, however, i don't know if this gives any chance for ABCL to run over there. 

CLISP emits bytecode. I guess some kind soul could create a VM that executes the bytecode created by CLISP on WASM. 

Yet additionally, the LuaVM has been ported to WASM, and there are two (limited) Lisps that transpile to Lua. 

Additionally, there is JSCL (CL implementation over Javascript) and if there was a sufficiently powerful ""javascript-to-wasm"" compiler, then it could be possible to run it on wasm. However, what we have now is ""AssemblyScript"" which is a very *very* restricted minimal subset of TypeScript compiled to WASM.  (For what i've seen, an acceptable description of AssemblyScript is ""wasm written with JS syntax."")

Yet additionally, I am not so sure (can't deduce from the specs) how possible is to have WASM code generate WASM code at runtime and execute it; as far as i understand WASM works under a strict AOT (ahead of time) compile mode, so the WASM module is defined beforehand, and then compiled to ML, and run. A possibility is to create the WASM bytecode at runtime (using wasm), send it to javascript and have Javascript load it as a new WASM module... However this means that your original code and the 'generated at runtime' code will be on separate WASM *modules*, so as far as I know (correct me if i'm wrong), they will access different linear memory spaces, so their only bridge of communication would be perhaps Javascript (and there is a significant overhead for doing wasm<->js calls).

* A workaround to this problem could be to have Lisp compile to a special bytecode that is then run on a bytecode interpreter (written in WASM), rather than direct compile to WASM. However that wouldn't give the best performance. On the other hand, this might mean that the total WASM module download size is made smaller (thanks to the custom bytecode). 

So i'm still thinking deeply on what would be best to do.  Feel free to pour ideas, i'm **very** interested on having Lisp a first-rate choice for wasm development. 

At least, the first step would be to have a Common Lisp system that is able to convert webassembly s-expression format to webassembly bytecode, without having to use any non-lisp lib. 
",1519246164.0
cheryllium,"Yes! But my problem is, I don't know anything about WebAssembly. If we want to get a group of people together to do this, however, I would be interested in helping out however I can. ",1519259456.0
eholk,"This isn't CL, but still related, there are the beginnings of a Scheme to Wasm implementation at https://github.com/google/schism ",1519857267.0
furych,"Author there, it is not really working now and I haven't worked on it for a while, so please dont try it yet ;)

The original [emacs ztree](https://github.com/fourier/ztree) package up-to-date and functioning well.",1519225074.0
sammymammy2,"""If displaced-to non-nil, a displaced array is created. The resulting array shares its contents with the array given by displaced-to.""

""displaced array n. an array which has no storage of its own, but which is instead indirected to the storage of another array, called its target, at a specified offset, in such a way that any attempt to access the displaced array implicitly references the target array. ""

http://clhs.lisp.se/Body/26_glo_d.htm#displaced_array",1519204588.0
WhatImKnownAs,"Since this is gives the implementation license to return a new array, you can only rely on it being the same array, if it's [*actually adjustable*](http://clhs.lisp.se/Body/26_glo_a.htm#actually_adjustable). Of course, implementors will seek to avoid unnecessary copying of the array contents, so using that as your heuristic, you can be quite confident in some other cases that it will be the same (but you should preferably `assert` that).

Note that it doesn't say ""The result can be displaced"", it says the argument can be displaced to the result (by a further call to `adjust-array`).",1519206663.0
Baggers_,"Fantastic! This is already clarifying some things I had been wondering about. 

Also, regarding `'ltn-annotate : I have no idea what LTN means'` I think LTN is local temporary name, I'm guessing from the definition of `ir2-block`:

	;; a vector that maps local TN numbers to TNs. Some entries may be
	;; NIL, indicating that that number is unused. (This allows us to
	;; delete local conflict information without compressing the LTN
	;; numbers.)
    ;;
	;; If an entry is :MORE, then this block contains only a single VOP.
	;; This VOP has so many more arguments and/or results that they
	;; cannot all be assigned distinct LTN numbers. In this case, we
	;; assign all the more args one LTN number, and all the more results
	;; another LTN number. We can do this, since more operands are
	;; referenced simultaneously as far as conflict analysis is
	;; concerned. Note that all these :MORE TNs will be global TNs.
	(local-tns (make-array local-tn-limit) :type local-tn-vector)

[edit]
From this i'd guess gtn is global temporary name. Local & global could be related to whether it applies only within or across blocks (similar to local/global optimization from classic optimizing 
compiler literature)",1519116231.0
defunkydrummer,Thanks so much. Yesterday i was taking a look at the documentation for the internals of CMUCL and was wishing there was something similar for SBCL. ,1519129806.0
lispm,"Macros in a compiled Lisp are expanded at compile time. Thus giving them source code at runtime does not work. Passing source code into a macro form at runtime does not work, since the macro form is already expanded.

To turn source code into executable code at runtime (!) you need to call EVAL or COMPILE explicitly.

If you want to create source code at runtime, want to compile it and want to use this compiled code, then use the function COMPILE. One does compile it once and the compiled function can be used multiple times.

For the SAME function, one just compiles it once:

    (let ((foo (compile nil '(lambda (x) (+ x 10)))))
      (+ (funcall foo 10) (funcall foo 20)))

What you do in your first version, is that you call the evaluator (which usually calls the SBCL compiler) and you compile the same function 100000 times. This usually makes no sense. It only makes sense if you want to compile DIFFERENT functions.
",1519113041.0
kazkylheku,"Hint: when you pass `'(+ =input= 10)` to the macro, what you're passing is the object `(quote (+ =input= 10))`. Just write the logic in your macro to look for `(quote ...)` and strip it away; then it can be called as a function.

Another idea: keep your  `run-form-function` but optimize it with a compiler macro. Look into Common Lisp [compiler macros](http://clhs.lisp.se/Body/m_define.htm).

A compiler macro written for `run-form-function` can recognize that it's being called with a quoted argument, and optimize that instance.",1519144618.0
lispm,"I have only the code of the first edition. pbi-code.cl

https://github.com/lispm/CommonLispCode/blob/master/pbi-code.lisp

The second edition file is called pbi-2e-code.cl 

If his department doesn't have it, you could ask the Franz Inc support if they have it or some of their staff has it. They listed Ira Kalet's work under their success stories and I think he was an ACL user. Typically their support is quite helpful - might be worth a try.

",1518974583.0
chuchana,Have you tried wayback machine on archive.org ?,1518960849.0
Baggers_,I've had no luck on archive.org so far. Sadly its seems [he passed away back in 2015](http://www.radonc.washington.edu/wp-content/uploads/2015/04/Ira-Kalet-Celebrating-the-Life-and-Contribution.pdf) but maybe you can email his department and see if we can get that code.,1518970802.0
KDallas_Multipass,Let us know what you find.,1519046651.0
,"So, after emailing Franz and a number of departments at the University of Washington, I received a reply from the UW School of Medicine which pointed me to an old [page](https://web.archive.org/web/20121223063732/http://faculty.washington.edu/ikalet/) from the Wayback Machine and the code from the 1st edition (which [lispm](https://www.reddit.com/user/lispm) already provided).  One thing I could do if I find the time is update the 1st edition and put it on GitHub. ",1520369723.0
defunkydrummer,"Excellent news, and i'm particularly excited by: 

>Feature: clx-fb backend (poc of framebuffer-based backend).

This opens up the door for even more portability, am I correct?",1518789283.0
borodust,"For those interested, you might also want to take a look at [Urn](https://github.com/SquidDev/urn)",1518728944.0
arvid,"> Project web is currently offline pending the final migration of its data to our new datacenter.

looks like sourceforge is migrating servers. [Maxima](http://maxima.sourceforge.net/) is also down.",1518712591.0
paulfdietz,"Important links that were at that page:

https://sourceforge.net/projects/sbcl/  -- page for SBCL on sourceforge (repo is now viewable)

https://launchpad.net/sbcl  -- bug report page",1518756115.0
,Yup... the main site is still down.,1518804575.0
paulfdietz,"It's back now.

EDIT: or not.

EDIT2: and back again.",1518827525.0
dangerbird2,Pretty much all sourceforge websites have been down today.,1518835864.0
stassats,For anyone missing the manual and unable to build their own: https://sbcl.github.io/,1518866754.0
WhatImKnownAs,"You could take the `symbol-name` and compare them using `string=`, but that's unlikely to be the right thing. Either they were not meant to name the same thing, and you're missing a converter that you need to use; or they were meant to name the same thing, and the package definition for one of the packages should inherit or import the names, so that they would be the same symbol.",1518688346.0
kazkylheku,"> *How do I compare symbols from different packages?*

Usually, by returning `nil`. 

:P


> *If I compare a func from my frontend I get a different symbol to the backend's notion of func it's different, however.*

Fix the pipeline not to goof up the symbols that pass through it. The compiled function's name should be the same symbol as of the source function.
",1518722184.0
anaerobic_lifeform,"Your reserved keywords need to belong to a package that is automatically used 
 (in the meaning of use-package) when you read your symbols. Then, they will be exactly the same symbols. Instead of `backend:func` and `frontend:func`, have a package which does not use CL but only exports your language's keywords:

    (defpackage :mylang (:use) (:export #:func #:global! #:macro!))

Then:

    (defpackage :backend (:use :mylang))
    (defpackage :frontend (:use :mylang))

Your parser then needs to translate tokens from text to Lisp symbols. You could use the Lisp reader, but then: take care to bind `*read-eval*` to NIL, use a  simplified readtable and maybe a temporary package for symbols introduced by the user.",1518703916.0
defunkydrummer,">How do I compare symbols from different packages?

But... but... symbols from different packages... are different symbols! Comparison would always return false/nil!

",1518796132.0
theangeryemacsshibe,"To append, you need to set the list to the newly appended data. Also, you could get better speed from just using `cons` if you're just prepending an item to the list, which is actually what you're doing with `append`. 

Don't feel stupid, making lists is probably the most flexible and confusable part of Lisp (hence the name List Processing).",1518679128.0
CallMeMalice,"Yeah, check clhs. In CL many functions (append, sort, nconc...) don't update the variable with the result - you use the returned value. Note that they might be destructive(like sort and nocnc), which means that not only you have to use the result, but the variable you have provided might be reused, so you should assume that it is no longer in a valid state. Some other do modify the data (e.g. push) to provide the result. There's no rule to it, I guess. You have to play with it to see if it modifies the value or just read the documentation. ",1518679510.0
anaerobic_lifeform,"> used to make this (y nil) or just (y) but it didn't seem to matter

LET contains a list of bindings, where each binding is typically a list (VAR INIT-FORM). But you can drop INIT-FORM and write only (VAR). You can even write only VAR, which means the following is valid:

    (let (x y z) ...)

An empty INIT-FORM stands for NIL.

NIL is a symbol whose value is the symbol NIL: yes, the slot-value of NIL is itself, and is thus a self-evaluating symbol, just like T and all symbols in the KEYWORD package.

When you quote NIL, you obtain the symbol NIL, which is the same value as the value of NIL, itself. Hence, quoting self-evaluating symbols does not change anything. Some people use different conventions to distinguish how the NIL is used based on whether it is quoted or not, but ultimately the computer doesn't care.

Finally, `()` is syntactic sugar for NIL. You write `()`, but this is actually read as NIL.",1518688481.0
eql5,"Your are simply too used to imperative programming style... Learn about imperative versus pure functional programming style, that will help!",1518697334.0
basic-gongfu,"Like others said; many functions in Lisp are pure, APPEND is one of them. It doesn't really matter whether you leave the LET-clause empty, specify nil or '(); it's optional and defaults to nil; and '() is just another way of saying nil. Learn to navigate the [HyperSpec](http://www.lispworks.com/documentation/HyperSpec/Front/index.htm), it's an outstanding piece of documentation once you get used to it. For recursive solutions, you'd usually use CONS to build the list in reverse; for iterative solutions PUSH does the same thing while modifying the list in place; and then call NREVERSE on exit. The reason for this is that Lisp's lists are very good at pushing head and rearranging, and suboptimal for most other uses.",1518703932.0
somekindofstranger,"`append` does not change the argument you pass to it; it returns a new list containing all the elements of the lists you give to it. So:

    (let ((x '(1 2 3)))
      (append '(0) x))

will return a new list `(0 1 2 3)`, but it will leave `x` unchanged.

If you want to change `x`, you have to use `setf`/`setq` or the like. Is this an exercise? From what you say I suppose what's really being asked is that you make a function that takes a list and returns a new list with new stuff appended to it or not depending on some condition. You don't have to *change* `x`; you just have to construct a new list. That's how things usually work in functional style: you transform your input data into the output data, rather than modifying it in place. I hope this makes things clearer :)",1518716465.0
dzecniv,"May I ask, are you trying things out in a REPL ? Because you could try and validate bits (append) step by step. In case, Portacle is a ready-to-use Emacs + Slime, cl-repl is new and useful, Lem is a ready-to-use CL editor (it hangs sometimes for me): https://lispcookbook.github.io/cl-cookbook/editor-support.html

also hope this helps: https://lispcookbook.github.io/cl-cookbook/data-structures.html",1518692188.0
Baggers_,Reupload https://youtu.be/MuxSwaPnabw,1518868149.0
defaultxr,"So, I've been trying to make my own game from scratch with cl-sdl2. I discovered recently that by default the rendering is done on the CPU, and thus it's really slow and CPU-intensive. I imagine there's some simple way to offload the rendering onto the GPU instead, but I haven't yet found any information about how to do that online. Is that sort of thing covered in any of your ""Daft 2D Engine"" videos? And could you point me to where, if so? I haven't started watching them yet but I may end up doing that when I have more time. If it matters, I'm not using CEPL; I'm using cl-sdl2, cl-opengl, and cl-cairo2.",1518736406.0
dk_jackdaniel,"McCLIM has bundled SciGraph application (in Apps/ directory), but it is broken in some regards, so that may require some work to bring it to shape.",1518628665.0
dzecniv,"It would be **awesome** if you could write a bit on your experience, your successes, examples of Lisp features you enjoy, how things were simpler than if it had been done in Python… I think the Lisp world lacks this sort of post. ",1518646676.0
can3p,"I'm aware only of gnuplot wrappers unfortunately. What do you use for GUI exactly? Ceramic, McCLIM or both?",1518625383.0
mmontone,"If you use Ceramic you can use any Javascript plotting library, don't you?",1518625702.0
dangerCrushHazard,"Right now I’m implementing a vector–field calculator, I use my program to generate code for PGFPlots to use to graph the data, it’s a little slow but it works.

Perhaps it would interest you?",1521157761.0
dk_jackdaniel,"Here you will find better explanation than reddit comment can provide:

http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html",1518590450.0
flaming_bird,"When a C++ exception is thrown, all your code can do is unwind the stack until you reach the matching `catch` block, at which point execution continues there. Dumb and simple.

----------------------

When a Lisp condition is signaled, the Lisp system does *not* unwind the stack automatically. Instead it searches for the last condition handler established for that condition type (last, meaning dynamic scope - just like dynamic variables, where the last binding established on the stack is the one currently used). 

Every condition handler is a function, and that function may be executed *right where the condition was signaled* or it may may decide to unwind the stack. The latter allows for behaviour like C++ exceptions (see `HANDLER-CASE`), and the former allows to just execute arbitrary code in-place, after which the execution continues after the `SIGNAL` call that signaled the condition (see `HANDLER-BIND`).

----------------------

The second part of the condition system are restarts. They also allow you to run arbitrary code, and can be called any time, though their usefulness is mostly in association with condition handlers. 

Restarts can be bound to various symbols, such as `CONTINUE`, `ABORT`, `RETRY` and so on, and at any point in code, you can get a list of *all* available restarts that have been established on your current stack. This means that you could get, for example, a list of four different `ABORT` restarts, each from a different depth in your code. A simple `(invoke-restart 'abort)` will invoke the last established restart, but nothing prevents your code from analyzing the restart list further and picking any of them to invoke.

Restarts are first-class objects of class `RESTART` and can be invoked programmatically, or - which is much more often in my case - they can be selected a list available in the debugger every time you enter it. They are the objects bound to these `CONTINUE`, `RETRY`, `ABORT`, `ABORT` options visible in the debugger here: https://common-lisp.net/project/mcclim/static/media/it7-cap-2017-debugger.png

----------------------

Now that you've read this very short summary, go and listen to dk_jackdaniel and read the PCL chapter mentioned by him. (:",1518592428.0
stassats,"It's all based on being able to unwind from higher order functions.

Consider a special \*condition-handlers\*, which is an alist for (condition-type . function).
Now, whenever an error is encountered, it searches \*condition-handlers\* for the first matching error type and calls the function. That function now can do anything, return normally and the condition won't be caught and the next \*condition-catchers\* entry will be examined, and so on.

You can also catch the error, which means you have something like (block catch (let ((\*condition-handlers\* (acons 'error (lambda (c) (return-from catch c)) \*condition-handlers\*))) ...)).

Or invoke a restart, restarts are the same, they are functions that are pushed onto a special variable that can unwind/do anything.

Basically, all you need is being able to perform non local control transfers and unwind-protect and you can implement anything on top of that.",1518620118.0
shizzy0,"When I was unlearned in the ways of Lisp and stuck doing Java, I came upon a problem where I desperately wanted a `throwback` keyword. So one can consider conditions are as a generalization of exceptions where they can be thrown up the stack as normal but also thrown back down the stack. ",1518636428.0
sickofthisshit,"First, some pedantic clarification.

Continuations are a very generic tool, able to express just about any kind of control flow. In the basic sense it is ""what the algorithm still has to do.""

Conditions are something else: a classification of certain situations or states of a program or the external environment. ""You are dividing an integer by zero"" is a condition. ""The disk is full"" is a condition. ""A network connection has broken,"" ""this string is not proper UTF-8,"" etc.

What is interesting is how control flow can be modified when more-or-less unexpected conditions arise, outside of the normal control flow. One simple idea is that you provide a different continuation for the computation to cover the exceptional case. But that is very generic and abstract.

To really get into it is different ways in which languages allow programmers to define the alternative control flow, and how different the environment looks in this alternative. C++ exceptions, for instance, put the exceptional continuation at the catch, where the environment is established by the try, and the exceptional case does not have any information left about what the low-level code might have been doing before it threw.

Common Lisp, however, allows you to specify computations which get executed at the point of the exception to determine which continuation gets used, or before the continuation gets executed, and also has separate ways to define and choose the handlers without introducing new continuations.

http://www.nhplace.com/kent/Papers/Exceptional-Situations-1990.html

http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html

One important thing about continuations is whether the language allows them to be ""reified"" and treated as values that can be stored or passed around, and whether they can be called multiple times or just once.",1518755113.0
patrickwonders,Here is me playing with them in 2011: http://nklein.com/2011/03/tutorial-introduction-to-conditions-and-restarts/,1518810326.0
flamingsushi,"Hey /u/Baggers_, any chance the previous streams were recorded?",1518440956.0
dzecniv,"Cool ! On reading:

- ""the lisps have a syntax based on parenthesis"" in the introduction: I wouldn't myself emphasize on the parenthesis, but speak about higher language features (a bit like code/data, that comes after)
- links: the Hyperspec and the (shitty) Cliki as the first two links is a bit arsh, IMO :S No love for http://lisp-lang.org/ ? For the [Cookbook](https://github.com/LispCookbook/cl-cookbook) and https://github.com/CodyReichert/awesome-cl ? :(
- Configuring Quicklisp: no love for https://lispcookbook.github.io/cl-cookbook/getting-started.html ? :D more complete than the QL doc IMO.
- your link to installing Slime gives the instructions to install from source :S there are more solutions, as listed in the ""getting started"" above.
- no love for Portacle ? Lem maybe ? https://lispcookbook.github.io/cl-cookbook/editor-support.html
- I wouldn't say the nEXT browser is totally written in Lisp, it uses bindings to webkit on Linux.
- for a list of project: what about https://github.com/azzamsa/awesome-cl-software ?
- you link to YASWEG, in Guile. What about https://github.com/kingcons/coleslaw ?

In general, I'd like to push towards the Lisp Cookbook… Would you be interested in translating and extending it ? If you write portuguese content that would fit in, tell us, we can link to it, and I can help with translation.
",1518360470.0
ryukinix,For anyone which wish talk through irc instead telegram we have some members at lisp-br@freenode.net,1518373661.0
defunkydrummer,"This is great. Is only Telegram where Brasilian Lispers go? 

I can understand and speak a bit of portuguese, it would be interesting to chat via IRC.",1518325756.0
flaming_bird,"There are several of them, yes - Baggers and Shinmera post their videos here or on /r/Common_Lisp, too.",1518333919.0
defunkydrummer,Livestreaming? I'd be afraid of people watching how I need to go back to the CLHS every 10 lines of code... ;),1518364249.0
dzecniv,"Some are listed here: https://lisp-journey.gitlab.io/resources/ Shinmera's Lisp Treehous (game dev), cbaggers' (openGL, tutorials), McClim demos,…",1518358249.0
stevelosh,"I stream most Tuesdays at 18:30 Eastern US time at http://twitch.tv/stevelosh

Sometimes I stream games, sometimes coding (in Common Lisp). It depends on the week. ",1518367834.0
Shinmera,"Yes. There'll be one today, even: http://events.tymoon.eu/1",1518336864.0
Baggers_,"Some lovely folks here have mentioned by stuff but for the lazy here are the links :)

I stream over [at twitch](https://www.twitch.tv/baggers___) every Wednesday 8pm CET (which is 7pm UTC right now). All recordings can be found [youtube](https://www.youtube.com/playlist?list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS). 

Currently we are making a small 2d engine with a specific code aesthetic ([episode 27](https://www.youtube.com/watch?v=J-tLs60agz4&list=PL2VAYZE_4wRITJBv6saaKouj4sWSG1FcS&index=32&t=2098s) has the details)

Hope to see you there!",1518431915.0
thearthur,I try to promote mentoring in the Clojure space. your idea of livestreaming sounds very interesting. world people actually want to watch? ,1518337796.0
stylewarning,Is there some sort of bar—subjective or objective—that libraries should meet to be on this list? Otherwise it starts to look more and more like manual syndication of Quicklisp libraries.,1518364933.0
defunkydrummer,"I am really excited that this list has had 150 additions in a year. Other people might think it's nothing compared to other ecosystems, but the high quality (in terms of what they bring) of many of the Lisp libraries stands out. ",1518325614.0
,[deleted],1518318264.0
papachan,nice !,1518177497.0
lispm,"You can set the precision for long floats in CLISP like this:

    (SETF (EXT:LONG-FLOAT-DIGITS) 3322)",1518160581.0
stylewarning,SBCL comes with bindings to MPFR. Try (require :sb-mpfr) and check out the package of the same name. ,1518150214.0
trimtab,Computable reals?,1518146404.0
,[deleted],1518148560.0
kazkylheku,"The `,,@expr` combination exhibits a kind of distributive property.

Suppose that `expr` evaluates to the list `(a b c)`.

The `,@expr` belongs to the outer backquote. Under the outer backquote, `expr` is evaluated to `(a b c)` and the `,@` notation wants to splice it.

But the splice is presented as the argument of a comma.  What the heck does it mean to splice something into a the argument of an unquoting comma?

Effectively, the comma **distributes** over the spliced elements. So what is spliced is the list `(,a ,b ,c)`. Or that is the effective behavior.  I.e. we end up with, effectively, the elements `,a ,b ,c` being spliced into the surrounding structure.

We can demonstrate it like this:

    [1]> ``(a b c ,,@(list '(+ 2 2) '(+ 3 3)) e f g)
    (CONS 'A (CONS 'B (CONS 'C (LIST* (+ 2 2) (+ 3 3) '(E F G)))))

It's a double backquote so we need to insert one more round of `eval`:

    [2]> (eval ``(a b c ,,@(list '(+ 2 2) '(+ 3 3)) e f g))
    (A B C 4 6 E F G)

See: it's the same result as this simplified simple backquote, where we have separate comma unquotes for `(+ 2 2)` and `(+ 3 3)`. 

    [3]> `(a b c ,(+ 2 2) ,(+ 3 3) e f g))
    (A B C 4 6 E F G)

Each item from the `(list ...)` expression is separately evaluated and then the resulting evaluated elements are spliced.

Disclaimer: I've only written two production backquote implementations. :)",1518201266.0
death,"Check out [Appendix C of CLtL2](https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node367.html) - it explains how `,,@` can be interpreted.",1518197363.0
basic-gongfu,"You may read the number of commas as the number of back quotes you want to peel off before evaluating the expression. This quickly becomes quite a mess to deal with though, I'd recommend not going much further than this; it's often worth the effort to add a let-binding to get access to the value using a single comma inside the following back quote.",1518169793.0
paulfdietz,"When I write macros like this I never nest the backquote forms.  Instead, I break out the inner backquote into a separate helper function, and call that function in the outer backquote form.  It just seems easier to understand.",1518191722.0
lispm,"Note also that backquoted lists are not a macro-specific feature. You can use them in other contexts, too.",1518184230.0
maufdez,"I like it but ctrl-e in Chrome calls a google search, alt-e does activate the menu, so no key combination does what I was expecting from the editor. I am on windows, as I said using Chrome.",1518116831.0
virtyx,Is it possible to execute JS functions with this?  What's the JSCL equivalent of `alert('Hello world')` or `console.log('Hello world')`?,1518127878.0
dzecniv,The repo: https://github.com/t-cool/jscl-playground,1518132896.0
dangerbird2,Just got around to playing with Cepl. Being able to play around with OpenGL interactively is *super* helpful for my own computer graphics projects.,1518191042.0
borodust,"Hello there! Emacs is a right tool and totally worth learning. I'm a Java dev professionally myself and use IntelliJ IDEA at work, but have no regrets getting into Emacs. It's awesome!

Also, feel free to hop into #lispgames freenode IRC channel where all cool lisp gamedev dudes gather or/and check out lispgames.org.",1517994861.0
dzecniv,"The Cookbook has you covered: https://lispcookbook.github.io/cl-cookbook/editor-support.html

besides Emacs & Vim:

- Portacle is Emacs shipped with everything you need to start right away, no installation needed
- the Atom plugin works but lacks important features (compile this file,… see issues)
- Lem is a CL editor for CL, ready to use, with ncurses and Electron interfaces. It has Emacs keybindings (M-x slime etc)

good luck and have fun !",1517993540.0
JaumeGreen,"Use portacle, as the others say.

Installation is easy, you are set to go. You'll have some minor problems adapting to the strange keyboard combinations, but it will be acceptable. 

To go any other way, as a beginner, would be a fruitless way to spend your time, while you should be advancing on your project. ",1517998845.0
theangeryemacsshibe,"Emacs can be menu operated and can also use standard CUA shortcuts, so it shouldn't be that much of a learning curve. You could always go head in and learn lots about using it efficiently though.",1517997929.0
sammymammy2,"I made this video for Lisp noobs which is supposed to be the absolute bare minimum to get started: https://www.youtube.com/watch?v=4_pzxoVDDdg

Baggers also has very good videos on using Lisp: https://www.youtube.com/watch?v=VnWVu8VVDbI&list=PL2VAYZE_4wRIoHsU5cEBIxCYcbHzy4Ypj


There is a plugin for Atom which is easily found by google :). That plugin is incomplete but may very well be ""good enough""!",1517999939.0
still_a_prodigy,"there really isnt a polished newb friendly IDE out there. i actually saw one that was a WIP, but i forget the name of it. if you're gonna get into lisp, i highly recommend you at least figure out how to run files from the console. ",1518016827.0
WhatImKnownAs,"For a modern GUI IDE, LispWorks can't be beat. [The Personal Edition](http://www.lispworks.com/products/lispworks.html#personal) is free, but comes with limitations. Beyond that, it's not cheap.",1518034091.0
flaming_bird,"The VS plugin does not integrate with the Lisp image and doesn't make it possible to conduct interactive and incremental development with Lisp. This kills one of Lisp's bigger advantages - the ability to work with your program as it lives, compile function by function, use the debugger to help you, use the inspector to help you.

Use an interactive environment, such as slime for emacs or slimv for vim.",1518042686.0
SlightlyCyborg,"Use Spacemacs with Vim keybindings. Ya it is hell of a lot to learn, but it is worth it. Or you can use Porticle like everyone else is saying. It comes with slime. I just like Spacemakes + common-lisp layer",1518051270.0
sgoldkin," If you have a mac, get Clozure CL (it's in the Apple app store and is free). It has its own editor (which is basically emacs) and you won't have to mess with slime or anything else.
(Apparently available for Windows, also:  https://ccl.clozure.com/)",1518138064.0
defunkydrummer,">and wanted to know if any of you have experience with LISP plug-ins for Visual Studio

I like Visual Studio a *lot* for C#, but believe me if I say that you can be as productive, and even more productive, by using Emacs+SLIME for Lisp development. Try Portacle. 

>LISP

Note that nowadays ""Lisp"" is the preferred way. Lisp = List Processing.",1518008994.0
mtelesha,Dr Racket was made 100% for this reason. Look at that https://racket-lang.org/,1518020981.0
PuercoPop,Even though PAIP has the appeareance of a dense book it is written in an extremely clear way. It is very approchable. You dont need any stepping stones. Go for it! You wont regret it. It is a masterpiece.,1517972483.0
lispm,"To get into some basics of the language, I would recommend Touretzky / Gentle Introduction book. With a bit wider scope there is ANSI Common Lisp by Paul Graham. Reading one of this might help to get familiar with some basics of the language - which is different from Scheme. I would also propose to do some of the exercises, to get practical exposure to writing/reading code.

PAIP can then be a next step, especially you then should have written some code, have set up your own development environment and be familiar with basics of using it.",1517989198.0
phalp,"Are you an experienced programmer in any language? If so you'll be fine with PAIP. But what's your purpose? These days, PAIP is best treated as a Lisp textbook, or a book of case studies in Lisp. *Artificial Intelligence: A Modern Approach* is more what you (or at least I) would expect from an AI textbook. So choose on that basis.",1517969877.0
mr_luc,"PAIP is one of the clearest, best-written, hand-holding, guided-tour programming books out there.

There are some chapters in there that cover extremely niche types of programs that may tax your attention span more than others -- ""let's sketch how you would implement a MACSYMA"" ... -- but even those denser, more specific chapters are no threat if you're willing to install a CL.

And, for my money ... ""On Lisp"" is a great one. On Lisp and PAIP are, IMO, the most pleasant ways to get into Lisp for people who like to read.",1517974284.0
defunkydrummer,"Welcome to Lisp!

I'd recommend Practical Common Lisp as a stepping stone before PAIP, just to get more familiar with the language.",1518009411.0
rpiirp,"I've been asking myself the same question. Everyone recommends Peter Seibel's book, but while it seems solid and useful, glancing through I find it not very exiting. PAIP and ""On Lisp"" have way cooler examples, but are they suitable as a first book about Lisp?",1517977019.0
still_a_prodigy,i don't think the leap from scheme to CL is going to be significant at all. especially if you're just using norvig's book. getting comfortable with recursion is the most important thing. and you're already doing that. what you're learning in the little schemer applies to all programming.,1518016151.0
meta-axiom,"I don't have that much cognitive resources so just reading a dense PAIP will not make me totally understand the book, it will only make me tired along the way. Instead, I experiment directly to the [PAIP's source code](http://www.norvig.com/paip/README.html) and try to relate to story of the code by optimizing it or making it more complex (time consuming but is far more rewarding). For me, the best Lisp book that is totally worth reading to really understand Lisp, functional programming, and programming in general is [SICP](https://mitpress.mit.edu/sicp/full-text/book/book.html) (SICP is written in Scheme and it's free).",1518119525.0
,"Wired called PAIP ""the best Computer book ever written"". Don't drop it on your foot, though. ",1518421994.0
timezone_bot,"7pm UTC happens when this comment is 19 hours and 47 minutes old.

You can find the live countdown here: https://countle.com/uEkq134373

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1517958765.0
KDallas_Multipass,"Ahh this old cruft.  Maybe I should get around to writing a blog post about this.
The ""not a valid win32 application"" is due to wrong bitness, likely a 32bit implementation loading a 64 bit dll.
Other gotchas mostly stem around confusion about where to put system libraries so that they can be found.  On a 64 bit system, 32 bit libs go in c:\sysWOW64 (right? its where a 64 bit implementation stores 32 bit libs for 32 bit programs) while system32 is reserved for 64 bit libs.
Also, dlls sometimes depend on other dlls.  An error can occur if dependent dlls are not in the dll load path, even if they are all in CFFI foreign library directories.  Once CFFI makes the first dllopen call, the system will take care of loading dependents and doesn't know about other cffi library directories.  If you can figure out the right order, you can CFFI load them yourself, or place all libs in a system-searchable location.

~~So to sum up~~ I first try putting all the libraries I want to use in a folder in my lisp project, adding that pathname to cffi:foreign-library-directories, then quickload their lisp bindings.  If I have to resolve dependent dll calls myself, I'll figure out the order and issue my own cffi:load-library calls.  I do it this way so that I know exactly what dlls I need to collect to ship if I want to build a standalone executable.  Usually when developing, I don't want to copy all the dlls into the directory of the currently running lisp image, but at deploy time, that would alleviate the need to modify 

    cffi:*foreign-library-directories*

If someone knows a better way of managing this I'm all ears.",1517891099.0
maufdez,"Try placing the dll in the directory where your project resides, that had worked in the past for me, and if you are using emacs/slime, in the REPL type ,cd and write your directory in the mini buffer. Also, in the case of sqlite3 I advise to install it, you can do it using [chocolatey](https://chocolatey.org/) to make it easier on yourself. Also as you mentioned you need the correct DLL (32 or 64) and it has to be named as expected by the application. Since you are starting I would not expect you to debug this, but if the problem persists file a bug.",1517879904.0
defunkydrummer,">To me, prefixing accessors with a . makes sense.

To me it does not make sense. What it does make sense is to keep the syntax as plain s-expressions made with very little special symbols, so macros can manipulate source code easily and powerfully. 

>doesn't the clutter up the namespace with generic fn's like name, desc, etc...

It doesn't ""clutter up the namespace"" because classes (and slots) have their own namespace (inside your namespace). They don't conflict with function names or symbol names. Accesors (not slots) are methods. Do they clutter the namespace? No, because of multiple-dispatch/multimethods:

If I define class A with accesor ""my-accesor"", then I can also define class B with accesor named ""my-accesor"". There is no conflict (or ""namespace clutter"") because when you call (my-accesor) you need to give it the *object* you want to use, and CLOS will automatically *dispatch* to the correct accesor, depending on the class of the object.

Thus, no clutter. Moreover, Common Lisp has separate namespaces for: keywords, symbols, packages, classes, slots, and functions. They can't conflict. Thus, inside a package, you can name such things as you wish, fearlessly.  Example:

    (defpackage cyborg (:use :cl))       
    (in-package :cyborg)

    (defclass cyborg (standard-object)        
      ((cyborg :initform ""YO CYBORG"") ))   

    (defun cyborg (cyborg)      
      (format T ""Cyborg slot value is: ~A~%"" (slot-value cyborg 'cyborg)))

    (defparameter                    
        *cyborg* (make-instance 'cyborg))

    (cyborg *cyborg*)

No conflicts at all.

>It looks like clojure

Why should Common Lisp look like Clojure? Clojure has been around for quite a long time and so far it hasn't convinced Lisp (or Scheme) users to adopt the same syntax. They could (because, as you know, Common Lisp has reader macros), but this hasn't happened. The reasons have been explained in forums many times. 

Common Lisp is not Clojure; they are very different. For example, CLOS, as an object system, is far more flexible. 

",1517852096.0
kazkylheku,"Cargo Cult alert!

In languages that have dot access, the dot isn't simply part of the name.

Simulating dot access by adding it to the slot name is silly.

The idea is that somehow if you just simply exhibit the ASCII period in the code, the *benefit*  of a dot notation will somehow materialize.

This falls under ""cargo cult programming"".

To avoid cluttering namespaces 1) use packages, 2) don't define accessors or read methods for all slots.

Avoid OOP designs in which everything is being done with trivial access mechanisms. (Or even ""beefed up"" access mechanisms with :before/:after/:around methods).

A method specialized to some class(es) need not resort to accessors to get to the slots of the objects it is working with; it can use `with-slots`.",1517859215.0
chebertapps,"The problem comes down to: you either need a naming-convention for your constructors or for your accessors. In CL, the style is to have constructors be called `(make-foo ...)`. 

This way you can have accessors be called `foo`:  `(defclass bar ... (foo :accessor foo))`. 

An alternative is to have your accessors be `.foo`, then you can have constructors like `(foo ...)`.

The answer to the question lies in which function/method is most likely to change. 

- Is a constructor likely to be changed something other than a constructor? e.g. `(make-foo ...)` does something other than make a foo object. If it does, then the symbol `make-foo` is no longer appropriate, because it no longer constructs an object of type `foo`.

- Is a slot likely to be changed into not a slot? e.g. `(.foo ...)` does something other than access a slot of a class? If it does the symbol `.foo` is no longer appropriate, because `.foo` does not access an object's slots.

To me it seems likely that `(foo ...)` could easily be changed from reading a slot on a class to performing a calculation. It seems possible, but less likely that `(make-foo ...)` would be changed to do anything but construct a foo. 

Aside:
I actually tried doing things this way, and I feel as though doing it was NOT worth having more concise constructor names.

TLDR:
accessors and constructors cannot have the same name, so one needs to adopt a naming convention.
accessors are more likely to change behavior than constructors, so give them more flexible names.
",1517862482.0
dk_jackdaniel,"It is bad for two reasons:

1) some implementations (i.e Allegro CL) have hierarchical packages[1] and symbol name `.foo` is ambigous with package accessor

2) given we adhere to the principle that we don't know anything about objects (we know only their protocol), having a separate convention for accessors is wrong - because knowing that something is an accessor (not i.e function defined with defun or other generic function) violates this principle. Having this principle adhered to allows you to switch implementation in the future when you get rid of the slot – your software clients won't notice.

[1] https://franz.com/support/tech_corner/hierpackuser.lhtml",1517858404.0
flaming_bird,"> and it doesn't the clutter up the namespace with generic fn's

Of course it does. You need to intern a symbol for the accessor anyway, and Lisp does not care if its name is `FOO` or `.FOO`.",1517854923.0
phalp,"I wouldn't do this, but I'm sympathetic to the feeling that an accessor called NAME isn't great. It's just a symptom of the fact that accessors in CLOS aren't scoped to the object, but to the package, making one feel that the name of the function should be meaningful within the context of the whole package.

In Java or C++, the implication of a method call is that most objects do not understand the message, and if they have a method of the same name it's likely to mean something different. Prepending a dot to CL accessors is intended to convey the same understanding, that the method has limited applicability.

However, consider this: you're writing the accessor's name as a literal in the code, meaning you know the class or superclass of the object in question. If the accessor applies only to one class, think about why exactly generic functions are involved. Would a struct have been more appropriate and saved you some typing? Or, if you've got a family of objects FOO, a naming convention like FOO-NAME becomes reasonable--it might have seemed silly if there was only one kind of FOO, but when an object may be a FOO and a BAR as well, it's totally logical to have a FOO-NAME and a BAR-NAME accessor floating around.

Take a moment to think about generic functions in the classic OO understanding, as messages. Some OO practices have reinterpreted methods as buttons and knobs on the surface of the object. But the original idea was that objects would receive messages, and respond to them according to their methods, more like stuffing a letter in a mail slot than turning a knob. In that interpretation, a message is theoretically a first-class object and as such it ought to have a global identity. Several messages taken as a group constitute a protocol, and naturally a protocol exists outside the context of any individual object. If this kind of interpretation doesn't make sense for the object you're writing, I'd begin to suspect that OOP isn't applicable to the design and a struct should be considered.

When generic functions get involved, I'd approach the design from the functionality inward, developing the core of the protocol first and writing the classes after. The FOO in FOO-NAME will refer to the protocol and not to a particular class, so you won't feel uncomfortable about including it. I would treat the :ACCESSOR slot-option (and :READER and :WRITER as well) as a shortcut to use when the protocol turns out to be best implemented with a root class.",1517955445.0
Shinmera,No.,1517850636.0
rosholger,Something similar can be done using macros. It might be heresy but you can create the macros `(: instance slot)` for access and `(:! instance slot new-value)` for setting,1518257851.0
,[deleted],1517872399.0
Shinmera,"I have a weekly gamedev stream where you can watch me code in Lisp called [Treehouse](https://www.youtube.com/playlist?list=PLkDl6Irujx9MtJPRRP5KBH40SGCenztPW).

As for getting started, there's [Portacle](https://portacle.github.io) which should provide you a ready-to-use package. It uses Emacs and Slime, but aside from some different shortcuts for cutting, pasting, and undoing you shouldn't have much trouble, really. Portacle includes a keybinding reference that you can refer to when you get lost, too.

You can obviously just use a terminal and a text editor, but that is such a severely deprived experience that I honestly can't recommend it. If you get over the initial fear of learning a new editor and just commit a week to Emacs you should be able to get yourself settled in and productive enough to hack away to your heart's content.",1517746736.0
bobbane,"You can get by with an editor that is minimally lisp-aware - parentheses matching is vital.

Many people don’t know that vim has had Lisp support since the dawn of time - back when it was vi the command

     :se lisp 

turned paren-matching on and made auto-indenting slightly more Lisp-aware.

You can just use two windows - one for your Lisp REPL, one for your editor, and just copy-paste edited forms between them.

You can get a decent start this way without the hump of mastering emacs.",1517752701.0
Paradiesstaub,"Go with Emacs and SLIME. [Here](https://pastebin.com/H7KBM7Wv) a simple but sufficient Emacs configuration file which will install and configure all needed packages to get you started.

The reason why I think you should use Emacs is, because it uses Lisp itself as configuration language. Most Emacs tutorials are overwhelming, so I try my best to give you a quick start.

Emacs key bindings are written differently, but once you know the notion, its easy. M stands for ""meta"", the `Alt` key. C stands for ""control"", the `Ctrl` key. 

`M-x` means press Alt and x together.  
`C-x b` means press Ctrl and x together, followed by b.

Cursor movement is done with:

    C-f        ; move forward
    C-b        ; move backward
    C-p        ; move up
    C-n        ; move down

Type `C-x C-c` to quit Emacs.  
A file can be open with `C-x C-f` and closed with `C-x k [enter]`.  
To cancel any action type `C-g` (sometimes multiple times).

Sometimes help windows pop-up, navigate with `C-x o` to them and close them by pressing `q` or with `C-x 0` (zero).

For getting help there are a lot of different functions, it took me some while to discover them, but they are very helpful. Move with the cursor above a function and press `C-h f` to get a detailed function description.

There is a similar function to get the description of a variable `C-h v`, can you see the pattern? `C-h` for help, plus an addition for what kind of help.

Some very basic lisp, which is used to configure Emacs:

    (setf inhibit-startup-message t)
    ; setf, a function (set field) which sets a variable to a value
    ; inhibit-startup-message is the variable to be changed
    ; t stands for true
    
Generally speaking Emacs has a lot of structure, once you understand it, it's not difficult to know where to look for something. Ah, and learning the most powerful text-editor in the world can never hurt ;-)",1517756682.0
bjoli,"You can have a decent development experience using a vanilla text editor and a repl. I did it for a while using scheme (and a readline-enabled repl). 

This works well for most smaller scripts, but won't give you the best lisp experience. What I like in Emacs is how simple and fast it is to just evaluate a function definition.

I mostly use guile, and some macro-heavy projects might take some time to compile. Then it is much faster to just change one definition and evaluate it directly than doing the usual script workflow of re-running the whole script.",1517745711.0
paulfdietz,"You don't need to master emacs to use it for Lisp.  Even the most common key commands will be quite adequate, and they are easy to learn.

Compiling of lisp files doesn't need to go through the editor at all.  You should use something like asdf and compile using that.",1517754143.0
,"sublime text, with parinfer and sublimerepl.

Or vim --lisp and tmux with sbcl repl.",1517759254.0
jsjolen,https://www.youtube.com/watch?v=4_pzxoVDDdg,1517751145.0
,"
use your Editor of choice and the repl. it's programming like it's 1976, but at least nothing gets in your way. (I use vim + sbcl + rcs on Linux. That's my IDE. Works great. I'm one happy camper.) 

",1517922974.0
kuemmel234,"If you want to learn lisp there's also racket. It's a great starting point. It has its own editor with a repl and modes for learning. You will have to start with scheme though (which I count as a plus). 

I've coded lisps in my usual programming environments (first sublime text, then vim and now emacs with evil (a vim emulator, if you know vim - try spacemacs)). And just opened a repl alongside or used a script to send code to it (there's a sublime plugin for that called sublimeREPL). There's tools for working with clojure in intellij too, I think.

There's also a pretty nifty short guide in 'Clojure for the brave and true' about working with emacs. It is for free if you want to try it out. ",1517755234.0
furych,"You can try Racket for Scheme. For Common Lisp there is Lispworks Personal, which is free with limitations, and Clozure CL for OSX which comes with editor and repl.",1517760518.0
thearthur,"Clojure + the atom editor will give you must of the good stuff without moving far from the traditional IDE comfort zone.

for my online Clojure course I used intellij and cursive because I didn't want to force emacs on students (yes I think it should eventually be leaned) if I was recording that course again today I'd use atom. 

",1517766908.0
dzecniv,"Hello, 

the Common Lisp Cookbook on github is your friend :) https://lispcookbook.github.io/cl-cookbook/editor-support.html 

Available editors are:

- Emacs, and Portacle mentioned below
- Vim 
- Atom with [Atom-Slime](https://atom.io/packages/atom-slime) (still lacking important features like ""compile this file"")
- Sublime (quite basic with the sublime-repl)
- [Lem](https://github.com/cxxxr/lem) - a Common Lisp Common Lisp editor, ready to use ! An ncurses and an Electron interface. It's ready to use, its keybindings ressembles Emacs though (C-x C-f to open a file, alt-x slime to launch Slime, C-c C-c to compile a function etc)
- [cl-repl](https://github.com/koji-kojiro/cl-repl) is a newish ipython-like CL repl. Very nice, its interactive debugger isn't complete yet though.
- you'll also find links to notebooks

A Slime video tutorial on the link too (and check the author's channel). I also enjoyed [this one](https://www.youtube.com/watch?v=bl8jQ2wRh6k), the guy develops a Slack-like app in CL and ClojureScript.

> I do want the ability to compile executables

https://lispcookbook.github.io/cl-cookbook/scripting.html#building-a-self-contained-executable

ps: https://github.com/CodyReichert/awesome-cl
",1517821568.0
defunkydrummer,">I want to learn lisp, but it seems like I have to learn SLIME and emacs in order to get started.
>is there any reasonable alternative? 

Yes, there are alternatives, but if you install **Portacle**, you will instantaneously have SBCL, Slime, and Emacs all ready to go, and it's a really good environment once you get past the initial weird feeling of using Emacs for the first time. Portacle ""just works"".

>can I use a vanilla text editor and a command line repl? 

Better don't do it. You will be losing time counting parentheses etc. A good Lisp editor (like Emacs) not only allows you to easily work with lisp S-expressions; it also automatically indents code in the best possible way. Not to  mention having syntax highlighting and excellent code completion. All this adds to the experience of using Lisp as a very productive programming language, not just an interesting programming language.

",1517842305.0
Aidenn0,"If you are really tied to another editor, try using that editor, but use SLIME as your REPL.  It's better than any other REPL currently out there, so while you only get a fraction of the power of when you use it also as your editor, it's still a better alternative.

If you create an ASDF system, then ASDF will manage reloading changed files for you automatically, so it's about on par with e.g. using another editor to edit your C++ files and debugging with visual studio.  It's a good way to ""get your feet wet"" without having to lose all your muscle memory from your editor.",1517864452.0
still_a_prodigy,"> can I use a vanilla text editor and a command line repl?

yes. that's what many of us do. 

plenty of us don't use SLIME or emacs. all you need is the same thing you need for any language: something to edit text with and the ability to use the console well enough to tell it to run a lisp file (""sbcl --load filename"" or some shit). the only thing i'd say you absolutely need to have is rainbow parentheses. otherwise you're gonna waste a lot of fucking time with your parentheses. like i honestly started out with Vim and Terminal, and now I use an IDE that I wrote in lisp to write most of my lisp code, because it runs the code as i type. like it's a complete piece of shit that i stumbled across when i was trying to make something else, but it's still years ahead of any ide that doesn't let you code in real time. lisp is not like the other languages. you're learning it because of the sheer power you're going to get by using it. the power to make your own editor, your own anything. ",1517866128.0
,[deleted],1518149437.0
jsjolen,"Specifically Ctrl+c Ctrl+c compiles the current function that your marker is over.

He says that in the video even :-)!",1517699092.0
KoltPenny,"If you like, get my config file and install Slime using melpa, it works a 100% of the time everytime I install Emacs on a new computer.

https://github.com/KoltPenny/Simple-emacs-conf",1519931689.0
ponkanpinoy,"`C-M-x` sends the thing at point to the interpreter. IIRC `C-c C-k` is compile and load file, which obviously sends everything.",1517709315.0
kukujaku,"Since linedit has recently been dropped from quicklisp, it seems like the only alternative is cl-readline. Best of luck finding a maintainer.",1518408075.0
xach,Sorry to hear about Lowell Hawkinson. He gave an entertaining talk at ILC 2010 in Reno about the history of Gensym.,1517507657.0
Daemmerung,"> Even if the project had had more mature leadership, it probably could not have overcome the unfortunate choice of an ALGOL-like syntax and type system, overemphasis on compiled code efficiency, and the obscure choice of first machine to build for [...]. LISP's fundamental strengths were lost in LISP 2's design.",1517517849.0
defunkydrummer,">enhancement: warnings and errors referring to bindings established by LET, LET*, FLET and LABELS point to the offending form more accurately

Nice!",1517417856.0
defunkydrummer,Yay!!,1517289758.0
lisp-is-noice,"Quite interesting.

-1- I am currently checking gsll ? How does it position with Magicl ? both seem to have a link to BLAS and LAPACK. I am guessing that the difference is in the declaration of matrices gsll is based on a sub-package called grid. Your solution is more ""lispy"" isn't it?

-2-  I have tried to work with DASKR (a DAE solver with root finding solutions in Fortran) recently ... but bumped into a personal wall with the call of a second fortran function from a first function called by lisp through cffi (I know not well presented). You mention in your work you fixed bugs in the Fortran parsing ? What does it mean ? Have you heard of DASKR ?

",1517305549.0
Steven1799,"Interesting. Can anyone explain how this is different/better/worse than the existing linear algebra libraries, like:

https://github.com/tpapp/lla

or the others here:

https://www.cliki.net/linear%20algebra

Just wondering why none of those worked and required the creation of another?
",1517560695.0
,Interesting. It looks like this only covers matrices; it'd have been nicer if this would provide something more akin to Numpy.,1517306954.0
fmargaine,Slightly related: I wish we could have real coroutines on CL :(,1517160962.0
stevelosh,"The requirement is:

> the product `a*(b^n)` is unchanged from state to state

You're right that when `n` is even, `a` is unchanged until the final state.  But the other two numbers (`b` and `n`) change, and the value of the product as a whole (`a*(b^n)`) stays the same:

                 b n a        a *   b^n
    (expt-iter   2 8 1)   =   1 *   2^8 = 256
    (expt-iter   4 4 1)   =   1 *   4^4 = 256
    (expt-iter  16 2 1)   =   1 *  16^2 = 256
    (expt-iter 256 1 1)   =   1 * 256^1 = 256
    (expt-iter 256 0 256) = 256 * 256^0 = 256
",1517086043.0
wmblathers,"What are the longer term plans for CLIM-TOS development time? Getting either McCLIM or CLIM-TOS really solid and up to the spec seems nontrivial, and doing both at the same time seems especially difficult.",1517084601.0
wrath_pounder,"Just wanted to give some words of praise regarding this project. The aesthetic is so surprisingly pleasing, and playing with the demos really shows how much more powerful it is than would seem at first glance. Really looking forward to building something with this interface.",1518186063.0
Shinmera,"Please read [What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html). It may be long, but it is really important that you understand this.

Then note that [`*read-default-float-format*`](http://www.lispworks.com/documentation/HyperSpec/Body/v_rd_def.htm#STread-default-float-formatST) is specified to be `single-float` by default. If you need double-precision, suffix your float by `d0` to read it as a `double-float`. But, even then, your floats will be ""changed"" if they cannot be represented exactly. Again, read the above article.",1516971157.0
stereosphere,"When Common Lisp was being developed, there were computers from many different manufacturers with different word sizes and floating point formats. For programs to produce the same results on different architectures, the programmer had to be able to inquire as to the details of the floating point format in use. 
So functions such as integer-decode-float were created. Using this function we can examine the floating point numbers in the region of 37.937045.
(defun list-neighbor-floats (start n)
 (multiple-value-bind (signif expon sign)
     (integer-decode-float start)
   (loop for sig from signif
         for return-float = 
                   (* sign (scale-float (coerce sig 'single-float) expon))
         repeat n
         do
         (format t ""~8d ~12,6f~%"" sig return-float))))

This produces
significand  floating point  
 9944967   37.937040
 9944968   37.937042
 9944969   37.937046 <= the closest float in the region
 9944970   37.937050
 9944971   37.937054

The floating point number is actually exactly 9944969/262144 (#x97bc05/#x40000), or exactly 3.7937046051025390625 in decimal. Every floating point number has an exact decimal representation, but not every decimal has an exact floating point representation, that is because floating point uses only powers of two while decimal uses powers of two and powers of 5. This is unfortunate, as Guy Steele pointed out.
The imprecision that people see in floating point numbers comes from the rounding that must be performed to fit the result in a limited space, not from the individual number.
Floating point numbers are a brilliant engineering device, but they are not really numbers in the mathematical sense. For instance,
(= (expt 2.0 24) (1+ (expt 2.0 24))) => t, from which it follows that 1 = 0, which pretty much causes mathematics to fail. Be careful with floating point!
",1517039642.0
cark,"This is because in common lisp, just like in most other programming languages, floating point numbers are binary encoded. This is a well known shortcoming of floating point numbers.

http://floating-point-gui.de/basic/

The good news is that in common lisp you can do exact arithmetic using ratios. 

http://www.lispworks.com/documentation/lw61/CLHS/Body/t_ratio.htm#ratio",1516971416.0
jsjolen,"CL-USER>  37.937045d0

37.937045d0

CL-USER> (type-of *)

DOUBLE-FLOAT

CL-USER>  37.937045

37.937046

CL-USER> (type-of *)

SINGLE-FLOAT
",1516974390.0
kazkylheku,"Unadorned floating-point tokens becoming single precision floats by default is a really stupid language behavior.

Even C is smart enough to make them double.

Nobody should use single precision float for anything other than saving space in large arrays (e.g. audio samples or whatever).
",1516982029.0
meta-axiom,"Is this universal floating-point arithmetic bug the effects of using base-ten?


I recently read Coders at Work by Peter Seibel and I find this interview with Guy Steele which I think is related to this problem:


> Seibel: So for the people who are reading this book and are going to be
writing some of the software of the future, is there any way to avoid that
stuff? Is there any way we can be smarter? Or is it just the nature of
evolutionary design?


> Steele: Yeah. And not knowing the future. If I could change one thing—this
is going to sound stupid—but if I could go back in time and change one
thing, I might try to interest some early preliterate people in not using their
thumbs when they count. It could have been the standard, and it would have
made a whole lot of things easier in the modern era. On the other hand, we
have learned a lot from the struggle with the incompatibility of base-ten
with powers of two.",1516975863.0
still_a_prodigy,"the real question is why anyone has ever put up with this floating point fucking nonsense in the first place. a computer is a bunch of switches that can represent anything, there's no reason to represent numbers as base 10 to the user and then convert back and forth between binary behind the scenes (BY DEFAULT nonetheless).

to answer your question. you need to do what you have to do any time you're pretending to use numbers in one base, but are actually doing math using numbers with a different base. you need to round the numbers to the precision that you're aiming for. floating point numbers have a limit to how precise they are and this is based on how many switches in the computer you dedicate to each number that you're storing. the reason you can't just convert base 2 to base 10 cleanly when dealing with fractions has to do with the fact that a base 10 system has the primary factors 2 and 5, and the base 2 system only has the primary factor of 2. in short, floating point numbers are retarded. round your numbers after every operation. never fucking invent a language where you pretend to use base 10 numbers even though you arent. ",1517866498.0
bsd_lore,"    CL-USER>  (/ 0.01d0 10d0)
    => 0.001d0",1516973692.0
still_a_prodigy,it took me 10 years to realize that blogs about programming are for the person writing the article. they're the worst fucking explanations in human history. ,1517865174.0
wrath_pounder,"I think there were some very useful tidbits in there that I haven’t seen in other, similar pages. I picked up a couple new concepts reading through. Looking forward to seeing more!

Edit: this is really cool. Forget what I said about similar pages above. Wow.",1518186266.0
eccp,"Since this seems to be C#, maybe a decent option would be F# or even Clojure.NET?

Also, is that a ~400 line lambda function on that screenshot (lines 231-627)?",1516857251.0
finnw,"No good piece of development advice ever contained the phrase ""you should just""",1516878476.0
furych,Lisp doesn't have RX library except of largely abandoned cells.,1516882421.0
patrickwonders,"In case you hadn't figured it out, the weird clamping was hitting the limits on floating point. I believe it is just that there is a great deal more resolution in floating point numbers near 0.0 than there is in ones near 5776573.0. If you had done (mod start-time 2pi).﻿",1518549841.0
kazkylheku,"The old IBM language [PL/I has ""conditions"" rather than exceptions](https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.ceea200/pliax.htm). Handling a condition takes place by searching the dynamic environment for ""on unit"" handlers, without unwinding the stack. These handlers are local functions. I **think** that local function can complete the handling by peforming a `GOTO` to a local label, which will unwind, which is a lot like a Lisp `go` out of a `lambda` into surrounding code.

Thus an ""on unit"" is like a `lambda` under a `handler-bind` binding.  An on-unit can decline the condition simply by returning, just like a `handler-bind` function, or it can perform a non-local exit via `GOTO`, just like a `handler-bind` function could do via `go`; though the usual thing to do is to bail via `invoke-restart`.

I think that throw-catch type control flow was first experimented with in Lisps, so PL/I (like everyone else) would owe its condition handling to Lisp; but then Lisp borrowed back from PL/I.

",1516836753.0
guicho271828,R's error handling system is directly based on CL's condition system.,1516838947.0
kazkylheku,"Beside the now obscure PL/I I already wrote about, there is exception handing system that is in wide use that has frame-bound handlers which intercept exceptions without unwinding. I'm thinking of Win32 SEH: [structured exception handling](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657%28v=vs.85%29.aspx).

SEH has the feature of ""filter expressions"" which are tied to frames. During the search for an exception handler, filter expressions found in stack frames are evaluated without unwinding. These expressions can make use of functions.  Filter expressions can cause the exception to be re-tried at the original place, or they can cause control to end up in the handling frame (such that unwinding takes place there first).",1516865194.0
jsjolen,"Don't quote me on this but I think that Rust was exploring the possibility of having a condition system.

Ping /u/steveklabnik1",1516830833.0
dzecniv,FYI a python library: https://github.com/svetlyak40wt/python-cl-conditions,1516836513.0
DGolden,"[Dylan](https://en.wikipedia.org/wiki/Dylan_\(programming_language\)) was very much not independent of Lisp of course, you probably know about it, but perhaps worth mentioning in context as [it also has conditions](https://opendylan.org/documentation/intro-dylan/conditions.html)
",1516905288.0
,[deleted],1517123930.0
timezone_bot,"7pm UTC happens when this comment is 4 hours and 1 minutes old.

You can find the live countdown here: https://countle.com/__fG126543

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1516719490.0
fisxoj,"I've been trying to get this to work for about the past year. Thanks for bringing it up.

My understanding is that SBCL can be compiled with some option that makes it build a linkable .o file. I'm on a train, so I don't have the correct directory handy, but there's a make file in the dir that ASDF uses for some of those compiler options there, too. It seems distros don't build with that flag enabled and the error we're both getting is because the entry point for the static binary is defined in that missing file. It tries to build an executable without it and ends up with a pile of compiled code with no lisp implementation in it, as best I can reason.

There's a set of patches that were contributed to SBCL a while ago that enable building this artifact, but I haven't successfully built SBCL in a way that produces the sbcl.o file. I think fare may have written the patches to SBCL. That would make sense.

I would love to solve this for deploying lisp webapps as easily as ones written in go, personally. Let me know if you find anything!",1516719130.0
guicho271828,Roswell is recently working on a rather ad-hoc alternative to this problem: `--bundle-shared-object` option for `ros build` will just copy the shared object from the cached result to the current directory. Fukamachi is currently dogfooding the option for his project now.,1516669800.0
KDallas_Multipass,I don't see any documentation for what you're trying to do.  What guide are you following?,1516655215.0
bagtowneast,Looks like homework,1516654834.0
d125q,"It filters `xs`, returning a list containing only those elements for which `f` is non-nil.",1516643195.0
kazkylheku,"What the code does is ... look like shit, making the author look like a moron who can't find a Lisp-aware text editor for proper indentation or follow common Lisp naming conventions.

Functionally, it is basically this:

    (defun thru (fun list) (remove-if-not fun list))

It accumulates a list of those entries of the input `list` for which `fun` yields true.",1516663584.0
xach,Where does the `xs` variable convention come from? It's pretty alien in Lisp.,1516645865.0
ebzzry,Where did you find this?,1516649086.0
,"I signed up just to answer this.

In around 2006 I had this running in Windows 2000 on an old SGI VW540 and VW320. And even then it was long dead, on even more dead hardware.

I remember the news of Izware buying Nichimen.

But like everyone else, we were swayed away from LISP by Python. Around 2004/2005 I succumbed to the comforting embrace of Softimage XSI (and mainwin...). Luckily I left the industry years before the heathens at Autodesk shutdown Softimage.
Just as Mirai originally went silent in the early 2000's, Silo3D and Zbrush came to the rescue for modellers.

Running a whois on izware.com says the domain is finally due to expire in March this year.

Maybe after Greg Minter left around 2008, the new owners took out a 10 year lease. Which is when they went totally silent.

Greg Minter and Bay Raitt have a great write up on some of their research and learning that was applied to Mirai:

* http://www.theminters.com/misc/articles/derived-surfaces/index.htm

Bay Raitt, the front man of Mirai's superior productivity demos, went onto Weta with a new tool under his belt, Zbrush.

I would love to see the source code for Mirai. Probably a proprietary lisp to get it building on NT and IRIX cleanly.

In terms of modelling tools, Wings3D is actually a superior clone of Mirai. That is pretty painful for some people to hear. But the developer did a really good job of cloning and improving the workflow.

I think the fact of the matter is, everyone got older, families and other responsibilities took over as industry requirements dramatically increased; small development teams were no match for the powerhouse of developers that became Autodesk. Many crumbled at their feet through acquisitions. The same goes for Adobe. Between them they sucked up all digital creation suites of worth into their portfolios.",1516630679.0
defmacro-jam,Try it.  Let us know.,1516582364.0
furych,"""for teaching #Lisp written in #Javascript."" Apparently lisp is not enough language to write a tool for teaching lisp in lisp :p",1516604694.0
BusFactor1Inc,AMA,1516591854.0
dzecniv,"FYI Series' documentation has been ported to a github wiki: https://github.com/tokenrove/series/wiki

(nice article)",1516533897.0
WhatImKnownAs,"Looking at those timings, it seems to me you're testing interpreted code here (even the second test, for `sum-squares-loop2`, allocates almost 60 MB, but the code allocates nothing). Since the calculations are trivial, you're mostly measuring macroexpansion (and creation of interpreted function objects for the functional ones) plus some list traversal.",1516543153.0
furych,"Since I've written this article, I'm curious what others think about the SERIES package. Why it is not widely adopted? I can see a lot of usages of the Iterate but none of this library, which is obliviously well documented and tested.",1516476352.0
Baggers_,"Interfacing with c++ is a real pain for most languages (unless maybe you compile via the same toolchain e.g. llvm). You have to extern everyhting you need and then work against that. It seems hard to do thoroughly and get a result that's nice to work with.

The c++ enthusiasts I've talked to had some feelings that I feel familiar with from lisp. The main one being: having a language that trusts you to do things, even though you can shoot your feet off. The element of control both languages give are ace.

> Context: frequent lisper & not very confident c++ coder",1516371668.0
Aidenn0,"I have experience in both C++ and Common Lisp.  I don't find them particularly complementary, as there is a large overlap in their target problems.

Lisp has much more ergonomic metaprogramming, and C++ gives the programmer explicit control over allocation.

I will also point out that modern C++ puts a very heavy burden on library writers; I've implemented a container in C++ that provides some of the interfaces that STL does.  There is a *huge* amount of code to back that, even though I used template metaprogramming to reduce that.

The upside is that all the tools are there to make a very ergonomic library, that looks just like anything that is builtin (an advantage it shares with lisp).  The downside is that it's easily 10x as much code to write that library.

From my point of view C++ is really only a win over lisp when you either care about latency at the millisecond level (where GC hurts you), or are in a resource constrained environment (SBCL really wants ~100MB of ram for a typical application; there are implementations that can use far less ram, but they tend to be much less performant than SBCL).",1516390266.0
chebertapps,"For me personally, the C part is fine. It's easy enough to have an FFI that binds to the simpler parts of C (definitions and functions, but not callbacks so much). If you have a C interface to C++ code (using extern ""C"" {}) that works fine, too. But that means writing your own wrapper.

When you start to use the higher level features of C++, which weren't a part of C, I think you'll find that CL does a much better job. Things like generic programming (templates), polymorphism (objects and classes), and domain specific languages all end up being much simpler and more powerful in CL. 

C can do things that CL can't, so it can make sense to use both. You may need libs from C++, which means making C wrappers. That isn't always straightforward. I believe /u/Shinmera has experience doing this with [QTools](https://github.com/Shinmera/qtools#qt-1), and it doesn't look very fun.",1516382574.0
KDallas_Multipass,"C++'s magic sauce is parametric template types.  This produces the biggest win for numeric, computation heavy code (so they say).  Thats it.  Every other part of the language is a dumpster fire.

As for C++ and Lisp, if you want to know the messiest details, head over to #clasp on freenode and lurk for a while, where someone is writing an implementation of lisp? that can be compiled with llvm and take advantage of c++ libraries.  Basically he has to write his own implementation of c++ to make it all work.

Source: Confident in my subset of C++ (C with classes, building/linking, method dispatch, some templating), lisper for 4 years.",1516397614.0
anaerobic_lifeform,"I have some hopes about clasp, but I haven't yet found the time to really test it:
 https://github.com/drmeister/clasp",1516395500.0
defunkydrummer,">I have already decided that my 2 langs of expertise will be C++ and CL and nothing will really change my mind on that.

Why C++ and not C?
",1516413081.0
Shinmera,I try to steer clear of C++ as much as I can.,1516372595.0
melevy,"In short, CL sets me free while C++ gives me cancer. Source: I used both among others for more than a decade.",1516385201.0
Heinemenusch,"I think C++ is possibly the most badly designed programming language there has ever been.

It has all of the disadvantages of both C and Java and literally none of the advantages.

It's worthless as a low level programming language, it doesn't have global garbage collection, and it has a bazillion different ways of doing the same thing and I doubt there's a single person in the world who knows them all.

C let's you shoot yourself in the foot, C++ encourages you to blow your whole leg off.

It's difficult to even see what's its niche: if you want to write efficient, fast, code directly to the metal you use C. If you want to use lots of outsourced developers to create a web site, you use Java. What's C++ good for? Like War: absolutely nothing.

It was a written as a language that was easy for compiler writers and hard for programmers: guess which there are more of.

A long time ago, before even the STL, I wrote that I had heard Stroustrup regretted C++. He responded to say he didn't. But I think he absolutely owes everyone an apology for that abomination.",1516372647.0
,"I wrote a C wrapper for ClanLib and another for Gamebryo (both C++ game libraries) and could use them in Corman Common Lisp with that implementation's DLL support and FFI. Large numbers of small object allocations (e.g. collision contact tuples) killed performance, making it have 100ms frames in momentary intervals. I'm sure that's changed, but not completely. Even in pure C++ land these days, my own game engine requires specific memory management strategies for large numbers of small objects per frame in order to keep framerate smooth. Cache coherency isn't a thing I would even want to ponder for long in a lisp. In C++, it is doable. It has two orders of magnitude of gains for well formatted data and justifies the use of C/C++ in a large lisp system.",1517350882.0
JimH10,What am I reading?,1516275633.0
Wintergreen762,Why C? Because you don't hate yourself *enough*,1516284466.0
ryukinix,Great! We need more games written in Lisp :),1516315530.0
ws-ilazki,"In addition to the other suggestions, how about [Ferret](https://ferret-lang.org/)?  Clojure-inspired, compiles to C++11, runs on very limited memory and you can control [memory management](https://ferret-lang.org/#sec-4-2) (garbage collection, reference counting, memory pooling) to get the behaviour you want if you have tight memory constraints or need to avoid GC pauses at all costs.",1516234168.0
dk_jackdaniel,"http://ulisp.com/ and https://github.com/ryansuchocki/microscheme may be worth trying.

edit: link fixed, thanks",1516210285.0
chuchana,"What do you mean by modern?

Could [Hedgehog](https://github.com/sbp/hedgehog) be of interest to you ?",1516209253.0
existentialwalri,https://picolisp.com/wiki/?embedded maybe,1516213852.0
beeff,[Armpit Scheme](http://armpit.sourceforge.net/),1516232934.0
jaoswald,"How big is your ""microcontroller""? That term can range from an 8-bit PIC to an embedded 32-bit ARM processor.

Also, do you really mean ""bytecode"" or do you mean native machine code?

Personally, I have been intrigued by low-level Lisp-like expressions of assembly code like [Henry Baker's COMFY](http://josephoswald.nfshost.com/comfy/summary.html)

But, frankly speaking, machines powerful enough to support garbage-collected symbolic languages are tedious to program at the assembly level, and machines small enough to want to program at bare metal are too small to support real Lisp. Unless you have some novel metaprogramming to do, Lisp is probably not advantageous.

Before people mention the Lisp machines, the OS was programmed in Lisp because the implementors were Lisp programmers writing for other Lisp programmers. Not because Lisp was inherently good for low-level programming.",1516286133.0
IL71,"Congrats. It means you're learning something, not just reading. I found and fixed several bugs in PAIP and LOL books code :)",1516208968.0
bobbane,"That does look odd to me.  I suspect he really meant to use map-into:

     (map-into
          (make-array *monster-num*)
          (lambda (x)
               (funcall (nth (random (length *monster-builders*))
                                     *monster-builders*))))",1516203003.0
tangus,"Apparently it's using that array only for its length. Maybe he wanted to do something like

    (let ((arr (make-array *monster-num*)))
      (setf *monsters* (map-into arr (lambda (x) ...) arr)))",1516203635.0
maufdez,"I think this should work you use map and tell it the type of the list is a vector, then it makes an array of size *monster-num* and uses the lambda function to funcall a random builder from a predetermined list, this assigns the result of running the builder to each element in the vector.
If you run:

    (map 'vector #'(lambda (x) 5) (make-array 10))

you get 10 fives which is a simpler version of that code in the question. It is perhaps not the clearest of idioms, but it should work.",1516214227.0
beeff,"Your point is about performance, while it should be about if the code is the most clear and specific way of writing down the problem. The argument for e.g. using an explicit loop should be one of clarity first and foremost. Try it with a loop macro and see if that code looks more clear to you.

Only THEN check for performance. Optimizing compilers can be really surprising, it is hard to predict what is going to be optimized away or not.

Case in point, it does not appear that the above map is creating a vector with SBCL. Taking a quick look at the disassembly of #'init-monsters (sbcl and optimize 3), I only see the array being allocated and map is transformed into a simple loop.

Traversal rules indeed state that the array passed to map cannot be modified, but do not assume that a compiler does not optimize it when it can determine that the side effect cannot be observed. 

1. make it work
2. make it nice
3. make it fast",1516230155.0
Aidenn0,"There are not well-established practices for this; if you want to use a autoconf script, I would say that's fine.  If you can get it to output a lisp file that assigns a bunch of parameters, then you can just load that file as part of your build process.",1516125440.0
kazkylheku,"This depends a lot on what kind of audience this is for: are the users complete neophytes, or can they fix environment variables such as `PATH`?

Also, what platform: are we talking about Windows, where utilities could come from several third party sources. Git Bash from here, GNU tar from there and whatnot.

In a sane Unix-like environment, either the utility you need is in the `PATH`, or else you can pretty much assume it's missing.

> *This library factorises common patterns for external program interaction and eases the production of command-lines for some utilities*

Would this be useful to someone who can't get those wrapped utils to show up in `PATH`?

Let's suppose the worst case: the utilities are all in separate paths somewhere. Then we need some UI to configure them. The installer will find as many utilities as it can by searching through `PATH` and populate the config.  If any are not found, then a dialog box shows up ""some utilities were not found; they may be missing or not in your PATH. Here is how you go into the config menu ..."".

In the config menu, you have some UI where for each supported utility, the user can browse where it is and set it up. (Similarly to selecting programs for handling file types.)  `tar` is this, `git` is that and so on.   The utilities which don't have a configured location are clearly flagged somehow.

Thing is, the user might not even care about all the utilities. Say the user wants your `git` wrapping functionality but doesn't care about `tar`.  Then even though the installer didn't find `tar`, and so the installation is borked as far as `tar` goes, that user doesn't care; they won't step on that problem.",1516155045.0
djeis97,Woo!,1516124625.0
piotr404,Yeeeah ! The gang is back !,1516006017.0
add_entropy,"Yay, I'm hoping to be able to come along!",1516013626.0
jacobb11,"Note that this is an O(n^2) algorithm.  It can be implemented by an O(n) algorithm.

(As/u/chebertapps suggests, I assume join is equivalent to Common Lisp's append.)",1515955294.0
chebertapps,"I'm guessing `join` combines two lists like:

    (join '(1 2) '(3 4)) ; => (1 2 3 4)

`rev` is a recursive function. try expanding  for smaller test case.

    (rev '()) ; => ()
    (rev '(1)) ; => (1)
    (rev '(1 2)) ; => (join (rev '(2)) (cons 1 nil)) => (2 1)
    (rev '(1 2 3)) ; => (join (rev '(2 3)) (cons 1 nil)) => (join '(3 2) '(1)) => '(3 2 1)

so `rev` breaks the list into two pieces: the first element and the rest. the rest gets reversed (using `rev`), and joined with a list of just the first element.",1515954319.0
Azulien,"Not iteration, recursion. I haven't touched Lisp in a long time, so the following might be completely wrong, but here goes! Stepping through:

- Check if the rest of ""xs"" is empty. 
- If it is, give me ""xs"" (which should only contain 1 thing, because the rest of it is empty).
- If it's not, give me the join of running the rev program, passing in the rest of xs, and the first element from xs.

Taking '(3 2 1) as an example:

1. Is (rest '(3 2 1)) null? Nope, it's (2 1). Go to join, get told to run rev on (2 1).
2. OK, is (rest '(2 1)) null? Nope, it's (1). Go to join, get told to run rev on (1)
3. OK, is (rest '(1)) null? Yup! Return (1)

Now that the program is done recursing, it has to complete the steps it ""put off"" until now. Essentially, we interrupted the 'join' function with recursion, and now we need to return to them and finish them, *but in reverse order.* Each time we hit the function, 'xs' is also different: The first pass it was (3 2 1), the second pass (2 1), and the final pass just (1).

The remainder:

1. OK, so now I want to (join (1) and (first (2 1))). I'll return (1 2).
2. OK, so now I want to (join (1 2) and (first (3 2 1))). I'll return (1 2 3).
3. I'm done!

As far as I understand it, the (join x (cons (y))) ensures we are joining lists, and not trying to join a list to uh... not-a-list.",1515964217.0
xach,Bundling third-party libraries with your project is a pretty old-fashioned way to manage things. What prompts the desire in your case?,1515935213.0
azimuth,"You want a `:module`.

Check this out: https://github.com/dlowe-net/local-time/blob/master/local-time.asd",1515933635.0
wellsford-lisp,Have you read this https://common-lisp.net/project/asdf/asdf.html#Controlling-where-ASDF-searches-for-systems ?,1515913378.0
flaming_bird,"Slightly unrelated: Quicklisp searches for ASD files at every startup and at every `#'ql:quickload`, but skips project subdirectories during this search. To make it perform a fully recursive search, use `(ql:register-local-projects)`.",1515916575.0
dzecniv,"Are you looking for Qlot ? https://github.com/fukamachi/qlot a tool to keep dependencies locally in a project (à la python pip or ruby bundler). Also [Qi](https://github.com/CodyReichert/qi) (newer, to be tested) and for the record, [lpm](https://github.com/asciian/lpm) (in development, buggy).",1515976203.0
theangeryemacsshibe,"Eww, that data mine? No thanks.",1515827671.0
reddit_clone,"Would love to..
But Facebook? Sorry!",1515848322.0
,[deleted],1515894581.0
Star_Rat,You sell Emacs on AppStore? Really?,1515956007.0
yhsvghnrOruGnpverzN,"Like others, there is zero possibility of me making a fb account without a firearm at my head.  I've thought maybe I will look into mastodon, but probably not.  Socnets are terrible all around for many reasons.",1515879051.0
BusFactor1Inc,"To those that won't take the course because it's on the Facebook:

1) are you concerned about the information you give when you post?
2) are you concerned about 'background information leakage' (cookies, link clicks, etc)

I see the most vocal opponents have no problem with knowing how much information they release when they are posting in forums, but I thought I would ask.",1515883742.0
cg84,archive.org has it. Here's the latest snapshot I could find: https://web.archive.org/web/20120106121645/http://wiki.alu.org/The_Road_To_Lisp_Survey,1515782669.0
one_zer,"Probably in the same place as the [""State of the CL Ecosystem 2016, 2017, and 2018""](http://borretti.me/article/common-lisp-sotu-2015)",1515869518.0
lisp-student,"I loved those pages. If you need help bringing them back, let me know.",1515850872.0
Shinmera,"The opening parenthesis is a terminating macro character. Thus, the first token is simply the symbol `A`. See [CLHS 2.2](http://www.lispworks.com/documentation/HyperSpec/Body/02_b.htm).

I can't make heads or tails of why you think this behaviour is unintuitive in any way. The only choice the reader has is to read one token at a time. Should `A(1 + 2)` then be read as a single symbol with the name `""A(1 + 2)""`? That would be very strange. If not that, then what in the world should be happening instead?

From the samples you posted you seem to be under the impression that Lisp should somehow support completely alternate ALGOL-like expression syntax. That is not the case. The reader is made for Lisp syntax, which enforces very clear and uniform rules about how things are structured. Function calls must be encased in parenthesis and there are no infix expressions. Thus your example can only be valid Lisp code if structured as `(a (+ 1 2))`, which the reader will parse as expected.",1515571106.0
flaming_bird,"`READ-FROM-STRING` reads a single complete Lisp form from the input. If you read from string ""A B C D"" then only A will be read. If you read from string

    (A
     B
     C
     D)

then `(A B C D)` will be read. If you read from string ""(foo)(bar)"" then `(FOO)` will be read.

The remainder of the string is just ignored.",1515574578.0
kazkylheku,"`a(1 + 2)` is character syntax denoting the same two objects in the same order as `a (1 + 2)`.

Thus you have to accept the same output as the one which looked ""OK"" for  `a (1 + 2)`.

Otherwise you're proposing that the reader should produce different results for instances of (standard) syntax which are documented as equivalent.

Note that no single object will print as `A(1 + 2)`. So even if we customize the Lisp reader with a custom read table to treat `a(` differently from `a (`, that will not get us `read-from-string` returning something which prints as `A(1 + 2)`. 
",1515621783.0
theangeryemacsshibe,There's a reader macro for that. (read-with-handwriting :type :calligraphic),1515536497.0
Slxe,"I need this as a monospaced font, it's gorgeous! ",1515536576.0
defunkydrummer,"Looks like somebody rendered McCLIM out to a printer...

https://common-lisp.net/project/mcclim/static/media/screenshots/7G9BTn9.png
",1515561765.0
,[deleted],1515538776.0
blue-dog-blues,"Okay.  Just got this running about an hour ago.  Some feedback:

1) For newbs on Debian 9, some quickstart instructions:

* Assumptions: you have installed sbcl, debian9 and quicklisp already.
* Install libwebkit2gtk
* Clone: https://github.com/nEXT-Browser/cl-webkit to a path within your local-projects. (~/quicklisp/local-projects/cl-webkit)
* Git clone nEXT: https://github.com/nEXT-Browser/nEXT.git
* Start SBCL: sbcl
* In sbcl: (require :asdf)
* In sbcl: (asdf:load-asd ""/full/path/to/next.asd"")
* In sbcl: (ql:quickload :next/gtk)
* In sbcl: (next:start)

All of the above are in the download instructions, this is just some shorthand to help newbs get it started.

2) In the 1 hour that I have used this, I have learned most of the shortcuts already.  I use Conkeror as my primary browser and switching over to this in an hour or less has been trivial.

3) I don't have a full handle of what about this is Alpha.  There are things that are glitchy but given that you are using an existing toolkit + render engine, the full experience is already there.  Realistically, this has most of Conkerors core features and then a whole bunch of new features that don't exist in Conkeror.

4) I am going to be trying to use this browser more and more over the next couple of weeks to understand the user experience.

Overall, I cannot say enough good things about this project.  I have been waiting for a lisp based browser for a long time.  This, in some sense, is very usable already.  The amount of features available is tremendous and as of now, if some polish and shine can be applied to the rough edges here and there switching to this from Conkeror full time seems plausible.  In particular you have taken the development of this project with a very pragmatic approach and it is very much appreciated that it is available on Linux now.

For a single dev project, this is remarkable work. 

Congrats. I and many others really appreciate it.  I hope to start adding to the project via feedback to start and then by writing extensions and tools and so forth.

Great work.",1515690247.0
Gosun,While very cool (I commented on the sister thread over on /r/programming) I agree with the other posters about needing to change the branding as it is too close to Apple's old product.,1515581542.0
blue-dog-blues,"Hi jmercouris.

I just managed to get this running on linux.  This is looking amazing.  Can't wait to move over to this from Conkeror.

",1515686868.0
tarballs_are_good,"I long for pkhuong’s solution being made robust. Vectors and functions are so heavy-handed. It would be nice if it actually compiled to computed offsets and jumps. 

Unfortunately that solution requires compiler support. Paul adds another AST node, IIRC. 

",1515534100.0
ruricolist,"Are you using any special parameters to SBCL to get this file to compile? It exhausts the heap on my machine.

I think there's one other approach you've missed: building a tree out of integer ranges (with <, rather than with logbitp). I first came across this technique [here](http://www.foldr.org/~michaelw/log/programming/lisp/icfp-contest-2006-vm). Also I think Strandh uses something similar in his paper on optimized generic function dispatch, and makes an argument for why it is optimal for modern processors. And I have my own version in Serapeum, as [tree-case](https://github.com/TBRSS/serapeum/blob/master/tree-case.lisp). On my machine at least it's about twice as fast as fcase7.",1515521583.0
xach,"Some prose would help me understand this, I think.",1515505804.0
paulfdietz,I'd like to see timing for a generic function with a bunch of methods discriminating on that argument with EQL parameter specifiers.  You'd want to prime the method dispatch table first by calling each method before you timed it.,1515507535.0
defunkydrummer,Nice! Will it also have java interop? ,1515425511.0
defunkydrummer,"This is exactly what I wanted to implement someday!!  C with a **true** macro system. 

Excellent idea, and it would be even more awesome if the compilation steps could be done within lisp (i.e. from the REPL). 

And it would be *(expt awesome 2)* if it had a way to define some C functions to be called later from CFFI so at the end one could have:

- write C in s-expression syntax
- compile within Lisp (using GCC, etc)
- call some of those C functions within Common Lisp using CFFI.


",1515166673.0
zodmaner,"C-Mera is great.

I used it to generate C code from Common Lisp, as well as writing a simple ""compiler"" that translates JSON-like syntax into C++ code.",1515196315.0
MCHerb,"I kind of wish there was a target for PHP since that's what I hate working with the most, though my co-workers wouldn't see the point of using it.",1515191312.0
xach,"FYI, `(floor (/ x y))` is equivalent to `(floor x y)`. Same with ceiling.",1515166742.0
bsd_lore,"I was looking for some Advent of Code 2017 solved using Common Lisp, this seems like a nice collection. (I am not the author.)",1515070158.0
defunkydrummer,I witnessed the power of Loop... interesting. ,1515074527.0
Baggers_,"As far as I can see the options are:

1. qualify the symbols
2. export the symbols
3. ignore the package in your macro and just use the name

Number 2 is the usual approach. Export the relevent symbols and let your users decide how they want to consume your library.

For number 3 we can note that `(string= :foo 'foo) -> t` so if you use this in place of `#'eq` in your macro (and do the equivilent for `find`, `case` etc) then you don't necessarily need to export the symbols. You are then essentially making [designators](http://www.lispworks.com/documentation/lw50/CLHS/Body/01_dae.htm) for your DSL's terms (I hope I got this terminology right).

You may have also noticed that you didnt need to qualify `and` or `or` in `'(rashell.posix:and (rashell.posix:has-kind rashell.posix:regular )(rashell.posix:name ""*.lisp""))`. The reason is that those symbols arent interned in your package, they are from the `cl` package. They only need to be qualified when in a package which does not `:use` the `cl` package.",1515059738.0
PuercoPop,Why you don't want to use keywords? They are there for precisely this use case. At least that is my impression.,1515266181.0
yhsvghnrOruGnpverzN,"You should start a blog.  (Actually I probably should, too.)",1515069563.0
ProfessorImprobable,Looks like a really cool forth. ,1515127585.0
tarballs_are_good,“decently typed” sounds so vulgar,1515147269.0
flaming_bird,"Nice, but isn't related to Lisp.",1515156912.0
dzecniv,"This looks very old and not very attractive:

> UnCommon Web is able to use multiple HTTP server backends: Apache + mod_lisp, aserve (and portableaserve), or araneida. UnCommon Web also contains a small pure lisp http server.

And this:

> UnCommon Web provides developers with the illusion that web pages are nothing more than function calls.

reminds me to [Snooze](https://github.com/joaotavora/snooze).",1514976748.0
bsd_lore,"Not as complete as CL-PPCRE, but a bit faster.

https://github.com/asciian/regex#benchmarks",1514813135.0
Kyo91,So am I correct that this REGEX engine is also a backtracking one? Not a traditional engine that can only match regular languages? It would be nice to have a good option for linear time matching in cases where we don't need advanced perl regexp functionalities....,1514918403.0
maufdez,"There are a lot, there's elisp (emacs), the dialect in Autocad (forgot the name of it), Arc , Clojure, uLisp, TXR Lisp, MAL, Racket, Shen, etc, etc

Edit: Adding. ",1514748133.0
azzamsa,"If you search before asking, you get this list from [wikipedia lisp page][1]

- Arc
- AutoLISP
- Clojure
- Common Lisp
- Emacs Lisp
- EuLisp
- Franz Lisp
- Hy
- Interlisp
- ISLISP
- LeLisp
- LFE
- Maclisp
- MDL
- newLISP
- NIL
- Picolisp
- Portable
- Standard Lisp
- Racket
- RPL
- Scheme
- SKILL
- Spice Lisp
- T
- Zetalisp

See the [**Timeline**][2] to know what dialect are disappear and what is not.

[1]: https://en.wikipedia.org/wiki/Lisp_(programming_language)
[2]: https://en.wikipedia.org/wiki/Lisp_(programming_language)#Timeline",1514756930.0
defunkydrummer,"If you want a quick, short list, I would list:

* Common Lisp is a happy amalgamation of some previous older Lisp dialects like Maclisp and Interlisp, which had ample usage.

* Scheme started before Common Lisp and has a famous very modern dialect today: Racket

* Emacs Lisp is the Lisp with more repositories on GitHub

* AutoLISP is the main programming language of AutoCAD, so i'd say it's an important Lisp. 

as for the Lisps that have been standardized by an international standards organization, those are:

* Common Lisp (ANSI)

* IsLisp (ISO)

Scheme and EuLisp also have a formal specification.

In the golden days of Lisp machines, where programmers were truly happy and rainbows shone everyday, some of the Lisp dialects used for them were:

* Intelisp-D

* Lisp Machine Lisp

* Zetalisp

Most of the features in them were later incorporated into Common Lisp. 

Some new (post CL) dialects are:

* Arc

* TXR Lisp

* Racket

Finally, there is also Clojure, which uses s-expressions and has a macro system so it's a ""Lisp-like"" language.",1514866181.0
winkywooster,"You can divide Lisp dialects into Lisp-1 vs Lisp-2—do you divide values cells vs functional cells into separate namespaces.  Scheme is a Lisp-1 and so only has one namespace for functions and values, whereas Common Lisp is a Lisp-2 and has different namespaces for functions and values.  Checkout Richard Gabriel's [article](http://www.nhplace.com/kent/Papers/Technical-Issues.html) on this subject.",1514770263.0
tankfeeder,PicoLisp,1514746764.0
Grue,"Not dialects. Those are completely different languages. Common Lisp and Scheme are at least as different as Java and C++ and nobody calls these ""dialects of C"".",1514824615.0
Someuser77,T (aka Yale T),1514754971.0
attento_redaz,[Lux](https://github.com/LuxLang/lux) can also be added to the list,1514808903.0
dzecniv,"[Pixie](https://github.com/vindarel/languages-that-compile-to-python#pixie-a-lightweight-and-native-lisp) built in RPython, the same language PyPy is written in, and as such ""supports a fairly fast GC and an amazingly fast tracing JIT"".",1514846138.0
ghandicraftsman,Tons of them. I prefer Hy.,1515698214.0
ClickHereForBacardi,Lisp Flavored Erlang,1514774700.0
yhsvghnrOruGnpverzN,Continue trying to learn how to write programs to an acceptable level of quality.,1514738901.0
flaming_bird,Common Lisp UltraSpec.,1514740014.0
,"Chicken 5 should be out soon, and that means updating a dozen eggs.",1514748981.0
paulfdietz,I plan to work on new ways to find bugs in lisp implementations.,1514745494.0
jmercouris,"I plan on finishing the GTK release of nEXT http://github.com/nEXT-Browser/nEXT

Feels so close!",1514736229.0
svetlyak40wt,"I'm planning to rewrite rest of the Weblocks and to write a full documentation for this frame work. This way it become useful for everybody, not only for me.

Also, will post some articles (in Russian) for Common Lisp newcomers. Hoping some of my colleagues at Yandex will start using CL as their second language.

Happy New Year, let's most our wishes will become the reality!",1514750030.0
azzamsa,"Finishing A Gentle Introduction, go to PCL. then learning to build intermediate web app with CL.",1514758111.0
Shinmera,"Well, I'll probably just continue working on what I've been working on in 2017.

* [Trial](https://github.com/Shirakumo/trial) a dynamic game engine
* [Lichat](https://github.com/Shirakumo/lichat-protocol) a novel chat protocol including server- and various client-implementations

And of course maintaining and advancing the dozens of other projects I have as needed.",1514759636.0
GNULinuxProgrammer,"I really want to work on a purely functional lisp designed for automated theorem proving. Currently it's just an idea, I didn't start anything but hopefully soon I'll start some development. Initially, I'll use Agda for type checking and compile to Haskell (by agda?) and/or C. Later, I want to build an interpreter (with JIT?) and my own compiler (I want to build a handrolled RISC-V backend and/or use LLVM IR as backend). I also want to implement my own intuitionistic type theory to type check without relying on agda. Big project, and currently just a dream, but this is one of my biggest desires from 2018. We will see...",1514781170.0
Baggers_,"- keep up a slow grind on CEPL
- learn more about bidirectional type inference by making a toy checker for a static subset of CL
- learn about SIMD (using SBCL's VOPs to expose the instructions)",1514898698.0
Sun_Kami,I plan to get back to SICP!,1514735423.0
amirouche,"I plan to stop worrying for my career and procrastinating less because of that.

I'd like to do more Scheme work:

- Continue my work on [wiredtiger](http://source.wiredtiger.com/) bindings for GNU Guile
- Continue to work on [Culturia](https://github.com/a-guile-mind/Culturia), and finally index StackOverflow, Wikipedia, HN and reddit and make it my primary way to search the web.
- Continue my work on a dynamic blog called [presence](https://github.com/a-guile-mind/presence) and maybe connect it to the federation

I hope that GNU Guile JavaScript backend can somehow be executed in browsers because TCO is implemented in browsers or because someone implemented TCO in GNU Guile JavaScript backend.",1514737803.0
migpok35,"My hope is to write some type of substantial sized application. So far all I’ve really done is advent of code stuff, and I’m not super strong when it comes to structuring things. ",1514751622.0
borodust,I'll continue with [`cl-bodge`](https://github.com/borodust/cl-bodge)  and [`trivial-gamekit`](https://github.com/borodust/trivial-gamekit) development. At this moment I'm working on [`cludge`](https://github.com/borodust/cludge) - visual tool (editor) for `cl-bodge` to help simplify some gamedev tasks that are better solved in WYSIWYG manner.,1514737916.0
defaultxr,"My main project, [cl-patterns](https://github.com/defaultxr/cl-patterns), a Lisp library primarily written for algorithmic music sequencing. I also contribute to one of its supported audio backends, [cl-collider](https://github.com/byulparan/cl-collider), which is a Lisp interface to the SuperCollider sound server.

I'm also working, albeit slowly, on a game in CL. Hit a lot of roadblocks with the SDL/SDL2 libraries but I think I'm finally getting somewhere.",1514839550.0
dzecniv,"I'd like to port my Django-Vue project to the new 40ants' Weblocks, if possible, and write extensively about it (and bring a maximum of content into the CL Cookbook).",1514846553.0
KDallas_Multipass,I want to don CEPL like a glove and finally start getting a hold on graphics programming,1514857832.0
oldbaldandugly,working on porting LLRP (low level reader protocol - rfid stuff) to common lisp,1514857445.0
michaeljforster,"Using CL, MithrilJS (v/Parenscript), and PostgreSQL: 1) OpenID Connect based SSO for our applications; 2) data warehouse and reporting; 3) Apple PassKit versions of our tickets; 4) rewrite of our POS.",1514914806.0
bjoli,"I am writing an editor in Qt where everything is accessible in guile with hooks and/or advices. I have the GUI done, but I am still working on method dispatch and event loop stuff. Some parts will be done in C++ (it's based on ewig by arximboldi on github), but apart from a small core of c++ (a couple of thousand lines for the basic interaction with qt, buffer handling and some other things that need to be fast) everything else will be guile scheme.

Still a long time to go for alpha release though, and I have zero time. ",1515405742.0
furych,"Finalize my work on porting Python's os.path library [almost done](https://github.com/fourier/ppath)

Use it to implement some file-walking/handling functionality in plumbing mode in my [CL library](https://github.com/fourier/git-api) to access Git repositories at the beginning of the year.",1515670616.0
SlightlyCyborg,"I am going to write a wrapper/support existing wrapper to the bullet physics engine, code up a robot simulator that integrates with fusion 360, write a wrapper/support existing wrapper to Tensor Flow or caffe,  use a few neural nets to control my simulation, iterate on the robot design a couple of times, build a robot prototype and test NN IRL, get investment from my mentor, build a second prototype that uses a NVIDIA Jetson board, a depth sensor system using parallax, and OpenBionic hands. Use CL + OpenCV + Tensorflow/Cafe to get my robot to identify components of a tea set; have robot brew me tea. Apply to YCombinator. Travel the world selling tea making robot to AirBnB property owners who want better customer service. Profit.",1515677772.0
maufdez,"I stated writing a rive script interpreter in Common Lisp, and I plan to blog about it. ",1514737506.0
bik1230,"Continue work on my discord library, which is currently really incomplete. ",1514778256.0
fisxoj,"I want to get more devops down, this year. Get better at dockerizing, CI, testing.",1514785466.0
can3p,"I don't have any definite plans, but I got really interested in DSP topic and will probably do some thing around it (not necessarily sound processing).",1514846202.0
pdoherty926,"I stopped working on my Lex/Yacc based Lisp interpreter last year in order to learn more C (as required by Lex/Yacc). I've now learned a decent amount of C and would like to revisit/finish my interpreter. It's just a toy and will never be used for anything, but it's a right of passage and I really would like to finish it. Also, if nothing else, it will have forced me to become somewhat-proficient with C.",1514926844.0
defunkydrummer,"My plan

* Implement the backend of at least one web application of my current employeer using Common Lisp

* Finishing implementing my Microsoft XLSX format reader lib (in Common Lisp)

* Continuing learning Common Lisp, which in itself is an activity as addictive as a hard drug and as fun as watching Rick James doing hard drugs. In particular, learning multiprogramming & concurrency for improving performance .


",1515008091.0
BusFactor1Inc,A fancy gameboy emulator called E'mu.,1515117429.0
CaptainShanks,"The link for proof, if it still looks like this:

https://www.amazon.com/gp/bestsellers/books/3981/ref=pd_zg_hrsr_b_1_5_last",1514702459.0
kazkylheku,Please don't spam the forum with this rubbish.,1514702778.0
GDP10,"Sounds interesting. I know Racket has a lot of potential in many domains, esp. web development.

Sadly, that's a pretty hefty price tag for a book, even with the 20% discount.",1514659932.0
redditzx,"Thank you for the constant effort.
Happy new year!
",1514731233.0
parens-r-us,"All good stuff, thank you!",1514707255.0
defunkydrummer,">bug fix: fixed heap exhaustion bug when consing millions of small objects

This is excellent news, it is just fantastic that such a great Lisp implementation is not only free, but that it keeps improving over time. Thanks!",1514985299.0
codemac,https://github.com/asciian/papyrus is the link to the literate tool used.,1514768728.0
xach,"I find this list more embarrassing than inspiring. It would be worth doing some proper research first.

In particular, I dislike the model of ""I'm going to put out a lot of bad info and invite corrections"" very, very much.",1514592231.0
jsjolen,"https://github.com/azzamsa/awesome-lisp-companies#sweden

Huh Michael Minock was my databases lecturer while he still worked at KTH. Nice guy, called people (no students, just in general :-)) numb skulls and made a lot of beer references.

http://www.sciencedirect.com/science/article/pii/S0169023X09001499

https://www.youtube.com/watch?v=fWio8bHq4wQ",1514588285.0
can3p,"Thanks for the list! It requires some proofreading though.

E.g. I tried one random company - adUup and it seems to be dead with last traces from around 2008

Another one, StreamTech in the Netherlands disappeared around 2012",1514588386.0
jgodbo,"ITA is no longer a lisp company, or a company for that matter...",1514606623.0
dzecniv,I began a (very) small but up-to-date list here: https://gitlab.com/lisp-journey/lisp-journey.gitlab.io/blob/master/content/who.md,1514632268.0
azzamsa,**This list has been updated at 2018-01-02**,1514865150.0
cg84,Cleartrip hasn't been a Lisp shop for quite some time now. You should remove it.,1514921465.0
erick_ikki,"In  www.ikkiware.com we are developing a entrepreneurs oriented Social Network,  (www.huuii.com) which includes project management and  productivity tools (called Huuii Smart) a social network (Huuii People), a Polls tool (Huuii Polls) and a web site creator tool (Huuii Sites).

We are located in Mexico, and currently our systems are in spanish language.

",1515007334.0
anaerobic_lifeform,"No, something like this?

    (defmacro with-hash ((&rest decls) hash-table &body body)
      (alexandria:once-only (hash-table)
        (loop
          for (var key) in decls
          for key-sym = (gensym ""KEY"")
          collect (list key-sym key) into key-let
          collect (list var `(gethash ,key-sym ,hash-table)) into sym-mac
          finally
          (return `(let ,key-let (symbol-macrolet ,sym-mac ,@body))))))
    
    (let ((hash (make-hash-table)))
      (with-hash ((foo :foo)
                  (bar :bar)) hash
        (setf foo 10)
        (setf bar (list (incf foo))))
      hash)

All keys are evaluated at least once, even if they are not used. Alternatively, you could also ensure the symbol macros expand into code that either evaluate the key or get a cached value if it already was evaluated once:

    (defmacro with-hash ((&rest decls) hash-table &body body)
      (alexandria:once-only (hash-table)
        (loop
          for (var key) in decls
          for key-sym = (gensym ""KEY"")
          for key-sym-p = (gensym ""KEYP"")
          collect (list key-sym key) into key-let
          collect (list key-sym-p nil) into key-let
          collect (list var
                        `(gethash (if ,key-sym-p
                                      ,key-sym
                                      (setf ,key-sym-p t ,key-sym ,key))
                                  ,hash-table))
            into sym-mac
          finally
             (return `(let ,key-let
                        (symbol-macrolet ,sym-mac ,@body))))))

",1514484620.0
stevelosh,"No, but you could make one pretty easily:

    (defmacro with-hash (bindings hash-table &body body)
      (alexandria:once-only (hash-table)
        `(symbol-macrolet
           (,@(mapcar (lambda (binding)
                        (destructuring-bind (symbol &optional (key `',symbol) default)
                            (alexandria:ensure-list binding)
                          `(,symbol (gethash ,key ,hash-table ,default))))
                      bindings))
           ,@body)))
    
    (defparameter *h* (make-hash-table))
    (setf (gethash 'foo *h*) :foo
          (gethash 'bar *h*) :bar)
    
    (with-hash (foo
                (b 'bar)
                (z 'baz :none))
        *h*
      (list foo b z))

    ; =>
    ; (:FOO :BAR :NONE)

EDIT: The key gensyms in the above comment would be good too.",1514485296.0
BnMcGn,There's a with-keys macro in [cl-hash-util](http://quickdocs.org/cl-hash-util/),1514519445.0
Heinemenusch,I see people have given your answer already but I was wondering what you would use it for?,1514487112.0
vseloved,"In RUTILS there's a generic WITH macro that can handle hash-tables. Here's an example of its application to a hash-table that has keys ""key1"" and ""key2"":

    (with ((((val1 ""key1"") (val2 ""key2"")) ? hash-table))
       (print (+ val1 val2)))",1514536174.0
tarballs_are_good,"Before using such macros, as yourself: Will it really vastly improve your code by using it?",1514553916.0
guicho271828,"To bind a variable to a part of a structure, then *pattern matching* is a good generalization compared to a random `with-` macro. Such a macro is not able to integrate with another type of destructuring macros, making it a single-purposed, ad-hoc solution.

    (ql:quickload :trivia)
    (use-package :trivia)
    
    (defpattern hash (&rest key-value-pairs)
      (with-gensyms (h)
        `(guard1 (,h :type hash-table)
                 (hash-table-p ,h)
                 ,@(iter (for (key subpattern . rest) on key-value-pairs by #'cddr)
                         (collecting
                          `(gethash ,key ,h))
                         (collecting subpattern)))))
        
    (let ((h1 (make-hash-table))
          (h2 (make-hash-table))
          (h3 (make-hash-table)))
      (setf (gethash :a h1) 1
            (gethash :a h2) (vector 2 3)
            (gethash :a h3) 4
            (gethash :b h3) 5)
      (ematch (list h1 h2 h3)
        ((list (hash :a a)
               (hash :a (vector b c))
               (hash :a d :b e))
         (assert (= 15 (+ a b c d e))))))

[Here is my take on the introduction to pattern matching.](https://github.com/guicho271828/trivia/wiki/What-is-pattern-matching%3F-Benefits%3F)",1514650667.0
eviltofu,What happens when you try to set something which does not exist in the hash-table?,1514485808.0
wwwyzzrd,"There is this:

http://clhs.lisp.se/Body/m_w_hash.htm

with-hash-table-iterator

What do you want to do with this function? Iterate the values of the hash table or modify them?

edit:
I'd like to suggest that if it is the latter, a hash-table (however convenient) might not be completely appropriate for this use case. You might be happier with a class or struct, or a plist, or an alist.",1514498359.0
rhabarba,"So *qooxdoo* is a JS framework without any JS?

Huh?",1514428798.0
dangerCrushHazard,This seems like FRP.,1514479786.0
chuchana,Cells [presentation (ILC2003)](https://raw.githubusercontent.com/kennytilton/cells/master/doc/Cells-ILC2003.pdf) & [wiki](https://github.com/kennytilton/cells/wiki) ,1514736730.0
flaming_bird,"Use Portacle, which is a package containing Emacs + SBCL + Quicklisp + Git, which should be a good enough software suite for you to start learning and developing Lisp.

https://portacle.github.io/",1514321468.0
stassats,"Homebrew is used widely for development outside of lisp. So it would be just brew install sbcl emacs. Then grabbing quicklisp, which will install slime. Doesn’t sound as dire as you’ve described.",1514335408.0
chuchana,[Portacle](https://portacle.github.io) seems to be the easiest way to get started right now.,1514321631.0
hiroki802,"We will hold a seminar using Practical Common Lisp.
We made a learning system using lem, a common lisp IDE.
https://www.youtube.com/watch?v=BCIvF8MTc9A",1514378406.0
sgoldkin,just get Clozure CL (it's in the Apple app store and is free).   It has its own editor (which is basically emacs) and you won't have to mess with slime or anything else.,1514331383.0
dzecniv,"The [Common Lisp Cookbook](https://lispcookbook.github.io/cl-cookbook/getting-started.html) gives up-to-date solutions, namely, Portacle. 

You can send PR to add Mac instructions if needed.",1514367668.0
patrixl,"I myself found this guide to be useful, as it explains how to make SBCL, Emacs (Aquamacs in his case but I went with a brew-installed emacs, I'll explain below), QuickLisp and Slime to work together:

http://www.jonathanfischer.net/modern-common-lisp-on-osx/

My install of emacs went like this:

brew install emacs --devel --with-cocoa --with-gnutls --with-imagemagick@6 --with-librsvg --with-mailutils --with-modules

(I used --devel because the full-screen mode is broken - emacs crashes when closing a window *ahem* I mean, a frame - in the stable emacs and fixed in 26.x)


I later went on to add Spacemacs to help me deal with my emacs config, but that's a topic that goes beyond getting started with emacs + common lisp on a Mac.

About Melpa itself, emacs comes with Elpa by default (the GNU software repository), but Melpa is more complete. Easiest way I can tell you to activate it, is to install emacs as above (the --with-cocoa will give you the GUI version), then:

M-x RET package-install

And from the Package menu in the menubar, select Customize, then Package Archives and add the melpa archive

Name: MELPA
URL: https://melpa.org/packages/


That should get you started.

Also, nothing stops you from using any other IDE and loading files in the SBCL (or other) REPL, rather than learning Lisp AND Emacs at the same time. Though I did so myself and have been quite stricken by emacs... ;)",1514371990.0
lispm,"If you want Gnu Emacs on a Mac, you can use a real application of the latest version:

https://emacsformacosx.com

Another version is Aquamacs:

http://aquamacs.org

The version Apple provides is older and non-GUI.

Common Lisp on a Mac alternatives:

Clozure CL with its GUI-based IDE, free:

https://ccl.clozure.com/download.html

https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12

LispWorks Personal Edition, GUI-based - useful mostly only for learning - the relatively expensive commercial version doesn't have limitations, though.
http://www.lispworks.com/downloads/index.html

",1514317710.0
,[deleted],1514386295.0
svetlyak40wt,Use SLY instead of SLIME. It is much better!,1514433559.0
Star_Rat,"I have to admit I have a problem with Emacs - I get overwhelmed when I try to use it, so for now I just use my editor (Geany) when I try to write Lisp code. ",1514396123.0
furych,"This is exactly the experience all newbies in CL get, which is unfortunate and sad. Have you tried to install free Lispworks Personal? You should have no troubles to start learning Common Lisp with it.

There is Clozue Common Lisp for OSX as well, its free and comes with an editor and repl. Its even available in Mac AppStore (for free). Its great implementation and more user-friendly (IMHO) than SBCL.

P.S. Your experience with installing Emacs via package manager shows that you are not familiar with package managers on OSX, it has nothing to do with Common Lisp.",1514454684.0
,"Thanks, all, for your suggestions. It will be a couple days before I can investigate.",1514380822.0
guicho271828,"I never used Mac myself, but I think installing brew is pretty much the starting point of anything related to programming, not particularly lisp, no? (I mean I know there are some other choises like macports, but they should also be providing the equivalent package, especially the important ones)",1514473565.0
Baggers_,"For CL they need to be using something like slime or sly, which right now ties them to emacs or vim. If they aren’t familiar with one of those already then sadly the best place to start is for them to get a little familiarity with one of those. Get them setup with a basic setup, not too flashy but try to get paredit in there if you can.

Then show them how to start a session, how to use `C-c C-c` & `C-c C-k` for compiling stuff and how a compiled function can then be used from the repl

After that I think land of lisp is a really good starting place. I loved it but there are two issues:
- it uses clisp so in a few places it deviates from the standard
- it doesnt (IIRC) explain the stuff from above, namely, how to interact with lisp

stretch goals: When the question of packages/namespaces come up, show how to use ql:quickload and then how to use something like quickproject to make a little project. This could be done before digging into land of lisp, but requires touching on packages sooner than necessary.

If they are going to do land of lisp, it may be worth setting them up with clisp and then switching out for sbcl as soon as they are done. If they start with paul graham's 'ansi common lisp' then just get straight to sbcl, the errors are way better, it performs better and it adheres to the CL standard.",1514104495.0
EscobarATM,"This BY FAR was the thing that helped me learn Lisp the fastest 0-60.

It's short and sweet, and I love how it uses graphics to help you remember rather than just fizz buzz bullshit

https://docs.racket-lang.org/quick/",1514794239.0
,"I'd start with Scheme (or Racket with DrRacket) and only then I'd go for CL+Emacs. I really love CL, but I do think that Scheme is much easier to get started with. After your friend knows Scheme it's pretty easy to explain CL in terms of it (Lisp-1 vs. Lisp-2, non-hygienic macros, etc.)",1514103133.0
lilkha_walker,"There is an interesting project for teaching CL on github. Here is the link https://github.com/t-cool/cl-exercise if you find it good, please tell me. I hope that will help ",1514111370.0
dzecniv,"I would avoid lisp oddities. Like, string manipulation is tedious (see (my) [str](https://github.com/vindarel/cl-str)), there are inconsistencies (a sequence as first or second argument), different functions for some different sequences (`first` doesn't always work), `loop` is not lispy,… I'd impose them some libraries (Alexandria, see [cookbook/data-structures](https://lispcookbook.github.io/cl-cookbook/data-structures.html), [for](https://github.com/Shinmera/for)) or even maybe make them use [cl21](https://lispcookbook.github.io/cl-cookbook/cl21.html). It's a CL library, we can mix it with regular CL in a project, so they won't have any problem reading other code or switch to regular CL later. I know I lost two much time dealing with sequence functions not applicable to arrays.

(edit) I knew I was going to be downvoted, neverthless looking at cl21 IMO helps in learning CL's oddities, flaws and limitations and ways to fix or live better with them. cl21 doesn't re-implement everything but uses many popular libraries: Alexandria, split-sequence, cl-ppcre, closer-mop, trivial-types, cl-interpol, repl-utilities,…",1514239524.0
Ace_Emerald,"Learning Lisp gives you a good understanding of programming languages and software engineering. It's also worth noting that a lot of features of modern programming languages are pulled from lisp. So even if you don't use lisp much at work, it's still worth learning.",1513991181.0
stassats,Yes.,1513990178.0
XNcdr4,You should. There is a pretty decent bundle of books that will help you get started available on humble bundle (https://www.humblebundle.com/books/be-a-coder-books). ,1513994398.0
GNULinuxProgrammer,"Every good programmer should know at least one lisp-like language and a functional language. It's not necessarily because you'll use these languages, but because they'll force you to understand different ways to solve problems, which will improve your work.",1513997869.0
yhsvghnrOruGnpverzN,"[Take this test](http://wordsandbuttons.online/learn_you_a_lisp_in_0_minutes.html).  I'm willing to bet even people who've never programmed a single line of code can get through it, and maybe even complete it 100%.  If so, then you should be able to judge for yourself whether Lisp is interesting enough for you to devote some time to. 

If you really need help: 
http://web-artanis.com/scheme.html",1513995964.0
guicho271828,"If you worry about the job market, advertise yourself as someone who knows ""functional programming""",1514003398.0
stumpychubbins,"You will not get an unbiased view here, but I would say that Racket (other schemes too, but Racket has better learning materials) is an excellent way to really _get_ programming, rather than just learning rote methods to make stuff work without knowing why. ",1514044142.0
younicorn_farts,"After finding out how many other languages had been influenced by Lisp I decided to learn it. I knew that I would probably never use it at my <dayjob>, but if I could learn to solve problems in a way that was previously foreign to me, then it was worth the effort. I won't say that I ""know"" the language well, but it has changed how I look at certain problems. ",1514009222.0
kazkylheku,"> *But then again, the job market values Python, Ruby, Java, etc.*

It does that now; what will it value by the time you're an expert?

If you know Lisp very well, you kind of have a key to any language.

Python, Ruby and Java are just collections of awkward syntactic sugar to some mutilated subset of Lisp semantics.



",1514005937.0
zodmaner,"Yes. Especially if you are a complete beginner with no background in either programming or Computer Science/Engineering.

Lisp, with its simple syntax, will let you focus on learning how to solve problems algorithmically, instead of getting bogged down by details.

It's also one of the best language to learn functional programming concepts.",1514023649.0
furych,"Not necessary - if you are on system side of things, better to learn C with a good C book (K&R C Programing Language).

Software Engineering is a as engineering as anything else, with practices which are language-agnostic, like layered and modular design, source control, code comments, documentation etc and has nothing to do with particular language.",1514018700.0
ProfessorImprobable,"Some bootcamp founder said something that sounds truthy:

> start with whatever language your best friend knows, otherwise start with JavaScript

If your friend is going to help you with Lisp (or racket or clojure), do it; otherwise -- well, before fully endorsing JS, lemme ask a little more about your background.  What sorts of computer things are you fluent with already? Linux, bash, etc or just Windows and wizards? Have you dabbled with any programming before?  When you say systems and infrastructure, can you give more concrete examples of things you'd like to do?",1514053889.0
,I would definitely recommend to learn lisp or scheme. I would also recommend SICP book because it gives pretty good understanding. I personally prefer Racket because there is a lot of examples on Rosetta code website. It is really helpful to learn basic operations like file reading etc.,1514244505.0
basic-gongfu,"And tomorrow the job market will value something else. What never changes is the need for experienced coders who actually know shit about anything that matters, and Lisp is one of the stepping stones to get there. I would say that Forth and C are at least as important, the holy trinity of programming languages. Most of the rest can be derived from that foundation.",1514605185.0
blue1_,"Leaning lisp is valuable, but at the current state of affairs it is valuable only because it opens your mind; it has little practical value in the real world (sorry, I am a Lisper too, but I believe this is the harsh reality). I think Lisp is a perfect *second* language. As first language to approach programming, Python is probably a more reasonable choice.",1514040372.0
alecigne,"If you never programmed before I'd suggest [How To Design Programs](http://www.ccs.neu.edu/home/matthias/HtDP2e/), which is based on Racket. There is a nice MOOC based on this book [here](https://www.edx.org/course/how-code-simple-data-ubcx-htc1x).

IMO, an awesome entry point to programming.",1514049141.0
dk_jackdaniel,"CLIM2 from Franz has a lot of legacy code and works pretty bad on anything but ACL. That said here is a semi-working port to SBCL and CCL: https://gitlab.common-lisp.net/mcclim/gramps-clim2/ . This port works only on X11 but sources for other backends are left in code tree.

McCLIM on the other hand was implemented from scratch and portability is one of its goals. It has more development focus, it is more complete and IMO it is more appealing as a tool to write applications in: https://common-lisp.net/project/mcclim/ . Of course it has some bugs and at this moment of time it works only on X11 server.

McCLIM license is LGPL-2.1+ (until you use it as a library you may incorporate McCLIM in any setting with any license, see https://common-lisp.net/project/ecl/posts/ECL-license.html), and CLIM-TOS license is BSD (so you may do practically whatever you want with it).

I'm saying that from perspective of person, who worked with code of both implementations. To sum it up: use McCLIM.",1514021715.0
flaming_bird,"`#clim` on Freenode might be able to answer best on the topic.

clim2 is Franz's fairly-recently-open-sourced implementation that AFAIK runs only on Allegro Common Lisp while McCLIM is a free-software implementation that is cross-platform.

McCLIM looks nicer at the moment, too. :)",1513965770.0
nickpsecurity,"Submitted this since there was interest in Scheme Chip submission. It looks like it's related through tooling to the CLI verified stack:

ftp://ftp.cs.utexas.edu/pub/boyer/fm9001/index.html

Here's the other paper on DDD-based LISP:

https://www.cs.indiana.edu/pub/techreports/TR544.pdf

So, there's yall a triple whammy for my first submission to the LISP sub-Reddit.",1513962121.0
MostlyFermions,This is quite interesting. I wonder if this can be implemented in an FPGA after I digest all the details. ,1514307413.0
BusFactor1,"Is there an actual implementation of this, or is it just a design doc?",1513965093.0
blue1_,[PLOT3](http://users.rcn.com/david-moon/PLOT3/) is a more recent version (2012).,1513958414.0
EdwardCoffin,This has been [discussed here before](https://www.reddit.com/r/lisp/comments/38mwa9/) (and other times as well),1513957885.0
dangerCrushHazard,"Is this really a lisp? It doesn’t share any of the syntax, but my god it has the most lispy macro system for any language like that",1513948198.0
Aidenn0,"Lisp can do all these things, as can nearly every single programming language in existence.

There's a lot of possible reasons for it, and they all compound and self-reinforce.

Both libraries and tutorials ease entry.

There need to be a lot of people using it to have the critical mass that will publish tutorials and libraries, so it's self reinforcing.

That being said, there's plenty of software in all of these categories.

https://franz.com/success/

http://www.lispworks.com/success-stories/

The PS2 game series ""Jak and Daxter"" actually *was* written in a special purpose lisp, called ""Game Oriented Assembly Lisp"" (GOAL) the compiler for which was written in common lisp.",1513925475.0
tarballs_are_good,"Lisp doesn’t do these well or at all:

- complete static type checking

- definition of useful polymorphic types

- declaration of polymorphic functions with a parametric type

- GUI development is pretty difficult for free

- complete, language-integrated lazy evaluation (its easy to make little lazy eval toys using closures though)

- certain control over memory layout, e.g., array of structs

- fast jump tables/computed GOTO (AFAICT, doing this in constant time is not possible in Lisp)

You can imagine a lot more, and for many of these, macros aren’t a simple or even viable solution. 

A lot of things that Lisp (supposedly!) can do are often implementation dependent. And the intersection of all of the features that you want result in no implementations. For example, the intersection of the following:

- ability to link static C libraries

- ability to generate extremely fast numerical code with little effort

- ability to generate smallish executables with tree shaking

- free

Some things Lisp can’t currently do, but could do if there was effort like

- a great documentation system a la Sphinx. Not all this auto-generated crap

- a great, free, cross-platform GUI library
",1513950261.0
NeoMarxismIsEvil,"Pretty much nothing at this point.

The reason more people don't use lisp is the lack of syntactic sugar, basically.",1513922704.0
chuckangel,Achieve mainstream success. :(,1513986795.0
dzecniv,"also http://lisp-lang.org/success/ you'll find big applications with a complicated GUI, and much more.

I think we (web surfers) have a bias to work on. There is no trendy fuzz on CL and that doesn't mean it is not used, or less than a new trendy language. Sometimes its use was even guarded secret, as a competitive advantage (so relates Paul Graham). 

As of today, we still see activity, new projects and new (big) players adopting it as their main application language (recently saw Riggetti, quantum computing (that already sponsored a Quicklisp feature, cool)). 

Some ideas of ready-to-use free software: https://lisp-journey.gitlab.io/software/",1513942085.0
kazkylheku,"Some languages can do things for which Lisp is not feasible.

One application is things that fit into a very tiny space. You probably wouldn't use Lisp for writing a 512 byte boot sector. Lisp could be involved as the toolchain for developing such a thing (e.g. Lisp-based assembly language).

Some applications/platforms are built around a specific language and everything else is locked out.  Microsoft Excel isn't scriptable with Lisp (not from within at least, such that the script code executes inside Excel). Another example is the web browser: browsers use Javascript. The only way to use a Lisp dialect in the browser is through either a Lisp interpreter written in Java (such as EchoLisp) or a translator from a Lisp dialect to Javascript.

There are probably many embedded systems for which the only supported high level language is C. For instance DSP chips and such. If you want any kind of Lisp, you have to port something yourself.

So those are the kinds of barriers why you can use only certain languages in some situations, and none of those are Lisp dialects.",1513972303.0
,[deleted],1514557782.0
lisp-student,"I wonder why this post has been down-voted so much. I found the question relevant and interesting, and the answers very interesting, too.",1514482861.0
furych,"The problem is not that it is just a few keystrokes to learn. The problem is that one have to still retrain ingrained in brain (yes specially if its a programmer!) habits and hotkeys just to try out a new language! Also terminology - Meta? wtf ask normal people who never worked on an old terminals. Buffers? Windows? Frames? Kill? Yank? etc all straight from 70s. That all will definitely block any normal (not geek/ fan of old tech) to go even further.

Regardless how easy it was for you personally, to break habits just to learn a new language (when you just want to try it out and not to spend next 20 years with it since employment possibilities for such an investment are pretty bleak) it is a little bit too much.",1515001401.0
,The demo looks clean. Is performance on par with Lua?,1514303978.0
BusFactor1,"Some of my generative work in CL using Vecto:

https://fineartamerica.com/artists/burton+samograd

Source code inthe artist statements.",1513891813.0
lisp4humanists,"I looked into this a little while back in the hope that I could just generate a cffi binding using swig. It turns out that the [tensorflow c api](https://www.tensorflow.org/extend/language_bindings) isn't currently at a state that would be useful for anything beyond running predefined graphs. Building a lispy tensorflow binding seems like it would be a good use case for the LLVM CL implementation [Clasp](https://github.com/drmeister/clasp) once it's more mature, as the whole point of Clasp (as I understand it) is to allow one to use Lisp macros to work with big C++ libraries.",1513841438.0
cracauer,"As mentioned, the C API for TF has serious implementation holes. The Python API, which is the complete one, has performance problems, you can run into problems feeding fast evaluators, especially since you cannot multithread (in a way that would use multiple CPUs for userland code in Python). The C API can be used to feed faster in those situations.

Overall I think it would be better to hack up a git checkout of TF to have a CL interface as native as the Python one (except that it could do multi-CPU).

I don't see Clasp helping at this point if you want the high-level interfaces provided to Python.",1514046755.0
djeis97,"There is a C api for tensorflow, but many of the things which make building models in tensorflow easy (like automatic computation of gradients for you’ve optimizers) are actually still implemented entirely in the python part of the codebase and so very difficult to access from other languages.",1514047799.0
tarballs_are_good,How does Python do it?,1513950588.0
jadziamd,I can confirm that Land of LISP is both a fun and informative book.,1513711222.0
defunkydrummer,"Very interesting, the bundle covers very interesting programming languages:
- Common Lisp (Land of Lisp)
- Racket
- Clojure
... and Assembly (which makes me extremely glad)

",1513694533.0
DoomBananas,The reason why I'm here :),1513972211.0
bsd_lore,Thanks to Baggers for this very nice and much appreciated ongoing series on Lisp.,1513675236.0
lisp-student,"Thanks, I also like that series a lot, succinct with depth, like Lisp is.

I wonder if he describes anywhere his workstation setup?

It looks interesting, possibly 3 monitors?

Also, what about the video setup?",1513697847.0
ryani,"The [2014 ICFP Programming Contest](https://icfpcontest2014.github.io/) required you to write assembly language for an [SECD Machine](https://en.wikipedia.org/wiki/SECD_machine), which is basically a 'scheme/lisp assembly-language'.

We wrote a [compiler](https://github.com/ychin/icfp_2014_CannonBrawl) embedded in Haskell.  ([Example output](https://github.com/ychin/icfp_2014_CannonBrawl/blob/master/solution/lambdaman.gcc))

The target language is simple enough that it could probably be implemented in hardware without much further concretization, with the exception of `LDC`, which needs to traverse a linked-list-of-arrays, and `CONS` which needs some concept of a heap and probably garbage collection.

Has anyone implemented a hardware GC?",1513674324.0
BusFactor1Inc,"Should be pretty to implement with today's tools.

Anybody familiar with VLSI?",1513669610.0
JaumeGreen,"It looks great and it would fit much better on my hobby use than other alternatives I've used.

Some nitpicks on my phone (huawei p8 lite 2017)

It starts with the focus on the middle field, trying to write a function there is hard, must be single line and lateral scroll seems missing.

Trying to paste with nothing in the buffer hangs the app. 

In my 5 minute test I've found no easy way to paste code from external clipboard. 

If I'm inspired tomorrow I'll try to code in there while commuting, it depends whether the input from advent of code will be simple or i find a way to enter it. 

Great job! ",1513629525.0
dk_jackdaniel,I'm eagerly waiting for F-Droid release! (I don't have Play Store),1513629247.0
LispSlurper,Great Job!!! ,1513672694.0
jmercouris,"Nice! Too bad I don’t have android :/


I imagine porting this to iPhone would actually be pretty trivial due to the support of C in iOS",1513683890.0
Slxe,"I was just looking for a way to try things out when I don't have a computer close, tyvm for this!",1513710813.0
lispm,"Lucid Common Lisp is pre-ANSI-CL, but close to ANSI CL in many parts.

Any ANSI Common Lisp implementation would be fine. There might be a few adjustments needed, for example the package names. LISP is COMMON-LISP, USER is COMMON-LISP-USER. CLOS is no longer needed, since it is built-in. Maybe there is some MOP usage. Pathnames may need some adjustments.

Generally I would guess that it would easy to update.",1513615778.0
xach,Is the code available to review online somewhere?,1513609700.0
BusFactor1Inc,What do I need to do to submit my 'Scheme Coin' to the symposium?  Write a paper?  Or is just the code good enough?,1513660534.0
anquegi,"I looked at stackoverflow I did not found anything so I will try with this post, maybe usefull tips of how to proceed.",1513594225.0
rudolfo_christ,"I did it from scratch with Ironclad for a previous project. Wasn't that hard. Security audit still pending.. :) 

When I did more Ruby (connecting to the SO question) I also did it from scratch most of the time. Without CanCan etc. There is also a nice [Railscasts episode](http://railscasts.com/episodes/250-authentication-from-scratch-revised) about this topic. Don't know if this is still doable. Didn't do much Ruby since 2012.",1513601202.0
fjames86,"Keep in mind there is a difference between authentication and authorization, your SO post seems to mix both terms. Authentication is proof of identity whereas authorization is about access control. 

I have successfully written Lisp applications that access Windows based services that use NTLM and Kerberos (SPNEGO) for authentication, I think the libraries got added to quicklisp. Both of those are somewhat niche though, and probably not what you want.",1513610384.0
svetlyak40wt,"If you are using a framework, based on Clack, then you can try Hermetic:

http://quickdocs.org/hermetic/

I didn't used it yet, seems it is only supports a password based authentication.",1513757776.0
svetlyak40wt,"I also will need a social authentication for one of my sites, based on Weblocks. It uses Clack underneath and I'll be glad if somebody will suggest a solution to authenticate user by Facebook or Google account.",1513757858.0
varoun_p,"[Keycloak](http://www.keycloak.org/), and your app fronted by  proxy is a good option. Two proxies you could try:
 
* [Keycloak Security Proxy](http://www.keycloak.org/docs/latest/server_installation/index.html#_proxy)  
* [Apache Module](http://www.keycloak.org/docs/latest/securing_apps/index.html#_mod_auth_openidc)

",1514106867.0
alcahd,It keeps looking better and better. I eagerly await the GNU/Linux port.,1513506459.0
dzecniv,"> EVIL mode now fully possible as an extension

How's that ?? Only found a [feature request](https://github.com/nEXT-Browser/nEXT/issues/28), no commit mentioning ""evil"".",1513517568.0
Gravybadger,"So this is just Crapple, right?

I was so disappoint when I got back from parts foreign and tried to run it on my Slackware box.",1513586737.0
rhabarba,Will there be a Windows version some day? We lack alternatives to qutebrowser since Firefox started to suck.,1513529829.0
cg84,"Hey that was written by me! (Aside: I redirected the page to point to the latest version of this post on my new blog)

Fun fact: I wrote this post way back in 2008 while working for an online travel portal. This was based on some actual work we'd done there. At that time, flight travel in India had started to boom. This I think went hand in hand with a bunch of online travel companies (including ours) gaining a lot of momentum.

To be more competitive, a couple of airlines decided that they wanted to introduce new discounted fares much more frequently than they were doing earlier. The only problem was that they were unable to upload their wonky fare rules in the GDS properly, so they started distributing excel sheets to travel agents with manual instructions on how to apply them. 

So our business team starts sending these sheets over to us, and initially, the frequency was low so we just manually hard coded these rules. However then they started sending these sheets every week or so which made our life hell. So we asked asked our business team to ""translate"" the airline's excel sheets and instructions into a csv, which was subsequently interpreted by a simple rules engine that we wrote. 

The only problem? Well, as anyone who's dealt with manually created CSVs will tell you, there were a **lot** of errors. This didn't really help matters much. We then added a couple of restarts to our CSV parser which allowed us to correct these issues interactively. This made life much better for us -- it was a lot easier than, say, getting a list of errors in a terminal and switching back and forth between the terminal window and the editor to correct them.

Later on we plonked the CSV parser behind hunchentoot and asked our bizdev guy to upload the file there. A handle-bind around the parser collected all the errors in one go and showed them in a nicely formatted way in the browser (see the last section of the post). And so it was no longer our problem :-)

Eventually these airlines decided they wanted to update fare rules **daily**. Thankfully our ""business rules engine"" was upto the task. Due to automatic feedback, our friend in bizdev became an expert at uploading the fare rules as soon as they came in. And for quite some time, we were the only ones who could show these cheap fares within minutes of them coming in (if I remember correctly, other portals would take hours to upload the same rules).

Ours was a small team, and we had to manage this in addition to a lot of other things. If it weren't for CL's condition system, I doubt we could have solved this as smoothly as we did. In particular, interactive restarts allowed us (devs) to correct CSV errors without wasting a lot of our own time, and without needing to build a full-fledged UI for a non-dev. And when the time did come for a UI, it was dead easy to write a web fontend on top of it.",1513451611.0
WhatImKnownAs,"That's good: Clearly explained (although I probably know conditions too well to really judge that) and the examples are illustrative and neatly written. Pitman's paper, though, is not tutorial material; It's a fun read if you're a language designer, but a little heavy if you just want to learn Common Lisp.

I always like to point out that one great advantage of the CL condition system is that it establishes a protocol for error handling that allows several independently written modules to cooperate in the process. The author of a handler does not have confer with the author of the error signaling code to the able to handle it, other than knowing some superclass of the error signaled. Likewise, a handler can invoke a restart without the author even having to know if it exists (due to FIND-RESTART). This allows libraries to handle errors of their clients or vice versa, with minimal extra documentation. And of course, it allows a debugger to provide useful restarts.",1513451690.0
jsjolen,Nice! I probably won't tune in for the live stream but I'm excited for the youtube video!,1513442231.0
theangeryemacsshibe,"Interesting theory, but surely there are better ways to store distributed data and/or code. Blockchains are very costly and tend to end up centralised cause not everyone can afford the hardware or startup coins to effectively mine or stake them.",1513424020.0
KoltPenny,Why not try something like the tangle?,1513496171.0
cloyo,Dit you specify a situation in [eval-when](http://www.lispworks.com/documentation/HyperSpec/Body/s_eval_w.htm)?,1513382223.0
djeis97,"Oh, one other point- if you stick a `defparameter` in an `eval-when` you may get surprised. It’ll create the global var at compile time and assign it the initial value (let’s say nil) and then at load time it’ll reset the var back to nil (because it’ll eval the defparameter again). Then at execution time it’ll again set the variable back to nil (although you’re unlikely to be doing anything that would notice this one). What you were probably looking for was `defvar`, which works like `defparameter` but doesn’t change the value if the variable already exists.",1513386249.0
djeis97,"What this sounds like to me is your `define-instruction` macro *expands* into code which manipulates `*instructions*`, which means the populating doesn’t actually happen until load or execution time.",1513385442.0
kazkylheku,"The problem is that the population of `*instructions*` is a macro-expansion-time effect. Thus the `*instructions*` variable which exists in the **compilation environment** receives a value during compilation. But that value isn't propagated to the compiled object file.

The question is, what is the goal of this? In the compiled case, what exactly is the compiled `.fasl` supposed to contain?

If you just want the final compiled form, you can arrange arrange for `(compile-machine-step-from-machine)` also to be called at macro-expansion time and capture its result.

It could be as simple as:

    (defparameter *compiled-stuff* (compiled-machine-step-form machine))

make this `(compiled-machine-step-form machine)` macro work in such a way that that it expands into a `(quote ...)` literal which is assembled at macro-expansion time from the material gathered in `*instructions*`.

This could perhaps even be a `defconstant` since that stuff isn't expected to change.

If you generate a form like `(defparameter *compiled-stuff* (quote obj))` then that should nicely propagate to the compiled file. Of course whatever `obj` is, it has to be an ""externalizable object"".  If that representation contains non-externalizeable stuff, then the next best thing is to generate code which calculates it. In that code, the `*instructions*` object is inserted as a literal:

    ;; sort of like ...
    (defmacro compile-machine-step-form machine
        `(compile-at-load-time ',machine ',*instructions*))

The final assembling is done by `compile-at-load-time`, into which the inputs are smuggled as quoted literals that get compiled into the object file.
",1513387685.0
maufdez,"I paused several times, it is funny to see lisp code scrolling like crazy, I even saw a multiple-value-bind in a defun, Lisp looks beautiful. Nice post and ""research"" you missed a screenfull of data when the ""counterhacker"" looks ad the code, a bit after 3.",1513281430.0
jsjolen,"https://jeena.net/images/2014/real-humans-code.png


From Swedish TV show!",1513246979.0
dzecniv,"mmh… [code folding](http://wikemacs.org/wiki/Folding), putting markers at every `(declare ` and `(the `, with help of [m-buffer](https://github.com/phillord/m-buffer-el) ? Then code folders have the option to unfold or fold all.",1513246407.0
melevy,Hmm... That would be a perfect feature for a projectional structured code editor.,1513284733.0
ruricolist,I would start by looking at [hideshow](https://www.emacswiki.org/emacs/HideShow).,1513290025.0
Shinmera,"I don't particularly care for what Quickref does, nor how it presents itself, but if it at least gave an obvious link to the author's own curated documentation or project page (through the `:homepage` ASDF3 property) I would be a lot less bothered.",1513191406.0
CelloAxeMurder,"Seems promising, but it shares a lot of the same functionality as http://quickdocs.org/ Also, I don't think I'll find the files section very useful",1513187640.0
Aidenn0,"Compare: http://quickref.common-lisp.net/clack.html
To: http://quickdocs.org/clack/

Can anyone find something that is better in quickref than quickdocs?

Also, for systems with lots of files, I need to scroll past pages and pages of files before I get to actually useful information.  When I tried it with ironclad, even the table of contents for the files was overwhelming.
",1513210234.0
Baggers_,"I really look forward to this project getting better as something that does a better job that quickdocs is sorely needed. However I have `(SETF (DOCUMENTATION ..) ..) on all of my public api (500+ symbols & thousands of lines [of ref docs](http://techsnuffle.com/cepl/api.html)) and quickref is seeing none of it. 

I'd really like to see one of these systems use lisp's standard functionality for this.

That said, best of luck with the project. Collating the docs in the ecosystem is super valuable and I hope this works out",1513245387.0
kukujaku,Competition is generally good.,1513308661.0
defunkydrummer,"It makes me happy that people are contributing new nice tools/ sites for Common Lisp, even if this -superficially- seems to duplicate functionality provided by Quickdocs.org. (:note ""Perhaps the author would like to fork and contribute to quickdocs (?)"" )

In any case, however, my tiny gripe with Quickdocs is that it will list and document the libraries that are within Quicklisp, and not all Common Lisp libraries out there are in Quicklisp, for diverse reasons.


",1513282395.0
,Interesting tidbit: iRobot still uses a Lisp derivative of this in their products.,1513141097.0
zodmaner,"Careful. The book that is being shared on the site, **Interpreting LISP**, is downright obsolete and contains misleading information.

In fact, the book is about writing an interpreter for a toy language called GOVOL. GOVOL is based on a very old dialect of Lisp (think LISP 1.5) that is obsoleted even back when the book was first published (which is ~~1988~~ 1996) and is not representative of the current state of the language.

Also, to add insult to injury, the interpreter code in the book are also terrible as well.

See [this thread](https://www.reddit.com/r/lisp/comments/6qc61v/second_edition_published_interpreting_lisp/) for the previous discussion on the book.

If you want to learn how to write a Lisp interpreter/compiler, then **Lisp in Small Pieces** is a much better book.",1512984632.0
flaming_bird,"**PLEASE AVOID THIS BOOK AT ALL COSTS.**

[Explanation.](https://www.reddit.com/r/lisp/comments/6qc61v/second_edition_published_interpreting_lisp/dkw66fl/)",1513006836.0
azzamsa,Thank for sharing.,1512975953.0
Baggers_,"gah missed it again, sorry dude",1513118976.0
BusFactor1,No macros.,1513892063.0
mestermagyar,"I will keep an eye on that, the game itself sounds awesome. Once I can program in CL in a considerable manner, I would want to do a Grand Strategy where historical evolution is simulated and generalized in a gamey manner just like the network you are trying to program.",1512853990.0
jaccarmac,"Sounds super neat, best of luck. I'm sure you'll find people who are better-equipped to help you than I.",1512887548.0
BusFactor1,Nice. Thanks for sharing.,1513719172.0
,"MAGICL seems like it'd be useful to the community; what was your take on the existing ones (blapack, gsl-ll, llapack, matlisp, mgl-mat ...) ?",1512783154.0
jsjolen,Thank you for the great libraries you've released over the years :).,1512826570.0
larsbrinkhoff,"Maybe ask Erik himself.
https://eriksvedang.com/contact/

The GitHub repository shows there's a handful of people involved.",1512740674.0
hellerve,"Author of the blog post here! Yes, it’s been mostly Erik and I who’ve been active, and I didn’t really expect the blog post to blow up like that.

Going to the [gitter channel](https://gitter.im/carp-lang/carp) is a pretty good first step, and among others I’ll often be online there and ready to answer any questions!",1512742583.0
VanLaser,Also: https://www.reddit.com/r/lisp/comments/7fmadk/a_statically_typed_lisp_without_a_gc_for_high/,1512762078.0
Ellieorhenny,I want to het into using it bit im not sure how to get started. How do i set it up? I was checking the repository but i did not figure it out,1512881238.0
bobbysmith007,Clsql-orm behaves this way and should be mostly database server agnostic,1512737829.0
guicho271828,"Fukamachiware (integral) has that capability.

    (defclass user ()
      ()
      (:metaclass <dao-table-class>)
      (:generate-slots t))

This generates slots from an existing db.
~~There is only jp ""explanation"" (not a document) though.~~ 
~~http://blog.8arrow.org/entry/2014/01/19/180013~~
Sorry the github repo has one. https://github.com/fukamachi/integral
",1512735034.0
amirouche,ORM is a bad thing. ,1514733724.0
dk_jackdaniel,"Short presentation of CLIM Listener, CLIM Debugger, drawing and presenting objects, defining application frame and working with commands.",1512590985.0
eql5,"Impressive, thanks!",1512603696.0
okflo,"Great! thanks! Hopefully you'll make some follow ups - my wishlist ;) : more on layouts and widgets (buttons, text-fields, ...)",1512731824.0
jsjolen,Is this the master branch?,1512591913.0
LegionPharma,Is it possible to include an OpenGL context inside a CLIM window?,1512671459.0
,[deleted],1512664287.0
stassats,"Adding a couple of declarations, running in 0.001 seconds on SBCL:

    (defun process (cells)
      (declare ((simple-array (signed-byte 32) (*)) cells))
      (do ((moves 0 (1+ moves))
           (position 0)
           (length (length cells)))
          ((>= position length) moves)
        (declare ((signed-byte 32) moves position))
        (let ((cell (elt cells position)))
          (setf (elt cells position) (1+ cell))
          (incf position cell))))

    (defun start (input)
      (let ((lines
              (with-open-file (file input)
                (loop for line = (read-line file nil)
                      while line
                      collect (parse-integer line)))))
        (print (process (coerce lines '(simple-array (signed-byte 32) (*)))))))
",1512597551.0
Aidenn0,"You use a list in lisp and a vector in javascript.  They have very different performance profiles.

A simple conversion to a vector in lisp shows a >10X speedup on my machine.  There are probably other ways of speeding up as well.


    
    (defun process(cells)
      (do ((moves 0 (+ 1 moves))
          (position 0))
          ((null (ignore-errors (elt cells position))) (print moves))
        (let ((pos (+ (parse-integer (elt cells position)) position)))
          (setf (elt cells position) (write-to-string (+ (parse-integer (elt cells position)) 1)))
          (setq position pos))))
    
    (defun start()
      (let (container)
        (with-open-file (file ""./input.txt"")
          (loop for line = (read-line file nil 'end)
            until (eq line 'end)
            do (push line container)
            finally (process (coerce (reverse container) 'vector))))))

[edit]

Using integers instead of strings gets another speedup, to the point where it's around 15ms.  I also didn't do a wasteful reverse, though that's likely a smaller win:

    
    (defun process(cells)
      (do ((moves 0 (+ 1 moves))
          (position 0))
          ((null (ignore-errors (elt cells position))) (print moves))
        (let ((pos (+ (elt cells position) position)))
          (setf (elt cells position) (+ (elt cells position) 1))
          (setq position pos))))
    
    (defun start()
      (with-open-file (file ""./input.txt"")
	(loop for line = (read-line file nil 'end)
	   until (eq line 'end)
	   collect line into container
	   finally (process (map 'vector #'parse-integer container)))))

[edit 2]

I [forked your gist](
https://gist.github.com/jasom/ac4b4f4672e23a05ded66cde3a267d2d/revisions); I had originally put a title in each version for why each change was made, but apparently github doesn't show the title edits in the version history.  If I add more versions I'll put the reason why in the comments.  From the first change made by me (jasom) the reasons are:

* Vector's have faster random access time than lists
* Integers are faster than strings; use collect instead of push/reverse
* Having `LET` as the outtermost form of a `DO` is a code-smell; I also eliminated all but one read of the current cell by binding cell-value in the `DO`

Note that since `ELT` works with both lists and vectors, you can compare the two for performance just by changing the `'vector` to `'list`; we are still 3x faster than your original posting in that case, but as always with all but the most trivial data, asymptotic complexity dominates, as we are still 20x slower than the even unoptimized version that uses a vector.
",1512583937.0
lispm,"Usually it is good to work over streams and not files.
Since the lines just contain a number, we can READ through the file:

    (defun read-numbers (stream &aux (*read-eval* nil))
      (loop for number = (read stream nil nil)
            while number
            collect number))

PROCESS is then redone to work over a vector, an one-dimensional array. The count is returned by LOOP:

    (defun process (cells &aux (maxcells (length cells)))
      (loop for position = 0 then pos
            for pos = (+ (aref cells position) position)
            count t
            while (< pos maxcells)
            do (incf (aref cells position))))

We then call the functions:

    (defun start ()
      (process
       (coerce (with-open-file (stream ""./input.txt"")
                 (read-numbers stream))
               'vector)))
",1512589788.0
stassats,Using NTH to iterate over a list.,1512583177.0
chebertapps,"> What am I doing wrong?

That's not a fun question to ask! 
Instead I recommend asking: ""How can I do it better?""

You can get it faster still using lists:

- I replaced `(reverse container)` with a [collecting clause](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L16) in loop.

- I calculated the [length of the list once and stored it](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L4). `(length list)` has to traverse the linked list every time it is called.

- I [accessed the element of the cell once](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L6). Each time you access an element of a linked list, it has to traverse to that position. I incremented the value in place, and [calculated what the old offset would have been by subtracting 1](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L7).

- [Call parse-integer once](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L16) on all cells. This avoids the need to read from string and write to string every time you make a jump.

Other changes I made to make it easier for me to debug:

- Replace `do` with `loop while` [here](https://gist.github.com/hebertch/c7f54f9452608c7e754382b07961d939#file-aoc-lisp-L5). I just understand `loop` better.

- Create a function `read-lines` for reading the input cells

I tested it on input.txt and got 381680 (like yours) and the sample problem and got 5.

    (time (your-start)) ;; => 1.13 seconds of total run time
    (time (my-start)) ;; => 0.79 seconds of total run time

If you want it _even better_, you should probably use a vector, like [Aidenn0 recommends](https://www.reddit.com/r/lisp/comments/7hzqq8/why_is_this_so_slow/dqv0wxd/).
A vector would give you O(1) random access (as opposed to O(n) for the lists) and O(1) length (as opposed to O(n) for lists).",1512586705.0
patrickwonders,"One other thing that might be making it slow is that there is additional startup work involved in bringing up the whole lisp image.

My guess is that if you ran your function from the REPL like: (time (start)) you would see times well under a second even before the optimizations mentioned below.",1512592755.0
xach,"Part of the problem is doing redundant work, like following a singly-linked list chain over and over, and parsing integers three times more than needed.",1512583167.0
kazkylheku,"TXR Lisp:

    (prinl
      (let ((cells (vec-list [mapcar toint (file-get-lines ""input.txt"")])))
        (for ((moves 0) (pos 0))
             ((ignerr [cells pos]) moves)
             ((pset moves (succ moves)
                    pos (+ [cells pos] pos)
                    [cells pos] (succ [cells pos]))))))

    $ time txr day5.tl 
    381680

    real    0m1.468s
    user    0m1.448s
    sys     0m0.016s

Another version:

    (let ((cells (vec-list [mapcar toint (file-get-lines ""input.txt"")]))
          (moves 0) (pos 0))
      (whilet ((cur (ignerr [cells pos])))
        (inc [cells pos])
        (inc pos cur)
        (inc moves))
      (prinl moves))

    $ time txr day5-2.tl 
    381680

    real    0m1.299s
    user    0m1.292s
    sys     0m0.004s

",1512593796.0
tlavoie,"Lisp is great for all sorts of data mangling. Couple questions / comments though:

* Why picolisp? Is there something it's especially good at?
* What's with the incessant blinking circles in the video? 
* A live stream of typing for the code is fine, but some audio instead of typing messages at the viewer would probably be better.",1512591795.0
tlavoie,"Ah, OK thanks! I haven’t tried picolisp, but there is ABCL too if you’d like Common Lisp on the JVM.",1512661003.0
timezone_bot,"7pm UTC happens when this comment is 10 hours and 2 minutes old.

You can find the live countdown here: https://countle.com/kqex109996

---

I'm a bot, if you want to send feedback, please comment below or send a PM.",1512550680.0
Baggers_,"Also, as I forgot to link last week's episode, here it is: https://www.youtube.com/watch?v=CA9wtu5Cxas",1512550722.0
xach,Who is the dodo who replied to a 22-year-old thread a few hours ago?,1512507040.0
kazkylheku,"> *You can ignore all the questions about order of evaluation of the initial
value expressions, just get the scoping of the variables right.*

TXR Lisp's [`mlet`](http://www.nongnu.org/txr/txr-manpage.html#N-008216E0) takes care of the order (but doesn't have a way to specify which init expressions see which variables: all variables are visible to all forms).

    1> (mlet ((y 3)
              (z (* 2 x))
              (x (+ 1 y)))
         (list x y z))
    (4 3 8)

Circular ref, oops:

    2> (mlet ((y z)
              (z (* 2 x))
              (x (+ 1 y)))
         (list x y z))
    ** (expr-2:1) force: recursion forcing delayed form (+ 1 y) (expr-2:3)

Rhetorical question: why have `mlet` in the language at all if you can just order the variables in a topological sort? Because circularity **is allowed** through lazy evaluations:

    3> (set *print-circle* t)
    t
    4> (mlet ((x (lcons 1 x))) x)
    #1=(1 . #1#)

The `lcons` constructor is a macro, arranging for `x` to be evaluated late, when its value is needed. By that time, it has a binding to the lazy cons cell that has been returned, and so the circular linkage is completed.

There is a `lnew` operator that complements `new` for lazily constructing objects. We can use `mlet` with `lnew` to make an object which refers to itself:

    5> (defstruct node nil
         next prev)
    #<struct-type node>
    6> (mlet ((n (lnew node next n prev n))) n)
    #1=#S(node next #1# prev #1#)

Lazily constructed objects can do cool things besides just support self-referential initialization. E.g. infinite list of incrementing numbers:

    7> (defstruct intseq nil
         (val 0)
         next
         (:init (me) (set me.next (lnew intseq val (succ me.val))))
         (:method print (me stream pretty-p) (print me.val stream)))
    #<struct-type intseq>
    8> (new intseq)
    0
    9> *8.next
    1
    10> *8.next.next
    2
    11> *8.next.next.next
    3
    12> *8.next.next.next.next
    4

And that's some macros for you.




",1512675885.0
larsbrinkhoff,"You could use the LOOP keyword COUNT or SUM to tally the count.

I think it's more idiomatic to use FORMAT to print the result.",1512464039.0
lispm,"You don't need RETURN-FROM PROCESS. Return 1 directly from the WHEN expression.

Don't use SETQ COUNT, bind the value in the LET.

Indent the LOOP expressions not so far to the right.

COUNT directly in the LOOP.

Don't use FINALLY. The LOOP should return the count, which you then would use as an argument to FORMAT.",1512466589.0
death,"[Here's my solution.](https://gist.github.com/death/927a6b0da136d69a12d8913882375d9b)

It also uses `LOOP`, but I don't think it's confusing. I use `SPLIT-SEQUENCE` to split the string. It is stable enough that I don't care whether it's in the Common Lisp standard or not. With most CL implementations, you can dump a custom core with such libraries loaded and use that for development. You should also look into SLIME (maybe check [Portacle](https://portacle.github.io/)).",1512476796.0
stassats,"LOOP DO has an implicit progn:
    (loop ... do (progn a b c)) == (loop do a b c)",1512509462.0
stevelosh,"Mine:

    (defun read-file-of-lines-of-words (path)
      (iterate (for line :in-file path :using #'read-line)
               (collect (str:words line))))

    (defun day-4/1 ()
      (labels ((contains-duplicates-p (list &key (test #'eql))
                 (iterate (for (head . tail) :on list)
                          (thereis (member head tail :test test))))
               (validp (phrase)
                 (not (contains-duplicates-p phrase :test #'string=))))
        (count-if #'validp (read-file-of-lines-of-words ""data/2017/04""))))
    
    (defun day-4/2 ()
      (labels ((anagramp (string1 string2)
                 (string= (sort (copy-seq string1) #'char<)
                          (sort (copy-seq string2) #'char<)))
               (contains-anagram-p (phrase)
                 (iterate (for (word . tail) :on phrase)
                          (thereis (member-if (curry #'anagramp word) tail)))))
        (count-if-not #'contains-anagram-p
                      (read-file-of-lines-of-words ""data/2017/04""))))",1512525508.0
knobo,"For example like this:

    (with-input-from-string (s (format nil ""a b c~%a b c b~%a b c""))
      (labels ((not-this-but-equal (a b) (and (not (eql a b)) (equal a b)))
               (dupl (list) (lambda (el)           
                             (find el list :test #'not-this-but-equal))))
             (loop for line = (read-line s nil nil)
                for list = (split-sequence #\Space line)
                while line                        
                count (notany (dupl list) list))))

EDIT: fix after testing the code.",1512989922.0
tankfeeder,"PicoLisp:

    (zero *C)
    (in ""4.txt""
       (until (eof)
          (let R NIL
             (and
                (loop
                   (T (eol) T)
                   (T (num? (accu 'R (read) 1)) (nil (line))) )
                (inc '*C)
                (char) ) ) ) )
    (println 'Result: *C)

feature: skip line immediately if duplicate found.",1512474147.0
avataRJ,"I have hard time deciding if this is genius, stupid, heresy, or all three at once. [Despite the rumours](https://www.youtube.com/watch?v=5-OjTPj7K54), the third one is in a different context than usual in the so-called holy wars.",1512415295.0
Baggers_,This is the repo linked from the post from a few days ago and that is still on front page. Please contribute to the first than double post,1512406710.0
dzecniv,and so is v1.15 of [Notalone](https://github.com/borodust/notalone/releases) !,1512304053.0
thelolrus,"a bit late for Ludum Dare 40, no? ;)",1512324423.0
mikelevins,"It's because save-application quits the Lisp process after it saves the image. When the Lisp quits, you of course lose the SLIME session connected to it.

In the process of copying in-memory data structures to disk, save-application does some things that can potentially leave the Lisp in an unsafe state. I don't know specifically what those things are. What I know is that from time to time over the years someone has asked for the ability to save-application and keep running. Gary Byers answered that it should be possible to do that, but it wouldn't be easy. Clozure probably wouldn't try to do it unless someone paid them to implement that feature. Evidently, nobody did.

So you can't fix it--or, more accurately, fixing it would mean either modifying CCL or paying Clozure to do so.

",1512241319.0
xach,"It is typical to save-application from a fresh session. I used to do that from a short lisp file that loaded everything else I wanted in the image and called save-application at the end, then started a fresh Lisp and loaded that file.

Now I use buildapp, which does pretty much the same thing, but automates it a bit.",1512253218.0
lispm,"The same with the Lisp Machine operating system from the 70s/80s: no password protection, no encryption. Even the commercial versions of Symbolics had no passwords...",1512233117.0
sickofthisshit,This does not really have much to do with MACLISP; it was a characteristic of (one of) the operating systems MACLISP ran on.,1512236696.0
Aidenn0,"There was a problem with people trying to find clever ways to crash the ITS kernel, so it was solved by adding a ""crash the kernel"" system call.  This made it no longer a challenge and people stopped doing it.",1512255851.0
lisp-student,Also interesting comment: https://mailman.common-lisp.net/pipermail/pro/2017-December/001506.html,1512226596.0
larsbrinkhoff,ITS got password protection later during its lifetime.,1512240123.0
VanLaser,"Niiice! :)  
About ""threads"" - ""processes"" confusion - AFAIK, in Linux threads *are* processes, hence the interchangeable names in the docs. ",1512158876.0
lisp-student,A high quality-content video. Thank you.,1512227064.0
KDallas_Multipass,Great videos!  One question.  Do you see a way to be able to modify memory while also allowing the original thread to run?,1512327916.0
