author,comment,timestamp
google_you,at least they delivered mvp,1543610003.0
clockish,"I suggest reading through the Real World OCaml book (available free online at https://realworldocaml.org ). It covers a wide range of features and techniques in OCaml, and does so in a sequential ""getting started"" kind of way. However, it's not written as a ""learn your first programming language"" document, so if this is your case you'll want to refer to external information (e.g. wikipedia) to explain some terms and concepts they use.

Make sure to check out their installation/setup guides (e.g. the one at http://dev.realworldocaml.org/install.html , there may be more though). The simple ""install ocaml; type 'ocaml' at a terminal"" setup is, IMO, a poor way to use or learn OCaml.

Note that Real World OCaml is a relatively opinionated take on OCaml. It teaches you to use certain libraries (""Base"" and ""Core"") that are and popular but not ubiquitous, and emphasizes the coding patterns used by those libraries. I don't think this is a bad thing; it's just something to be aware of if you're wondering why what you see there doesn't quite line up with stuff you see in the official OCaml manual at http://caml.inria.fr/pub/docs/manual-ocaml/ (which is _not_ written in ""getting started"" style, so I don't recommend reading straight though that).",1543448542.0
gmfawcett,"A great place to start: http://ocaml.org/learn/

While a bit older, there's also a book dedicated to (Unix) system programming. Depending on your familiarity with Unix/Linux, some of this stuff might be familiar:

https://ocaml.github.io/ocamlunix/",1543440058.0
andrejbauer,I wonder if there's some way for you to get access to the [Ocaml MOOC](https://www.fun-mooc.fr/courses/course-v1:parisdiderot+56002+session03/about).,1543438223.0
lilkha_walker,"I don't think anyone in this sub-reddit would say, you should learn Perl or Python instead of OCaml.  Professional Programmers use to know more than one programming language, so you can learn them all if you want, but I would suggest to not learn them at the same time.",1543440378.0
markwong,"I got started Ocaml from Westley Weimer lectures:

&#x200B;

[https://www.youtube.com/watch?v=LkiIQxC-kQ8](https://www.youtube.com/watch?v=LkiIQxC-kQ8)

&#x200B;

&#x200B;",1543462330.0
yawaramin,"My standard advice is to actually learn OCaml in a _slightly_ roundabout way, by first learning Standard ML and the concepts behind ML-like typed functional programming (modules, immutability, inference, etc.). I say this because SML is a simpler language than OCaml and once you learn the former you can easily transfer your knowledge and pick up the 20% extra that’s OCaml.
hopeishigh
The perfect intro to SML in my opinion is the Coursera MOOC ‘Programming Languages, Part A’. Professor Dan Grossman’s lecture videos are short and to the point, and he is very good at explaining things clearly. The course runs almost constantly and you don’t even have to do the assignments if you don’t have time initially—even just watching the lectures will give you a lot.",1543765173.0
sam_binder_of_demons,"so, given that only two of the responses (so far) actually endeavor to answer this question......
I'd personally stay away from it, though its interesting.  Its unfinished and quite old at this point.  If you have the $$ (and its not much, at all) I'd buy the OCaml from the Beginning ebook, or even shell out a little bit more and get the package that includes More OCaml.  They're both excellent books geared toward beginning programmers.  On top of that if you get the bundle it gives you a third book on building pdfs with ocaml, detailing precisely how the author used ocaml to write the original two books.  It'd be a good start to work through those three and on the third, try to write or manipulate some pdfs with ocaml.  As far as Real World OCaml, while it is one of the best programming books I've ever read (really), its also not geared toward beginning programmers (at all). On top of that it uses third party libraries exclusively which alter the semantics of the underlying language in subtle but occasionally important ways.  On top of *that* the old version is now fairly out of date, a number of the libraries have undergone significant change if not out right deprecation and the dev version is not quite stable last time I checked (this summer). Which would mean that you'd not only have to learn the language, but also the environment, such as tools like Opam, and you'd have to be willing to work your way through installation issues which will absolutely crop up.  Depending on your experience and level of determination that could be a deal breaker for you.  Again, after you've done some work in the fundamental language by all means, work your way through Real World OCaml, the dev version, just keep in mind the extra work and changes involved.  
Some other options:

Theres a free manuscript floating around out there called Introduction to Objective Caml, which is excellent, but expects more from the learner as it was based on a compiler class at CalTech.  While its old (about 10 yrs now I think), its also based entirely on OCaml and its original standard library, none of the competing standard libs which can introduce changes to the language proper.  Because of that its still perfectly useable on any unix system, just install the language and get to work.  

Finally a different option for you:
Theres a course offered via Coursera, out of the U of Washington run by Dan Grossman called Programming Languages.  Its excellent and covers three languages, Standard ML, Racket and Ruby.  Standard ML if you don't already know is the direct ancestor of OCaml. If you work through the first third of the course, doing the exercises and writing your own code along with it, you'll gain an excellent understanding of ML style and be able to move into using OCaml quite seamlessly.  

If you're doing that french mooc, I'd suggest just sticking to the documentation, which while less than ideal, would acclimate you to using OCamls actually docs. Ask question at the discussion forum for OCaml, its well attended by excellent programmers, and specifically by people who are actually involved in OCaml language development and library authors.  

Good luck!




",1543284831.0
nojb,"If you can read a bit of french, I recommend ""LE LANGAGE CAML"" by P. Weiss and X. Leroy, available at [https://caml.inria.fr/distrib/books/llc.pdf](https://caml.inria.fr/distrib/books/llc.pdf)",1543395841.0
kuratkull,"I also just started learning/writing OCaml. I feel doing things differently after a decade of OOP is good for me. Also hoping to push some OCaml to production at work soon. I feel this is a really beatiful language and definitely worth learning.

Basically just wanted to say hi to fellow OCaml newbie :D",1543247345.0
k0t0n0,"Yes, OCaml is a beautiful language its worth learning. But I will suggest you finish a medium size project in any language you pick before making a jump to another language.",1543243983.0
_ar7,Read https://dev.realworldocaml.org/,1543246988.0
yunfeng_lin,"Ocaml's module system is much more powerful than main stream language's module system as it has the concept of high order modules. It is used for code reuse, parametric polymorphism, dependency injection, etc

&#x200B;

I would recommend to read ""real world ocaml""s relevant chapters for functor, first-class module.

&#x200B;

It is such a fundamental part of language. For example, you have to use functor even for the basic things such as initializing a Map with specific key type: [http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html)

&#x200B;

&#x200B;",1543241023.0
laylomo2,"I like to think of modules as collections of types and values, and module types as interfaces.  You can create a functor and specify the type of its argument to be some module type.  Then within the module, you can use the functor argument without caring for the implementation.  You can also do things like including all of the contents of one module into another module instead of having to copy paste code.",1543356264.0
abathologist,"Some informal guidelines I use:

I think a module is generally called for whenever an encapsulated namespace makes sense. For example, if I find myself repeating the same prefix/suffix in snake- or camel-case, I usually introduce a module. E.g., if I see a pattern of functions and variables like `foo_make`, `foo_is_empty`, `foo_last`, I take it as a sign a module is needed to provide `Foo.make`, `Foot.is_empty`, `Foot.last`, etc.

As a corollary, anytime a new *principle* type is introduced, I usually end up making a new module for it. This follows from the previous, since any principle type will have a number of functions taking arguments of that type or reducing to values of that type, and this usually calls for namespacing. So, if I end up making a lot of use of some type 

```
type bar = ...
```    

I generally define a module

```
module Bar = struct
  type t = ...
end
```

All functions which can be thought to ""belong together with"" that type are grouped together in the module. (This practice is endorsed by the [Jane Street Style Guide](https://opensource.janestreet.com/standards/).) This also behaves nicely with ppx derivers. 

I freely nest modules whenever it one namespace is naturally a subspace of another (or if I'm using modules to model ""object like"" things and one object is a part of another).

This informal practice fits loosely with the formal principles from algebraic specification on which the module system is based (going back at least to Goguen's work on [OBJ](https://en.wikipedia.org/wiki/OBJ_(programming_language))). The basic ideas is that a [signature](https://en.wikipedia.org/wiki/Structure_(mathematical_logic)#Signature) specifies an algebraic structure, and an implementation of that structure gives you an algebra.",1543721571.0
mephage,"The de facto build system is now [dune](https://github.com/ocaml/dune). As per the readme, there's a bunch of [examples](https://github.com/ocaml/dune/tree/master/example) included.",1543090949.0
darrenldl,"This can be kind of tackled using polymorphic variants in ocaml. Specifically the idea of subtype can be expressed/simulated to some degree as demonstrated [here](http://blog.shaynefletcher.org/2017/03/polymorphic-variants-subtyping-and.html) and [here](https://blog.janestreet.com/a-and-a/).

An example using your provided type and function signature is as follows

```
(* we use polynormphic variants instead of normal variant type *)
type error = [ `UserError
             | `RoleError
             | `PostError
             | `ThreadError
             ]

(* let say the check may only result in RoleError, one instance of error type *)
let is_user_exist (user_name : string) : (bool, [`RoleError]) result =
  if user_name = ""alice"" then Ok true
  else                        Error `RoleError

match is_user_exist ""bob"" with
  | Ok b -> (
      if b then Printf.printf ""Bob exists""
      else      Printf.printf ""Bob does not exist""
    )
  | Error e ->
    (* :> refers to coercion, which only works if the type being coerced is
     * an instance of the result type
     *
     * In our case, since `RoleError is an instance of error type, we can do
     * coercion
    *)
    let x : error = (e :> error) in ()
```

Note that coercion is necessary, since an instance is not automatically grouped into the ""larger"" type automatically, as shown with `z` below

```
let x : [`A] = `A in

let y = [`A] = x in                     (* Ok *)

let z : [`A | `B] = x in                (* Type error *)

let k : [`A | `B] = (x :> [`A | `B]) in (* Ok *)

()
```",1542813006.0
TheAspiringHacker,"Facebook uses OCaml for the [Infer](https://github.com/facebook/infer), [Flow](https://github.com/facebook/flow), and [Pyre](https://github.com/facebook/pyre-check) tools and develops the [Reason](https://github.com/facebook/reason) alternate syntax. OCaml is also popular for writing programming language implementations; it's used for itself, [Coq](https://github.com/coq/coq), and [Haxe](https://github.com/HaxeFoundation/haxe). I think that OCaml will continue to be a good language for writing compilers, and in addition, I hope that Reason and Facebook's influence will bring it into the mainstream as a type-safe replacement for JavaScript.
",1542756694.0
Someuser77,OCaml is used by the Tezos team in building their blockchain. ,1542773145.0
chrismamo1,"Bloomberg developed Bucklescript and uses it for... Something, I guess? I've not seen what they actually do with it, tbh.

Ocaml is useful for applications where you need a lot of certainty, e.g analysing crypto usage, formal verification, or building compilers. The advantages of ocaml over Haskell are, imo, mainly accessibility. It can be a chore to do some fairly basic things in Haskell that are a breeze in ocaml, mainly due to ocaml's optional mutability.",1542769688.0
testcross,"https://ocaml.org/learn/companies.html

It is basically used everywhere.",1542954448.0
Semi_Functional_Ken,Found an article written by Yaron featured on Hacker News this morning. Speaks on why Jane Street moved to OCaml.  [https://queue.acm.org/detail.cfm?id=2038036](https://queue.acm.org/detail.cfm?id=2038036),1543246259.0
gmfawcett,"Move the definition of `type stackVal` above the `let bound_values = ...` statement.

You're creating a hashtable of type `(string, stackVal) Hashtbl.t`, but at the point you create it, `stackVal` hasn't yet been defined.",1542600158.0
sir_bok,"By not work do you mean this type checker error?

    This expression has type stackVal
           but an expression was expected of type 'a
           The type constructor stackVal would escape its scope

I got that and it went away when I created the hashtable `bound_values` after declaring `stackVal`. Probably because `stackVal` is considered out of scope of `bound_values` since it was declared later? (I didn't know the values a hashtable can take is restricted to what types were visible during its creation)",1542598806.0
gasche,"The descriptions of the language, and the exercises, are still very relevant today (with the exception of stream parsers which use camlp4 and are not very used anymore; for that part of the book you should go directly for ocamllex + menhir).

The parts on the tooling in this book are extremely minimal; I believe that everything described there still works, but ""real projects"" do things less manually these days, using a build system rather than calling the compiler on each file by hand. If you want to do anything practical beyond simple exercises, you'll need to get up-to-date on modern programming environments: OPAM, merlin, dune. I believe RWO does the job, and you don't need it specifically to do the ""Developing applications ..."" exercises anyway.

",1542615691.0
jazzandpython,"If you don't mind me asking, what is RWO? ",1542589614.0
TotesMessenger,"I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:

- [/r/functionalprogramming] [Is ""Developing Applications with Ocaml"" worth the read in 2018? • r\/ocaml](https://www.reddit.com/r/functionalprogramming/comments/9yb2yr/is_developing_applications_with_ocaml_worth_the/)

&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",1542584276.0
Sarwen,"As a first book to get into functional programming it is still very relevant. The core of OCaml did not change much. But for example of simple projects, there has been a lots of evulution in OCaml tooling, the biggest certainly being opam.

Once you've read Réal World OCaml, take a look at small open source project in OCaml, it's the best way to see how things are done.",1542613211.0
flexibeast,"Don't know of a video, i'm sorry; but if you're not completely against reading something, you might find [this article](http://blog.ezyang.com/2010/10/ocaml-for-haskellers/) helpful.",1542528323.0
choeger,"The difference is as follows: if you search for a video about Haskell you may as well find a camera, a script, and the URL to upload  it. But if someone already searched the video before you, you can watch the end result on YouTube.",1542552934.0
moocat,"Most likely Ocaml is not in your shell's path. Try specifying the full path (my example is just a guess, you'll need to figure out where it's installed on your friend's computer):

    > C:\Program Files\Ocaml\ocaml interpreter_part1.ml

",1542502791.0
Leonidas_from_XIV,"Last time I checked it was actually still possible to compile and run Caml Light, at least on [Arch Linux](https://aur.archlinux.org/packages/camllight/), so you can try to run this.

Or you can try to port it yourself which might also be an interesting experience (of course do ask either here or on IRC or on the Discuss if you get stuck).",1541775678.0
jeffsco,"I can't reproduce your reported problem. The following program runs vi to create a file, then copies the file to stdout.

    let main () =
        ignore (Unix.system ""rm -f abc.txt; vim abc.txt"");
        let inch = open_in ""abc.txt"" in
        let rec loop () =
            match input_line inch with
            | s -> print_endline s; loop ()
            | exception End_of_file -> close_in inch
        in
        loop ()

    let () = main ()

What is your evidence that the OCaml program is exiting when vi exits? That is not at all the expected behavior. Note that `Unix.system` returns an exit status value.",1541712419.0
juloo65,"If you use https://ocsigen.org/js_of_ocaml/3.1.0/api/Lwt_xmlHttpRequest, it should work in the browser. Are you trying to use this function in the NodeJs side ? From this module I guess https://www.npmjs.com/package/xmlhttprequest. You cannot use it unless you `var XMLHttpRequest = require(""xmlhttprequest"").XMLHttpRequest;` it before. I don't known how you can do this with js_of_ocaml.",1541614731.0
BoinkGoesTheScience,">	Explicit. Smart. No magic.

This sums up my experience with OCaml. ",1541612417.0
existentialwalri,Looks like go is the most sensible option here,1541611980.0
jdh30,Fascinating.,1541615584.0
contextualMatters,"So 

    opam update default
    opam upgrade

is how to get the new version, right ?",1541761087.0
jeffsco,"The basic issue is that `Printf.printf` is an imperative construct. I.e., it *does* something. You can't expect to use the same code with `Printf.sprintf`, which is a functional construct. In other words, it *returns* a value.

For example, you can't use `List.iter` to collect up a value. It always returns `()` (also known as unit).

It's also worth noting that `Printf.sprintf ""%s"" x` has the same value as `x`, and `Printf.sprintf ""%s\n"" abc` has the same value as `abc ^ ""\n""`. So you probably don't need really need to use `sprintf`.

At any rate, to make your code work you need something like this:

    let line1 = Printf.sprintf ""%s"" docs_num in
    let lines = List.map (fun i -> Printf.sprintf ""%s\n"" i) list_output in
    line1 ^ String.concat """" lines
",1541307031.0
sir_bok,"> There is also a fancy repl called utop that I think far exceeds any stand-alone repls out there in terms of usability and number of colours in use 

😂",1541083003.0
StrykerKKD,Ocaml multiprocess results are pretty amazing if you compare it to Go + goroutines.,1541085622.0
AlexKosh,"> I also was stunned by how effortless it was to write a C stub. Just throw in a C file into the source directory, declare external function signature and it’s done! I couldn’t find a “glob” library so I used find tool in the first version. The program was building a huge pattern and then read the command output using a pipe. It felt somewhat unfair because find was doing all the job. After some research I stumbled upon a piece of code that called a libc function in OCaml. So I wrote \~20 lines of code that wrapped the libc’s glob function and used it instead. It did slow down the program a little bit but that painless, almost native-like interop with C code was something.

Interesting! I am still learning Ocaml through [fun-mooc.fr](https://fun-mooc.fr) course, and was not really planning to use it, I was just curious how ocaml modules can imitate haskell typeclasses. But language is very pleasant, so I am kin to use it somewhere :) I do some scientific computing with C (not C++) and  if the C interop is very easy, that is nice! Can someone comment if I can easily use it to glue C code? Will it be a pain in the ass? the code is not strictly trivial - it is parallelized via MPI (actually, I mostly use petsc which uses MPI, but it is almost the same thing + some pain in the ass when compiling...)

Will real world ocaml 2ed be a nice next step to use ocaml as a C glue code after the [fun-mooc.fr](https://fun-mooc.fr) course?",1541115960.0
RedPetrichor,Totally naive question here: how is the Ocaml compiler able to achieve those compile speeds?,1541118935.0
yawaramin,Did I read that right ... OCaml (multiprocess version) runtime is less than half of Go with coroutines runtime ... and orders of magnitude less than the others?,1541171458.0
TheAspiringHacker,"`[_]` is the same thing as `_::[]`, i.e. the pattern to match a one-element list and ignore the element.
",1541038921.0
examachine,Cool :))),1540820460.0
Leonidas_from_XIV,"[Reader](https://ocaml.janestreet.com/ocaml-core/v0.11/doc/async_unix/Async_unix/Reader/) and [Writer](https://ocaml.janestreet.com/ocaml-core/v0.11/doc/async_unix/Async_unix/Writer/) are both part of Async (Async_unix to be exact).

From what I see [this function](https://github.com/vbmithr/ocaml-websocket/blob/e7b1fb23a7b05936ab2d9eadad6f4d4c726c5897/async/websocket_async.mli#L44) takes a Reader and a Writer instance and transforms it into Pipe.Reader and Pipe.Writer that are connected to the other side of the Websocket. Why does it take a Reader and Writer and does not just create them for you? No idea, sorry.",1540798191.0
darrenldl,"Best if you could provide the code or a stripped down version of it, otherwise it'd be a lot of guessing.",1540514135.0
Kyo91,"The OS can cache frequently accessed files for you automatically. However, if you try to maintain your own cache in memory and take up a lot of space, then the OS will eject it to swap and you'll actually be pulling it from disk. Not saying that's happening here, but it's an example of how this can happen.",1540526201.0
jinwoo68,"Maybe because the data in the cache are not colocated? You said it’s an array of bigarray so it’s possible that each bigarray is located far from each other, and it causes many cache hit misses.

Probably the data in the file are sequentially accessed and the prefetching works quite well.",1540477615.0
rand7plan0,"I just found that it wasn't a problem with OCaml, but apparently, as I use OpenGL, calling `Gl.finish ()` at end of rendering, started something that took time *after* `Gl.finish` had returned.... 

Solution; remove `Gl.finish`

Thanks for the guesses (: 
",1540560814.0
asymptotically508,">it does not work

What doesn't work?",1540453187.0
_bruno_,"Open the developer tools (View -> Command Palette and find the command that says ""open developer tools""), and take a look at the console there to see if there is something useful in the logs.",1540473093.0
jeffsco,"This code seems to get the wrong answer for some inputs, so I'd say it can definitely be improved :-)

    # two_sum [2;7;11;15] 22;;
    - : int list = [3; 2; 1]

This happens because 11 + 11 = 22. But the rules explicitly say you can't use the same number twice. Aside from this minor point (pretty easy to fix), I can't think of a better solution than yours.",1540346680.0
AlexCoventry,"If you used a while loop or recursion, you could return as soon as you find the solution.",1540386322.0
brool,"Something like this might work for a recursive solution:

```
let find_index arr target =
  let rec fidx ix arr =
    match arr with
      | [] -> -1
      | h::tl -> if h = target then ix else fidx (ix+1) tl
  in fidx 0 arr

let twosum arr target =
  let rec twosumix ix arr =
    match arr with
      | [] -> raise Not_found
      | h :: tl ->
         let j = find_index tl (target - h) in
         if j != -1 then [ix;ix+j+1] else twosumix (ix + 1) tl
  in
  twosumix 0 arr
```",1540417099.0
infinitypanda,"`String.compare` might do what you want. Just pass it as the first argument to `List.sort`:

    List.sort String.compare <your_list>",1540309406.0
radlr,"`.ocamlinit` has nothing to do with `ocamlopt`. `.ocamlinit` is just an initscript for the `ocaml` interpreter and/or `utop`.

What you are looking for is the linker flags. You should have `ocamlfind` installed. Run `ocamlfind opt -o hwbin hello_world.ml -thread -linkpkg -package core`. If you are using more libraries (lwt for example) add them like this: `-package core,lwt`.

Actually you should probably use a build system.
[dune](https://github.com/ocaml/dune) is quickly becoming the standard build system for OCaml. Check out the example directory.",1540250544.0
jeffsco,"There's nothing in the Random module that supports this directly.

If the length of the list is greater than the number of different possible numbers (like a list of 20 numbers between 0 and 9), this is impossible by the pigeonhole principle.

If the length of the list is close to the number of different possible numbers (like a list of 10 numbers between 0 and 19), it's probably better to think of this as a shuffling problem. You can shuffle all the possible numbers, then take the first N of them.

If the length of the list is much shorter than the number of different possible numbers (like a list of 10 randomly chosen OCaml ints), then you can use a Set to keep track of the unique numbers you've seen so far.",1540079338.0
glacialthinker,"There are many ways to generate nonrepeating pseudorandom sequences. Some of the simple mod-based pseudorandom generators will cycle through all 32-bit ints, for example.

This article has an interesting take on the problem: https://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/ ... But even better is that the comments have pointers to a wide range of different approaches.
",1540103179.0
no_chocolate_for_you,"`to` starts with `start_value` and adds one at each iteration until `end_value` is reached; `downto` starts with `start_value` and *subtracts* one at each iteration until `end_value` is reached.  So which one you should use depends on whether `end_value` is larger or smaller than `start_value`.

Edit: If you use `to` and `end_value` is less than `start_value`, nothing will happen; same thing if you use `downto` and `end_value` is greater than `start_value`.",1539851324.0
eterps,"The difference is the direction:

```ocaml
for i = 0 to 9 do Printf.printf ""%d "" i done;;
0 1 2 3 4 5 6 7 8 9

for i = 9 downto 0 do Printf.printf ""%d "" i done;;
9 8 7 6 5 4 3 2 1 0
```

So the following has no result on stdout (should have used `downto` instead of `to` to let it count down):

```ocaml
for i = 9 to 0 do Printf.printf ""%d "" i done;;
```",1539868967.0
jeffsco,"Your function works to read ints from a file, but it prints them rather than making a list.

Since you're learning OCaml (I assume), you should probably aim for a recursive solution.

So you want to write a function that reads one int, then calls itself recursively to get the rest of the ints. Since you also need to open and close your input file, this recursive function should be a ""helper function"" called internally.

So your code would look something like this:

    let read_list_int (x : string) : int list =
        let rec helper chan =
            try
               let i = read_one_int_from chan in
               i :: helper chan
            with End_of_file -> []
        in
        let in_chan = open_the_file in
        let result = helper in_chan in
        let () = close_the_channel in_chan in
        result

I haven't tested this code, but that's probably for the best since you're supposed to be learning OCaml :-) However I think it returns the ints in the same order as in the file (not reversed).

It would be an exercise for the reader to rewrite this so that it's tail recursive.",1539402235.0
flexibeast,[This section of the OCaml manual](http://caml.inria.fr/pub/docs/manual-ocaml-4.07/coreexamples.html#sec9) gives an introduction to OCaml lists.,1539402263.0
ErwanLikesRacketLang,">Exit gracefully when a signal is received (#1366, @diml)

Thanks you @diml

(link: https://github.com/ocaml/dune/pull/1366/files)",1539364041.0
news_at_111111111111,Exclusively printf statements.  I don't know any professional ocaml devs that really do anything else.,1539269364.0
das_kube,"I use a combination of:

- defensive programming (plenty of assert, private types/private aliases, isolating in modules, etc. ie leveraging the type system)
- `Format.printf` that I temporarily add when debugging
- logging statements with a configurable level (all my programs have a `--debug <int>` option somewhere). This also entails that most types have a pretty-printer.",1539360785.0
alain_frisch,"Mostly print statement, but we(=LexiFi) have a generic debug printer (based on our runtime type extension) that can print value of almost any type as OCaml literals.",1539601403.0
sumofzeros,"That depends on the nature of the program you're developing, and the same sort of classification certainly occurs with other languages.

Is your program interactive, (pseudo) real time? Does it depend on third party software? Is this software traceable? (there are probably many other relevant questions).

Depending on these aspects, you might want to use different strategies: tracing, debugger, regression/unit tests, asserts, plain printf statements, etc.",1539327558.0
eterps,"I just discovered that [codi.vim](https://github.com/metakirby5/codi.vim) supports OCaml, as a long time Vim user and beginning OCaml dev that makes me very happy.

Having interactive feedback like that gets me up to speed much faster and is a great aid in my debugging efforts so far. I even use printf statements in addition to Codi to display intermediate results. The greatest thing is that everything has proper OCaml syntax highlighting which makes details in data structures easily discernible for beginning programmers.

I'll look into assertions/expectations tooling next, it would be nice if there was support for displaying diffs of data structures when actual results don't match expectactions. I already found out about [repeatable exploratory programming](https://blog.janestreet.com/repeatable-exploratory-programming/) but there is probably a lot more out there.",1539369697.0
lpw25,"Mostly printf. However, when working on things for which I have the bytecode version working -- in particular the OCaml compiler itself -- I use ocamldebug. I especially like ocamldebug for debugging a broken error or uncaught exception: I run the compiler until it errors/raises then I just step backwards until I get to where things went wrong, then after I had a look at what's going on there I step further backwards to find what caused the underlying issue.",1539407537.0
jordwalke,"Hi,

Andrey, Bryan, Ulrik,  Jared, Rauan and others from the Reason community are actually the ones who are building esy. I (Jordan) just help organize the project, and use esy daily to get stuff done. We haven't focused on marketing/docs much so apologies for the ambiguity.

**How esy relates to opam:** Opam is many things including a command line app, a repository, a package specification format, a submission process, as well as infrastructure that builds a curated list of quality packages at scale (with reverse dependency builds!)

Esy isn't an alternative to opam - you can use esy to partake in the opam ecosystem, and consume/publish opam packages. It's only an alternative to the command line `opam` app. (esy itself even uses some of Opam 2.0's internal libraries).  So no matter what, there's a lot of opam going on when you use esy.

**How esy relates to npm:** esy just doesn't stop at opam - it also builds a bridge from native Reason/OCaml to npm, which is the most popular package manager (at 4 billion package downloads per week). You can share/consume native esy packages on npm/Github before you're ready to submit them to opam repository. esy also lets you create cross-platform prebuilt binaries for arbitrary esy/opam projects and publish them to npm so that the largest number of people can try our your final application without compiling or messing with dependency management.

**My favorite feature:** My favorite thing about esy is its ultra-sandboxed workflow that feels similar to npm project management, automating away the concept of a switch and eliminating global state. esy is kind of like React(JS) but for package management:

All of your dependency source code, and their build artifacts, are purely a function of your `package.json`  (and lock) file. Every time you ever change/build your top level project, it's as if the entire world is reconstructed ""from scratch"" - a totally new build environment is constructed for each dependency in the dependency graph, and their build artifacts are recomputed. Their builds leave no global trace, except for an entry in an immutable build cache, which makes it very fast to rebuild the world all the time! Those package builds are automatically shared across all of your projects, so the more you use esy, the faster it will be to build new, unrelated projects. Builds are relocatable across the network so you can even share them with other people to make \_their\_ builds faster. It's pretty wild.

There's a lot of work to do, so if you'd like to help out, please drop by the Reason Discord server: [https://discord.gg/reasonml](https://discord.gg/reasonml)

Some things you could help work on or just play with:

&#x200B;

* Add more Reason/OCaml specific commands for project management.
* Add support for one-click releasing projects to brew/rpm/pip.
* Cross compilation integration.
* Help with our Windows effort.
* Help with docs.
* Packaging up popular apps/runtimes as sandboxed esy packages (vim/emacs/python as esy packages).
* Solidify using esy as a JavaScript package manager too (why not!)
* Add special commands for managing multi-package monorepos.",1539163389.0
theindigamer,Is Esy a Dune alternative? The examples make it look like it works on top of Dune...,1539112067.0
andrejbauer,"Yes, there is an [OCaml debugger](https://caml.inria.fr/pub/docs/manual-ocaml/debugger.html) and various editors have support for it.",1538770580.0
strobegen,"I left OCaml behind a long time ago but still have hope that efforts like Multicore OCaml may boost industry adoption dramatically at some point.

Maybe someone could summarize how OCaml ecosystem changed over the last 5 years?",1539364702.0
Freyr90,"You could just use modules:

    module type REGISTER = sig
      type t
      val on : t
      val off : t
      val to_int : t -> int
    end

    module Foo : REGISTER = struct
      type t = int
      let on : t = 1 (* turn FOO on *)
      let off : t = 0 (* turn FOO off *)
      let to_int x = x
    end

    module Bar : REGISTER = struct
      type t = int
      let on : t = 11 (* turn BAR on *)
      let off : t = 20 (* turn BAR off *)
      let to_int x = x
    end
    
    let write_register (type a) register_file (module Reg : REGISTER with type t = a) (data : a) =
      write_raw_memory register_file 42 (Reg.to_int data)

    write_register register (module Foo) Bar.on
    (* This expression has type Bar.t but an expression was expected of type Foo.t *)",1538661851.0
pqwy,"I would do it like this, eschewing even the modules:

    module Regs = struct

      type 'a reg = { offset: int; inj: 'a -> int; prj: int -> 'a }

      let bool ~offset : bool reg = {
        offset; inj = (function true -> 1 | _ -> 0); prj = (fun x -> x <> 0)
      }
      let int ~offset : int reg = { offset; inj = (fun x -> x); prj = (fun x -> x) }
    end

    let read_register register_file reg =
      read_raw_memory register_file reg.Regs.offset |> reg.Regs.prj

    let write_register register_file reg data =
      write_raw_memory register_file reg.Regs.offset (reg.Regs.inj data)

    let foo = Regs.bool ~offset:0x1000
    and bar = Regs.bool ~offset:0x2000

A register is just a correspondence between 'a and int, coupled with an offset. With that, you can uniformly create all kinds of typed registers without adding variants, modules, or types:

    let interesting ~offset =
      let inj = function
          `This  -> ...
        | `That  -> ...
        | `Bof x -> ...
      and prj = function
          ... -> `This
        | ... -> `That
        | ... -> ... in
      Regs.{ offset; inj; prj }
",1538671770.0
octachron,"Your problem has little to do with covariance. If you have a `GADT` of type `a t` and you wish to  observe the possible types of `a`, you need to pattern match on the GADT:

    let write_register (type t) register_file (register : t register) (data : t) =
      let (register, data): int register * int = match register with FOO -> FOO, data | BAR -> BAR, data  in
      write_raw_memory register_file (offset_of_register register) data;;

Note that this only works because `FOO` and `BAR` have both `int register` for types. Since there is no dependencies between values and data, this is a sign that GADTs are not a good match for the problem at hand. In fact, it would be easier to rewrite the previous code as

    let write_register register_file register data =
      write_raw_memory register_file (offset_of_register register) data;;

Modules (and functors) seem to be a better path. Another option is to use a phantom type `type 'a register = int` and then defines a functor to generate new independent register subtypes.

    type 'a register
    module Register(): sig
      type t
      val to_int: t register -> int
      val of_int: int -> t register
    end",1538669672.0
gmfawcett,"Here's a good starting point:

http://ocaml.org/learn/",1538582159.0
_ar7,"https://sketch.sh/new/ml is good for playing around with / sharing OCaml snippets online without having to install anything on your computer.

[Reason](https://reasonml.github.io/docs/en/let-binding) is an alternative syntax to OCaml with pretty good docs. You won't be able to use the same syntax, but the concepts are exactly the same. Also you can convert Reason syntax to OCaml on sketch.sh by pasting into a code block, and then switching the language to OCaml using the language selector.

[Real World OCaml](https://dev.realworldocaml.org/guided-tour.html) is pretty good for more intermediate stuff, but also has good sections on getting started.",1538584227.0
jeffsco,"What `List.fold_left` does is apply a function that builds up some cumulative value as it visits each element of the list. `List.map` applies a function to each element of a list and returns a new list of the computed values. So your description in (1) applies to `List.map`, not to `List.fold_left`.

But yes, you can use `List.map` to get the list of strings.

If you are allowed to use the OCaml standard library, there is a function `String.concat` that will do the rest.

If not, you can use `List.fold_left` to build up a result one string at a time. Because of the way `List.fold_left` works (left to right) you will want to reverse your list of strings first. Or you could use `List.fold_right` (which, however, is not tail-recursive.)",1538515478.0
cartesiancategory,"You have sort of flipped the idea between `fold_left` and `map` in your original ideas. /u/jeffsco's answer is good and explains how to use each one.

Here's a better way to tackle it:

 * Use `map` to turn each integer into a string, presumably using `string_of_int` as you said.

 * Use `fold_left` to combine all of the strings into one using `(^)` as you said.

You just seem to have the two functions confused.",1538518981.0
AlexCoventry,"Try 

    let string_of_intlist( x : int list) : string = 
        x |> List.map string_of_int |> String.concat ""; ""

This is better than constructing the concatenated string on the fly with `fold_left`, etc., because that's quadratic time complexity, and this is linear.",1538526103.0
darrenldl,"In this specific case, you can obviously replace `_` with an actual name.

In the general case, you can use `_ as x` syntax, where x is the desired name.

In above case, you can do `(k, _ as x) -> Some x` for instance.",1538463075.0
mookid11,"_ can't be matched. it has its won representation in the parser. you can match `k,_v` and capture `_v` but it's bad style.

Use simply `k,v` instead.",1538496857.0
iguer,The way you are matching on 'h' to get a 'k' (or something else) is not correct. The match introduces a new variable 'k' that has nothing to do with the parameter k. You should introduce another name (v for instance) and test if its value is equal to k's or not.,1538464532.0
jeffsco,"It seems like you're losing heart right at the moment you should be applying your function `f`. In this case:

    | L e -> lol

wouldn't this be the time to be mapping `f` over the list `e`? Why are you returning `lol`, which is essentially an empty list?

I also suspect you should be making a recursive call for *both* parts of the pairs `P (y, z)`. And you should be returning  a pair in that case (so I would assume).

It's pretty straightforward to use `List.map`:

    # List.map (fun n -> n * 2) [1; 3; 5];;
    - : int list = [2; 6; 10]",1538456601.0
andrejbauer,"You did not specify whether `f` should be applied to the `L` alternative recursively or not, so here are both options:

    type printable =
      | B of bool
      | I of int
      | C of char
      | S of string
      | L of int list
      | P of printable * printable

    let f_on_int_list_1 ( f: int -> int) (p: printable) : printable =
      match p with
      | L lst -> L (List.map f lst)
      | x -> x

    let rec f_on_int_list_2 ( f: int -> int) (p: printable) : printable =
      match p with
      | L lst -> L (List.map f lst)
      | P (p1, p2) -> P (f_on_int_list_2 f p1, f_on_int_list_2 f p2)
      | x -> x
",1538461608.0
salade,"Nice! Can this work with dune to figure out the right compilation command for the current buffer instead of trying a ""default"" one? What's a good workflow in that case?",1538396102.0
jdh30,"Wow, very cool!",1538415327.0
cartesiancategory,"OK so here's what's going on from what I can see.

`split` is just using some internal auxiliary helper function `aux`, presumably because that function is tail-recursive.  So what we really need to do is analyze `aux`.  I'm not sure if you're familiar with this syntax, but the following notations are equivalent:

1) Using explicit parameter naming:

    let foo param =
      match param with
      | p1 -> e1
      | ...
      | pn -> en

2) Using the `function` keyword:

    let foo = function
      | p1 -> e1
      | ...
      | pn -> en

Ostensibly the advantage of this is to avoid naming parameters that you only use once, and then only to pattern-match on it right away.  Basically, whenever you see the `function` keyword, what it means is that the last parameter to the bound function is not given an explicit name, and instead it is pattern-matched on right away.

Thus we see that `aux` really accepts _three_ parameters: `i` (some indexing number), `acc` (some accumulator), and a third unnamed parameter that seems to be a list.  Then, when `split` calls `aux`, it passes in `n` for the indexing parameter, `list` as the unnamed parameter, and `[]` as the initial accumulator value.

What is `aux` then doing?  Well in the most general case `n <> 0` and `list <> []`, so we will end up doing `aux (i-1) (h::acc) t`. What this is doing is popping off the head of the passed-in list, throwing it onto the accumulator instead, and then decrementing the indexing parameter by 1.

So if [1;2;3] is the initial list, then after one recursive call the list will become [2;3] while the accumulator will become [1]. This recursive process repeats until `i` hits 0, in which case a pair is returned: the accumulator at that point (but reversed) and then the rest of the remaining list.  So let's say that `n` is initially `2` and `list` is originally `[1;2;3;4;5]`. I encourage you to work through the recursive calls, but basically here's what happens:

        split [1;2;3;4;5] 2
    --> aux 2 [] [1;2;3;4;5]
    --> aux 1 [1] [2;3;4;5]
    --> aux 0 [2;1] [3;4;5]
    --> (List.rev [2;1], [3;4;5])
    --> ([1;2], [3;4;5])

Thus, `split` is rather aptly named: it takes the list `list` and splits it into two pieces of a pair, where the first `n` elements are on the left side of the pair and all of the remaining elements are on the right side of the pair.

Then, we should examine what `rotate` does. The first thing I see it doing is finding the length of the passed-in list. The next part is really confusing and I honestly think is bad style. When you see this:

    let n = if len = 0 then 0
            else (n mod len + len) mod len

The `n` on the LHS is a new name and the `n` on the RHS is actually the passed-in parameter to the function `rotate`. This is really bad style because it's confusing to just shadow things like this. So in any code below this within `rotate`, the `n` will always refer to the re-bound `n`, and never the passed-in parameter `n`. A better idea is to name the LHS `k` or something so that nobody gets confused (especially if you want to change the code).

Anyway, that line seems to be binding `n` to either 0 (if `list` is empty) or otherwise some mathematically-determined number between `0` and `len-1`, where `len` is the length of `list`. What that mathematical number is doing is just ""normalizing"" `n` so that its index is always in range. If `0 <= n < len`, then `n` stays the same. Otherwise, if `n >= len`, the number is ""wrapped around"" and counted again from 0.  So if `len = 3` and `n = 5`, then `n` becomes 2. The reason for the two sets of `mod`s is to account for negative `n`, presumably.

After that, the code figures out how to rotate the list based on what `n` is. If `n` is 0, then you are saying ""rotate starting at the beginning index"", which is just everything. So the original list is returned. In the other case, we split the list into two parts: the first `n` elements and the rest.  Then, we take the rest and put it in front of the first `n` elements.

So in our example from above, if we had `n = 2` and `list = [1;2;3;4;5]`, we would split that into `([1;2], [3;4;5])` and then finally return `[3;4;5;1;2]`. Thus we have ""rotated"" the list around the first two elements.",1538335690.0
PrimaryBet,"Suppose we do:
    
    rotate [1; 2; 3; 4; 5] 2

In effect this will happen:

    [1; 2; 3; 4; 5]
         ^
     split point
    
    [1; 2] [3; 4; 5]
      a        b
    
    b @ a = [3; 4; 5; 1; 2]
",1538335731.0
AlexCoventry,"You can run this under the [debugger](http://caml.inria.fr/pub/docs/manual-ocaml/debugger.html) to get some more information about what it's doing, although you need to narrow the types to print the intermediate data.

    let split list n =
      let rec aux (i : int) (acc : int list) = function
        | [] -> List.rev acc, []
        | h :: t as l -> if i = 0 then List.rev acc, l
          else aux (i-1) (h :: acc) t  in
      aux n [] list
    
    let rotate list n = 
      let len = List.length list in
      (* Compute a rotation value between 0 and len-1 *)
      let n = if len = 0 then 0 else (n mod len + len) mod len in
      if n = 0 then list
      else let a, b = split list n in b @ a;;
    
    let eg_list = [1; 2 ; 3 ; 4; 5] in
    rotate eg_list 3 |> List.map string_of_int |> String.concat "" "" |> print_string;
    print_string ""\n""

Here's an example interaction with the debugger:

    ubuntu@ubuntu-VirtualBox:~/tmp$ ocamlc -g eg.ml && ocamlrun a.out
    4 5 1 2 3
    ubuntu@ubuntu-VirtualBox:~/tmp$ rlwrap ocamldebug a.out 
    	OCaml Debugger version 4.06.1
    
    (ocd) r
    Loading program... done.
    4 5 1 2 3
    Time: 137
    Program exit.
    (ocd) break Eg.split
    Breakpoint 1 at 38764: file eg.ml, line 2, characters 3-186
    (ocd) reverse
    4 5 1 2 3
    Time: 26 - pc: 38764 - module Eg
    Breakpoint: 1
    2   <|b|>let rec aux (i : int) (acc : int list) = function
    (ocd) step
    Time: 27 - pc: 38780 - module Eg
    6   <|b|>aux n [] list
    (ocd) step
    Time: 28 - pc: 38616 - module Eg
    4     | h :: t as l -> <|b|>if i = 0 then List.rev acc, l
    (ocd) step
    Time: 29 - pc: 38668 - module Eg
    5       else <|b|>aux (i-1) (h :: acc) t  in
    (ocd) step
    Time: 30 - pc: 38616 - module Eg
    4     | h :: t as l -> <|b|>if i = 0 then List.rev acc, l
    (ocd) p i
    i: int = 2
    (ocd) p h
    h: int = 2
    (ocd) p t
    t: int list = [3; 4; 5]
    (ocd) p l
    l: int list = [2; 3; 4; 5]
    (ocd) step
    Time: 31 - pc: 38668 - module Eg
    5       else <|b|>aux (i-1) (h :: acc) t  in
    (ocd) 
    Time: 32 - pc: 38616 - module Eg
    4     | h :: t as l -> <|b|>if i = 0 then List.rev acc, l
    (ocd) 
    Time: 33 - pc: 38668 - module Eg
    5       else <|b|>aux (i-1) (h :: acc) t  in
    (ocd) 
    Time: 34 - pc: 38616 - module Eg
    4     | h :: t as l -> <|b|>if i = 0 then List.rev acc, l
    (ocd) p acc
    acc: int list = [3; 2; 1]
    (ocd) 
    ",1538341180.0
laylomo2,I NEED SOME OMG,1538170481.0
oldmanstan,I just went and grabbed a set after seeing this!,1538166431.0
news_at_111111111111,Where's the corresponding emacs plugin?,1538151255.0
SteeleDynamics,Holy Crap!!,1540693944.0
wk_end,"are you actually compute-bound? it looks more like you're IO-bound, in which case I think you'd likely more mileage out of using `async` or `lwt` than anything.",1537415662.0
andrejbauer,There is [multicore OCaml](https://github.com/ocamllabs/ocaml-multicore).,1537421960.0
yunfeng_lin,"Great post! Ocaml does have a very compelling story! We are using Scala at work. Ocaml code is much more readable and compiled super fast, whereas Scala some time is too noisy and takes forever to compile:).

I don't understand why the dislike to Jane Street stdlib Core/Base though. It is obvious that more and more people in the community are using Base from Opam statistics, and frankly, Jane Street's code base has the highest quality/consistency ...",1537468411.0
kstarikov,A bit of off-topic: do you want to extend your post to F#?,1537448566.0
shefmichelle,"I'm certainly not an OCaml expert, but the line with the syntax error is missing an `in`, which I think is required because this is a let binding inside a function. Someone with more experience might be able to give a better answer...",1537392503.0
spicausis,let a = b _**in**_ ...,1537392528.0
argent_smith,BTW it's always a good thing to post the error output as well ;),1537521593.0
Chimrod,"Here are some syntax which will prevent you some strange errors :

Always surround match pattern by begin … end like : (this is needed in nested pattern matches)

    begin match with
    | … ->
    | … ->
    end

Always surround your if then else with begin or paren :

    if (…) then (
    
    ) else (
    
    )

and so on",1537458812.0
argent_smith,Top-level \`let\` \[should be at least \`let ... in ...\`\] in \`else\` branch perhaps?,1537521532.0
alfredmuffin,Just as I started learning ocaml :),1537354227.0
jeffsco,"    let rec aux n i = function
    | [] -> []
    | h :: t -> if i = n then aux n 1 t else h :: aux n (i + 1) t

    let drop list n = aux n 1 list

(This code doesn't look right to me, but I believe the translation is faithful.)",1537315923.0
VictorNicollet,"Hello there. [I believe I wrote the code you're looking at](https://github.com/VictorNicollet/99-Problems-OCaml/blob/master/1-10/p09.ml), so I am very flattered :-)

Consider the imperative pseudocode that does the packing: 

    current = [] (* the currently ""open"" pack to which we are appending *)
    acc = [] (* the list of all closed packs generated so far *)
    while list not empty:
      let a = take first element of list
      current += a (* append 'a' to the current pack *)
      if (there is no next element) or (the next element is not a):
        (* this means this 'a' was the last of its pack, so we close the
           current pack and open a new one. *)
        current += acc
        acc = []
    return acc
    
Translating this to functional OCaml has two difficulties: first, you cannot append to the end of a list, you can only prepend to it, so both `acc` and `current` will be in reverse order. You don't care about `current` because it contains only equal elements, but you still need to reverse `acc`, hence the use of `List.rev` at the end. The second difficulty is turning an imperative loop into a tail-recursive function, but this is just mechanical translation (variables become function arguments, end of loop becomes recursive call).

The straight translation of the above would look like this: 

    let rec aux current acc list = 
        match list with [] -> acc | a :: t ->
          let current = a :: current 
          let acc, current = match t with 
             | h :: _ when h = a -> (acc, current)
             | _ -> ([], acc :: current)
          in
          aux current acc
    in
    aux [] [] list

But it can be made more elegant by using multiple tail calls instead of re-binding to 'aux' and 'current: 

    let rec aux current acc list = 
        match list with [] -> acc | a :: t ->
          let current = a :: current 
          match t with 
             | h :: _ when h = a -> aux  current acc
             | _ -> aux [] (acc :: current)
    in
    aux [] [] list

And even more elegant by merging the two `match` statements into one, which is the code you are looking at.",1537299933.0
octachron,"When seeking help for homework, you should try to ask questions, the more precise the better. Merely, copying the wording of your exercise conveys little information about what is giving you trouble and make it hard to help you. Is recursion the issue at hand? Is it reading the type of the function? Did you try to see what happens with simple examples: `pack []`, `pack [1]`, `pack [1;1;1]`, pack `[0;0;1;1;1]`, `pack [0;1;0]`?",1537289803.0
juloo65,"This function ""pack"" identical consecutive elements. eg. `pack [1; 2; 2; 3; 3; 2]` returns `[[1]; [2; 2]; [3; 3]; [2]]`",1537289306.0
cies010,Not the answer to your question. But did you see the http/af lib?,1537194562.0
sizur,I had to click 4 links to get idea of what Dune is.,1537257995.0
octachron,"The use of variants with single constructor is quite non-idiomatic. In particular, `decode_attempt` would often be written as

    type decode_attempt ={key:key; ?:int; text:plain }

Similarly, the key and encoded types might be better encoded as abstract types. Nevertheless, the main problem in your code is that you missed the fact that you can destructure with only `let`

    let Xor.Decode_attempt (Xor.Key v, _, _) = attempt in

(using your definition of decode_attempt).",1537023683.0
permetz,"Some of your choices are indeed _not_ idiomatic. I’m on a mobile phone right now so replying in depth is hard, but since your types and approach are unusual you will, as you have noticed, end up with awkward constructions. I will try to reply more later. ",1537005882.0
andrejbauer,You came from Haskell didn’t you? Your code is more or less Haskell. ,1537011586.0
wk_end,"Nope, the collector stops the world; ocaml is very single-threaded.

While this is kind of sad in terms of making collections slower, it does help to make run-time performance more predictable; while nowhere near as close as C, you can still generally surmise what assembly code your ocaml's going to compile down to, including when it's going to hand off execution to the runtime/what the runtime is doing.

When I wrote ocaml full-time we sometimes needed to write extremely timing and latency sensitive code; in those cases we would write our code in such a way that we knew the GC wouldn't be invoked. The predictability of the ocaml runtime makes that possible.",1536968438.0
rbjorklin,There is  a project ongoing to create a concurrent GC: https://github.com/ocamllabs/ocaml-multicore/projects,1536992330.0
Dean177,"Here are some exercises: https://github.com/janestreet/learn-ocaml-workshop.

I have quite enjoyed working though advent of code problems for 2015, 2016 & 2017 too https://adventofcode.com/2017

",1536856064.0
laylomo2,You could also do the OCaml MOOC which starts next week: https://www.fun-mooc.fr/courses/course-v1:parisdiderot+56002+session03/about,1536864469.0
donatasp,"I'm no ocaml expert, but I think I would do reading part this way:

    let () =
      let ic = open_in ""hello.txt"" in
      try
        while true do
          let line = input_line ic in
          print_endline (""line: "" ^ line)
        done
      with
        End_of_file -> close_in ic
",1536733967.0
shtanton,"open\_in has the signature of 'string -> in\_channel'

This means that you give it a filename and it will give you a channel for reading from that file.  It gives you a channel instead of the text as a string though because if you read from a very large file, copying the whole thing to memory is a mistake.  Channels allow for reading and handling a part of a file at a time so in order to get a string from it, you would use input\_line to get one line at a time etc.

If you know that you are working with small files and it is safe to load them into memory, you can use:

    let rec string_of_channel ?(acc="""") ic =
      match input_line ic with
      | exception End_of_file -> acc
      | line -> string_of_channel ~acc:(acc ^ ""\n"" ^ line) ic

Which will recursively get each line and join them together, though of course you can change the initial value and combining operation to have it prepend to a list or whatever you need to do.

You should also close a channel once you're finished with it.

The documentation that I based this one is here [ocaml pervasives](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html)

&#x200B;

EDIT:

Modified the code to use match instead of try for tail recursion ;)

ta u/juloo65",1536737874.0
rnt111,Why so much extreme downvoting for beginner questions in the ocaml reddit? You almost never see this in the Haskell reddit.,1536849341.0
Denommus,"Cons: still no support for multicore, fewer libraries in comparison to other languages, a type system that's sometimes counter-intuitive (like when the object system is involved).

Pros: very expressive, powerful type system that can prove a lot about the code and provide many useful abstractions, the best module system out of any commercial language, the best web framework I have ever used, a very good parser generator (menhir). ",1536715731.0
rnt111,"**Cons:** outdated tooling, OO that nobody uses in favor of modules, worst FFI ever, dozens of of 3rd party library to do anything ""real world"", no IDE, extreme NIH (Not invented Here) in codebases due to academia (where using standard libraries is a crime), no out-of-the-box cross compilation.

**Pros:** LGPL License (no longer the godawful Q license), good single thread performance, OPAM, good REPL, good ARM/ARM64 support/performance",1536849161.0
Miltnoid,No ad-hoc polymorphism (yet) is pretty annoying.,1536812146.0
juloo65,"If you have read [Real World OCaml](http://dev.realworldocaml.org/index.html), I suggest you go straight to coding challenges websites (eg. HackerRank or CodinGame)",1536695962.0
locaml,The [Ocaml MOOC](https://www.fun-mooc.fr/courses/course-v1:parisdiderot+56002+session03/about) provides you a way to learn the language and you get to write code that is verified online.,1536747709.0
spencerwi,"Hey, you've been pretty active in this sub asking a lot of specific-but-somewhat-introductory questions about OCaml. I recommend starting with a tutorial like [Real World OCaml](https://dev.realworldocaml.org/toc.html) for a guided tour of the language and its syntax. After using it for a bit, I think answers to some of your questions might reveal themselves more clearly. :)

&#x200B;

Good luck with your learning!",1536663550.0
wk_end,"What does ""search through"" mean? What do you want `check` to return? A bool indicating if the item was found in the list? Can you give us some context behind why you want to ""search through"" the list? Are you just asking us to do your homework?

Also, that's not idiomatic ocaml; we generally use curried functions and would write `check 2 [1; 2; 3]`.",1536624276.0
montgras,"Use the ""mod function"" and check that it is zero. I am not sure how to use it in ocaml. Might be i%j",1536615750.0
andrejbauer,"Who are these people who promote Haskell in relation to HoTT? Do you mean things like [cubicaltt](https://github.com/mortberg/cubicaltt)?

OCaml is not directly used for ""HoTT"". It's used as the *background language* in which proof assistants are implemented. The same goes for Haskell. You can't really do theorem proving directly in OCaml. Sometimes people in Haskell pretend that they can, but don't listen to them, it's a trick.

My advice would be, if you're interested in learning how to formalize HoTT then learn that directly (either via Coq or Agda). If you have an independent interest in programming, then it would help if you explain what aspect of programming you're interested in. Just programming in general? OCaml gives you a slightly wider picture of programming languages, as it has features that Haskell does not. Haskell is pretty unique with its purity and laziness.
",1536246033.0
BoinkGoesTheScience,"As a programmer who first tried Haskell and then later actually got into OCaml, I would recommend OCaml first. I’m not mathematician, but I found Haskell’s tooling much less friendly as compared to OCaml. Especially if you’re relatively new to programming, I’d start with OCaml since it’s less likely the tooling will get in your way. ",1536247486.0
fab13n,"Haskell is cleaner syntactically, and its laziness allows a lot of elegance. However, I believe that first learning a language with strict evaluation gives a better grasp on algorithmic complexity (figuring out the asymptotic speed, up to a constant multiplication, of an algorithm as a function of its inputs' size). So I'd vote for OCaml.

Moreover, IIRC it's hard to do a lot of Coq without some knowledge of OCaml (but I learned OCaml long before Coq, and forgot almost everything about the latter, so I may misremember).",1536253207.0
PM_Me_Bayes_Theorem,">categorical logic, homotopy type theory and functional programming

I have a somewhat opposite experience. I was in theoretical particle physics grad school, and had to learn   
OCaml at some point -- it was promoted as a good choice of language for heavy automated symbolic calculations   
I needed to implement. After that, I got much deeper in those mathematical subjects than I expected to.  
My path was: OCaml -> functional programming -> categorical logic -> homotopy type theory.  


>What resources do you suggest

* I recall that reading the first chapters of the [OCaml reference manual](https://caml.inria.fr/distrib/ocaml-4.05/ocaml-4.05-refman.pdf) was enough for me to start writing useful code. 
* If you are into online courses, I'd definitely recommend [Introduction to Function Programming in OCaml](https://www.reddit.com/r/ocaml/comments/99r8u4/introduction_to_functional_programming_in_ocaml/) I had fun finishing it even though I didn't learn anything new.

>some Coq-like applications

* Check out [this book](http://www.cambridge.org/fr/academic/subjects/computer-science/programming-languages-and-applied-logic/handbook-practical-logic-and-automated-reasoning?format=HB&isbn=9780521899574). Examples are in OCaml, although quite outdated version of it.
* As shameless plug, [try the online proof-assistant](https://try.imandra.ai/) that reasons about pure subset of OCaml    


   
",1536305385.0
PM_ME_UR_OBSIDIAN,"Haskell is a great language to do research in, but a questionable choice for learning functional programming. OCaml is a better first language.

That being said, being a mathematician (and being uninterested in writing production software) I would strongly recommend going straight for Coq via the [*Software Foundations*](https://softwarefoundations.cis.upenn.edu/) interactive workbook. The first volume is enough to learn the basics of type theory and functional programming, and can be done in 20-50 hours depending on your pace. I have never worked with a better resource for self-study in any field. Adam Chlipala's *Formally Reasoning about Programs* and (later) *Certified Programming with Dependent Types* are great companion reading.

Once you feel like you've had your fill of Coq and have tentatively exhausted *Software Foundations*, OCaml and Haskell are both good next steps. I'm partial to OCaml at first for the gentler learning curve, but a lot of very interesting type fuckery is impossible in OCaml (contra Haskell and Coq).

You're on the verge of a very exciting journey. May it take you far.",1536370349.0
notfancy,"Haskell's laziness and class system often let you express some ""mathematical"" ideas more directly and succinctly than in OCaml, but in general programs are interexpressible with more or less elbow grease. One standard exercise is to express a tower of algebraic structures (e.g. semigroup, monoid, group, field, ordered field, archimedean field, euclidean field, vector space…) generically. Both languages can do this in different styles having different strengths and weaknesses.

For an example of mathematical programming that (mostly) doesn't involve (character) strings, graphs or numbers, you might find [this post by Martín Escardó amusing](http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/) (see also [the corresponding discussion on Reddit.](https://www.reddit.com/r/haskell/comments/2k0xg2/seemingly_impossible_functional_programs/)) Note that Andrej Bauer himself prefers ML to Haskell, so there's nothing that says that a ""pure"" mathematician has to choose Haskell over ML.",1536244304.0
felis-parenthesis,"I think that you would enjoy OCaml and [HOL light](https://www.cl.cam.ac.uk/~jrh13/hol-light/). HOL light is a a theorem proving in the LCF (logic of computable functions) tradition. The core is implemented in OCaml. Then the type system is used to seal to the core. Finally you interact using the OCaml REPL (read-eval-print-loop). You prove theorems by writing programs that create theorems by calling the sound logical manipulations sealed in the core.

At the bottom of the [wikipedia page](https://en.wikipedia.org/wiki/HOL_Light) they refer to a book

> This formulation of type theory is very close to the one described in section II.2 of Lambek & Scott (1986). 

which [seems to be close to your interests](http://www.cambridge.org/gb/academic/subjects/mathematics/logic-categories-and-sets/introduction-higher-order-categorical-logic?format=PB)",1536325352.0
silencer6,"    let rec pos = function
    | [] -> []
    | x :: xs ->
      if x < 0
      then pos xs
      else x :: (pos xs)
",1536092454.0
jdh30,"    let pos = List.filter ((<=) 0)

&#x200B;",1536108074.0
potterman28wxcv,"How to execute an Ocaml code : [https://caml.inria.fr/pub/docs/u3-ocaml/ocaml-steps.html](https://caml.inria.fr/pub/docs/u3-ocaml/ocaml-steps.html)

Alternatively, you could have done a Google search on your error, which would have given you the reason why this error message happens : [https://stackoverflow.com/questions/34363660/ocaml-unbound-value-load-when-trying-to-load-module](https://stackoverflow.com/questions/34363660/ocaml-unbound-value-load-when-trying-to-load-module)

(this is on the first page of [https://www.google.com/search?hl=en&q=unbound%20value%20use%20ocaml](https://www.google.com/search?hl=en&q=unbound%20value%20use%20ocaml) )",1536095154.0
permetz,"It's trivial to install OCaml+OPAM on a Mac. However, as you haven't really explained what's been going wrong for you, it is hard to help effectively.",1535827377.0
_ar7,You didn't link to a program,1535825675.0
chrisn96,"My preferred editing/debugging method for OCaml is vscode. Download the OCaml plugin from the marketplace. Then go to the debug bar and click run, it'll autogenerat a debug config file and you can edit the name of the '.d.byte' file of your compiled program.  Then you just click run.


When you install the OCaml vscode plugin, it'll probably notify you that it can't find some OPam packages. So just install them with OPam as the messages popup in vscode.

To compile the program to a .d.byte file you should add a debug configuration in your Makefile that will output this type of executables",1535989430.0
elliottcable,"Start by installing OPAM, the software that installs and manages OCaml itself nowadays; it’ll make everything ten times easier:

    sh <(curl -sL https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)

Then, you can tell OPAM to configure itself, and install an OCaml:

    opam init # and follow the instructions … then,
    opam switch create default 4.07.0 # or similar

Once you’ve done the above, you’ll “have OCaml installed” on your Mac … but we can’t really help you with the installation of the next part (your program), unless you give us some more details. `(=`

(I typed this on my phone; forgive any typos, and double-check my commands 🤣)",1535880397.0
ollehar,"> Alms is a general-purpose programming language that supports practical affine types. To offer the expressiveness of Girard’s linear logic while keeping the type system light and convenient, Alms uses expressive kinds that minimize notation while maximizing polymorphism between affine and unlimited types.

> A key feature of Alms is the ability to introduce abstract affine types via ML-style signature ascription. In Alms, an interface can impose stiffer resource usage restrictions than the principal usage restrictions of its implementation. This form of sealing allows the type system to naturally and directly express a variety of resource management protocols from special-purpose type systems.

Alms is a research prototype language that was made ~6 years ago. It has some interesting aspects, I think, especially when comparing with e.g. Rust and Pony of today.

Alms supports universal (""normal"") types and affine types (""use at most once""). A related paper by the same author describes how the full URAL lattice (unlimited, relevant, affine, linear) can be supported in one language using type-classes: http://users.eecs.northwestern.edu/~jesse/pubs/linearity2014/

There's a talk by the author on Mozilla Air, but for some reason you have to login to see it now? I don't know. This used to be the working link: https://air.mozilla.org/alms/",1535570525.0
drbolle,I take part:-).,1537221480.0
darrenldl,"Tried closing `oc` as well?

Also your Python server does not seem to do any clean up, you seem to need to at least call `shutdown`([see here](https://docs.python.org/3.4/library/socketserver.html#socketserver.BaseServer.shutdown)) for cleanup.",1534997932.0
rbjorklin,I’m not well versed within this so I might be completely wrong but don’t you need to close the out channel as well?,1534997930.0
coder543,"> Cryptocurrency is a domain where correctness really counts. As such, a cornerstone of our approach is a focus on building reliable software through the use of statically-typed functional programming languages. This is reflected in our OCaml codebase and style of structuring code around DSLs, as well as in the design of the smart-contracts platform they're developing

Performance is _also_ very important in a crpytocurrency that wants to scale, and OCaml doesn't support multicore parallelism (yet). What makes OCaml a better choice here than Rust, which is heavily influenced by OCaml, yet offers stricter guarantees and better performance? I'm honestly curious.",1534567223.0
potterman28wxcv,"In France Ocaml used to be the first language you ever learn. I am pretty sure there is no requirement to learn Ocaml ; but I have found it certainly lacks in tutorials. And the jump from imperative to functional is certainly tough.

Don't hesitate to ask questions in the ocaml communities",1534322771.0
SkinnyGeek1010,"If you are used to a more C based syntax, i've found that ReasonML is an easier place to start learning OCaml, and then you can gradually learn the ML style syntax. I would also agree that learning functional concepts (map, reduce, recursion, etc..) in Python might be good since you're only learning the concepts at that point.",1534277481.0
Freyr90,"Try SICP and scheme, it will tell you quite a lot about programming in general. Anyway OCaml's barrier of entry is lower than that of Haskell, so you could just use it without any problems after java. I would also recommend you to read about type systems.

http://web.mit.edu/alexmv/6.037/sicp.pdf

https://softwarefoundations.cis.upenn.edu/

https://www.cis.upenn.edu/~bcpierce/tapl/",1534317682.0
shtanton,"Honestly I would recommend doing some functional programming in python first to get used to the paradigm, then learn the syntax.  Learning too much at once can really slow you down.  Other than that, probably not much else, once you know the syntax, the docs have nearly everything you need ",1534267863.0
argent_smith,“Real world OCaml” is a very good starting point.,1534326693.0
permetz,"I recommend just reading “Real World OCaml” and not overthinking preparing. The language isn’t that hard to learn, certainly not given your background. ",1534331170.0
AceJohnny,">For employment purposes, I am very interested in Ocaml.

Could you clarify this? Unless you're aiming for (...and have the chops for) JaneStreet or Facebook, I'm afraid the market for OCaml-aware developers is close to nonexistent, certainly compared to other mainstream languages.

Granted, you'll learn some useful programming concepts, but they'll be secondary to more immediate skills such as properly structuring your code as appropriate for the language you're using, development for testing/debugging, error handling, logging, etc...

I think it's great that you're thinking of learning OCaml, but don't overestimate its employment value.",1534282468.0
enverx,Read John Whitington's OCaml From The Very Beginning and do the exercises.,1534446515.0
yawaramin,"I'm a bit late, but my standard recommendation is to start here: https://www.coursera.org/learn/programming-languages

This course teaches Standard ML, which is a _very_ close relative of OCaml and has all of its most important aspects, like static typing with type inference, the module system, and the emphasis on functional programming. What little syntactic differences there are, you can easily bridge that gap with a standard OCaml reference.

Prof. Dan Grossman is a fantastic teacher, who explains at just the right level between beginner and advanced, and throws in comparisons to other languages like Java and C. So I believe you'll find the course quite approachable. At the very least, check out the lecture videos; they're short and quite instructive.",1538150183.0
alfredmuffin,I’ve been flirting with OCaml (coming from JS) for a while and this article series sealed the deal!,1534161627.0
languagehaxor,This was really nice. I found very useful.,1534100248.0
agambrahma,Huh? Why not mention the ocamltop repl?,1533957755.0
gasche,[part II](https://blog.acolyer.org/2018/08/10/bounding-data-races-in-space-and-time-part-ii/) is now out,1533888864.0
radlr,"Think of `let () = something` as a main function. Oftentimes you'll also see `let _ = something`. Both simply execute `something` and then terminate. OCaml itself simply executes modules from top to bottom.

`let () = something` additionally does a compile-time check to verify that `something` returns `()`. If you messed up and forgot one argument for `printf` (in this example `(read_and_accumulate 0.)`) the program would not compile since the only value that matches the pattern `()` is `()` itself.

[Later in the book there is an explanation.](https://v1.realworldocaml.org/v1/en/html/files-modules-and-programs.html#idm181618944736)

Edit: If you're curios [here is the grammar definition for let-bindings](http://caml.inria.fr/pub/docs/manual-ocaml/expr.html#let-binding). [As you can see](http://caml.inria.fr/pub/docs/manual-ocaml/expr.html#sec136) `let` can both bind expressions to names (as in `let x = 1`, technically also a pattern-matching) as well as match patterns like `let hd :: tl = [1; 2; 3]`, though the latter is rarely used due to being able to match only a single pattern. In fact  `let hd :: tl = [1; 2; 3]` will give you a compile-time warning due to it not matching the empty list `[]`.",1533456599.0
eras,"Something few books seem to tell you is:

OCaml *.ml files are sequences of phrases. Phrases are separated from each other with `;;`. One phrase is either a sequence of top-level statements (sometimes separated by whitespace due to ambiguity), or one expression.

Examples time!

Two phrases, each one expression:

    print_string ""hello"";;
    print_string ""world"";;

One phrase, with two top-level statements:

    let () = print_string ""hello""
    let () = print_string ""world""

EDIT: This is the Zen of writing OCaml programs without a single `;;`. Omitting `;;` makes it easier to move code into `struct`s where `;;` is not allowed (though I think language spec claims otherwise..), but on the other hand it may allow error messages to 'flow' into misleading places. YMMV.",1533649308.0
gasche,"There might be!

But note that ""Haskell is getting linear types"" is, as far as I can tell, quite a simplification of the current state, which is ""there is a language change proposal that is fairly invasive and has been somewhat controversial and is still being debated with no obvious final decision in sight"" (unless I missed some big news). (Not to say anything negative about the proposal, I find it quite interesting). I would prefer people to be precise about the difference between the two, instead of jumping from ""there is a precise proposal"" to ""language X is getting Y"" -- the latter you can say once an implementation has been *merged upstream*.",1533114239.0
yawaramin,"An OCaml/SML variant called LinearML was being developed a few years ago: https://github.com/pikatchu/LinearML

But its author has I guess moved on to other things.",1538157243.0
darrenldl,"**EDIT** : Please also read \[/u/testcross's comment\] [below](https://www.reddit.com/r/ocaml/comments/933e7p/job_prospects_for_ocaml/e3brrzf/). I forgot to look at OCaml's list, so there might be more positions than I previously thought.

Note that I have very limited knowledge, but I have been looking into getting a job that uses OCaml recently as I'm graduating, so thought I might share my very limited experience. This reply might end up being rubbish, but anyway.

Also note that I only looked at OCaml, I don't know anything about jobs using ReasonML.

You get a better chance in US, but not in Australia/Asia. But even then, not too many companies use OCaml to my limited knowledge. The companies that do use Rust/OCaml also tend to be cryptocurrency companies rather than the more traditional companies, which may be an important aspect to you.

If purely for career move(depending on your definition), I would look at something else honestly.

OCaml is quite popular in the academia and some R&D companies/organisations, just did not get picked up by too many companies presumably due to a higher barrier of entry.

I think a reasonable compromise is to go with ReasonML, since you don't miss out on anything from OCaml (I think), while allowing you to do web dev, which may be more important for the UI/GUI side of your work as the core parts are done in Java presumably.

Personally I'd still invest in ReasonML/OCaml just as a backup plan, cause FP, and also sometimes it's nice to know you did not miss any null pointer checks cause you don't have to.",1532953149.0
clockish,"Learning OCaml will do two things for you: teach you OCaml (duh); and, given your Java & JavaScript background, make you a better programmer/engineer in general by exposing you to some rather different paradigms.

As a career move, investing time in learning OCaml just so you're familiar with OCaml is not worthwhile, IMO. If your metric is being able to use the language for your work, study a more popular language like C++, Python, or Go (or C# or Swift, if you think your work might move towards applications on those platforms).

In the second regard—learning a different language to become better programmer—OCaml may still not be worthwhile as a career move *for you right now*. Compared to more popular languages, OCaml will probably broaden your horizons more (by virtue of OCaml differing a lot from Java & JS), but the paradigms you learn from OCaml will likely have less direct work applicability than the things you'd learn from, say, C++.

All that said: just go ahead and play around with OCaml, if it inspires you. It will not be a waste of your time. If you're concerned about career relevance, I might suggest trying C++11 instead (and the newer C++14/17/20 stuff, if it catches your fancy, but bearing in mind that super-new C++ is not always welcome in the workplace).

(FWIW: in my job I use a lot of C, C++, OCaml, and Python. Not doing full-stack development, though, so take my advice with a grain of salt.)",1533040293.0
gasche,"There was a [job ad](https://www.reddit.com/r/ocaml/comments/8wjqbu/looking_for_ocaml_developers_for_tezos_based/) on this subreddit just a few days ago, with no replies. I have the impression that the market is actively looking for more skilled OCaml programmers right now -- the Tezos people in particular seem very interested in hiring good engineers, and have remote positions.

It's hard to say whether that is a robust/stable trend (I wouldn't advise anyone to focus only on one single technology, for any single technology; but that's not what the poster had in mind anyway), but historically it seems that the number of OCaml jobs available over time keeps growing.

Also, having experience with one functional language helps get into the other, so efforts invested in OCaml can help get familiar with F# (obviously, it is a very close language), or Haskell or Scala, which also have the same kind of ""small but serious"" niche markets hiring profiles.",1532954934.0
reasonablecaml,"If you're interested in FP, pursuing it in a language/platform designed for it will always be a good move.

I'm relatively bullish on ocaml & reason considering FB's intentions towards and usage of it, but for the average developer it's not a particularly viable *career* move at present. 

From someone who worked front end from '09 - '16, it's reminiscent of picking up React during Backbone, or even jQuery's prime, not Angular's for reference. Essentially, it *will* help you in the current scheme of things, but you most likely won't be writing ocaml, reason, or anything like it professionally for a while yet.

And to be perfectly honest, a personal project with an something like an OCaml backend and Reason front end will probably make you sad in the same way using react in 2014/2015 after watching a Pete Hunt talk felt. *I wish I could use this every dayyyy*",1532955446.0
randomatic,"OCaml is a niche language (by popularity - no value judgement) in a market with very few programmers.  Facebook, Jane Street, and a bunch of startups are looking for ocaml programmers, and they are hard to find.  Given you sound like you're learning, if you have a project on github with ocaml people can review during interviews I think you'd have no problem.",1532961948.0
wk_end,"Jane Street doesn't require their hires to know OCaml - they put you through an OCaml bootcamp when you start. If I had to guess, most other companies that use OCaml are the same way.

My advice to you is to learn types and the functional programming style through whatever means or language you like. OCaml's a great way to do that, but so is Haskell or SML or Idris or Coq or...

Do that because it'll make you a better programmer, and being a better programmer will do more to get you a good job than having any particular language on your resume.",1532982307.0
testcross,"Ahrefs is always looking for ocaml/reason developers. Or people willing to learn ocaml/reason at work. I tend to think that there is a shortage of good ocaml developers. Many student learn ocaml but never try to use it in the industry. It's a bit sad. So don't hesitate to learn and apply.

There are plenty of places using ocaml: https://ocaml.org/learn/companies.html

Note that the list isn't complete. Uber has some ocaml and isn't listed for example. Grab has ocaml in their job offers. Many small companies or industrial companies aren't listed either.

In any case it worth to learn ocaml because it will teach you how to use types properly and improve from javascript.",1533001687.0
shtanton,"Honestly it seems pretty underused, aside from Jane street and maybe Facebook now that they have reason, I doubt many companies will be using it because it isn't well known enough.  I only use it for freelancing where that isn't really an issue",1532952388.0
param_module,"Please don't take what I'm going to say as condescension. 

I'm sorry to tell you this but you'd be better off using Haskell or Scala.

If you're using Scala for your next job, honestly knowing Ocaml helps a lot, like the ocaml people who use Scala write the cleanest most maintainable scala I've ever seen by basically mimicing the module system in scala, like the typelevel code from the people with haskell mindsets code winds up to be a mess of lazy implicit vals all over the place. 


The situation is pretty much like that of Erlang's, the companies that hire will only hire people who straight up enjoy reinventing the wheel, who are also generally either really good systems hackers, big on PL theory, or both. 

Like there aren't any jobs out there to build crud apps, and it's not because we as a community are super geniuses or anything like that, it's a limitation brought on by the ecosystem because does your average web developer want to reinvent the wheel constantly and does your company want to have to open source most of what they write. 

As to why is it so beneficial to financial companies, I'm not super into finance, but like it works well for finance because, 
it's really easy to review if you always use MLi files. 

The module system is more powerful than haskell's type classes, and doesn't make it hard to decipher with inheritance like in OO, and out of any language I've used MLs has the best level of modularity, so it's super easy to swap out functionality. 

It has the best C interop story I've ever seen.

It's run time is light weight, the GC is really good, and in terms of single threaded performance it's almost as fast as C. 

",1535140286.0
BoinkGoesTheScience,"I've found OCaml to be much easier to get into than Haskell. The tooling is easier to use and the Visual Studio Code plugin with Merlin is great. Makes starting out much easier if I'm getting feedback as I type. I like that OPAM will tell me what packages I need to install with the current system's package manager. 

[More of my experiences.](http://donut2d.tumblr.com/post/171205516399/my-experiences-building-a-url-shortener-with-ocaml)",1532542888.0
chrismamo1,"Mutability is available with minimal hoop-jumping required.

Excellent resources (especially if you'd like to try out ReasonML, as they have a good tutorial and super helpful discord community).

Powerful type system that you don't need a math degree to use.",1532542632.0
pinkyabuse,"I started learning OCaml from [exercism.io](https://exercism.io/tracks/ocaml). I've learned several languages from exercism but OCaml is the only one so far where experienced users give valuable feedback on your code.

It's also a fun language to use for the coding test style questions you see on exercism making it a good introduction to functional programming.",1532641199.0
PM_Me_Bayes_Theorem,"I remember having a choice between Haskell, Lisp and OCaml when first learning the FP. I went with OCaml and as the first one, and I think that was the right call. If you, like me then, have a background in more mainstream imperative/objective oriented languages, then OCaml doesn't feel as ""alien"" as Haskell or Lisp. You can write imperative code in OCaml, with the language gently encouraging to do more pure FP.

I found the book ""[Unix system programming in OCaml](https://ocaml.github.io/ocamlunix/)"" to be extremely useful for appreciating the advantages of the FP in general and OCaml in particular.",1533034514.0
AlexCoventry,What are your goals? What's your background?,1532554559.0
jdh30,"* Easy to get into.
* Easy to use.
* Very friendly and helpful community.
* Compelling real-world applications and major users.
* Decent libraries covering the fundamentals.
* Lots of potential for mind expansion (higher-order modules, polymorphic variants, GADTs etc.).
* Easy to reason about.
",1534467402.0
Camarade_Tux,"About .a vs .o files: iirc .a files can have an index and therefore can be more than a collection of .o files. Some tools depend on that index (I haven't dug more into that thing).

Also, I was at first expecting an article on OCaml code calling Rust code (for the performance-demanding parts).",1532411169.0
twistier,"It sounds like you might misunderstand what tail call optimization is. Tail call optimization can only be performed if your function ends in a tail call. A hypothetical optimization that transforms a function that is not tail recursive into one that is would be called something else. The OCaml compiler does perform tail call optimization, but it does not automatically transform your functions to be tail recursive.",1532311780.0
chrismamo1,"The compiler will always try to make function calls as tailcalls when it can. If you'd like to make sure that this is being done, annotate the call with `@tailcall` and the compiler will throw an error if it can't be done.

E.g.

    let rec fact ~acc=1 n =
      match n with
      | 0 | 1 -> acc
      | _ ->
          let acc = acc * n in
          (fact[@tailcall]) ~acc (n - 1)

edit: post was misleading, see /u/Drupyog's comment",1532308930.0
haterofallcats,"Check out the new dev version of Real World OCaml.  They actually do a really good job of explaining when TCO applies. 

Short answer is yes, but as in most languages, you must take care to not require the stack in your final call action.",1532306724.0
jdh30,"> I'm reading this book from 2013 and it says:

That is not a great description of tail recursion.

> Do we have to manually ensure our functions are tail recursive?

Forget the phrase ""tail recursive"" and focus on the phrase ""tail call"". A function call is a tail call if it is in tail position. Tail position means it is the last thing the function does. Consider the following function `f`:

    let f x =
      g x;
      h x

The call to `g` is not in tail position because there is more code after it. The call to `h` is in tail position because it is the last thing `f` does before it returns and, therefore, the call to `h` is a tail call. The OCaml compiler will compile this call to `h` into a jump rather than a normal function call. Technically, this call will not allocate a new stack frame. Consequently, you can make an infinite number of tail calls using only a finite amount of stack space. This is important because stack space is a limited resource and it runs out quickly killing your program with a stack overflow.

> Some compilers can automatically convert recursive functions into loops, if they satisfy certain criteria.

While that is technically true I seriously doubt it is true in the way that you think it is true. Specifically, some very unusual compilers like SML/NJ, a Scheme implementation using Cheney-on-the-MTA and stackless Python can execute arbitrary code without using the (OS thread) stack. However, they do this by, for example, invasively rewriting your code into continuation passing style.

I think you're talking about almost all compilers for functional programming languages performing ""tail call optimisation"" (TCO) aka ""tail call elimination"". This is the optimisation I referred to above where a function call in tail position is compiled into a jump rather than a function call.

Note that I am careful not to talk about recursion here because this has nothing whatsoever to do with recursion and that is actually really important. The whole point of genuine TCO is that all calls in tail position are optimised into jumps, not just recursive calls or calls to self.

Some languages (particularly those on the JVM like Scala and Clojure) limit TCO to, for example, recursive calls from the body of a function to the function itself. This is a serious limitation and it results in some functional idioms like continuation passing style causing stack overflows because the compiler cannot handle the general case.

Consider the following variant on the above example:

    let f g h x =
      g x;
      h x

Our function `f` is now a higher-order function that has been parameterized over the functions `g` and `h` that it calls. In a real functional programming language there is absolutely nothing wrong with this at all and it is quite commonplace. Consequently, it is critically important that the compiler optimises the tail call to `h` in this case exactly as it did with the first-order version of `f`.

This problem arises in the context of the functional idiom called [""untying the recursive knot""](http://martintrojer.github.io/clojure/2012/07/23/untying-the-recursive-knot) (a reference to the [Gordian Knot](https://en.wikipedia.org/wiki/Gordian_Knot)). Another real-world example is solving common problems like [the knapsack problem with memoization but in continuation passing style](https://zbray.wordpress.com/2011/11/02/solving-the-0-1-knapsack-problem-using-continuation-passing-style-with-memoization-in-f/).

Caveat: watch out for exception handlers as they're a subtle way to make a non-tail call look like it is in tail position. In OCaml, a common example is reading input like this:

    let rec read_lines lines =
      try
        let line = input_line stdin in
        read_lines (line::lines)
      with _ -> List.rev lines

The recursive call to `read_lines` looks like it is in tail position but it isn't because the exception handler requires work to be done after that call and, therefore, it is not the last thing the function body does, is not in tail position, is not a tail call, will leak stack space and is likely to cause a stack overflow if the input has 100k+ lines.

The solution is to rewrite that code as follows:

    let rec read_lines lines =
      let line = try Some(input_line stdin) with _ -> None in
      match line with
      | None -> List.rev lines
      | Some line -> read_lines (line::lines)

The recursive call to `read_lines` is now in tail position, is a tail call and will be optimized away into (roughly) a `goto`.

> Is OCaml capable of that too? As this book is from 2013, I thought this optimization might have been added to the compiler by now.

OCaml has always done that. OCaml's predecessor, CAML, always did that. CAML's predecessor ML did that in the 1970s when TCO was invented and [first documented](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.4500). TCO is a hallmark of real functional programming languages.
",1534468215.0
Cheddar_Ham,"My rule of thumb is to set up .mli files each module of the program, only exposing the type signatures of what you want to be used in other parts of the program. This way the contract of each module is clear, and when you add stuff to one module, it's harder to break type inference in a different module.

Within the .ml files, I don't usually annotate much, except if I have a value that has a complicated type and I want to remember it. For that I might annotate individual arguments of a function, maybe not the whole thing, eg:

    let my_func (complicated_arg: int list Result.t Deferred.t) other_arg = ...

Ultimately, it's a matter of what helps you. Definitely annotate the functions that comprise the public interface of a module, but anything beyond that is mainly to help you reason about your own code, so if you need more annotations to help you, then by all means add more.",1532274810.0
darrenldl,"I use .mli files and also annotate all functions within the .ml files too, unless it's very trivial like binding an operator to a name etc. I leave the inside of the functions unannotated normally, but do add some when the function is lengthy.

I think this is not very commonly done, IIRC most people just leave it at .mli and that's it, and that's perfectly fine. I just do it this way just so I can refactor easily(move functions around, etc) without worrying about type inference messing up the design. I normally refactor my projects 2-4 times before release(this can mean rewrite of entire file, etc), so the rigidity at the function boundary is particularly critical for me, might not be for other people.

It's not required for maintainability of the program, but it is helpful. As mentioned above, this avoids unknowingly breaking things when moving the functions to different modules, and also help you make sure the (critical) functions have the right type signature across future releases.

Lastly, if your software has anything to do with security, I think annotating at function boundary at both .ml and .mli is the minimum.",1532321018.0
mookid11,"I think that the right approach is to add the amount of annotation necessary to make you read your program without effort. 

Type inference is a nice feature but the important thing is that the code is easy to read; you should not work for the compiler, it should work for you. If your code is made easier to read with a type annotation, there is nothing wrong in putting some.


",1532335494.0
AlexCoventry,"I keep tags I've used to debug typing issues, on the principle that you should always keep your debugging instrumentation around in some form. I also add tags wherever I think they'll improve readability for someone unfamiliar with the code base.

I do seem to have more concern for readability than most OCaml programmers, though, and I'm relatively new to it. So I might be bucking the culture here, a bit.",1532281777.0
Freyr90,It seems that ODBC is the only lib that supports Informix. You could help a [caqti](https://github.com/paurkedal/ocaml-caqti) project with that though.,1532243865.0
octachron,"No, `Location` is part of compiler-libs and not the [standard library](https://caml.inria.fr/pub/docs/manual-ocaml/stdlib.html) .",1531851405.0
,[deleted],1531666570.0
gallais,Related thread on /r/coq (with a link to a draft of the paper!): https://old.reddit.com/r/Coq/comments/7wd9lr/systematic_generation_of_fast_elliptic_curve/,1531666678.0
msbic,"This worked for me

https://stackoverflow.com/questions/39560241/how-can-i-install-ocaml-with-opam-on-windows",1531402502.0
,[deleted],1531243016.0
XVilka,Looking forward also to Opam 2.0 long-awaited release too. Will bring a lot of improvements to the ecosystem.,1531328607.0
existentialwalri,"was trying to get into ocaml, is there anything better than this dune tool? i dont get it at all",1531150187.0
maattdd,"It completely depends on your application. If it is a highly parallel number crunching app (such as matrix multiplication), the performance cost will be big for example.",1530781096.0
coder543,"It is a big deal. There is no disadvantage to having the option of using multiple cores, but there is a large disadvantage to not having that option. It's very unusual to a buy a computer with less than 4 cores these days, and it's not even that uncommon to buy a desktop with 8 cores and 16 threads.

You may write an application and think the performance using a single thread is fine right until your customer asks you for a feature that's just not going to be fast enough. The customer has cores in spades, of course, so what are you going to do now? If you were using a language that supported parallelism, you would have that option, but now you don't. It's not even that hard to write correct data-parallel programs in Rust (with Rayon) or C and C++ (with OpenMP), although correctness in other areas will be much harder to achieve in C or C++.

In my experience, there are very few applications which can't benefit from *some* amount of parallelism.

I'm glad that a Multicore OCaml runtime is being researched, but it can't arrive soon enough.",1530810396.0
smosher,"I've never written a program that would have benefited hugely from parallelism, save for the async I/O stuff which is available everywhere.

But data is huge, machine learning is huge and both are highly parallel. And more importantly (sadly) is the fact that not being multicore is seen as a huge wart. People who don't need it will complain about its absence.",1530999730.0
gmfawcett,"For an ""average"" app, it's fine. Paralellism isn't a silver bullet for many (most?) applications, and can degrade performance if used incorrectly. It really depends on what you're writing.

Thomas Leonard's well-documented [conversion of 0install from Python to OCaml](http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/) is a relevant read for anyone interested in OCaml performance in real-world applications.

If message-passing is a reasonable IPC approach for your application, then OCaml can work fine as a parallel language. Shared-data parallelism is also possible,  but requires low-level tricks that might be more trouble than they are worth (depending again on your application, and your experience level).

About ten years ago, JoCaml (an extended OCaml language that adds some concurrency and message-passing primitives) had a moment of Internet fame when it dominated the [WideFinder benchmark](https://www.tbray.org/ongoing/When/200x/2007/11/06/WF-Discussion). Much of the success was due to the winner's talent as a progammer, but he also [acknowledged](http://www.eigenclass.org/hiki/wide_finder_conclusions/) that (well-written) OCaml is speed-competitive with well-written C++ in some problem spaces.
",1530795991.0
BluddyCurry,"Well, it's complicated...

The world has now filled up with languages that don't do parallelism - javascript, python, and ruby, to name a few. So clearly you can do many things without requiring multicore support in the language. People have generally found out that parallel programs are too hard to write well and leads to subtle bugs, and that using promises or green threads is easier and sometimes gives better results (due to a lack of context switches).

At the same time, CPUs aren't getting any faster -- they're only getting more cores. One way to take advantage of those cores is by spawning multiple processes and sending messages between them. This is what python does, for example. OCaml supports this workflow, but doesn't have a uniform, easy interface for doing it cross-platform. It also requires trusting the OS to manage your processes.

But there's a problem with this approach, too. It's fine for sharing small pieces of data between processes, but not if you need to share more (think of an OS, games or simulations). For that, you need to use OS-mapped shared memory between processes, which is another fiddly thing that's hard to manage, but also, shared memory doesn't work so well for languages with a garbage collector such as OCaml. Python and ruby have reference counting, which does ok with shared memory areas. OCaml has a tracing garbage collector, which does not. To support shared memory for a language like OCaml, you need to create a new runtime, which is what the [multicore runtime](https://github.com/ocamllabs/ocaml-multicore) is about.",1530796104.0
rnt111,It's generally better to use one core efficiently than inefficiently using several cores.,1530975538.0
jdh30,"> Absense of true parallelism isn't a big deal - correct?
> That's for an average OCaml app, in terms of performance.

Depends what you mean by ""true"" and ""average"".

Absence of HPC tools like MPI isn't a big deal but absence of multicore parallelism can be a real pain.

The problem with the ""average"" OCaml app is that it is self-selected. OCaml is really bad for parallelism so everyone avoids using it in situations where parallelism *might* be required because if it turns out to be then its absence will be a show-stopping problem.

For many servers, serialization is expensive and messages to and from clients can potentially be serialized and deserialized in parallel. OCaml has great support for concurrency so it can handle servers with many concurrent connections but under high load both throughput and latency suffer because of OCaml's inability to do parallelism effectively.

On the other hand, if you're compiling to JS then you probably don't care about parallelism at all.

Or if you're writing the Coq theorem prover, which was OCaml's raison d'etre, then you crave OCaml's data representation and efficient serial GC. To date, nobody has figured out how to add parallelism without sacrificing this advantage (which is an important advantage for the very people in charge of OCaml's evolution).
",1532122711.0
chrismamo1,"If you're willing to tolerate some half baked fuckiness, you could check out my library github.com/chrismamo1/cucaml if you need parallel numeric code",1532292356.0
theindigamer,"I'm not sure why the normal ascription example doesn't actually work like the transparent case ... i.e. why is transparent ascription not the default historically? Are there good use cases for the normal ascription case?

> The days of Error: Syntax error. may be numbered.

Yay!",1530646418.0
rnt111,Having to choose between a 31/63-bit unsigned integer and a 32/64-bit unsigned integer with inefficient memory usage and slower performance is not an ideal situation. Bigarrays and tedious FFI code will just continue to have to do.,1530721722.0
mookid11,The fact that a bunch of expert compiler writers did not figure out that writing a recursive descent parser is superior after 20+ years of development is... interesting.,1530649730.0
jdh30,"I don't know of a course but (shameless plug) the [OCaml Journal](http://ffconsultancy.com/products/ocaml_journal/) contains an article about the built-in collections (including the imperative ones: Array, Queue, Stack, Hashtbl) and implementations of some imperative data structures.

For example, the article ""Triangulated Irregular Networks (TINs)"" describes algorithms over a graph that uses an imperative representation for performance.
",1530483152.0
Endofunktor,"My comment is irrelevant but just out of curiosity, why would you like to learn data structures with OCaml if you are not following a functional approach? What is the relative strength of OCaml here?",1530423799.0
raevnos,Just take any existing class and use ocaml for all the exercises?,1530451162.0
mookid11,Look at the stdlib code?,1530542094.0
rnt111,"Nobody actually uses Ocaml for imperative coding, just as nobody uses Ocaml for its object-oriented features.

Please be advised, most professors using Ocaml will laugh at and immediately fail any student caught using for-loops, while-loops, hash tables, stacks or mutable cell references in any assignment.",1530536944.0
aantron,"- [project page](https://github.com/ocsigen/lwt#readme)
- [changelog](https://github.com/ocsigen/lwt/releases/tag/4.1.0)",1530296270.0
Camarade_Tux,I'm really at a loss with the number of SQL interface libraries in OCaml. Is there an overview somewhere?,1530342207.0
frumsfrums,See [this](https://github.com/ocsigen/js_of_ocaml/blob/066ebfdd78eaea87ec79cba7a341935192ee7173/lib/js.ml#L473-L483) and [this](https://github.com/ocsigen/js_of_ocaml/blob/066ebfdd78eaea87ec79cba7a341935192ee7173/runtime/jslib_js_of_ocaml.js#L208-L213). This is just so your exports don't fail in the browser (where `module` is not defined). The compiled file should be a valid node module (albeit using the pre-ES6 syntax) which you can interact with in the usual way.,1530241380.0
permetz,"I don't disagree with the sentiment, but it would be more likely to be noted on discuss.ocaml.org or the ocaml mailing list or some such.",1530644312.0
ollehar,"Great write-up, thank you!

Any more info on type-and-effect or other proposed effect system?",1530206887.0
shinzui,I suggest posting to discuss.ocaml.org. ,1529993515.0
smosher,"Thought people here might find this interesting. It has a familiar syntax and interesting features, such as universal quantification, HKTs, and implicit arguments.",1529785242.0
permetz,Seems gratuitously different from OCaml given that it looks almost like ocaml.,1529846373.0
ocamlsh,"Fascinating project!

Are there any plans for open-sourcing this? It looks like it could useful for OCaml development ...",1531983050.0
examachine,Is this basically a logical inference engine for crypto fintech apps?,1529695381.0
Drupyog,"The packaging part is, sadly, completely outdated. :(

People who write new ppxs should use jbuilder and omp, as advised in [rudy's tutorial](http://rgrinberg.com/posts/extension-points-3-years-later/).",1529663014.0
frefity,https://github.com/ocamllabs/ocaml-multicore/projects/3,1529404383.0
permetz,"Yes. There's an effort in progress called ""multicore"" and it is expected to go into the mainline very soon. It will include an algebraic effects extension of the type system.
",1529407018.0
cafedude,There used to be a pinned post here on r/ocaml with the latest links to updates. It's been gone recently.,1529519325.0
gasche,"I just posted a summary of recent discussions on the current state and ongoing merge plans for the Multicore OCaml project:

[[Discuss] Ocaml-multicore: report on a June 2018 development meeting in Paris](https://discuss.ocaml.org/t/ocaml-multicore-report-on-a-june-2018-development-meeting-in-paris/2202?u=gasche)",1530178646.0
permetz,This is too good to just sit in a blog post that I only am aware of because I happened to glance at the reddit feed...,1529279177.0
permetz,Homework problem?,1528760044.0
glacialthinker,"Yes, and Rust was fairly influenced by OCaml. Kind of like an attempt to have much of the goodness of OCaml with the practical system-programming aspects of C. Over time the syntax evolved to something more familiar to C++ programmers, and some functional features couldn't be resolved (tail-call optimization, and there are some limitations with closures due to no GC... though the closure situation is better now I think?). Traits also became fairly dominant in practical style, like with typeclasses in Haskell.

I was very interested in early Rust. Lost interest due to the shift in code-style (imperative). But it may be getting more interesting as it matures and better supports a functional style (like C++ has managed, though C++ is forever crippled by foundational choices).",1528647971.0
elliottcable,"> … which we then ... tend to turn directly into x86 anyways. Sorry; it wasn't clear during initial construction that we'd wind up stopping at x86, so the IL is probably superfluous, but there it is.",1528722471.0
gasche,"Why is it ""free until June 11th"", is there no plan for a properly Open Access version? (Is this a book rather than a paper? Should that make a difference?)",1528401684.0
glacialthinker,"A book by Oleg. Should be `fun`! :)

I'm also curious why free... I'm guessing to help promote the publisher / get users. But what's the author's take on this?",1528462891.0
Freyr90,"Ok, so I have two questions about metacaml:

1) Are there any plains on mainlining it in the future?

2) Since there is no homoiconity in OCaml, is metacaml powerful enough to replace current PPX completely?",1528388377.0
cafedude,"Anyone know where to get the source files that are referenced in the text? It seems that the download did not include them.
For example on page 23: ""(The com-
plete code for this section is in the accompanying file filter.ml.)""
",1528926260.0
sam_binder_of_demons,"this is awesome, thanks for the link",1528411315.0
jdh30,"Never thought I'd see ""functional"" and ""HPC"" in the same sentence... :-)",1528244435.0
frefity,"I think if you're looking to find a job in programming it's actually a better idea to go with a mainstream language. The simple reason is that there are far more jobs available. Sure, there there are more people to compete with but in general their skill level will also vary a lot more and there will be more jobs available at your skilll level. Have a look at the market you're in and pick a language that's in demand. 

You can focus on a more obscure language later once you have some general programming experience.",1528190812.0
loxs,"If you are doing this with the intention of finding a job ""relatively easily"", I would recommend Elixir over OCaml. If you want to have your mind blown, become a better programmer and thinker, go for OCaml.",1528183215.0
permetz,"I'm a very big OCaml fan, but if you're looking for a job, learn Go or something. But truthfully, if you don't think you can learn a new language in a few weeks, you aren't good enough to be worrying about which language to learn, and you should be brushing up on your general understanding of programming in general, which implies not yet thinking in terms of what language you're going to be selling yourself as an expert in.",1528198669.0
jeffsco,There's no native way in OCaml to associate chosen integer values with the constructors of a variant. There is an extension that allows this called [ppx_deriving](https://github.com/ocaml-ppx/ppx_deriving). See the section called **Plugin: enum**.,1527908494.0
seriedivergente,That is wuite surprising. Can you check what is in the stdout and stderr files? Or grab the sources wih ‘opam source jbuilder’ and thencheck the iutput of ‘cd jbuilder.1.0+beta20 && make’,1527334226.0
seriedivergente,"Sorry for the typos, I am typing from the ipad, trying to do my best :P",1527334276.0
glacialthinker,"I've submitted a new *pidigits*, using Zarith, as the other bignum libraries/bindings were failing to be found on the benchmarks machine.

I also submitted fixes for *fasta#3*, and *mandelbrot* which were much easier: `String` -> `Bytes`.",1526510302.0
mookid11,Only Jon Harrop seems to care about caml's benchmarks game.,1527110034.0
ocamlsheep,"I tried fixing the `regexredux` and `knucleotide2` benchmarks, but the outputs are different from the reference outputs (and not related to String/Bytes, it seems, as they also fail without my fixes on 4.04).",1526841501.0
nleyten,"I'm hoping some of you will find this useful the next time you want to generate a passphrase having a decent amount of entropy (32 or 64 bits). As we know, people tend to grossly overestimate the security of the ""clever"" passphrases they come up with on their own.

It's written in OCaml of course, though the code is pretty unremarkable. Much greater effort went into constructing the actual lists of words, as you can probably imagine!

Anyway, feedback is welcome. And if nothing else, the generated passphrases often have comedic value:

 - `Bright skull counsels almighty spasm from Budapest`
 - `Feminist fleet visits clumsy narwhal from Kingston`
 - `Airborne pelican debunks gleaming wrestler from Bali`",1526034188.0
gallais,"Found via [this tweet](https://twitter.com/kc\_srk/status/994535108127404038)

> KC Sivaramakrishnan: Spent the week making a roadmap for upstreaming Multicore OCaml: https://github.com/ocamllabs/ocaml-multicore/projects/3#column-2679937 …. I am hopeful that we can get all of items sorted by the end of the year.",1525950781.0
lyspr,"How long has Github had that beautiful Trello card thing? Am I retarded?

Oh my gosh, that's such a nice thing, and it's even integrated with the issues...

",1526226233.0
jeffsco,"There is an auxiliary recursive function defined inside `inv`. The expression `let rec aux acc ...` defines this function, giving it the name `aux`.  The auxiliary function has two parameters. The first is named `acc`, a common idiom to indicate that this is an accumulator parameter to which values are added as the recursion proceeds. The second parameter doesn't have a name; instead it's matched by the two patterns associated with the `function` keyword. The auxiliary function does the actual reversing by adding each new list element to the accumulator and then calling itself recursively with the remainder of the list. The main function `inv` just calls `aux` with an empty accumulator and the given list.

The `function` keyword acts like a combination of a function definition and a pattern match. Essentially, it is another form of the `match` keyword for defining a function of one parameter. So the `[]` is a pattern (matching the empty list). When the auxiliary function sees an empty list, it's time to return the accumulated result `acc`.

The expression `aux (h :: acc) t` is the recursive call that adds the next list element `h` to the accumulator and then calls `aux` recursively to handle the rest of the list `t`. ",1525832511.0
AlexCoventry,"> I was getting mad because it seemed so easy on python.

Note that there is a comparably easy way in OCaml: `List.rev <list>`.

> rec aux acc

The `let rec` tells the compiler that it needs to be prepared for the coming function to call itself (`rec` for recursive.)

This might help you to think about it:

    let inv list =
      let rec aux acc l =
        Printf.printf ""l:   ["";
        List.iter (fun e -> Printf.printf ""%d; "" e) l;
        Printf.printf ""]\nacc: ["";
        List.iter (fun e -> Printf.printf ""%d; "" e) acc;
        Printf.printf ""]\n"";
        match l with
        | [] -> acc
        |h::t -> aux (h::acc) t
      in aux [] list ;;
    
    inv [0; 1; 2; 3; 4]
    
    (* Output:
    
    l:   [0; 1; 2; 3; 4; ]
    acc: []
    l:   [1; 2; 3; 4; ]
    acc: [0; ]
    l:   [2; 3; 4; ]
    acc: [1; 0; ]
    l:   [3; 4; ]
    acc: [2; 1; 0; ]
    l:   [4; ]
    acc: [3; 2; 1; 0; ]
    l:   []
    acc: [4; 3; 2; 1; 0; ]
    
    *)
    ",1525840184.0
silencer6,"This function translated to Python:

    def inv(lst):
        def aux(acc, x):
            if len(x) == 0:
                return acc
            else:
                h = x[0]
                t = x[1:]
                return aux([h] + acc, t)
        return aux([], lst)

The ```function``` keyword in your code hides the parameter that pattern is matched on. It may be easier to understand if you write it like this:

    let inv list =
        let rec aux acc x =
            match x with
            | [] - > acc
            | h::t -> aux (h::acc) t
        in
        aux [] list
    ;;",1525868592.0
moosekk,"We could start off with a simple implementation of `reverse`:

    let rec reverseA = function
      | [] -> []
      | item :: rest -> reverseA rest @ [item] ;;
    
Hopefully, this function makes sense to you. ""To reverse a list, reverse the tail of the list and and append the head to the back of that tail. 

Unfortunately, this solution is not very efficient because `@` needs to copy over the `reverse rest` part every iteration, so it is a `O(N^2)` solution. We'd prefer to build up a list ""from the back forward"", if that makes sense.

Here is a version of reverse that takes a stack of already reversed items and sticks the current item on top of the stack. When there are no more items to reverse, the stack is returned.

    let rec reverseB stack list = 
        match list with
        | [] -> stack        
        | item :: rest -> reverseB (item :: stack) rest

    reverseB [] [1; 2; 3; 4; 5]
    reverseB [1] [2; 3; 4; 5]
    reverseB [2; 1] [3; 4; 5]
    reverseB [3; 2; 1] [4; 5]
    reverseB [4; 3; 2; 1] [5]
    reverseB [5; 4; 3; 2; 1] []
      (returns [5; 4; 3; 2; 1])

Now we have a fast `reverseB` function, but it's a little annoying to have to pass the empty list we're using as the initial stack, so we'll wrap it in another function that passes the initial `[]` parameter:

    let reverseC list = 
        let reverseB =  ... just as we defined above ...
        in
        reverseB [] list

and there we have it. `reverseC` is your `inv`, `reverseB` is your `aux` function.",1525978620.0
TheAspiringHacker,"> rec aux acc, why is acc here and right after ?

As others have mentioned previously, `let rec` is like `let` but for recursive bindings: the definition can refer to itself. It is used in this context to write a recursive function.

> [] -> acc, what ? Why ?

The function is using pattern matching, in which a value is deconstructed into its parts. A list is defined recursively: it can either be

- an empty list, the base case, or
- an element in front of the rest of the list, the recursive case.

`[]` is the empty list.

`h::t` is the nonempty list where `h` is the element and `t` is the rest of the list.

> aux (h::acc) t , ????????????

This expression calls the `aux` function with the argument being `h`, the head of the list obtained from the pattern match, in front of `acc`, a list being built. `h::acc` forms a new list using the recursive definition mentioned above.",1525898608.0
improbabble,"- upstream library: https://uber.github.io/h3/
- Uber talk on using H3 to tile the earth with hexagons: https://www.youtube.com/watch?v=ay2uwtRO3QE",1525310168.0
karahobny,"I have yet to test this, but already it sounds like something that should be in MELPA as soon as possible. Thank you!",1525290404.0
,[deleted],1525569014.0
henrebotha,"Don't need an IDE, I think most people just use a text editor. I prefer Vim, you may prefer something simpler like VS Code.

https://ocaml.org/docs/install.html#Windows",1524844639.0
lwzukw,"You might be interrested by this basic introduction (online, no worry with installation).

https://try.ocamlpro.com/",1524848537.0
mookid11,Your best bet is to run linux through virtualbox.,1525304192.0
chrismamo1,"I have no experience with Windows, but I would recommend trying Facebook's ReasonML. It's geared toward JS developers who'd like to take advantage of some of OCaml's features, so the tooling is probably really well suited for Windows users. I personally use ReasonML (compiling to native binaries) and VSCode",1525316039.0
tftio,"I would actually recommend that you download Visual Studio and spend some time with F# -- it is very similar to OCaml, and well supported on Windows.",1524850687.0
catlion,"I strongly recommend you choose ""Bash on Windows"" installation to get `utop`, `merlin` and all *nix-related things to work out-of-the-box.",1524844901.0
pitastrudl,"if you really want to use an IDE, then try eclipse. but it's a hassle to get it working sometimes but it works. i only used it when i did ocaml for a uni course. ",1524850293.0
gmfawcett,"I haven't used `sqlexpr`, but have you tried:

    opam install sqlexpr

and then in your `jbuild` file, something like:

    (executable
      ((name main)
      (libraries (sqlexpr))))

then `jbuilder build main.exe` ought to be able to use `sqlexpr`.

[This is a nice article](https://medium.com/@bobbypriambodo/starting-an-ocaml-app-project-using-dune-d4f74e291de8) on using Dune/Jbuilder that you might like.",1524860625.0
gmfawcett,"How much progress have you made so far? 

Are you new to programming, or just to Ocaml? If just Ocaml, could you sketch out a high level, incomplete idea of what you're trying to accomplish, but in a different language?",1524782101.0
ThomasPatJ,"Pure speculation here, but it seems that `it` is unified with `[]` without being unified with `l`. This kind of ""limit to unification"" seems coherent with what would be needed for the typing of GADTs (i.e. types limited to a branch of a pattern matching).

EDIT: after asking to an adult, it may be linked to principality more than GADTs. Anyway it's correct so the typer goes for the most general type it can guess.",1524581380.0
Leonidas_from_XIV,Have you tried calling `corebuild` instead of `ocamlbuild`?,1524406359.0
Drupyog,"But why use gprof when `perf` is better and work on any OCaml code, without any modifications?",1523906116.0
pinkyabuse,Thanks for this. I do like OCaml but getting started is challenging. Looking forward to your future posts. ,1523711777.0
glacialthinker,"5.0?

Or is this a new sitcom about students using an undersung language, but it's mostly about awkward social situations they get themselves into and narrowly resolve?",1523649976.0
sonologico,"As long as you make sure to inform ocaml that you're dealing with lists whose elements are either of some type or a list of such elements, then you're able to do it.

    type 'a nested_elem = Single of 'a | List of 'a nested_elem list
    
    type 'a nested_list = 'a nested_elem list

    let nth i list =
      let rec loop i list rest =
        match list, rest with
        | [], [] -> None
        | [], (y :: ys) -> loop i y ys
        | (Single x) :: xs, _ when i = 0 -> Some x
        | (Single _) :: xs, _ -> loop (i - 1) xs rest
        | (List a) :: xs, _ -> loop i a (xs :: rest)
      in
      loop i list []

    ",1523594638.0
gsg_,`list` isn't the right data structure for arbitrary nesting. For that you could use a more tree-like datatype like `type 'a cons_list = Nil | Atom of 'a | Cons of 'a cons_list * 'a cons_list`.,1523594092.0
aantron,"- [changelog](https://github.com/ocsigen/lwt/releases/tag/4.0.0)
- [repo](https://github.com/ocsigen/lwt)",1523462580.0
AlexCoventry,"I'm not clear exactly what you're trying to do, but maybe you want something like this?

    # let myfunc = function | (a, [hd; tl]) when a = tl -> Some hd | _ -> None;;
    val myfunc : 'a * 'a list -> 'a option = <fun>
",1523319261.0
jozefg,"You're returning a `[]` in the else branch of this program so the type must be `some_type -> some_other_type list`. What should be returned if they do not to compare equal? For that matter, what should happen if your function is called with list of length not 2? Or with types for which there is no notion of equality?

(I assume you have a good reason for wanting to write a function like this, it is quite unidiomatic)",1523317081.0
doraki697,"you say that you want a signature of 'a * 'a list -> 'a.

what int should ""myfunc (1,[2;3;4])"" return ?",1523349674.0
darrenldl,"As far as I know, you need to encapsulate your computation in a type that suspends your comutation(so the type contains your comptutation procedure in form of lambda function).

You can obviously make this type yourself, but normally people just use `Lazy.t`([here](http://caml.inria.fr/pub/docs/manual-ocaml/libref/Lazy.html)) or [streams](https://stackoverflow.com/questions/1631968/ocaml-lazy-lists#1632320), depending on which one is more suitable.",1523340948.0
tweettranscriberbot,"^The linked tweet was tweeted by [@kc_srk](https://twitter.com/kc_srk) on Apr 06, 2018 07:56:57 UTC (24 Retweets | 93 Favorites)

-------------------------------------------------

Multicore OCaml catches up to trunk. It has now been rebased to OCaml 4.06.1: [https://github.com/ocamllabs/ocaml-multicore.](https://github.com/ocamllabs/ocaml-multicore.) Going forward Multicore OCaml will track OCaml releases. Many runtime system features are unimplemented (finalizers, weak refs, ephemerons, latency improv, spacetime profiler..)

-------------------------------------------------

^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •",1523147842.0
lostman_,"Great work!

    Going forward Multicore OCaml will track OCaml releases

Does that mean no merge in sight?",1523217498.0
eras,Still waiting for opam switch!,1523264461.0
YuntiMcGunti,"Did the algebraic effects work land as a typed solution (I did see earlier talk of possibly doing a limited version that was untyped)?
Additional the reamining problems leo mentioned in this talk https://www.youtube.com/watch?v=ibpUJmlEWi4&feature=youtu.be
get resolved - did he go for introducing linear types or an alternative solution?  ",1525088139.0
AlexCoventry,"You might mean `filter` instead of `map`. E.g.

    # let f a b = List.filter (fun x -> List.mem x b) a

That's going to be slow, though (bilinear run time in length of `a` and `b`.)",1523143076.0
L72_Elite_Kraken,"If I'm understanding right, I think you want

    let f a b = List.map (fun x -> List.mem x b) a;;",1523153584.0
TarMil,"Yes, this is a classic stumbling point for beginners. When you use the `function` keyword, you don't need to declare the argument separately. In other words, you should use either this:

    let myfunc = function
      | ([], _) -> []
      (* etc... *)

or this:

    let myfunc (l, table) =
      match (l, table) with
      | ([], _) -> []
      (* etc... *)

but the function you wrote takes two tuple arguments.",1523133764.0
L72_Elite_Kraken,"OCaml provides more than one way of defining functions. What's happening here is that you're using two of them together, so instead of just defining a function that does what you want, you define a function that returns a function that does what you want.

In a simpler example, one syntax looks like this:

    # let increment = function | x -> x + 1;;
    val increment : int -> int = <fun>

The syntax here matches closely how we would describe this in English: ""Let `increment` be a function that takes `x` to `x + 1`. In fact, we can also express the ""function that takes `x` to `x + 1`"" part without binding it to an identifier:

    # function | x -> x + 1;;
    - : int -> int = <fun>

The other syntax can be viewed as a sort of shorthand:

    # let increment x = x + 1;;
    val increment : int -> int = <fun>

In your code, however, you've mixed these two syntaxes together. It's as if we wrote:

    # let increment x = function | x -> x + 1;;
    val increment : 'a -> int -> int = <fun>

This defines `increment` as a function that takes in a value, does nothing with it, and returns another function that takes `x` to `x + 1`. Oops!

So, tl;dr: to fix it you want to either get rid of the `([i; j], table)` part or the `function` part.

I also wouldn't recommend using the pattern `[i; j]` in defining a function. How would `i` and `j` be defined if the function is given a list with fewer than two elements? For this reason, I would assume that the compiler has been complaining about non-exhaustive pattern matching.",1523134220.0
gtenik,"You might also want to consider using a couple instead of a list if you only need two indexes (i and j). The pattern matching might fail otherwise : e.g. f [1;2;3] [] raises an exception.

    let f (i,j) table =
      match table with 
      | ...

",1523136545.0
L72_Elite_Kraken,You need parentheses or `begin` ... `end` around the inner match expression so that the compiler knows that the last two lines (the `31` and `_` cases) are part of the outer match.,1523050097.0
icspmoc,"OCaml's pattern matching syntax lacks an end marker, with the result that nested `match` expression often have to be enclosed by parentheses (or `begin ... end`). Currently, the last two cases (i.e. `|31 -> ... | _ ->`) in your code are syntactically part of the inner `match`, which is not want you want.",1523050392.0
yawaramin,"Another option to solve this is to flatten your pattern match by matching against multiple things at the same time:

    type t_date = {mutable jour: int; mutable mois: int; mutable annee: int}

    let change date = match (date.jour, date.mois) with
    | (28, 2)
    | (30, 4)
    | (30, 6)
    | (30, 9)
    | (30, 11)
    | (31, _) -> date.jour <- 1
    | _ -> date.jour <- date.jour + 1

I'd argue this is actually a bit easier to read because it looks like a table of dates for which you increment the dates.",1523669235.0
andrejbauer,"The first step towards learning how to program is not to publish PNGs of source code, but rather the text of the source code, for instance [here](https://pastebin.com).",1523049641.0
JGailor,"Do you have ocaml installed?

```
%> ocaml --version
```

If you have that line in a file, say ""test.caml"", you can run the file by then typing

```
%> ocaml test.caml
```

It won't produce any output because it doesn't do anything.  It just declares a function and exits.  If you would like it to print out the square of 2, you can paste the following (there are better ways to do this, but I'm trying to be very clear)

```
let square x = x * x;;
```

```
let two_squared = square 2;;
```

```
print_int two_squared;;
```

```
print_newline();;
```


*** Sorry to keep editing and adding, but the extension really doesn't mean much in this case.  Some languages depend on it for imports, some for tooling, but in some ways it's just a useful bit of context.  This code will still run the same if the file was called ```test.oh_my_god_is_that_a_caml```.  The OCaml compiler doesn't really care.",1522955582.0
infinitypanda,"It's a little long form, but the first chapter or two of https://realworldocaml.org/v1/en/html/index.html might help :)",1522982422.0
Amenemhab,"I think you should tell us more clearly what sort of things you'd expect to be able to do, as in a series of fake commands or whatever. Or perhaps what languages you've used previously. Currently it isn't clear to me what information would be useful to you.

(Also: what system are you on? How well do you know how it works? Possibly your prof is assuming greater computer knowledge than you have, and your problem is not really related to OCaml, just to installing and running stuff in general. Maybe I misread it though.)",1522963041.0
jdh30,"You can get a REPL by running:

    $ ocaml

Or go to the [Try OCaml](https://try.ocamlpro.com/) website.

Then you can enter your function definition:

    # let square x = x * x;;
    val square : int -> int = <fun>

Now you can call your function like this:

    # square(3);;
    val - : int = 9

Those brackets are optional in ML so you can just write:

    # square 3;;
    val - : int = 9
",1523013093.0
oreolennon,"Here is maybe a better example of what I need to show for my project:

file.ml-

    let square x = x * x;;

command line-

    # square 3;;
    - : int = 9

If i were to make an ocaml file using that line, that is the output I need to show for the project, but every time I try to use something from a file i get `Error: Syntax error` or `Error: Unbound value`. I just read in my project guidelines this line:

The following strategy will be used with varying input files and parameters to test your code:

    #use ""proj.ml"";;      (*YOUR occaml source *)
    #use ""grader.ml"";;   (*OUR TEST inputs and scripts *)
    <testing>

I just tried to do something using `use` and I got the response from ocaml `Error: Unbound value use`",1523016539.0
,[deleted],1522964179.0
lpw25,"The flat version using arrays is not safe. If you make a pair out of a float and a non-float then it will segfault, due to the `float array` optimisation. See [here](https://github.com/janestreet/base/blob/master/src/obj_array.ml) for an example of how to safely create an array containing different types.

Even without the `float array` optimisation it is risky to use `int array`. Magicing things to `int` is dangerous because if the value ends up in a register across a GC safe point then the compiler will not register it with the garbage collector -- since `int`s do not need to be scanned. It's better to use an abstract type (e.g. `Obj.t`) or a type like `option` which may or may not be a block.",1522912084.0
gsg_,"Multiple rows gets you into trouble because it allows patterns like `(.., x, ..)`, which is hopelessly ambiguous. Having the 'tail' only on the right solves that problem, while also allowing a very simple implementation - pretty much identical to the current implementation.

As a language feature row polymorphic tuples aren't all that exciting because the lack of polymorphism isn't that painful. It is a simple matter to pattern match on tuples of any reasonable size, and tuples of unreasonable sizes are vanishingly rare. Having said that, it would be pleasant to be able to give the right type to `fst`.",1522925621.0
Dinosaure,"May be, you should be interesting by [orec](https://github.com/Octachron/orec) which is a nice game between GADT, objects and so on to implement an Open RECord.",1523023648.0
JGailor,This is still one of the best books to read whether you are going to write OCaml or not.  The depth with which the authors dive into how things work under the hood is fantastic and gives real insight into how a real-world implementation of a language works.,1522945978.0
tweettranscriberbot,"^The linked tweet was tweeted by [@yminsky](https://twitter.com/yminsky) on Apr 03, 2018 21:54:26 UTC (15 Retweets | 46 Favorites)

-------------------------------------------------

If you haven't looked at it in awhile, take a look at [http://dev.realworldocaml.org,](http://dev.realworldocaml.org,) look again. Many thanks to [@eriangazag ](https://twitter.com/eriangazag )for the work!

-------------------------------------------------

^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •",1522873279.0
zero_coding,"Whare can I buy the book?
",1522954159.0
,"i think this is the first DSL for blockchain operations to be built with OCaml, good vector for a language resurgence.
Don't want to hate on Solidity, but it could stand to learn a few things from this.",1522759748.0
PM_ME_UR_OBSIDIAN,"Not a fan of the multiline tuple style. Does OCaml not support trailing commas?

    let tup = (
        foo,
        bar,
        baz,
    ) in
        ...",1522841619.0
randomatic,I was with them until they said 90 characters is the maximum line length. ,1522755566.0
lambda_foo,Is there a good tool for enforcing this style guide? ,1522807578.0
StrykerKKD,There is a pretty [good answer](https://discuss.ocaml.org/t/will-ocaml-be-a-good-choice-for-writing-high-performance-parallelizable-machine-learning-libraries/558/2) for this question on Ocaml discuss.,1522580961.0
apoisel,"On Linux go with OCaml.  It's great for [Unix system programming](https://ocaml.github.io/ocamlunix/), and there are [OpenGL games with open source code to look at](https://github.com/a-nikolaev/wanderers).

    ocaml graphics.cma <( echo 'open Graphics;;open_graph "" 640x480""let complex_mul(a,b)(c,d)=(a*.c-.b*.d,a*.d+.b*.c)let complex_add(a,b)(c ,d)=(a+.c,b+.d);;let rec mandel c n=if n>0 then let z=mandel c(n-1) in complex_add(complex_mul z z)c else (0.0,0.0);; for x=0 to 640 do for y=0 to 480 do let c=((float_of_int(x-450))/.200.0,(float_of_int (y-240))/.200.0) in let cabs2(a,b)=(a*.a)+.(b*.b)in if cabs2(mandel c 50)<4.0 then plot x y done done;;read_line()' )
",1521896015.0
Caltelt,I was just able to install it with opam 1.2.2 and ocaml 4.06.1. ,1521847541.0
icspmoc,"> [This paper](https://www.lri.fr/%7Efilliatr/ftp/publis/puf-wml07.pdf) gives an efficient functional union-find implementation in ocaml, but seems to assume a fixed upper bound on the number of elements that can be in the union find data structure.

I ran into exactly the same problem a couple of years ago. My solution was to replace the underlying array by one twice the size on every out-of-bound write. I never did any benchmarking so I can't tell you whether this degrades performance significantly.

> The synthesizer infers Hindley-Milner types [...]

François Pottier's [Hindley-Milner Elaboration in Applicative Style](http://gallium.inria.fr/~fpottier/publis/fpottier-elaboration.pdf) might be relevant to what you are doing.",1521597169.0
das_kube,"You can write a backtracking program in imperative style (with mutable structures). The trick is usually to have an ""undo stack"" (e.g. a `(unit -> unit) vector`); just before you change something (like, setting an array slot), put a closure undoing the change into the undo stack. Then when you backtrack, pop all closures down to the old position in the stack, and execute them to restore your mutable structures the way they were.

Note that OCaml itself has a save/restore mechanism for its typechecker's internal mutable state.",1521608158.0
secondwtq,"This is off topic but may I ask why you need an immutable data structure to do this? I've never written Hindley-Milner yet but AFAIK for plain Hindley-Milner you just generate a set of type variables and constraints, and do unification among them.

You have to do a depth-first traversal of expressions, and update the typing context, but no DFS in solution space. There is *at most one solution* for a specific program, if a single unification fails then it just fails, no backtracking thus no need for immutability. And it costs time linear to program size.

There is [some variations](https://github.com/apple/swift/blob/master/docs/TypeChecker.rst) of HM however, which utilizes backtracking because of fancy features e.g. Java-like subtyping/overloading, which could lead to exponential complexity in the worst case.",1521689480.0
XVilka,You can use https://github.com/thierry-martinez/pyml for writing Python modules.,1521712846.0
andrejbauer,"Is there a particular reason for trying to do such a crazy thing? In any case, it seems that passing through C is the ""best"" option.",1521561814.0
icspmoc,"Your code snippet looks fine too me, if a bit idiosyncratic. You'll have to also show us the lexer and parser for us to give any useful feedback.

Two unrelated questions:

* Why aren't you handing the input channel directly to the lexer/parser?
* You are only ever parsing the first line of a file. Was that your intention?",1521200089.0
gasche,"One thing that is strange in your post is that the things you are discussed are all at the micro-optimization level. If you compiler is *very slow*, you can probably save some nice constant factors optimizing things, but maybe you are doing too much computation in some parts of your implementation, and higher-level design questions should come into play?

Have you tried to measure the time that the various passes of your compiler take (just adding a few timer calls to your codebase should suffice for this)? How much of these 3.5s are you spending in parsing, in typing, in optimizations (if any), in code production? Is there an identifiable critical section / performance bottleneck right now?",1520945265.0
jdh30,"Forgive my repeatedly referring you to commercial content that is behind a paywall but I've spent the past 10 years writing about exactly these kinds of things...

> 1) The pervasive usage of F#'s standard library map and list for which I do not have any good alternatives

I invented/developed a [Concestor dictionary](http://fsharpnews.blogspot.co.uk/2017/10/an-optimized-concestor-dictionary.html) as a faster replacement for `Map` where persistence is uncommon. Some code [here](https://gist.github.com/jdh30/1b86476d34d10820f1a13956558cc331).

If you're not already, I recommend using a symbol table to replace heap-allocated strings with ints to avoid the GC write barrier.

> single threadedness

There are usually many opportunities for both parallelism and concurrency in compilers. For example, files can be processed in parallel. Lexing, parsing and type checking can be done concurrently (as stream processing). IME, parallelization is usually the bigger win and it is trivial in F# but virtually impossible with OCaml.

> supports hash consing innately.

See also my [article on perfect hash consing of expressions](http://fsharpnews.blogspot.co.uk/2018/01/hash-consing.html).

> 2) F# is amazingly inefficient at reusing memory for this and I think the allocation rates could be reduced by 100x or more. I am guessing most of this is because the way the map works.

Try to use value types and reified generics to avoid boxing. This can give huge wins over OCaml. You need to reduce the allocation rate before parallelizing because the GC is a single shared resource that is contended for.

> It might be possible that OCaml is faster than F# in general due to its new inliner.

I seriously doubt it. OCaml's main performance problems are lack of multicore support and excessive indirections in the heap due to unnecessary boxing. Inlining doesn't really address either of those problems.

FWIW, I ported a commercial compiler from OCaml to F# and the final result was substantially faster than the original. In fact, I wrote a [case study](http://fsharpnews.blogspot.co.uk/2015/01/porting-commercial-compiler-from-ocaml.html) about that too.

> I'd really want it to be 10-100x faster

Then you need to look for high-level optimizations.

If you package it up into a self-contained VS solution that just runs a benchmark then I'll be happy to take a look as long as you're happy for me to write F# Journal articles about it.
",1520957787.0
alain_frisch,"> Do you think I could significantly improve the language implementation by rewriting it in OCaml? 

It's hard to know without trying, but the kind of programs you want to optimize is typically the one where the OCaml runtime system shines.  I'm pretty certain you wouldn't get a 100x speedup compared to F#, though, without algorithmic changes.",1520963524.0
choeger,"You are saying you do some kind of compile-time evaluation. Am I right to assume that your compiler thus contains an interpreter? If so, its design largely influences your performance.

How does that presumed interpreter work? How do you substitute variables? Deal with closures? Data structures? Instruction dispatch? There a plenty of techniques to make these aspects more efficient. The simplest reference is any reasonably small lisp implementation. 

And of course you should consider how that interpreter is triggered and how its results are fed back into the compiler.",1520974753.0
gallais,"Caveat:

> The input code is a subset of OCaml, with the following key points:  
* Code must be a single OCaml statement (i.e. excludes the trailing "";;"")  
* Pattern matching is not supported  
* Physical equality is not implemented  
* Strings are supported only for use with failwith; they cannot be manipulated  
* The tool does not use type checking, nor is typed: therefore where OCaml would throw an error, it is possible to step through such a program",1520800019.0
Crandom,Practically every strict language has this ugly special case for short circuiting || when used as an operator. Lazy languages like Haskell don't need this kind of hack. ,1520769569.0
gsg_,"I think this is a case of the implementation leaking out into the sunlight rather than a deliberate decision.

What's going on: `||` is a primitive, the binding in pervasives being

        external ( || ) : bool -> bool -> bool = ""%sequor""

When you mention such an `external` identifier in any way other than fully applied, (the current implementation of) OCaml makes it behave like a curried function by rewriting it as `fun args... -> prim args...`. For almost all `external` bindings this is fine, but for `||` and `&&` short circuiting gets broken as you have observed.

Note that you can partly observe this rewriting with `==`: `(+) == (+) => false` but `let add = (+) in add == add => true`. More directly, you can peek at what the implementation is doing with `-dlambda`.

This is definitely not as clean as it should be, but isn't really a problem in practice.",1520825199.0
sepp2k,"A function call always evaluates the arguments first and then calls the function. This is true regardless of the function's body.

So if you have `f exp1 exp2`, you'll know that `exp1` and `exp2` will be evaluated and that this will happen before the body of `f` is evaluated, even if you know nothing about the contents of `f`'s definition.

This is true in all languages with strict evaluation rules, which are the vast majority of programming languages. One language where this wouldn't be the case is Haskell, which uses lazy evaluation by default.",1520765755.0
Drupyog,"It's not used internally (why would it?) but you should be able to use andreas' libraries.

You might have to plug things together yourself (the code will be very similar to `graphql-lwt`, but with ocsigenserver's api instead of cohttp) but other than that, I don't think there would be any issues.",1520594920.0
aantron,"- [changelog](https://github.com/ocsigen/lwt/releases/tag/3.3.0)
- [repo](https://github.com/ocsigen/lwt)",1520532762.0
,[deleted],1520544602.0
ollehar,TL;DR? Use-case?,1521021450.0
das_kube,You might be interested in the [series of blogposts](http://roscidus.com/blog/blog/2014/06/06/python-to-ocaml-retrospective/) about migrating 0install from python to OCaml. The author is now a full time OCaml programmer :-),1520223963.0
bobbypriambodo,"Being a popular language Python is, it has tons of robust open-source libraries that are currently nonexistent in OCaml. Depending on your use case, it may be a deal-breaker. You can build them yourself but it'll definitely cost you time and effort.

That said, people *have* build large scale things with OCaml (think Jane Street, Facebook, Ahrefs), so it's definitely ""usable enough"". I imagine with the rise of Reason it will bring many more developers to the OCaml world that can help shape the ecosystems even nicer.",1520241572.0
Leonidas_from_XIV,"So, as someone who started with Python in 2003 until roughly 2013 I vastly prefer OCaml nowadays to the point of being very irritated whenever I have to write Python.

The main advantages of OCaml is the static type system, which allows me to be somewhat confident in the fact that whatever I am coding actually works and does not explode because I mistyped a character in some rarely-executed branch of my program.

Another advantage is that the language is functional-first and mostly immutable (despite being multi-paradigm, but honestly after using it since 2009 I still can't remember the syntax for imperative loops). You can do functional programming in Python but all the core data structures are mutable, so it is very difficult to reason what your program is doing and the programs end up being somewhat unidiomatic (imagine using itertools, functools and the operator module for everything). Then I gave up and switched to Clojure it was like coming home because I didn't have to fight with hash tables anymore.

Packaging is sort of bad in both languages. OCaml has about as many build systems as programs but at least once it compiles it is fine. In Python everybody uses setuptools to build but getting it to build can be a challenge and I hate virtualenvs for how cumbersome they are. pipenv is trying to make it better but I don't understand why Python won't just copy what Node/NPM are doing.

I much prefer OCamls Async/Lwt to Asyncio. In OCaml you have a Deferred (Async) or Thread/Promise (Lwt) and you can wait on it. In Python you have [all of this](http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/), which makes even simple programs hard to understand for me. Even those I wrote myself. I don't remember Twisted being this complicated, but it has been many years since that.

I was compiling OCaml to JS which sort-of works surprisingly well, at least until you use native code at which point it breaks down. So even though I have JS and native compiled code, I have to be very careful what I like with what. The only code I share is type definitions for the most part. I did however enjoy building HTML with Tyxml, which has the additional benefit of only constructing valid HTML. Pretty neat.

On the other hand, I don't particularly like named/labelled arguments. I think they make composition harder, since unlike Python labeled arguments are not positional, so you always have to call them by their name, which forces you to be really careful about naming them. But you don't run into weird surprises as in Python where there are functions that you just cannot call with named arguments.

I also liked the Elm architecture, therefore I'll look into [ocaml-vdom](https://github.com/LexiFi/ocaml-vdom) next time I'll do frontend code. I wanted to like Elm-the-language too and I think it has many good features but every time I use it it is too limited or not expressive enough (and I am not doing very complated things, really).

In short: I suspect I am too stupid to use Python. I wouldn't want to use it for much of anything nowadays.",1520291936.0
laylomo2,"I coded Python professionally for 3 years, and I must say, it was very painful. Python is usually seen as an ""easy"" language, but when you are debugging 1500 line functions written by a legacy of programmers before you... *shudder*, you learn to lean hard towards static typing. At some point I realized that what I really needed was a language that had sane defaults.

I was drawn towards OCaml for a few reasons:

- Fell in love with functional programming through learning a bit of Haskell

- I loved the clean and lightweight syntax

- Static typing!! Variants!! Functors!! Monads!! Oh my!!

- Seriously badass type system, it's unbelievable how much you can get out of it

- Sane defaults! Immutability, composition oriented programming, exhaustiveness checking

- Imperative and mutable programming escape hatches (seldom actually used in practice)

- Predictable performance

- Pragmatic community

- Four backends!  Native, Bytecode, JS via Bytecode, and JS via transpiling

- Adoption by some major companies: Jane Street, Facebook, Bloomberg, Docker, Citrix, to name a few

There were a couple warts though:

- Unfamiliar syntax

- Community fragmentation

- No multicore

The unfamiliar syntax grew on me over time, and now I much prefer it over C-like language syntax.  But it also has a few warts (nested match statements, weird nuances with operator precedence), but the warts don't really take away much IMO.

Since I've started programming in OCaml, I feel the community has actually become a lot closer than it was before.  With the introduction of dune and the creation of the discuss.ocaml.org community, I feel the community is beginning to come together like it never had before. The RWO book is a fantastic resource, and I have to say, the Jane Street libraries are rock solid, serious feats of engineering. In all, I'd say the OCaml community is a small community of intensely smart programmers.  There is much to gain from interacting with everyone and becoming familiar with and using the code that is out there.  Also, since the community is small, there are many niches to be filled. There's a lot of growth potential in the community.

Lack of multicore never really bothered me too much, but I also haven't been in a situation where I really needed it.  For most things, the async/lwt libraries get the job done, but, like Python, OCaml has a GIL, so in order to get parallelism, one must fork.  At that point, I would just start designing the app to work in a distributed model, which anyways, is more flexible.  Though, occasionally I'll feel a little jealous of Go's goroutines.

The last point I want to make is something which I heard somewhere but I can't remember where, which is that ML wasn't really a language that was designed, as much as it is a language that was discovered. The mathematical foundations run deep in OCaml, and the more you use it, the more you'll realize it and come to appreciate it.",1520312798.0
apoisel,"My company builds applications on top of PostgreSQL with web interfaces written mostly in Django.  We are using OCaml for everything outside the contexts of the database and the web application.  Not only to gain performance but for increased runtime robustness.  

While OCaml can't match the wealth of PyPI, we've managed to check all the boxes.  A few days ago I found [py — OCaml interface to Python](https://github.com/zshipko/ocaml-py).  Haven't tried it, but looks interesting.
",1520290706.0
jdh30,Who?,1520445612.0
,[deleted],1520474521.0
10xjerker,"lol, it was 100-140K and is 100-120K now",1520335975.0
AlexCoventry,Why not just go hit /u/murbard up on /r/tezos?,1519950336.0
andrejbauer,"You don't have a problem with nested recursive functions, but with the understanding of what `function` does. Consider the following function:

    let f x = function
      | 0 -> x
      | 1 -> x + 2
      | y -> x + y

Question: how many arguments does `f` take? Two! The function `f` is equivalent to

    let g x z =
      match z with
      | 0 -> x
      | 1 -> x + 2
      | y -> x + y",1519824444.0
Cricco95,"Can you train to explain me also how the recursive function works? Here is the missing code:

    let rec costocammino = function
	    [] -> 0
	    | (p,v)::coda -> v + costocammino coda
    ;;

    let confronta c1 c2 =
        let costo1 = costocammino c1
            in let costo2 = costocammino c2
                in if costo1 > costo2 then c1
                    else c2
    ;;

In particular is really difficult to me to follow the behaviour od the function *zaino_aux* which calls itself and also the *confronta* function.",1519828089.0
RedPetrichor,"Here, The ""function"" keyword can be replaced with ""fun l -> match l with ""

Is it more clear to you that way?",1519824058.0
Cricco95,"Thanks, now it's clear. Into the recursive function I'm performing a pattern matching with listaf which is another parameter of the function.",1519824566.0
poke_peek,"The *function* keyword introduces a one-argument function and matches against the argument. Since it is bound to a function with one pre-existing argument, you now have a two-argument function (partial application is built-in to Ocaml).

The *let rec* line could be replaced by:

    let rec zaino_aux p_temp x = match x with
",1519824811.0
VictorNicollet,Looking for a Lech lead ? :-),1519761136.0
programmerChilli,"I really suggest reading through the reddit thread that he got the definition from. Lots of good explanations/examples in there too.

https://www.reddit.com/r/ocaml/comments/1jmjwf/explain_me_gadts_like_im_5_or_like_im_an/",1519794155.0
BoinkGoesTheScience,"Author here • I'd appreciate any feedback or suggestions to make this more useful to others. Also, any corrections if I got something wrong. ",1519412475.0
kaycee,"There has been a series of improvements in the Multicore land which some of which don't immediately show up in the code I am afraid. :-) 

A key development has been our work on the memory model which answers a fundamental question - what does it mean to run a shared memory multicore OCaml program on modern multicore processors. Multicore memory model provides much stronger guarantees compared to C++ or Java memory model (the two well known ones). A [paper](http://kcsrk.info/papers/pldi18-memory.pdf) on the memory model has been accepted to PLDI'18. The first few sections should be fairly accessible.

We've also worked out a new termination detection algorithm for the GC. In a concurrent mark-and-sweep GC, there is usually a point at the end of every major cycle when all the cores need to synchronise. The problem is that cheaply detecting when all of the cores have finished their work in the current cycle is very hard since work might dynamically migrate between the cores (due to work stealing or, in a much more subtle fashion, due to the effect of the write barrier). The new termination detection scheme has been included in the latest multicore release. 

As a direct result of the new termination detection, we've also worked out the new implementation for the awkward squad of the GC -- finalisers, weak refs, ephemerons. Getting some of these features working in a concurrent GC required new research. We have a design for this now and will soon be implemented. 

I have also been working to rebase multicore OCaml to more recent releases. This is quite a painful process since lot of the GC/runtime bits have changed and one needs to work out how best to incorporate new features such as spacetime profiler, latency optimisations for the GC. I am currently working on this. 

There has been more work on algebraic effect handlers and in particular their interaction with resources like file descriptors. We've published a [paper](http://kcsrk.info/papers/system_effects_feb_18.pdf) detailing some of these interactions and our solutions to them. 

The current focus is to rebase it to latest release before adding new features in. You should expect to see more work in the coming weeks. ",1519133322.0
,[deleted],1519079085.0
nnbbb,i was wondering about the interaction of flambda and the multicore compiler -- does the rewrite of flambda that is currently in progress mean additional work for multicore? or are these features reasonably orthogonal?,1519315816.0
Drupyog,"At the moment, WASM is not featureful enough to handle everything that js_of_ocaml is used for. In particular, wasm can't access the DOM or anything included in the js heap. While that might be sufficient for some things, it would certainly not handle the stuff exposed by the js_of_ocaml and eliom libraries.

So, you would need to design new libraries from scratch, and then try to figure out how and when to offload computations. I think it's simpler just to wait for GC and other features to land. :)",1519223331.0
cedlemo,"The cheat sheet is really great. 

There is this topic on discuss.ocaml.org :

[Making OCaml accessible and learnable for more people](https://discuss.ocaml.org/t/making-ocaml-accessible-and-learnable-for-more-people/381). Maybe you can share your point of view there or create a new topic.",1518983437.0
PM_ME_UR_OBSIDIAN,"Completely agree. F# is significantly more beginner-friendly than OCaml, and the differences are subtle enough to not matter for a beginner.",1518981167.0
frumsfrums,"Take a look at [Real World OCaml](https://realworldocaml.org/) (free, very comprehensive reference), or [OCaml from the Very Beginning](http://ocaml-book.com/) (not free, but suitable if this is your first (functional) programming language). RWO is practically the de facto introduction to the language for most people, so hopefully it works for you.",1519046428.0
,[deleted],1519074399.0
dalastboss,Can this be seen as an argument for a CPS-based calling convention as opposed to the usual C stack?,1518741178.0
,[deleted],1518741917.0
jellysci,This is really cool! If you end up writing a blog post on your experience (given that it’s your first project in OCaml/Reason) I’d definitely read it. ,1518671484.0
TotesMessenger,"I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:

- [/r/reasonml] [A URL shortener in OCaml and ReasonML](https://www.reddit.com/r/reasonml/comments/7xk41l/a_url_shortener_in_ocaml_and_reasonml/)

&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",1518632965.0
cies010,"Nice project, but...

Why not write both in ReasonML or both in OCaml (using BuckleScript w/o Reaon on the FE)? I do not get it :)",1518652550.0
spicausis,"A proper function would return  Some(x) or None.

Returning a magic integer ""-1"" is such an error-prone and un-camlish way to do things, even for a homework, that I'm wondering what is this poor course and what more examples of a bad style are they teaching.",1518515906.0
jellysci,"You should probably disclose if something is a homework problem. I won't give you a solution, but I'll give you a hint: think about pattern matching.",1518500062.0
,[deleted],1518570405.0
theseus905,"youuse tail recursion, or just use List.nth 

honestly you should be doing a bit more research. the manuals are very important. ",1518569975.0
PseudonymousCustard,"If you go for the Result monad, embedding polymorphic variants is indeed probably a very good, folklore solution... but then, it seems to me that ""real"" programs are more complex than this academic example. For instance, you may need to resort to monadic operations (liftM, mapM and the like), and then you also want to use other monads at the same time... and ultimately you spend a lot of time composing monads and interpreting type errors ('cause you forgot a liftM somewhere...), and you work with other people who are not acquainted with monads and so on (and OCaml does not come with a commonly-agreed library for monads)... And then you realize that exceptions, and imperative aspects in general, when used in a reasonable, as local as possible, way are very compelling.

I'd very much like to see some feedback from experienced people on this topic.

I'd like to see ",1518611928.0
jellysci,This kind of glosses over how to extensibly display the different kinds of errors. But polymorphic variants seem like a very nice solution overall.,1518557379.0
TheGrammarBolshevik,I'd be interested in seeing how extensible variants would compare in this application.,1519919314.0
jonsterling,Are there examples of its output?,1518275493.0
XVilka,"Not exactly an OCaml example, but I have a high hopes for the *TeX restart with Rust - https://github.com/tectonic-typesetting/tectonic
I hope it can give TeX ecosystem a new breath and modern user experience (and higher-level concepts and abstractions in a functional style of course).",1519028049.0
maninalift,I feel I should mention (although I'm sure the author is aware of) [patoline](https://github.com/patoline/patoline),1518289992.0
gasche,"The question was already resolved on StackOverflow. OP is using `ocamlyacc` instead of `menhir`, on a grammar that uses Menhir-only features.",1518254860.0
,"
should be easy to be able to just copy the files
for running emacs use `-q -f \your\file\here` as the flags for the emacs configuration
the utop and emacs parsers should be able to be set by setting the global variables",1518213544.0
eras,"If you are looking for a safe solution, then starting a separate process for this function is that. Otherwise, in a multi-threaded program, the computation may acquire locks that won't be relinquished/locked when the process is killed: consider the severity of that in presence of locking in the IO or garbage collector. So you would need to inject an exception into a thread, that's not probably possible..

You may be able to use SIGALRM and exceptions in some situations. Previous discussion: https://www.reddit.com/r/ocaml/comments/3qapbv/question_about_writing_a_timeout_function_and_the/
",1518012079.0
andrejbauer,"The killer feature is simply the fact that OCaml has decent algebraic datatypes, and these are precisely the datatypes that express abstract syntax trees. On top of that, the `match` statements with patterns make it very easy to write functions that analyze the abstract syntax trees.",1517778369.0
,[deleted],1517783689.0
jdh30,"> Why does OCaml seem to be the language of choice for this sort of work? Does it have some killer feature that other languages don't have? Is there some really fantastic library in OCaml for this? Is it mostly inertia?

OCaml hits a sweet spot in this context:

* OCaml has great lexing and parsing tools that are not only capable but also easy to use and, just as importantly, easy to get started with. For example, ocamllex and ocamlyacc even have emacs editor modes so you get all the usual IDE features even within your familiar lex and yacc files. Even F# doesn't have that.
* Processing programs, which boils down to rewriting trees, is much easier in OCaml than languages like C or Java thanks to algebraic datatypes and pattern matching over them. Other languages like Standard ML, F#, Haskell and Swift share this benefit. Note that Rust does not yet share this benefit because (in the absence of a tracing GC) you inevitably end up falling back on reference counting and it is not yet possible to pattern match ""through"" and `Rc` in Rust so you must effectively compile your pattern matches by hand as if you were using `switch` in C so Rust does not yet capture this huge productivity boost from the ML family of languages.
* The OCaml compiler is very fast which makes development very fast because rebuilding is quick. F#, Haskell and many Standard ML compilers are a lot (~10-100x) slower.
* The OCaml compiler generates code that can not only be fast but, in particular, has very predictable performance characteristics. Standard ML compilers either generate code that is not as fast (SMLNJ) or is not predictably fast because it relies upon whole-program optimisations (MLton). Haskell is notoriously unpredictable not only in terms of performance but also memory consumption.
* OCaml has a lot of handy and pragmatic but mundane features like statically-typed and high-performance `printf`, an easy-to-use `Hashtbl` and so on. This, again, makes it quick and easy to get started with OCaml.

OCaml is the only programming language to offer all of these benefits at the same time, making it an alluring choice for this kind of work. Incidentally, OCaml is also really good for a lot of other work too: like writing servers.
",1517793602.0
smog_alado,Frama-C was developed in partnership with INRIA. Of course they would use Ocaml :),1517781235.0
,[deleted],1517578840.0
ulfurinn,"_casual OCaml follower here_

The proposal has been floating around for ages, what's blocking it from being merged?",1517499648.0
gasche,"I don't think the OCaml compiler distribution currently uses autoconf, what gives you this impression? Yes, building with clang is possible (if clang is the default on your system and aliased by `cc`, `./configure -cc cc` may just work, otherwise `./configure -cc 'cc -O2 -pipe' -aspp 'cc -O2 -pipe -c'` seems to be the standard invocation to not use an available `gcc`).",1517416510.0
notfancy,See [this post](https://www.reddit.com/r/ocaml/comments/puz7t/neat_code_persistent_arrays/) with references. Also [this implementation](https://github.com/shepard8/ocaml-ptarray).,1517531466.0
IndiscriminateCoding,Some time ago I've done OCaml [implementation](https://github.com/IndiscriminateCoding/clarity/blob/master/lib/vector.mli) of RRB trees. Feedback are welcome :),1517582623.0
Categoria,Seems like this is weirdness on your distro's installation of OCaml. I'd recommend to install a switch using opam and install inside that switch.,1517390784.0
raevnos,"Saw this on /r/programming, thought it was an interesting project.",1517317230.0
Drupyog,The paper (https://hal.archives-ouvertes.fr/hal-01292266/) combines this with ocapic to program microcontrolers in OCaml! :),1516902944.0
callipygous,"Coool, I know its really annoying when you give the world a shiny new toy and the world immediately asks for more toys but....any plans in the future to look at clocked dataflow?",1516904504.0
Drupyog,camlp4 :(,1516726785.0
juloo65,"`utop` does this when it's stdin or stdout is not connected to a terminal
eg. `cat | utop` or `utop | cat`
Quick check: `tty` should ouput something like `/dev/`...",1516491838.0
anaerobic_lifeform,"Do you have the exact same prompt as when you type `ocaml` or something slightly different?

Any difference when calling `opam config exec utop`?",1516474872.0
ChainReplication,"Yeah, it was a good year, from a pl design point of view I am pretty biased towards Ocaml / SML, I'm also pretty happy about all the attention session types got this year. 

Especially since even before I knew about them I used to use plain pi calculus and I would write out the protocol using ml records for the data and variants for duality, and just write what protocol type I was using on top of the math. 
",1516131244.0
,[deleted],1516202635.0
catlion,"Sound quality is far from perfect, unfortunately",1516397972.0
osrs_zubes,"A note about BuckleScript & ReasonML interop with the OCaml ecosystem like Core — remember that ReasonML is almost like a syntactic sugar for OCaml. Both languages produce the same untyped AST which is parsed all the same. So you can totally use OCaml packages in ReasonML and vice versa. 

The issues with interop come when you target javascript with BuckleScript — the OCaml ecosystem wont necessarily work since it would need a way to be converted to JS. That’s why you’ll see things like BuckeScript standard libs in place of things like Core, and you’ll have to stub a lot of JS functions. 

For testing, I think it really comes down to _what_ you’re testing to pick the right tools. ReasonML/OCaml have some good unit testing frameworks which you are aware of, and ReasonML also has snapshot testing support with Jest",1516062495.0
allenguo,"Glad you're enjoying the language!

You can make the trace more useful by telling the compiler the type of `lst`

    let rec bubble (lst : int list) =

or by writing a MLI file (this is the recommended way).

`bubble` uses a nested match. You should disambiguate this using parens or `begin`/`end` as explained [here](https://stackoverflow.com/questions/257605/ocaml-match-expression-inside-another-one). You could also just use `if`/`then`/`else` in this particular situation:

    let rec bubble lst =
        if is_sorted lst then lst
        else match lst with
        ...

A case like `x::[]` where the `x` isn't used should probably be written as `[_]`.

Regarding correctness: your bubblesort implementation is missing something. I'll leave you to figure out what it is. :) Let me know if you need a hint!",1515940474.0
juloo65,"The problem is that on this line:
`| x::y::ys -> if x <= y then x::bubble (y::ys) else y::bubble (x::ys)`
you extract 2 elements from the list and you recurse on `y::ys` (or `x::ys`)
the list is shorter by 1.

In the case of the bubble sort, you probably want to try more permutation by recursing on the full list
`| x::y::ys -> bubble (if x <= y then x::bubble (y::ys) else y::bubble (x::ys))`",1515966915.0
aantron,"You may benefit from using Ctypes. Repo is here, https://github.com/ocamllabs/ocaml-ctypes, lots of documentation links in the README. Hope it helps.",1515782443.0
chrismamo1,"u/yminsky is correct that noalloc calls are quite fast, only marginally slower than native non-ffi calls.

The excessive byte code overhead is something of a non-issue to me at least, since speed isn't exactly a top priority there.

I think the major problem here is that there's a slight lack of accessible documentation describing the tricks for making the ffi perform well. I believe the official OCaml manual maintained by INRIA has a comprehensive overview of the ffi, and there's a JSC article called ""writing performance sensitive OCaml code"" which probably covers what you're looking for, but it's been a while since I've looked at that.",1515868401.0
Syrak,"Nice find, thanks!

I like that it's one front-end with multiple backends as opposed to the current state of one variant of lex/yacc for every language.

The author stresses hygiene and error messages. More than debugging, instantiating actions directly via a functor in a familiar target language helps with *writing* lexers/parsers. It makes it easy to discover how to use the API. Just look at what is in scope, instead of having to remember the odd lex/yacc syntax to get the current location, this or that token, to continue lexing...",1515414461.0
hardmathproblem,"As someone who has recently started learning OCaml and hopes to really dig into it this year, I really enjoy articles that highlight the practical use cases of OCaml’s type system. Looking forward to rest of the series. ",1515207066.0
ollehar,"Done. As an employee of LimeSurvey, I also feel obliged to point out how much better LimeSurvey is than SurveyMonkey. ;)",1515149594.0
icspmoc,"Opam 1.x.x relies on external constraint solvers like `aspcud` or `mccs` for dependency resolution but, as a fallback, ships with a very naive built-in solver. Unfortunately, `aspcud` and its alternatives tend to be a bit too brittle in practice and the internal solver is too limited to handle non-trivial scenarios.

To rectify this situation, opam 2.0.0 ships by default with a [forked version of `mccs`](https://github.com/AltGr/ocaml-mccs) that has been stripped-down and modified to suit the needs of opam. The current 2.0.0 beta is already in a very usable state so, personally, I'd recommend just using that instead.",1514900424.0
ChainReplication,"This happened to me twice once on a fresh install of Debian, the other on a fresh Arch install. 

Did you try installing aspcud, last time I got that error when I was doing a fresh install on a debian machine and it was fixed because it didn't have aspcud out of the box then running opam init , if you do have aspcud try uninstalling aspcud and installing packup  then running opam init which solved my problem on arch.",1516130565.0
bobbypriambodo,AFAIK [cohttp](https://github.com/mirage/ocaml-cohttp) is popular for that. It supports both Async and Lwt for providing the asynchronicity.,1514879238.0
andrejbauer,"1. What operating system are you using?
2. What editor are you using to edit files?
3. You linked to part 19 of 33 in the tutorial. Are you saying that you successfully completed the first 18 parts of the tutorial?
4. Where did you save your file?
5. From what directory did you run the `ocamlopt` command? (What does `pwd` say?)

The files have to be in the same directory from which you run `ocamlopt`.",1514854115.0
Leonidas_from_XIV,But it is not actually written in OCaml?,1514717400.0
callipygous,"Hey op, really interesting work. Thanks for posting. Could you quickly summarise what tool chains you use to target each different platform?",1514890024.0
nnbbb,this looks cool. i was wondering: is it possible to use Reprocessing in a pure-Ocaml context? i.e. compiling to bytecode or native only. what toolchain would be needed? can i install Reprocessing as an opam package and treat it like an Ocaml library? ,1515000826.0
hannesm,"this is awesome, thx for sharing. I'd also be interested in toolchain, as I get it you used OpenGL on all targets, and no native widgets!?",1515281058.0
vonschlager,thanks!,1515357537.0
sverrejoh,"What about using html? BuckleScript, ReasonReact and Election gives you a native like application with a nice api. Slack, Visual Studio Code and Atom is made in this way. 

Probably not what you’re looking for, but web based apps are getting very popular, and the electron platform is capable. ",1514648877.0
,[deleted],1515782496.0
andrejbauer,"Yeah, I've been wondering about this myself for a while. It prevents compilation of CoqIDE on OSX.",1514379416.0
queus,"Try replace `-I +lablgtk2` with the full path or with

    -I $(opam config var lib)/lablgtk2
",1514383471.0
andrejbauer,"It would help if you told us how much experience you have with programming tools in other languages. What have you used so far? What IDEs, if any, have you used?

You should probably learn to use competently at least one decent general-purpose editor (by which I do not mean Notepad). Since you live in the Windows world, something like [Atom](https://atom.io) might suit you. It has OCaml support (you need to install the relevant packages).

It's still too difficult to get OCaml going on Windows.",1514368791.0
yawaramin,"Basic overview: OCaml has two different compilers and an interpreter, also known as a REPL (read eval print loop). You will usually want to write OCaml programs in your favourite editor and run the `ocamlopt` compiler to compile the programs to native executables for your machine. For simple projects you will be fine just passing all your source code to the compiler: `ocamlopt file1.ml file2.ml...`.

For more complex projects, especially if you want to use existing packages from the OCaml community, you will need to use a couple more things: opam, the OCaml package manager, and jbuilder, the build tool (soon to be renamed to dune).

You can look up tutorial guides on how to use those tools separately.

One more thing: you will most likely want to use a tool called Merlin. It's available as a package from opam. Merlin is very useful because it lets your editor help you write OCaml code. It gives you things like 'jump to definition', 'show type on hover', and so on.",1514560460.0
AlexCoventry,"Find an IDE with good OCaml support. The only one I know is Emacs, and that would be quite a large detour for you.",1514358535.0
StrykerKKD,"The workflow is basically the same as the the C workflow.

 1. Write the code.
 2. Compile it from command line.
 3. Run it from command line.

I guess in your case your command line will be cygwin.
You can find a simple [example](https://ocaml.org/learn/tutorials/basics.html#Running-OCaml-code) on Ocaml's site.",1514370800.0
aantron,"- [Changelog](https://github.com/ocsigen/lwt/releases/tag/3.2.0)
- [Future breaking change notice](https://github.com/ocsigen/lwt/issues/453#issuecomment-352897664)",1514152968.0
_lindig,An app compiled to native code (using `ocamlopt`) will run fine. You can find the libraries that are required at runtime by running `ldd` on the binary: `ldd app` You will find that no unusual libraries are required. You could also link the binary statically.,1514128972.0
yawaramin,"I think most serious deploys are done with Docker nowadays, here's a guide https://medium.com/@bobbypriambodo/lightweight-ocaml-docker-images-with-multi-stage-builds-f7a060c7fce4",1514228707.0
glitch_freq,I think it requires a shared library. You can use ldd to check what shared libraries the executable it needs,1514129126.0
Categoria,"On the plus side, I see it as a huge potential benefit that even those who are totally uninformed hearing about and knowing a little about OCaml/Reason. If the criticisms presented in this post are what we have to debunk to gain adoption, then I'd say we're in a good position.

What's important is that once people get out of the noob stage, they will start discovering the actual weaknesses that are mostly present in the tooling. If we fix those issues in the near future, we have a good chance to gain a lot of new users.",1514000577.0
AlexCoventry,"I think he made some cogent points, and as [nec4b said on HN](https://news.ycombinator.com/reply?id=15995932), I'd be much more interested in hearing solutions to the readability and debugging issues he's raised than listening to people pat themselves on the back about how ignorant he is.

By the way, vjeux is a highly capable developer. If he's struggling to understand a piece of code, probably there's been a failure of presentation somewhere and a lot of other potential converts are missing out, too.",1514087998.0
haterofallcats,"It took me a while into my career to agree with his comments about point-free style.  It requires more cognitive load to read, but is dead simple to write.

Also, a great read on the topic: https://www.yesodweb.com/blog/2015/10/beginner-friendly-code-and-apis",1514033661.0
das_kube,"Please, /u/ry_harper, there is no need to be that harsh in the title. The gist wasn't even intended to be that widely shared, as explained on HN. ",1514296593.0
jonsterling,"This guy should be fired on grounds of being an idiot! 😂 And this a followup to a post defending his CS degree from those who think such degrees are worthless... I am afraid they may have been right in this case, sadly. 

Jokes aside though, I agree with the other commenter who said, if this is all we have to debunk, then we must be in pretty good shape.",1514012377.0
gasche,"This is a very interesting project, thanks!

Right now, you are mostly focused on matching the convenience of the Scheme-based framework (modulo the fact that attributes/extensions used to control metaprogramming have a heavier syntax than Scheme macros). One thing that I found find interesting is to also investigate how much magic you can *remove* (without reducing convenience too much).

For example, given my model of the type declarations that you generate, I have the impression that it should be possible to write the `Scheme0 ==> SchemeNoLet` transformation without any magic, with something like

    let rec remove_let : Scheme0.t -> SchemeNoLet.t = fun expr ->
      match Scheme0.map remove_let expr with
      | `Let (id, value, body) ->
       `Apply (`Lambda (id, body), value)
      | other -> other

This is assuming that `module%language Scheme0` defines both a closed type `Scheme0.t`, but also an open-recursion type `'a Scheme0.t_` (with `Scheme0.t = Scheme0.t Scheme0.t_`), and a function `map : ('a -> 'b) -> 'a Scheme0.t_ -> 'b Scheme0.t_`.",1513683071.0
mindeavor,Does nanopass help with type checking in any way?,1513717016.0
das_kube,"That's cool, but crowbar itself is still not on opam :-/. Maybe release crowbar before writing a ppx for it?",1513610079.0
laylomo2,"Thanks Bobby, this is really good!  One point which I think should be mentioned that many beginner OCaml tutorials seem to skip is the camlp4 to ppx transition.  I don't currently maintain a blog, but if I did, I would write a piece about that as well.",1513185152.0
Drupyog,I encourage everyone to use and recommend the usage of `opam user-setup`. It looks up the various tools you have installed and setup your editor of choice just the right way so that everything works.,1513193984.0
laylomo2,"Which version of jbuilder are you using?  I know there was an issue resolved in jbuilder version 1.0+beta12 (18/08/2017) with this description:

> Use digests (MD5) of files contents to detect changes rather than just looking at the timestamps. We still use timestamps to avoid recomputing digests. The performance difference is negligible and we avoid more useless recompilations, especially when switching branches for instance (#209, fixes #158)",1513109768.0
,[deleted],1513032550.0
andrejbauer,"I would advise you to try stackoverflow.com, and tell people a bit more about your setup. What operating system, what version of C, what version of ocaml? Is there a reason you're not showing us the code?",1512827440.0
sebmondet,"Difficult to know with this information, but I don't see what would create the `xattr.cmo`, maybe that's what's missing in the `.cma`?

Also, `ocamlmklib` is already supposed to create a whole properly linked library, incl. the `.cma`s and everything needed, sounds like it should be the last step before building the custom-executable.
http://caml.inria.fr/pub/docs/manual-ocaml-311/manual032.html#toc137",1512829068.0
Leonidas_from_XIV,"While OPAM does not generate `.merlin` files for you, `jbuilder` does, out of the `jbuild` description of your build.",1512311612.0
rymdhund,The ocaml-tls project has a .merlin file in the repo so in that particular case it shouldn't be that. Did you install the opam dependencies? If you dont have them installed you will get the unbound module error for the missing packages. And for merlin to find the local modules from the same project you need to build the project in order to generate the .cmi files that merlin uses.,1512379198.0
Camarade_Tux,Avoid Graphics and use something like lablgtk instead.,1512285110.0
carette,"But does it support Windows? Last I looked, opam didn't.",1512220034.0
Syrak,"My source is this SO answer https://stackoverflow.com/questions/15561714/when-does-the-relaxed-value-restriction-kick-in-in-ocaml#15562110

The relaxed value restriction applies to type variables that appear only in covariant position. `list` is covariant, but `array` is not, because of mutability.",1512103109.0
octachron,Another sources for the relaxed value restriction are the imperative programming chapter in RWO (https://realworldocaml.org/v1/en/html/imperative-programming-1.html) and the polymorphism chapter in the official manual (http://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html#sec51).,1512142504.0
