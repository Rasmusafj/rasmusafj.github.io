author,comment,timestamp
DanielPerezAlvarez,"It should work replacing \`fromLeft\` to \`\[Directions.FROM\_LEFT\]\` and the others...

And for your question, I generally just iterate over them when I have doubt

&#x200B;

    enum Directions {
      FROM_LEFT = ""fromLeft"",
      FROM_RIGHT = ""fromRight"",
      TO_LEFT = ""toLeft"",
      TO_RIGHT = ""toRight""
    }
    type animationData = {
      [id in Directions]?: { entering: string; exiting: string }
    };
    const data: animationData[] = [
      {
        [Directions.FROM_LEFT]: { entering: ""keyOne"", exiting: ""keyTwo"" }
      },
      {
        [Directions.FROM_RIGHT]: { entering: ""keyOne"", exiting: ""keyTwo"" }
      }
    ];
    

&#x200B;",1543617950.0
brainbag,"Ok, you're almost there but have a few little oddities. 

If you want to use an enum as a key, it must be a `const enum`. ([stack overflow explanation](https://stackoverflow.com/a/49827446/1742070))

There's comments in the fixed sample code. [Here's the working code](https://www.typescriptlang.org/play/#src=%2F%2F%20To%20use%20this%20as%20a%20key%20index%2C%20it%20must%20be%20%22const%22%21%0Aconst%20enum%20Directions%20%7B%0A%20%20FromLeft%20%3D%20%22fromLeft%22%2C%0A%20%20FromRight%20%3D%20%22fromRight%22%2C%0A%20%20ToLeft%20%3D%20%22toLeft%22%2C%0A%20%20ToRight%20%3D%20%22toRight%22%2C%0A%7D%0A%0A%2F%2F%20This%20should%20likely%20have%20its%20own%20interface%2C%20so%20when%0A%2F%2F%20you%27re%20specifying%20options%2C%20you%20can%20use%20it%20to%20type%20check%0Ainterface%20AnimationOptions%20%7B%0A%20%20entering%3A%20string%0A%20%20exiting%3A%20string%0A%7D%0A%0Atype%20AnimationData%20%3D%20%7B%0A%20%20%2F%2F%20Have%20to%20say%20that%20the%20key%20is%20%3F-optional%20or%20else%20%0A%20%20%2F%2F%20your%20objects%20will%20expect%20ALL%20of%20the%20directions%0A%20%20%5Bkey%20in%20Directions%5D%3F%3A%20AnimationOptions%0A%0A%20%20%2F%2F%20If%20you%20want%20to%20require%20a%20single%20key%2C%20look%20into%20%0A%20%20%2F%2F%20Pick%3CT%2C%20Exclude%3Ckeyof%20T%2C%20K%3E%3E%20in%20the%20documentation%3A%0A%20%20%2F%2F%20https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-2-8.html%0A%7D%0A%0Aconst%20data%3A%20AnimationData%5B%5D%20%3D%20%5B%0A%20%20%7B%0A%20%20%20%20%2F%2F%20Dynamic%20key%20works%0A%20%20%20%20%5BDirections.FromLeft%5D%3A%20%7B%20entering%3A%20%22valueOne%22%2C%20exiting%3A%20%22valueTwo%22%7D%2C%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20%2F%2F%20literal%20key%20works%20too%0A%20%20%20%20fromRight%3A%20%7B%20entering%3A%20%22valueOne%22%2C%20exiting%3A%20%22valueTwo%22%7D%2C%0A%20%20%7D%2C%0A%5D%0A%0Aconst%20directionKey%20%3D%20Directions.FromLeft%20%2F%2F%20%27fromLeft%27%0Aconst%20dataObject%20%3D%20data.find%28%28obj%3A%20AnimationData%29%20%3D%3E%20%21%21obj%5BdirectionKey%5D%29%0A%2F%2F%20undefined%20check%0Aif%20%28dataObject%29%20%7B%0A%20%20const%20options%20%3D%20dataObject%5BdirectionKey%5D%0A%20%20%2F%2F%20undefined%20check%0A%20%20if%20%28options%29%20%7B%0A%20%20%20%20const%20%7B%20entering%2C%20exiting%20%7D%3A%20AnimationOptions%20%3D%20options%0A%20%20%20%20console.log%28entering%2C%20exiting%29%0A%20%20%7D%0A%7D)

Note there's one minor issue with fixing your approach—you can have empty objects `{}` in your `AnimationData`.  If you want to restrict the keys to guarantee having only one, look into [`Pick`, `Exclude` and maybe `Partial` advanced built-in types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html).

PS I recommend sticking to TypeScript style of capitalization, which I've fixed in my sample code.",1543666404.0
LetterBoxSnatch,"I’m not quite sure what you mean by sequelize on the client, as I’ve only ever used it server side, but the “require” syntax is node. Try changing module resolution to “node”? Very hard to tell without additional context.",1543620749.0
thistoohard,Systemjs?,1543619023.0
notAnotherJSDev,"First question, why do you need sequelize in the front end? 

Second, if you did this, what stops someone from maliciously accessing your database?

Lastly, you're looking for shipping as a UMD or AMD module",1543623002.0
gnawlej,"Not sure if this would work, but try changing your module setting from commonjs to es2015?",1543672058.0
gnawlej,"The reason everyone is giving you shit about Sequelize in browser is because it requires a db connection config to work, which in general, you'd never want to expose in browser code.",1543672297.0
sotimting,No.,1543639686.0
saltupz,"The real issue seems to be you using deprecated functionality. The right way would be to rewrite using the new api, not turning warnings off. Probably a quite easy fix, as the api has little room for big changes",1543641159.0
mrand01,"Not really sure, but a quick glance shows that property isn't in their provided .d.ts file:

https://github.com/moment/moment/blob/develop/moment.d.ts

Nor is it mentioned in their documentation.  However, I do see it in their source code as well as some references to it in various stackoverflow posts.",1543617352.0
cspotcode,"When you say `const translations: ITranslateTest` you disable all inference for the `translations` variable, because specifying a type for a variable overrides inference.

One easy way to use inference is wrap the object literal in a function call.  The function's signature can declare certain type constraints and use generics, allowing inference.  For example:

    function translatableString<Interpolation extends string>(value: {en: string}, ...interpolations: Array<Interpolation>) {
        return value as IPropertyLanguages<Record<Interpolation, string>>;
    }

And then

    const translations = { // <-- no type declaration
        yes: translatableString({
            en: 'yes'
        }),
        helloPerson: translatableString({
            en: 'hello {name}'
        }, 'name'),
        text: translatableString({
            en: 'Is this some text? {yes}, ok! {helloPerson}'
        }, 'yes', 'helloPerson')
    }

I haven't tested, but that should do the trick.",1543594128.0
Dispix,"The slides are awesome ! Great visual, lots of good informations. Will the talk be available on youtube (or any streaming platform) at some point ?",1543585933.0
Dispix,"Your slides are mostly about ""what is FP"" and ""how do we write FP code"" and not much about the compatibility with Typescript. What are your thoughts on that ?

This is one of my main concern at the moment. For example, I love Immutable.js and its FP-oriented style, but found it very difficult to handle types. Another example would be [R.assocPath](https://ramdajs.com/docs/#assocPath): you cannot accurately type the function because of the array of string representing a path.",1543589209.0
ihsw,"What do you mean by modular project structure?

Do you mean [modules and namespaces using `namespace` and `module` keywords](https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html)? They come with their caveats and drawbacks compared to ['ES2015' modules](https://www.typescriptlang.org/docs/handbook/modules.html). ES2015 modules on their own are a significant improvement over CommonJS modules (files that append onto a predefined `exports` object.)

Do you mean [project references](https://www.typescriptlang.org/docs/handbook/project-references.html), where a project's `tsconfig` file can reference another one? This can be a god-send for larger projects.",1543600992.0
MikeMitterer,"How would you organize your files, classes, interfaces or functions?
I can't think of any program language without an equivalent...",1543620622.0
slashmsu," 

# [monolithic-vs-modular.md](https://gist.github.com/joepie91/7f03a733a3a72d2396d6)",1543832638.0
AngularBeginner,"    function process<T extends string | null>(
      text: T
    ): T extends string ? string : null {
      ...
    }

This makes no fucking sense at all. And it can't be implemented without using a type assertion.",1543560188.0
EarlMarshal,Spread & rest are really helpful. Loving all that syntax sugar so much I'm hoping not to get syntax diabetes.,1543527568.0
unshipped-outfit,Inference of function parameter types! ,1543531108.0
flanger001,*Slaps roof of fibonacci function*,1543554675.0
son_of_meat,"sweet. I've been waiting for the configuration inheritance. no more ""extends"": ""../node_modules/..."" !",1543549107.0
r3nya,Yay!,1543526691.0
ShippingIsMagic,really loving the addition of strictBindCallApply!,1543528412.0
esamatti,"""Infer parameter types from usage"" is awesome but unfortunately not that useful with React yet. Found couple of missing features:

&#x200B;

[https://github.com/Microsoft/TypeScript/issues/28764](https://github.com/Microsoft/TypeScript/issues/28764)

[https://github.com/Microsoft/TypeScript/issues/28766](https://github.com/Microsoft/TypeScript/issues/28766)

&#x200B;",1543594127.0
cr125rider,The words wrap weird on mobile. ,1543551936.0
kwiwksh,"As soon as you use any, you lose all type information, and everything reduces to any.

For example, without generics the statement `new Set([1, 2, 3]).forEach(i => ...)` would force `i` to be `any`. With generics, `new Set([1, 2, 3])` is inferred as `new Set<number>([1, 2, 3])`, and `i` would be of type `number`.

Generics are great for data structures. Another example:
```
type Tree<T> = { value: T; children?: Array<Tree<T>> };
```

This allows Typescript to know that the `string` of a `Tree<string>` is `string` instead of `any`.",1543521391.0
EarlMarshal,"Any is just accepting anything and doesn't contain any type information anymore. Generics are a way to use and keep the type when using the function/class with the particular generic. 

For example you want to write functions for a library and you know that most of the time people would give you a number or a string you could just type it as 'number | string' and you are good to go but there times where you don't know yet what you will get so you just use a generic so people could even use their own made types with your library.",1543529259.0
notAnotherJSDev,"Do you use React? If you do, we use generics in the TS version of it all the time.

```
interface Props { ...some amount of props }

class Component extends React.Component<Props> {
  ... all our method stuff
} 
```

So, what we're saying here, is that `React.Component` is a component that takes some object as the props, or the `Props` interface. This lets us get inferences about what properties we have on our props and how to avoid using properties that we don't. We can also pass a second argument, as a typing for our `State` in the class. 

Edit: Another, closer way to look at this is to use a React, stateless functional component...

```
interface Props { ...some amount of props }

const Component: React.SFC<Props> = (props) => {
  ... all our render stuff
}
```

Here, again, we're guaranteeing the type that `props` is going to be, by declaring what `interface` it should match.",1543522917.0
droomph,"Maybe this example will help

    function map(array: any[], cb: (val: any) => any): any[] {}
    
    // some arbitrary complex type
    type type Complex = { i: number }
    
    // naive typed map functions
    function mapNaive(array: number[], cb: (val: number) => string): string[] {}
    function mapNaive(array: Complex[], cb: (val: Complex) => number): number[] {}
    
    // simplified; see full version at https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/core-js/index.d.ts#L183
    function mapGen<T, U>(array: T[], cb: (val: T) => U): U[] {}`
    
    const foo = [0, 1, 2, 3]
    
    // takes number[] and (any -> string)
    const stringified = map(foo, String) // inferred any[]
    // takes number[] and (any resolves to number -> string)
    const stringifiedNaive = mapNaive(foo, String) // inferred string[]
    // takes number[] and (any resolves to T = number) -> string)
    const stringifiedGeneric = mapGen(foo, String) // inferred string[]
    
    const bar: Complex[] = [{ i: 0 }, { i: 1 }, { i: 2 }, { i: 3 }]
    
    // takes Complex[] and (any -> (any + number) resolves to number)
    const extracted = map(foo, obj => obj.i + 1) // inferred any[]
    // takes Complex[] and (any resolves to Complex -> (Complex.i + number) resolves to number)
    const extractedNaive = mapNaive(foo, obj => obj.i + 1) // inferred number[]
    // takes Complex[] and (any resolves to Complex -> (Complex.i + number) resolves to number)
    const extractedGeneric = mapGen(foo, obj => obj.i + 1) // inferred number[]

    // and free type hints
    const foo = map(foo, obj => obj.j + 1) // no error, but will make everything NaN during runtime because undefined + 1
    const foo = mapGen(foo, obj => obj.j + 1) // type error: no property j on type Complex

- we start off with the any-ified `map`. It takes all types and turns them into any[]. Doing this means that typescript can't do its job properly, so we don't want this. (in other cases, you might want to explicitly cast to any, but not here where it's really easy to keep the types)
- the ""first"" alternative is to have override functions for each pair of types. but as you can see, that will get real tedious real fast.
- so we bring in generics, which basically makes an infinite list of those overrides by substituting T and U where appropriate. So much work saved!
- another benefit is that callbacks are typed without you having to manually type them, so you have free type hints.

The other big thing you can do with generics is to limit the types accepted:

    interface Lorem {}
    interface Ipsum extends Lorem {}
    interface Dolor {}
    interface Amit {}

    function mogrify<T extends Lorem>(subject: T): Dolor {}

    const a: Lorem
    const b: Ipsum
    const c: Amit

    const d: Dolor

    d = mogrify(a) // Lorem extends Lorem, ok
    d = mogrify(b) // Ipsum extends Lorem, ok
    d = mogrify(c) // Amit has no inheritance chain to Lorem, type error",1543544575.0
cspotcode,"I would look at arrays, ES Maps, Sets, WeakMaps, and Promises for real-world examples of generics.  For example, `Array.from()` is generic so that the return value is an array of whatever you built it from, instead of a not-so-useful array of `any`.

`Array.prototype.map` is generic so that it returns an array of whatever type the mapper callback returns, instead of an array of `any`.

Promises are generic so that if you have a Promise of number, the `then` callback will take a number as its first argument.",1543594549.0
fafiga2019,"In `fn2`, `T` is not only the type of the `str` parameter, but also of the return value. While it might be not obvious, the full signature of this function actually is `<T>(str: T): T`, however you didn't have to specify the return value type as it could be inferred from the function body. This signature tells the compiler that the types of the parameter and of the return value are the same, so that if you pass a number to this function, it will return a number too. `T` is a kind of variable and the signature is a kind of template interpolated using the value of `T` every time the compiler finds a call of `fn2`. For example, a call might look like this: `const a = fn2<number>(2);`. `number` in the angle brackets is a value for the variable (the correct term is *type parameter*) `T`, that's why in this expression the type of `fn2` becomes `(str: number) => number`. While we totally can write it this way, we actually can omit the angle brackets because the compiler is smart enough to infer `T` to be `number` from the type of the argument `2`. That's why our call, without losing any information about types, can be rewritten: `const a = fn2(2);`. The type of the variable `a` still will be `number`. The logic of *type argument inference* in this specific case is pretty simple, but actually this ability of the compiler is very powerful and works in much more complicated sittuations too, so that we seldom need to specify type arguments explicitly, with the most notable exception being constructor calls: `const m = new Map<string, number>();`.

But what if the signature, even fully resolved, without any omissions, included `T` only once? In this case generics wouldn't make much sense. It's like using a normal variable only once, assigning it a value and never using it. E.g. using generics in this signature doesn't really make sense: `function serialize<T>(object: T): string;`. It's indeed just a disguised `any`.",1543604158.0
icholy,"
    function firstAny(items: any[]): any {
        return items[0];
    }

    // since firstAny returns any, we need a type assertion
    // to change it back to number
    let a = firstAny([1, 2, 3]) as number;

    function first<T>(items: T[]): T {
        return items[0];
    }

    // the generic definition preserved the number type.
    let b = first([1, 2, 3]);",1543686633.0
gamebuster,"So now we represent the

```
try {

catch () {

} finally {

}
```

structure with promises? Cool, i guess. I rarely use promises directly though, I always try to use `await`",1543408072.0
esamatti,"This is pretty similar to [redutser](https://github.com/wkrueger/redutser) but I think does suffer from the same issue that it's hard/impossible to implement calling other actions via ""this"". See [https://github.com/wkrueger/redutser#-using-this-on-createredutser](https://github.com/wkrueger/redutser#-using-this-on-createredutser)

&#x200B;

That's why I decided to go with classes instead of plain objects with [Immer Reducer](https://github.com/epeli/immer-reducer) which is also trying to solve the same issue more or less.",1543413571.0
kwiwksh,"I prefer to avoid create-react-app and just have a ""template"" version of a barebones project saved.

https://github.com/russleyshaw/react-template

Feel free to base your projects from it!",1543360099.0
scaleable,id suggest dumping TSLint and instead adopting prettier. One less blocker on the road,1543353844.0
InvernoSnowfall,"I believe the favored model is to export each function and allow the use of external modules instead of exporting an internal one. That's assuming you're working with modules and not the global scope. 

See the ""Do not use namespaces in modules"" section at the bottom of the page.

https://www.typescriptlang.org/docs/handbook/modules.html

A snippet:
> When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.

Keep in mind that naming collisions are handled by the importer using the 'as' keyword.",1543318833.0
_nebular,"In Typescript, the namespace mechanism exists to group related functions, variables, etc. under a common object/name. 

The class mechanism exists to defined object prototypes for instances of said class.

I can't think of reason you should ever use a class with only static methods instead of a namespace. I would certainly never do it, I would be shocked if my colleagues would do it, and I would criticize any use of this pattern. If you're using the class as a singleton, then just create a regular class and a singleton instance. 

&#x200B;

Creating a namespace vs. a class with just static methods results in pretty much the same output except that the class is an instantiable function and not just an object. In my opinion, this is a misrepresentation of what you're actually trying to create which may lead to confusion in the future. 

    // class
    class MyStaticClass {
        static init(): void {
    
        }
    }
    
    // namespace
    namespace MyNamespace {
        export function init(): void {
    
        }
    }
    
    // output:
    
    ""use strict"";
    // class
    var MyStaticClass = /** @class */ (function () {
        function MyStaticClass() {
        }
        MyStaticClass.init = function () {
        };
        return MyStaticClass;
    }());
    // namespace
    var MyNamespace;
    (function (MyNamespace) {
        function init() {
        }
        MyNamespace.init = init;
    })(MyNamespace || (MyNamespace = {}));
    

Using a class with strictly static methods is an old pattern that has been replaced with modules and namespaces.

&#x200B;

I tend to disagree with the points /u/InvernoSnowfall brought up from the handbook. I prefer the syntax `import { ModelUtil } from ""./util"";` rather than `import * as ModelUtil from ""./util;""` or `import { create, destroy } from ""./util"";`, but that is just personal preference to me. Unless you're writing a library which is intended to be used in many codebases and codesplitting/treeshaking is necessary, I don't see a point in making everything ultra modular when I know I'm using all of the exported names and I like namespaces to provide contexts for the values I'm using.",1543328497.0
scaleable,"Namespaces used to be helpers to moduleless javascript back when commonjs or webpack werent a thing. Most of its usefulness came from its merging and scoping features. Once we started using file  modules, those quite replaced namespaces in utility.",1543337181.0
kirk-clawson,About the only place I use namespaces any more is to faux-add a method to an enum (e.g. a parse() method usually).,1543342114.0
besthelloworld,"If your only compilation step is tsc, then you should just make the referenced file the .js named file.  If your were using any kind of Webpack packager, there are compilation steps that could fix this.  But overall, it's not really a TypeScript feature to compile-time replace file references.
",1543321309.0
EarlMarshal,"Do you even have to write the file extension? Shouldn't it work without it? 

(I'm just wildly guessing so don't kill me plz)",1543327127.0
GreyhoundDota,How about installing the dependencies on your machine and then mounting them as a volume into the container?,1543316175.0
DanielPerezAlvarez,"This seems to work

    const arr: (number | undefined)[] = [];
    const result = arr.filter((t): t is number => !!t); // result type number[]

Edit:

Also a more generic version:

    function filerTruthy<T>(t: T | undefined): t is T {
      return !!t;
    }
    const arr: (number | undefined)[] = [];
    const result = arr.filter(filerTruthy);

&#x200B;",1543280313.0
kingdaro,"Someone else already brought up user-defined type guards (the `x is Y` bit), and you can take it a bit further with generics:

    const isNonNil = <T>(value: T | null | undefined | void): value is T =>
      value != null

    const items = [1, undefined, null, 2] // (number | null | undefined)[]
    const existingItems = items.filter(isNonNil) // number[]",1543282743.0
codythekid,"I know this might not answer your question because this is likely just a simplified version to illustrate a point, but since I'm not sure there is a way around this since filter is defined as  


```
filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];
```

meaning the value will always be some super class of type T (T | undefined in this case). So I just wanted to offer another solution. Using reduce you can carefully control the types put into the array so you never have to worry about dealing with the undefined values.

```
function makeThings(): number[] {
      const things = [1, 'string'].reduce((memo, t) => {
        if (typeof t === 'number') {
          return [...memo, t];
        }
        return memo;
      }, [] as number[]);

      return things;
    }
```

",1543278812.0
madster9000,"You can just use ""reduce"" without this creepy undefined behavior.
If you need behavior with mapping and filter - use null instead of undefined.",1543278067.0
vinnl,"I don't really know what the problem is (though an error message would be nice), but I do want to offer you the advice of creating an issue with the project you want to contribute the typings to. If they're included with the project itself, that includes the expectation that the typings will be kept up-to-date, which the project owner should feel up to.

(If you don't mind that much if they decline your PR, then that's not too bad, but creating an issue first can help prepare the owners for what's coming :)",1543265392.0
scaleable,"Just a guess but...

Let's say you got lib X installed, then X has Y as a dependency.

Even if Y is not a dependency of your project, writing `require(Y)` works just fine, because npm and yarn nowadays just pull all deps from all packages in a flat structure.

Now when you are reading something through npm link, the ""side effect dependencies"" are not the same anymore, which may lead to different behaviours. The same happens if you use pnpm.

It's not that being allowed to require Y was intended, but in the end you might have been taking advantage of an ""unintended"" feature ""the bug became the feature"".",1543276413.0
notAnotherJSDev,"```
interface MyModule extends React {...}
```

That should do it.",1543274660.0
brainbag,"I can't really tell from your example what you're trying to do, but maybe you're looking for an intersection type: https://www.typescriptlang.org/docs/handbook/advanced-types.html#intersection-types

",1543246524.0
notseanbean,"Start with the official docs: 

* [https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html)
* [https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html)

but bear in mind that (IMO) the dearth of decent documentation and examples is the worst thing about Typescript. The basic types in the guide are okay, but the ""advanced types"" section rapidly descends into gibberish, so don't worry if you get baffled by them - you're not alone. Post here or SO if you get stuck. Good luck.  
",1543250206.0
amZNeZk1,"The option is:
1. learn the very basics 
2. review the TS's changelogs, each one of them
3. practice a lot, start building something, even if that's a very simple thing",1543237417.0
Shadowvines,"well, that's pretty damn cool!",1543270620.0
AngularBeginner,"Personally I prefer having **two** functions, instead of something ugly as a `noThrow` parameter.

I usually simply call them:

- `assertNever` -> asserts and throws at run-time.
- `ensureNever` -> ensures at compile time and does nothing.",1543250661.0
recursive,"Here you go.  No redundancy.  Nice and tidy. 

    const PETS = specifize([""cat"", ""dog"", ""horse""]);
    function specifize<T extends string>(p: T[]): T[] { return p; }
    type Pet = typeof PETS[number];
",1543252794.0
gluecat,"Would an [enum](https://www.typescriptlang.org/docs/handbook/enums.html) work?

```   
 enum Pets{
   Cat = 'cat',
   Dog = 'dog',
   Horse = 'horse'
 }
        
 const someValue: string = 'cat'
 
 if (Object.values(Pets).includes(someValue)) {
   // Do stuff here
}
```
This works because Pets converts into:
```
{Cat: ""cat"", Dog: ""dog"", Horse: ""horse""}
```

Enums can also be used as types:
```
const someValue:Pets;
```",1543223311.0
amishstripclub,"I found a hack last week for doing this. Try: 


    const pets = ['cat', 'dog', 'fish']
    type Pets = (typeof pets)[number]
    let petOne: Pets = 'cat'
    let petTwo: Pets = 'chicken' // throws error

I say hack because`(typeof someArray)[number]`is very confusing to see on its own. It might require a rather recent version of TS because it doesn't seem to throw errors in the typescript playground editor. 
 ",1543233166.0
fecal_brunch,I wish I had a solution for this. My understanding is that it's not currently possible.,1543231865.0
_nebular,"    export type SomeValue = number | string | Function | object | boolean | null | undefined | {};
    
    export type ICanMakeABetterEnum_TM<T extends SomeValue[]> = T & {
        isValid(value: unknown): value is ValueType<T>;
    };
    
    export type ValueType<T extends SomeValue[]> = T[number];
    
    export function iCanMakeABetterEnum_TM<T extends SomeValue[]>(...args: T): ICanMakeABetterEnum_TM<T> {
        const fakeEnum: ICanMakeABetterEnum_TM<T> = args as any;
    
        fakeEnum.isValid = function(value: unknown): value is ValueType<T> {
            return args.indexOf(value as any) !== -1;
        };
    
        return fakeEnum;
    }
    
    export const Pets = iCanMakeABetterEnum_TM(""cat"", ""dog"", ""horse"");
    export type Pets = ValueType<typeof Pets>;
    
    const a: string = """";
    const b: Pets = """"; // Error
    const c: Pets = ""cat""; // :)
    
    if (Pets.isValid(a)) {
        a; // ""cat"" | ""dog"" | ""horde""
    } else {
        a; // string
    }

&#x200B;",1543240154.0
notNullOrVoid,"There is a language suggestion to allow explicitly expressing the type of literals here: https://github.com/Microsoft/TypeScript/issues/10195

Which would help you achieve what you want without any ""hacks"".",1543257412.0
AngularBeginner,"Call me old-fashioned or boring, but I prefer the simple straight-forward no-magic-bullshit way of things, at the cost of having to write a few more lines of code:

    type Pet = 'cat' | 'dog' | 'horse';

    function isPet(value: string): value is Pet {
        const casted = value as Pet;
        switch (casted) {
            case 'cat':
            case 'dog':
            case 'horse':
                return true;
            
            default:
                ensureNever(casted);
                return false;
        }
    }

    function ensureNever(value: x): void {}
    
    
    const someValue: string = 'cat'
    if (isPet(someValue)) {
        callAPetMethod(someValue);
    }

- A simple type guard that checks if the `string` is a valid `Pet`.  
- The cast to the `casted` variable ensures that you only check for valid values, so the compiler forces you to change the function when you renamed or removed elements. A case for `'foo'` would result in a compilation error.  
- The little `ensureNever` helper function ensures that you have handled all cases, so the compiler forces you to change the function when you added elements. If you add a new element to the union, then the type of `casted` is **not** `never` anymore in the `default` block, and calling `ensureNever(casted)` will result in a compilation error.

Straight forward dead-simple code that ensures you have handled all cases.",1543250185.0
ghillerd,"I often use interfaces to define server responses. Interfaces don't have ""complex uses"" because they are an inherently simple concept, and like most programming concepts should be used as simply as possible. The most complex you might get is type arguments, something like `APIResponse<Car>`, where APIResponse has properties like next, prev, and data of type T[].",1543183153.0
fecal_brunch,Try looking at the DefinitelyTyped definitions for your favorite node module that takes objects as arguments.,1543324479.0
MikeMitterer,"Really??? You can find simple examples for every language that supports OOP.

interface Vehicle
class Car implemts Vehicle...

https://www.typescriptlang.org/docs/handbook/interfaces.html

In general an interface can be seen as a contract how something was / will be implemented",1543181857.0
BigGayMusic,WTF? Why are you posting bug reports to reddit?,1543162747.0
GreyhoundDota,"There is a node module that takes care of this: [tsconfig-paths](https://www.npmjs.com/package/tsconfig-paths).

But yes, I totally agree having that in tsc itself would be super neat.",1543146950.0
grinde,">""Works as intended"" - Guys @MS: THIS IS A BUG

I get where you're coming from, but no it's not a bug and *is* working as intended. That option is meant for use with something like [requirejs's paths config](https://requirejs.org/docs/api.html#config-paths) (which is directly compatible with how this currently works). I've had similar problems in the past, and the TypeScript team's stance has always been that tsc doesn't alter module paths as written - full stop.

Personally I'm 100% on your side wanting something that *can* rewrite module paths. Maybe even just a compiler flag that changes how tsc handles paths. That being said, I doubt it'll be implemented in the base compiler. Best bet would be to either use a custom transformer (which is a pain), or tsconfig-paths.",1543173195.0
arogozine,This is the reason I have paths like ../../../foo.ts,1543158491.0
cheekysauce,"Yep, I spent a few hours on exactly this last week and was furious when I found this, I thought I was losing my mind as changing tsconfig.json makes the absolute imports work in VSCode, it compiles correctly, but Node can't run it. Manually inspecting the files proved tsc wasn't rewriting paths and lead to all the more confusion.

&#x200B;

Ended up having to use Webpack which itself invokes tsc and bundles stuff correctly.",1543174078.0
Drawman101,"I use this feature like you intended with my code bundled with webpack. I guess I never thought of the use case when it comes to node, but this would be super annoying to deal with since node doesn’t need webpack to resolve modules.",1543143529.0
son_of_meat,This post has been linked to from the GitHub issue. For my two cents I feel that tsc path mapping introduces unnecessary complexity into module resolution. The “hell” of relative paths isn’t actually so bad with automatic imports and import path rewrites in VS Code. ,1543146974.0
MrXyfir,"I'm glad this finally seems to be getting attention again. Hopefully the TS team will change their mind. All we need is a compiler option.

Someone should try contacting one of the developers. I tried summoning the person who originally closed the issue but it's been about a month now with no response.",1543167398.0
cspotcode,"You're supposed to configure a runtime or build-time module loader like webpack, requirejs, or rollup.

The benefit of delegating runtime resolution is that tsc's emitted code continues to match the input code without injecting too much ts-specific runtime behavior.  This is a more powerful separation of concerns.

The JS community can definitely create tools that, for example, auto-configure webpack based on path mapping from tsconfig.

I'm sure someone could also write a TS transformer that handles resolution at compile-time if they wanted to.",1543177713.0
spitfire092,RemindMe! 14 hours ,1543143105.0
cspotcode,"I'm confused why this is necessary.  If you install RXJS from npm, you get a precompiled copy with .d.ts files, right?  So dependencies will not be recompiled?  I think I'm missing something.",1543113171.0
Schampu,"Hi everyone,

I recently added TypeScript support - The Type definitions are machine-generated (see [here](https://github.com/maierfelix/node-vulkan/blob/master/generated/1.1.85/index.d.ts)). Please feel free to submit any improvements!",1543064264.0
sickcodebruh420,Say I'm using Three.JS already and knows nothing about Vulkan. Are there reasons I might want to consider using this instead?,1543078638.0
spitfire092,"You should split the dependencies in your package.json file into separate dev and normal dependencies. That way when you go into production you don’t need to include all of the development modules on a production machine. 

For example, webpack and all of the front end loaders probably should be included only inside of devDependencies and not production dependencies since they are not needed to run the application, only build. Express would be a normal dependency that needs to be included on production machines.

Looks really cool otherwise, good work and thank you for sharing it with us!",1543023101.0
lukeautry,"I thought this might be interesting to some folks here. Most boilerplates are either front-end framework focused or backend framework focused.

This boilerplate uses several tools that I use for my own projects and I've found the combination to be very effective. The gist is that you write your API and UI in TypeScript and you get type safety throughout the stack.",1543014496.0
darkdigitaldream,"Hey Luke, I've been relying on your tsoa package in one of my projects for about a year and a half now. 

There really is noting else like it when it comes to TS swagger doc generation, so I really just have to say thanks.",1543091464.0
icholy,This is one area where typescript is pretty lacking IMO.,1542992370.0
lukeautry,"I think what I'd like to see a decoupling of the source code metadata (files and symbol metadata) and the UI that surfaces that metadata. `typedoc` is a decent tool but the UI is just not acceptable for most branded tools and, while some customization is possible with `typedoc`, it's sort of a pain.

So I'd rather be able to point a tool at my library, have it generate a JSON file, hopefully, compliant with some json-schema, and then build up a custom UI around that data. Maybe folks could build their own UIs around the schema so you have several options to choose from if you don't want to build your own.",1543004360.0
cspotcode,"""documentalist"" might work but I haven't used it personally.",1543115901.0
CaribTech,"I have multiple opinions if, I have read this question/concern correctly.

1. There is this site for typescript docs ( [https://www.typescriptlang.org/docs/home.html](https://www.typescriptlang.org/docs/home.html) )
2. Use Evernote to probably archive the TypeScript Docs
3. Get down and dirty with some web scraping and then creating your very own API for TypeScript { I'm pretty sure the community would love/ praise you for } ",1542999041.0
notNullOrVoid,"> Most of solutions are bundled with webpack which means if you want to write library which have extendable replacable styles included you mustn’t use webpack! So automatically you need to disqualificate these solutions

What? That's not true yes you can use webpack to bundle those but it's not required, there are other options. You could compile scss, sass, cssNext very easily to multiple files that you can allow the consumer of your library to then import as needed, they can even be css modules.

Also I got the meaning, but ""disqualificate"" is not an English word, the word to use ""disqualify"".",1543077545.0
siggirh,"So, it's styles-as-objects, and yet react inline styles are ""spaghetti code"" while typestyle isn't?",1542995424.0
UberAtlas,On mobile. But you can ignore unused parameters by prefixing them with an underscore I.e _req,1542988358.0
callensm,"You can keep your strict linting rules with TypeScript and avoid that error by either using the `// @ts-ignore` comment above it, or the more preferred and clean method of just prefixing the unused variable with an underscore. So the callback for the Express route becomes `(_req: Request, res: Response) => {...}`",1542990887.0
vs845,"As you mentioned, the `noUnusedParameters` config flag would do it, but for the entire project.

You could use the `// @ts-ignore` comment to instruct TS to ignore errors on that one line. You could also break up the line so that it only ignores that one parameter without ignoring any other errors in that line, like this:

    app.get(
      ""/hello"",
      // @ts-ignore
      (req,
       res): Response => {
        return res.send(""Hello, World!"");
      }
    );

It's kind of ugly but it would achieve what you're looking for.",1542987982.0
AngularBeginner,"Why don't you utilize the `strict` flag of TypeScript? It always surprises me that people use TypeScript for the type-safety, but then don't make use of all type-safety features it has to offer.",1542951835.0
unshipped-outfit,"Sorry mate but that’s just how it is sometimes. 

They probably thought your idea was good at the time, but then realized it actually would be better suited implemented as part of a bigger change they were already making. Sure it’d be nice to get told ahead of time, but there are tons of community PRs to go through, and if they had to check every one before implementing a feature, their dev speed would slow down dramatically. 

VSCode for instance is a slightly larger team, with slightly better community input stats, but they need to dedicate two people at a time to just issue tracking (one in Zurich, one in Redmond). That’s a trade off the TS team can’t make. ",1542926289.0
notNullOrVoid,"I'm not sure what their contribution policy is, but I would say it's generally not a good idea to do a PR for an issue that hasn't been verified and assigned to you or flagged with ""help wanted"".

That being said from the outside looking in TS needs more maintainers, and much better organization. You'd think this would be possible given the resources MS should be able to provide.",1542949963.0
synin,"just FYI: ""requested changes"" is the [only option](https://help.github.com/assets/images/help/pull_requests/pull-request-review-statuses.png) github allows you to give. It doesn't actually mean the maintainer is requesting changes, it means they clicked reject.",1542963980.0
AngularBeginner,"Yes, it works like that. It will create an array that can contain strings **and** numbers. If you want to have either an array of only strings **or** an array of only numbers, then you must use `Map<string, Array<string> | Array<number>>` instead (or shorter syntax `Map<string, string[] | number[]>`).",1542905926.0
Rollingdownhills,"Yes, this will work.

    const ourMap: Map<string, Array<string | number>> = new Map();
    
    ourMap.set('u', ['a', 1, 'b', 2, false]);

In the above example the false will be marked as an invalid value.

You could perhaps use an object?

    const ourObject: { [key: string]: Array<string | number> } = {};

    ourObject.u = ['a', 1, 'b', 2, false];

It would also mark the false as an invalid value.",1542905968.0
Bjeaurn,"If you want to learn, I'd be happy to help you out a bit. Are you familiar with some JavaScript or completely new to that too?

&#x200B;

Hit me up on the DMs, Twitter, Discord of Twitch; using the same name. I'd be happy to help you out a bit and get you started! 

(promise I'm not selling trainings or courses or whatsoever)",1542900998.0
ResponsibleLife,https://typescriptcourses.com/typescript-fundamentals,1542897270.0
know_not_much,https://old.reddit.com/r/typescriptvideos/,1542911573.0
dudovcic,"Hi everyone, how many of you would be interested learning RN + Typescript + Node full-stack application through the pragmatic ebook ?

I'm currently writing one and it'll demonstrate how to make a nice project structure, type safety throughout the app, OOP programming and some challenges you might face as a fullstack developer such as uploading an image which then gets resized to 3 different sizes etc.

Any feedback is welcome, thanks in advance.",1543094261.0
MikeMitterer,I don't get it... if you want types why not use TS?,1543439380.0
Rollingdownhills,"Perhaps you are looking for something like this:

    interface K {
        k: number;
    }
    interface R {
        r: number;
    }
    interface U {
        u: number;
    }
    
    function addK<T extends {}>(obj: T, kValue: number = 0): T & K {
        return Object.assign({
            k: kValue,
        }, obj);
    }
    function addR<T extends {}>(obj: T, rValue: number = 0): T & R {
        return Object.assign({
            r: rValue,
        }, obj);
    }
    function addU<T extends {}>(obj: T, uValue: number = 0): T & U {
        return Object.assign({
            u: uValue,
        }, obj);
    }
    
    const kru = addU(addR(addK({
        v: 0
    })));

Just replace all the `{}` with your base interface.",1542804666.0
voidvector,"This is a fairly common pattern in function pipelining. There is a proposal to add ""pipeline operator"" to JS to make this clean. 

The common solution is use generics. Each pipeline operator is `declare function<TInput, TOutput extends TInput>(arg: TInput): TOuput`. Though in a more general pipeline there is no reason output is an expanded version of the input, you may have filters/reducers in your pipeline.

In addition, many implementation have a clear beginning and an end. if you look at RxJS which is a pipeline library:

    Observable.of(input).pipe(
       transformOne(),
       transformTwo(),
       transform,
    );

This way you don't have to check intermediate types, and the entire pipeline can be fully checked.

Since you are saving intermediate steps to a variable, you can leverage: `Partial<T>`, `ReturnType<T>`.


",1542804490.0
notseanbean,"Is `priceAdded` etc, only ever an augmentation for `baseObject`? Will `somethingElseAdded` always be returned by something that takes a `priceAdded`? If that's the case, you could maybe define them as extended types as the decorations happen.

    interface baseObject {
       ...
    }
    
    interface priceAdded extends baseObject {
      price: number;
    }
    
    interface somethingElseAdded extends priceAdded {
      somethingElse: object;
    }
    
    ...
    
    interface augmentedObject extends nextToLastAugmentation {
      finalAugmentation: object;
    }
    
    // and then just pass augmentedObjects around",1542801240.0
rift95,"Short answer, you can't.

Slightly longer answer, whether or not it should be possible is up for debate here: https://github.com/Microsoft/TypeScript/issues/22865",1542819770.0
pancomputationalist,"One nitpicky detail: I think you should re-evaluate if you really want to merge everything into one giant ""god""-object in your functions.

For example,

`let priceAdded:baseObject & priceAdded = addPriceToBaseObject(baseObject:baseObject)`

Here you're tightly coupling the price to the base object. Now you can't really isolate the price from the object. Maybe you want to pass the price to a function that sums up the total cost of a purchase, you now have to pass all the data of your object, including storeList and whatnot, even though it is not required by the function.

Instead, why not just have a function that clearly states what it requires and only returns what it's adding:

`let price = calculatePrice(baseObject)`

Then later you can use it in other functions that require it, but might not require other information:

`let discount = calculcateDiscount(price, store) // no baseObject needed`

Then, at the end, you can merge everything together into one big object that you can return from your API:

`return {...baseObject, price, discount, ...storeData}`
",1542822542.0
snowthunder2018,"When I did this I ended up dividing the properties up into separate components.  So there'd be a productObject and a priceObject and if a function needed both, both would need to be passed to it.  

I was working off of Amazon's structure for products so everything was already highly divided up. That made this approach fit with the overall way things worked.",1542851207.0
cr125rider,What makes this a database? What indexes are available to search with?,1542829654.0
,I think some real-ish examples of how you might use these would be nice! Many of these type utility libraries are technically interesting but quite abstract.,1542753260.0
notseanbean,"Hi - these are nice, but look to be a duplicated effort to [type-zoo](https://github.com/pelotom/type-zoo)?

* ArgsType === [ParamTypes](https://github.com/pelotom/type-zoo#paramt-extends-function-and-paramtypest-extends-function)
* Assign === [Overwrite](https://github.com/pelotom/type-zoo#overwritet-u)

Match is quite useful though - maybe add via [a PR to type-zoo](https://github.com/pelotom/type-zoo/issues/33)?",1542805350.0
TheNoim,Could someone explain the usage of the library. Just started to learn TypeScript and don’t really understand why I should use this or how.,1542792509.0
ArturCzemiel,"Hi, I definitely want to contribute! This is great always wanted to have such cheatsheat",1542795395.0
kwiwksh,"The problem here is that TS will automatically resolve something like `[1, ""yo""]` as `Array<string | number>`. If you want to return something that can be positionally spread from, consider explicitly defining the return value.
such as:
```
function getTuple(): [number, string] { ... }
```

EDIT: Specifically
```
async function connect(): Promise<[number, string]> {
    let foo: number = 10;
    let bar: string = 'baz';
    return [foo, bar];
}
```

It is better to define your return type so you can infer within your function rather than the internals be the driver of your return type.

Also you don't need to Promise.resolve if you are returning from within an async function.",1542741519.0
saltupz,"Never mind, i have to make a wrapped function like this:

    function tuple<T extends any[]>(...args: T): T {
      return args;
    }

    return Promise.resolve(tuple(foo, bar));",1542740523.0
thistoohard,Anyone use these in the wild? Or should I just make some extensions and make a hip blog post too? Gonna go back to developing an NPM package first. ,1542728904.0
xrpinsider,I didn’t knew that good programmers used VS code. ,1542749229.0
asadmo,That's pretty cool. Reminds me of this tool that i use https://transform.now.sh/json-to-ts-interface/,1542696915.0
son_of_meat,"I was looking for something like this recently, and the kind folks of this sub pointed me to [quicktype](https://quicktype.io/).",1542711338.0
baddev,Î,1542730125.0
richie_south,"I created this basic implementation to generate interfaces from javascript objects.
At my work we have lots of network requests that have missing return types and i wanted a nice way to get a 
basic interface structure.

This package is in no way 100% but it helped me with basic interface implementations at work :D",1542695885.0
r0ck0,"Cool! I'm about to look into a few libraries like this, as I'm writing a bunch of code where I can just throw millions of JSON files at it, and have it detect if they're the same format as known schemas or not so they can be processed (without the script being explicitly told which type of file it is).  

A few questions:

1. Does yours happen to do anything that normalizes the order of property keys so that two files with the same properties (but in different orders) can produce the exact same interface? e.g. For your `User` example, different JSON files with ""id then name"" or ""name then id""  would produce the same interface?   I guess it would just sort the property names alphabetically for the generated interfaces.  It then makes it each to detect if two source files have the same structure, regardless of property names order.  I guess that might not be what everyone wants, but should be a common use case.

2. I think there might be a few similar packages around, is there anything different that yours has in mind?

3. Any random tips related to any of this stuff and the system I mentioned above?  (not necessarily about your package specifically, but just seeing you've obviously done some similar work on identifying and parsing lots of different formats)

Also thanks for the obvious example and animated gif on the README.md!  Makes it much quicker to get an idea of how it works.
",1542702520.0
thistoohard,This is trash. Basic ass shit just to use Okta. Save your time. ,1542892369.0
Yharaskrik,Orrrrr use [nestjs](http://nestjs.com/),1542693363.0
cr125rider,Do you need lengthy docs if the typings are well defined?,1542664212.0
Heka_FOF,This is very valid point. Only way without documentation is just to dig to the redux types for example and try to make sense of it. One good way to documentate the types is to make tests for them showing how they are used + you will get confidence the types are right.,1542704320.0
sheepsy,Thanks for this post. I have been playing with ts and I find it impossible to follow the more complicated typings with the nested interfaces. I don't understand who they're written for? Just for autocompletion or what?,1542681885.0
demoran,"As often happens, after posting this I had an epiphany.  The following type guard works:

    type MyListItem =
      | ListRenderItemInfo<MinimalUserInfo>
      | ListRenderItemInfo<Group>;
    
      lineItemIsUser = (
        lineItem: MyListItem
      ): lineItem is ListRenderItemInfo<MinimalUserInfo> =>
        !!(lineItem.item as MinimalUserInfo).FirstName;
",1542649271.0
galvatron,"I think the ”as” casts away any type information in the caller. So if the caller has some object which has a wrong type and casts it with ”as”, you  don’t get a compiler error and lose the benefit of using TypeScript in the first place. ",1542637657.0
Bjeaurn,"If you're using the Angular CLI, it's using the AngularCompiler under the hood, I don't know how it exactly works but I'm going to make an assumption that it's optimized for both detecting deltas in your code.

&#x200B;

In case of your other project, a big part of what may be causing the delay is that your (default?) settings are compiling your imported libraries as well. It could also be that it does't properly detect delta's in your code out of the box without a plugin or proper setup, which may be triggering recompiles all the time whilst the compiler is still busy and thus waiting. 

&#x200B;

Just my assumptions honestly, I'm not to familiar with the exact innerworkings of the compiler.",1542536222.0
Yharaskrik,I have a very large Nestjs project (a TypeScript based nodejs express server) and I use nodemon to dev. It reloads very quickly whenever I change a file. Also take a look at Nestjs if you like angular and typescript and want that same architecture on the backend. Almost all of your code is portable over as it is still just an express server under the hood.,1542555409.0
dcsan,"what is your build pipeline? perhaps your angular project is only compiling modified files, perhaps down to a webpack setting?",1542538264.0
thinkmatt,"It would be helpful for us if you shared your configurations. Maybe something is not set up right? It takes me about 12 seconds to compile a medium-large size Typescript project in full. Also, maybe it's not just the incremental compilation. If your server has to do any setup (connect to DB) on boot, you have to take that into account too.  


We have been using \`ts-node\` and  \`ts-node-dev\` for backend projects. It makes working with Typescript very seamless by translating the source in memory; you can even disable type-checking but turning transpiling off, and \`ts-node-dev\` is a wrapper around ts-node that adds incremental compiling.",1542556410.0
5Vlad,"If you're using a webpack setup, try using [cache-loader](https://github.com/webpack-contrib/cache-loader/), it's an almost instant speed increase for not that much setup effort. ",1542565849.0
Capaj,Try https://github.com/whitecolor/ts-node-dev and let us know if it works for you! It certainly works for us.,1542579607.0
,[deleted],1542526861.0
ch0dey,"if you're already familiar with React, why not use [v2 of \`create-react-app\`](https://github.com/facebook/create-react-app) to generate a TypeScript project?",1542498820.0
threemanycats,"To start out I would keep it simple. All you need is `tsc` the Typescript compiler paired with a `tsconfig.json` to tell it how to work. 

The other stuff you mentioned it just sugary tooling to help you integrate TS into more complicated environments. Helpful once you're comfortable with it but to start I'd just `tsc` from your `src` directory and output it into your `.build` and then run your app from there like a regular JS one.",1542496643.0
joshribakoff,"typescript-loader & awesome-typescript-loader basically do the same thing. They both use tsc under the hood.

&#x200B;

babel & tsc both transform code (from one language to another).

&#x200B;

Webpack bundles code, it takes multiple code files & combines them into one, so you don't have to write your code in a global.js and can write 1,000s of smaller files but still combine them to run the code in the browser.

&#x200B;

With the babel/ts loaders, webpack can transform the code at the same time it ""combines the files""

&#x200B;

You may prefer babel to tsc if you want to support other language proposed features that haven't made it into tsc yet. If you're just starting out don't sweat it too much as its easy to switch at anytime. Using babel doesn't mean you're using 2 transpilers. You can however using multiple babel plugins, to make the transpiler (babel) perform multiple different transformations. You wouldn't want to use both babel (with ts plugin) AND ts-loader together, that would be redundant.",1542516228.0
mattstrom,"You can choose one or the other, using both is redundant. To address the very confusion you're feeling, the TypeScript team a while back released a Babel plugin that runs the TypeScript compiler. But I would recommend that you choose tsc as your compiler for simplicity because you will need either tsc or the Babel TypeScript plugin.

There are scenarios where both can be used, but if you don't know the explicit reason, you won't need both. You can drop one from your build procedure.

I use ts-loader nowadays as awesome-typescript-loader was sort of a stopgap to address some shortcomings in ts-loader that have now been addressed.",1542516645.0
scaleable,"Babel is the newest one and probably should be your choice for new projects.

Id also recommend picking a build pack like next js so you worry less about webpacks boringness",1542507806.0
AngularBeginner,`strict` flag is turned off. :-(,1542474349.0
Superseuss,I'm going to add a syntax/context plugin system eventually (sooner if there's demand for it).,1542475932.0
endjynn,"TypeScript is absolutely good enough for Java developers. I speak from experience as I've used Java extensively and it's one of my favorite languages. NodeJs/TypeScript makes for a powerful back end for web applications. The tooling is on par with Java - I use Webstorm which is made by JetBrains the same guys who make Intellij IDEA for Java. TypeScript itself is an elegant language and actually makes coding in JavaScript enjoyable. NPM is a perfectly adequate dependency management system despite some occasional teething problems as they adjust to the sheer scale of their ecosystem. The benefits of using TypeScript for both the front end/back end are many such as, code sharing, reduced context switching, shared tooling/deployment/infrastructure etc. The JavaScript ecosystem is absolutely massive, active and growing and even dwarfs Java's. In my opinion if you're using anything other than JavaScript (or TypeScript) for back end web development these days then you're ""doing it wrong(tm)"".",1542394644.0
PM_ME_YOUR_HIGHFIVE,"Is your question about ""typescript vs java"" or ""node vs jvm""?

If it's about ""typescript vs java"", then yes it's good enough. There are editors that force you to write type safe typescript, so it doesn't feel like javascript.

If it's about ""node vs jvm"", then it depends on the project. There are cases where node is better, there are cases where java is better.",1542398778.0
MrSpontaneous,[That post was submitted here yesterday](https://www.reddit.com/r/typescript/comments/9xea3e/is_typescript_on_nodejs_good_enough_for_java/).,1542394492.0
EarlMarshal,"I worked as a student in university and developed some REST API in java for out chair. I pretty much jumped on this train when I first heard about Typescript beta versions. I never enjoyed JavaScript much but with Typescript and the newer ECMAScript version i love to do it.


You can also take a look at deno which is a Typescript runtime also by Ryan Dahl. There still has to be stuff done but looks interesting atleast.",1542410264.0
psxpaul,"That's a silly question to pose, without saying what it is you're building",1542405866.0
Oalei,"I feel like you don’t really need Typescript to make it easier for a Java dev. Just use es6 classes and it will be very similar already.  
Typescript is a nice addition though",1542394874.0
r0ck0,"I mostly hate Microsoft (yes very immature old skool /. l33t lamer micro$shaft attitude, I know it's silly).

TypeScript kind of changed my mind more than everything else.  It's fucking good.

Want to hear something fucking weird?  Microsoft's latest and most highly successful GUI desktop program (vscode) is written it TS/JS.  That's pretty crazy considering they own .net (nice platform for GUI software) ... and Java finally is fairly decent in that space too.

Is TS/JS the most pure & best language?  Nope, it doesn't have runtime type safety. Fails hard there.  But wins at almost everything else from a logistical perspective.  

At the end of the day, is your priority the ""best language"", or the most productive/profitable outcome, and ease of development?  Including a stupid amount of stuff already done for you via NPM packages.

I'm not going to make some ""the others are dying?"" call.  But TS is most certainly growing more than the rest right now IMHO.

Don't worry about it all too much.  We're all going to get on with building something.  It's not the right choice for every project, but I think TS devs are going to have the biggest productivity and most flexible gains within the next 10 years or so.  Maybe after then something will kill it.  

But right now I think it's the best for greenfield projects in most areas.",1542466316.0
PeabodyEagleFace,"Runtime typing info isn’t quite as good ,  nor is the runtime reflection.   It’s not really needed for most projects.  I’m not surprised the java folks didn’t like this.   Java’s ecosystem is 22 years old .  Meanwhile typescript has been around for about 5 years.   

I write in both languages for my job.  I find that you can do almost anything you need in both languages,  it’s just slightly more verbose in Java sometimes.  ",1542471506.0
Rollingdownhills,"I am guessing that `Response` is [this `Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) and if that is the case it is not compatible with `{result: RequestResult, payload: Response | PromiseLike}`. You perhaps meant to resolve with the response instead of the object?",1542386594.0
Dested,"Can you try specifying the the of the promise explicitly?

return new Promise<Response<DsbMannschaftDO>>(res=>...)",1542397629.0
GreyhoundDota,Have you tried [quicktype](https://quicktype.io/) ?,1542393307.0
calomer,I remember a visual studio code extension that does this. Unfortunately I am on mobile right now😢. ,1542386912.0
brockvenom,"I use Swagger and Swashbuckler on all my Web Apis to automatically generate a documentation site which does all this. You can even use it like PostMan for testing the api endpoints. 

EDIT: My bad... truthfully I didn't read your post very carefully. I thought you were asking for a way to generate documentation for all api endpoints that return json. 

For generating types from json, you can use json2ts as you mentioned, or maketypes is another: https://jvilk.com/MakeTypes/",1542404141.0
bqlou,Combine swagger and swagger-code-gen ? Never used it though... (If someone has feedbacks) git: https://github.com/swagger-api/swagger-codegen/blob/master/README.md,1542439548.0
--algo,"My advice would be to throw this idea out the door and rethink. Usually when you find yourself in a position where you have to think up these enormous abstractions you should take a step back and re-evaluate. Don’t over-engineer.

Why not split it up in another component instead? Simplify with some more vanilla prop management. 

Source: 10 years JS experience",1542378505.0
AngularBeginner,"How about something like this?

    function select<T, K1 extends keyof T>(val: T, k1: K1): T[K1];
    function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(val: T, k1: K1, k2: K2): T[K1][K2];
    function select<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(val: T, k1: K1, k2: K2, k3: K3): T[K1][K2][K3];
    function select<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(val: T, k1: K1, k2: K2, k3: K3, k4: K4): T[K1][K2][K3][K4];
    function select(val: any, ...keys: any[]) {
        let res = val;
        for (let i = 0; i < keys.length; ++i)
            res = res[keys[i]];
        return res;
    }

    const obj = {
        abc: {
            def: [{
                ee: 123
            }]
        }
    }

    const res = select(obj, 'abc', 'def', 0, 'ee');
    console.log(res);

Or if you prefer tuples:

    function select<T, K1 extends keyof T>(val: T, keys: [K1]): T[K1];
    function select<T, K1 extends keyof T, K2 extends keyof T[K1]>(val: T, keys: [K1, K2]): T[K1][K2];
    function select<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(val: T, keys: [K1, K2, K3]): T[K1][K2][K3];
    function select<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(val: T, keys: [K1, K2, K3, K4]): T[K1][K2][K3][K4];
    function select(val: any, keys: any[]) {
        let res = val;
        for (let i = 0; i < keys.length; ++i)
            res = res[keys[i]];
        return res;
    }

But I don't think you can create a `PathInside<T>` property, you need to go with rather ugly overloads. Recursive types are still rather icky in Typescript, and `PathInside<T>` would need to be recursive.",1542376593.0
moremattymattmatt,"Can the path be a string? If so you might be able to use jsonata, though it wouldn't be typesafe.

I haven't thought that through though so it might be less than brilliant in practice.",1542365339.0
beegeearreff,Look at the package “idx”.(sorry on mobile) It’s really useful for GraphQL apis where things could be null along the way.,1542378075.0
tvi016,"What do you mean by widget-based?

",1542501842.0
recursive,"Glad to see `BigInt` finally made it in.  Thanks Caleb.

    // *Slaps roof of fibonacci function*
    // This bad boy returns ints that are *so* big!

lol",1542321162.0
AngularBeginner,"Any chance for an updated spec? The specification is still stuck at version **1.6**, and the last update was made **almost three years ago**.  
https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md

It's always annoying trying to figure out if behavior is intentional or a bug. Digging through the documentation freckles and the GitHub issue is absolutely not an adequate way.",1542344244.0
unshipped-outfit,"Love the object spread typing, just wish it was typed to be 

{...A, ...B} :: Pick<A, Exclude<keyof A, keyof B>> & B

This is more accurate, as the B properties will overwrite A's of the same key. Not sure why it isn't implemented like this...",1542334158.0
Zephirdd,"Good lord I've needed strict `bind` for SO. LONG.

For those unaware, if you use class components on React(-Native) and you need to pass class functions into your components - say, a something like `this.handleFormSubmit` on a button's `onPress` prop - you need to pass in a bound function reference. In other words, you need to make pretty much every class function something of the form `private func = ((args) => {/*...*/}).bind(this)`, otherwise you can't use `this` inside said functions. This meant you'd lose the type information on your functions that would be passed into components.

Technically, you could call `bind` or even use an arrow function inside the `render` call in order to properly reference these functions, however when you have small quickly updating components that means creating a new function reference for *every render*. That quickly explodes the memory usage performance goes down, which means the (func).bind(this) declaration is the best way to use private functions while keeping the performance of a normal non-class function.

So yeah, I'm just happy that calling `bind` won't kill type information anymore. I wonder if we could start using `call` and `apply` along with rest parameters to promisify certain APIs? That'll be fun to try out.",1542421427.0
arogozine,Still waiting for error messages in haiku or iambic pentameter,1542516132.0
freebit,One nice thing about TS that people often forget is that the V8 engine can optimize the heck out of it because of the stable types.,1542317684.0
MrSpontaneous,"No, not enough XML.",1542309830.0
WHO_WANTS_DOGS,"    enum Gender {
     male = “male”, female = “female”
    }    
shots fired",1542319410.0
SnowyMovies,"Can you **not** post blogspam on reddit? Jeez, some people.",1542309652.0
welkie,"It can be pretty close, yeah. I've played around with classes and dependency injection libraries in TS and it's not bad. You can go something similar to Spring Boot where you end up with lots of small classes, and it's easy to add more classes to the constructor parameter list of a given service and have them injected in.

The unit testing is a bit annoying though. The fact you need source maps to view coverage results can make coverage tough to set up. I've experienced an issue running tests with ts-node where the coverage was coming back as different % each time despite the exact same test behavior.",1542352735.0
scaleable,"Even if TS is really cool, the node ecosystem quite lacks on monolythic frameworks (theres loopback but meh). While on java and C# you got many toolkits to pull organized and documented APIs out of the blue.

Not that those kinds of frameworks are best for everything, but surely they are really useful in some niches.",1542311387.0
davidmdm,I work in typescript now cause the company I work for has a lot of c# devs. Every day I miss working in pure nodejs. ,1542310779.0
mattstrom,"The inferred type of `htmlTag` is going to be string[]. So you need to first constrain that to an array of string literal types.

    type TagName = 'a' | 'div' | ... ;

    const htmlTags: TagName[];

If you are using React DOM, you may be able to instead do this as a shortcut to avoid list every tag name (I'm mobile at the moment, so I haven't tried this yet):

    type TagName = keyof JSX.IntrinisicElement;

Next all you might need to do is to upgrade to TypeScript 3.1 as it adds support for property declaration on functions.

Otherwise you need to specify a type for the styled function.

    interface StyledFunction<Props> {
        (element: React.ComponentType<Props>): unknown;
        [key: TagName]: (className: string) => unknown;
    }

    const styled: StyledFunction<unknown> = function ... ;

(Replace unknown with whatever the types are supposed to be; it's hard to follow all of your types on my mobile device.)",1542235974.0
AngularBeginner,"`typeof property` is always `keyof T`, which allows all keys of `T`. You can only solve your issue with an additional type parameter that makes the exact key clear:

    function filter<T, K extends keyof T>(property: K, value: T[K]) {
        return `${property} ${value}`
    }

In this case `K` is narrowed to a specific key, so the correct type can be inferred too.",1542196581.0
rssfrncs,"https://stackoverflow.com/questions/53299743/generic-function-and-index-types

further discussion and potential solution",1542197879.0
DanielPerezAlvarez,"what about 

&#x200B;

    type Fn<T> = <K extends keyof T>(prop: K, value: T[K]) =>  string;
    
    function filter<T>(property: keyof T, value: T[typeof property]) {
      return `${property} ${value}`;
    }
    
    type Person = {
      name: string;
      age: number;
    };
    
    const result = (filter as Fn<Person>)(""name"", 123);

&#x200B;",1542211086.0
alfredmuffin,"This is a React/GitHub pages issue, not a TypeScript issue. ",1542108113.0
Charles_Stover,I don't think GitHub Pages supports routing. You may want to use Gatsby or your own nginx instance that proxies to GitHub.,1542120161.0
Bjeaurn,"I have no experience with Nuxt, but a lot of experience with Angular; runs completely on TypeScript. provides excellent types and language services, runs superb. Compiler support is also on point and of course; CLI!

Heard some good things about the maturity of React as well in regards to Typescript/TSX, so plenty to choose from honestly. Typescript definitely loves the Frontend too.",1542102944.0
kingdaro,"Your experience sounds about right. I'm a casual fan of Vue, but Vue + TS has always felt like a patchy afterthought compared to other frameworks. I'd like to see if this will change with Vue 3.0, though.",1542130113.0
pkej,I've got Nuxt worrying with TypeScript and typing works well. I'll have to upload it to a repository of you want to test it ,1543529964.0
moltar,"Nuxt is Vue, so just google for Vue TypeScript. There are many tutorials and types libraries for this.",1542122658.0
__gc,strictNullChecks and DI work well together. I think you're looking at the wrong thing. ,1542101854.0
wisepresident,"You can use the exclamation mark to overrule the compiler on a per instance basis:

    class MyService {
        hello() {};
    }
    
    class MyClass {
        constructor(private _myService: MyService) {
            _myService.hello();
        }
    }
    
    let myService!: MyService; //<-- use ! to overrule compiler and tell that myService is indeed initialized
    let myClass = new MyClass(myService);

Now the compiler is satisfied, but note that this will lead to an error at runtime since myService is obviously not initialized.

But I would check the code before suppressing the error with the exclamation mark, usually TypeScript complains for a reason.",1542104476.0
voidvector,"Constructor injection is fine. Manual property wiring or property injection is not, but I don't think those are common in Angular. 

I had code base like what you describe as well, but I have also written code with DI that has strictNullCheck. 

Try make sure your code rarely if ever re-assign anything (variable, property, etc). ",1543295780.0
vs845,Have you tried the [DefinitelyTyped three.js typings](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/three)?,1542070876.0
grinde,You should always check the DefinitelyTyped packages: [@types/three](https://www.npmjs.com/package/@types/three),1542071087.0
sickcodebruh420,"As others have said, use the ones from DefinitelyTyped. They are very good, I have used them for years. ",1542074535.0
villiger2,"Curious about how other people do TS + redux. I found a solution that works for me but I definitely can see how other people may not like it. I lean on TS with it's smart type ([type guards?](https://www.typescriptlang.org/docs/handbook/advanced-types.html)) to keep me safe when using the actions.

Since every enum value is only used in 1 action type I can be sure that when I'm in those case statements I do in fact have that type and TS can infer that.

    const enum ActionType {
      Create = ""Create"",
      Destroy = ""Destroy"",
      Update = ""Update""
    }

    interface CreateAction {
      type: ActionType.Create;
      payload: { name: string };
    }

    interface DestroyAction {
      type: ActionType.Destroy;
      payload: { name: string };
    }

    interface UpdateAction {
      type: ActionType.Update;
      payload: { oldName: string; newName: string };
    }

    type Action = CreateAction | DestroyAction | UpdateAction;

    interface State {
      readonly names: string[];
    }

    const reducer = (state: State, action: Action): State => {
      switch (action.type) {
        case ActionType.Create:
          /* Only 1 action that has type: Create so we're sure it's a CreateAction */
          return {
            names: state.names.concat(action.payload.name)
          };
        case ActionType.Destroy:
          return {
            names: state.names.filter(n => n !== action.payload.name)
          };
        case ActionType.Update:
          return {
            names: state.names.map(n =>
              n === action.payload.oldName ? action.payload.newName : n
            )
          };
        default:
          return state;
      }
    };

I've seem other solutions using weird type ""hacks"" by using another library to wrap their actions/creators and get it looking kind of like non TS redux but I've never liked any of those solutions. The above solution has no performance overhead but still has full type checking, and is conceptually super simple.",1542080981.0
son_of_meat,`baseUrl` and `paths` are the `compilerOptions` you're looking for: https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping . The exact scenario you describe is described in those docs.,1541983564.0
liangchun,"You probably don't need a package for this. Check out [https://www.davideaversa.it/2016/06/typescript-binary-heap/](https://www.davideaversa.it/2016/06/typescript-binary-heap/)

It only takes one argument for the scoring function, but I think it's easy to change it.",1541948261.0
Vaielab,"Have you tried adding it without a star too?

    ""common/*"": [""src/components/common/*""],
    ""common"": [""src/components/common/index.js""]
    

My guess is that since your import does not have a /\*, it will not match with common/\*

By adding both, you should cover all possibilities.",1541867326.0
ClutchHunter,Why don't you alias the parent folder `components/` instead?,1541863607.0
weffe,"Maybe you can take advantage of typescript's built-in path mapping and combine them with yarns workspaces. Here are two links that explain how to set it up:

1. [https://decembersoft.com/posts/say-goodbye-to-relative-paths-in-typescript-imports/](https://decembersoft.com/posts/say-goodbye-to-relative-paths-in-typescript-imports/)
2. [https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping)

So essentially you can have your tsconfig set up like so:

    // tsconfig.json
    {
        ""compilerOptions"": {
            ""baseUrl"": ""."",
            ""paths"": {
                ""@errorMsg/*"": [ ""@project1/shared/errorMsg/*"" ],
                ""@graphQL/*"": [ ""@project1/shared/GraphQL/*"" ]
            }
        }
    }

&#x200B;

Then with actual usage in your code, it can look like this:

    import {...} from ""@errorMsg/user"";
    import {...} from ""@graphQL/post"";

&#x200B;

This way it saves you from mistyping and from importing long names.  I haven't tried this out myself but you can try to see if it solves your issue.

&#x200B;

Edit:

I should mention that the baseUrl may be different for you depending on where your tsconfig lives in relation to your project directory. If your tsconfig is at the root of the project directory then you should be fine with just the `""baseUrl"": "".""` path. If your tsconfig is nested inside some folders like so `src/tsconfig.json` then it may need to be a relative path back to the root like so `""baseUrl"": ""../""`",1541700676.0
kredditacc96,"### Tools

[pnpm](https://pnpm.js.org/) is both a package manager and monorepo manager (npm and lerna in one).

### Repos

[The repository of pnpm](https://github.com/pnpm/pnpm.git) itself is a monorepo. This repo has local scripts differ from package to package.

I personally also have a [monorepo](https://github.com/ksxnodeapps/fun-little-utilities.git) in Typescript that uses pnpm. This repo has global scripts run once in root directory. It is also super duper strict.",1541706981.0
vinnl,"Fixed formatting:

> Im trying to apply the following list of reactstrap dropdowns by toggling the isOpen inside each Object array in typescript. I receive a object from redux that has the following structure, Object.InnerObject.Array[isOpen,isOpen,...] Im trying to trigger the toggle in that array but typescript is restricting me from doing the following. I have the following object in state:
> 
>     totalWorkload: {
>           userId: 'd3d4',
>           cost: 3,
>           options: [
>             {
>               optionTitle: 'dedew',
>               optionDescription: 'fewfw',
>               options: [],
>               isOpen: false,
>               selectedOption: ''
>             }
>           ]
>         }
> 
> Im trying to toggle the isOpen in the options array in the following component:
> 
>     export const Options = props => (
>       <div>
>         {console.log(typeof props.totalWorkloadOptions.isOpen)}
>         {console.log(typeof props.toggleDropDown}
>         <Dropdown isOpen={props.totalWorkloadOptions.isOpen} toggle={() => props.toggleDropDown(props.totalWorkloadOptions.optionTitle)}>
>           <DropdownToggle caret>{props.totalWorkloadOptions.optionTitle}</DropdownToggle>
>           <DropdownMenu>
>             {props.totalWorkloadOptions.options.map(op => (
>               // tslint:disable-next-line:no-invalid-this
>               // tslint:disable-next-line:jsx-no-lambda
>               <DropdownItem key={op} data-key={op} onClick={() => props.appendChoiceList(props.totalWorkloadOptions.optionTitle, op)}>
>                 {op}
>               </DropdownItem>
>             ))}
>           </DropdownMenu>
>           <strong> {props.totalWorkloadOptions.optionDescription} </strong>
>         </Dropdown>
>         <br />
>       </div>
>     );
> 
> The problem is when I get to here I cant actually set the state of the passed dropdown isOpen:
> 
>     toggleDropDown = optionTitle => {
>           console.log(""TITLE:"" + optionTitle);
>           const options = this.state.totalWorkload.options.map(item => {
>             if (item.optionTitle === optionTitle) {
>               this.setState({ ...item, isOpen: !item.isOpen })
>             } else {
>               return item;
>             }
>           });
>           return { options };
>         };
>     

As for the actual question: could you show how TypeScript is restricting you, i.e. the exact error message?",1541682149.0
leafsleep,"It looks like your issue is around \`this.setState\`. It doesn't look like you're using it right - in one branch of the if/else you're returning, in the other you're calling \`this.setState\`.

&#x200B;

setState is used to set a property in your component's state. You need to set the whole property each time, you can't set a subsection of it. TypeScript is probably complaining that the shape of the object you're trying to set doesn't match the shape of the property you've defined in state.

&#x200B;

To be clear, this doesn't look like a TypeScript issue, but a React issue that TS is warning you about.",1541760323.0
welkie,"I found that I was able to achieve type safe templates by using the React library directly on the server, for HTML templates. I think your way is more flexible since it can generate more than just HTML.

If anyone wants to see mine, I've got a tutorial on my blog at: https://blog.mattwelke.com/strongly-typed-server-rendered-views-with-react-and-typescript/",1541679919.0
QW4K,I was looking for something similar to use in TypeChain project and in the end I went with ES6 templates. They are type safe with TS and were good enough for my use case. But great to see improvements in the space! Nice project.,1541669575.0
thinkmatt,"Great to see some more experimentation in this area. We generate many emails at my company which have a LOT of logic and are written using ejs. I experimented with template strings, but it only goes so far. Using React + Typescript has been the best way I've ever seen to write emails. Not only are variables type-safe, the HTML is validated and they're easy to compose and read. It has been a great introduction to React as well :)",1541682757.0
DanielPerezAlvarez,"I made something similar with the idea of replacing other templates engine on the server, [https://github.com/danielpa9708/jsx-to-str](https://github.com/danielpa9708/jsx-to-str)",1541694689.0
toggafneknurd,"Lol
Wtf",1541665118.0
sittytucker,"Thanks for this article. Haven't read it yet, but after a glance I know that I will want to read it this week.",1541609025.0
saltupz,"OOP in javascript via inheritance using extends is, and will always be sugar for how prototypes work, this has really nothing to do with typescript per say, its using the same idioms from the early 2000s when users first started to mimic javalike inheritance.

That said i find classes kind of bad, and very seldom resort to using them. The only usecase for them would be when newing up 1000s of instances of the same type. Other than that, they are prone to bugs and unneccessary complexity.

Javascript/typescript really shines when you have typed data going to functions with typed parameters.",1541610438.0
r0ck0,"Thanks for the article.

One suggestion for future articles though:  please don't use ""foo"" and ""bar"" in example code.  I don't understand why anyone chooses to use something meaningless like this for examples about anything.

You could use almost anything else (things that actually mean something), and the whole thing would be much easier to follow without having to think back about which nondescript abstract thing was inheriting from the other nondescript abstract thing... which distracts focus and just makes the whole thing harder to follow than it needs to be.

""Animal"" and ""Dog/Cat"" are common examples used for articles about inheritance.  Everyone just inherently knows which is which without having to distract their conscious focus away from the what is actually being taught.",1541644333.0
mhackmann,"[MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/Element)

**Tl;DR** - `HTMLElement` is an extension of `Element` and would include things you'd only find on an HTML tag, like `style`, `clientWidth`, and things of that ilk. Other types of elements would be `SVGElement` and probably anything pertaining to XML. `querySelector` can be used to select those other types of elements, so it makes sense that it'd return the parent class. If you're expecting to only get back an `HTMLElement`, it's perfectly fine to type it that way.

**EDIT:** [Microsoft has intentionally broken spec in their definition file](https://github.com/Microsoft/TypeScript/issues/4689).",1541540952.0
coolcosmos,"If I remember correctly, querySelector returns the element at the moment the method is called. getElementById returns the element.

example:

html:
`<html><body><div id=""test""></div></body></html>`

js:

`document.getElementById('test').style.color = 'green';`

`var testQuery = document.querySelector('#test');`

`var testGetEl = document.getElementById('test');`

`document.getElementById('test').style.color = 'red';`

`console.log(testQuery.style.color === 'green') // true`

`console.log(testGetEl.style.color === 'red') // true`
",1541540790.0
BrunnerLivio,"Decorators are great for a lot of use cases, but can also be really annoying when being over-""forced"" by frameworks. The problem with decorators is generally that they are not dynamic. So if we want to generate dynamic routes, SugoiJS for example would need to provide a routing variant without the decorators. 

I do not know a lot about SugoiJS and is rather questionable since it is being developed by just one developer and it does not seem to have a large community.

But what I can recommend is [NestJS](https://github.com/nestjs/nest) which has similar features as SugoiJS, but has a way larger community. In addition it tries to be dynamic even with decorators, so things like dynamic routing would be possible.
",1541509608.0
AngularBeginner,"Additional negative points about decorators:

- They increase load times of your script.
- They force you to use classes, increasing the risk to get `this` wrong.
- The current TypeScript implementation is outdated.
- It's still a preview feature.
- They can't augment type information.",1541518034.0
fecal_brunch,"> It seems like before TypeScript, developers wrote “code sections” instead of a program with a real design behind it.

I still write essentially the same programs as I did in JavaScript.",1541670532.0
_nebular,"    // Edit:
    type ValuesOf<T> = T[keyof T];
    type ActionTypeDef<T extends string[]> = { [k in T[number]]: k }
    type ActionTypes<T extends ActionTypeDef<string[]>> = ValuesOf<T>;
    
    function actionTypes<T extends string>(types: T[]): ActionTypeDef<T[]> {
        return types.reduce((actionTypes, key) => {
            actionTypes[key] = key;
    
            return actionTypes;
        }, {} as any)
    }
    
    const MyActions = actionTypes([
        ""SomeAction"",
        ""ActionTwo""
    ])
    
    // Edit: 
    type MyActions = ActionTypes<typeof MyActions>;
    
    console.log(MyActions);
    
    /**
     * Output:
     * 
     * {
     *   SomeAction: ""SomeAction"",
     *   ActionTwo: ""ActionTwo""
     * }
     */

Playground link here (not official typescript playground): [playground](https://agentcooper.github.io/typescript-play/#code/FAehAIFEBMEsBcBcx4E8AOBTcA1AhgDYCumAzgPIBmAPACoB84AvOLQNoDWmqA9pawF0A3CgzYAggGN4sHgDtaYgCKYatcJgAe8THOilwpeACdYcgOZsBjFgG9wncGdZs5RALYAjTMYEDE4BzgAL6iWOBSMvKKWKR0Gtq6+hHSsgrKqtRGphZW9Da4hCQUavQiwJREcqny4Hg16bHxWjp6Btlm5vQAFGixAewCAJQBkWkxmCpqeeC2wOAL4MaY8ETGcuB9ZAB0y9BEkpjd3fVRjWQANIHcQ8yMc4uPdQ0TpJzcAszXqOVPi8urdbPM6vESPYJXWzBOoGPByVBDYChYCSeRGcAAWVQYzRX1O4zEpG6bHmiwARABlHjuTA4uRki6khZkum0ADuPDJwGGwFAEBgCACYWwWLpBhYrMJ1C2fEx2IapDKvJAACoVfMVeByER4OgdchwJqNbNjQsqTS6QFKdTaQ0GaaUiCOVbWRyuYaQhqQLygA)",1541510051.0
turkishlady123456, Have you considered declaring Actions as a string enum instead?,1541500406.0
,This is a known limitation. See here for extensive discussion https://github.com/Microsoft/TypeScript/issues/10195,1541556722.0
villiger2,"Sounds like a tricky one, have you looked at mapped types though? Seems along the lines of what you're trying to do.",1541496946.0
kwiwksh,"Yes, TSX works basically the same as JSX. There's nothing special about adapting TS to ReactJS & Redux assuming you understand all 3.",1541454675.0
welkie,"I use TSX but not for client side apps. I use React libraries to render components as strings and send out HTML responses from Express. You get more compiler help with your ""HTML"" than with view engines like handlebars.

Note that this is not typical ""server side rendering"" with React. I'm not mounting the React component when it hits the browser. I'm just tapping into the same API that the server side rendering libraries would to render it out as HTML. And then, when I have that HTML, I'm done. I send it to the browser as if it were any other HTML page. I just use it as a view engine.",1541466485.0
vinnl,"> What are the main things you must understand to be able to adapt Typescript to ReactJs

- TypeScript
- React

> and Redux?

- Redux
- The Redux typings, which can be somewhat complex, and unfortunately have little documentation available, so much of this is dependent on reading the names of the types and guessing what they represent.
",1541492178.0
ChooseADinosaur,"The main problem is that not every 3rd party library, especially smaller ones,  supports typescript out of the box so you have to do some research on get it working 

TSX itself is almost straight forward one you learned the basic concept.

This helped me a lot [https://github.com/sw-yx/react-typescript-cheatsheet](https://github.com/sw-yx/react-typescript-cheatsheet)",1541492309.0
demoran,"I'm not sure if this has been fixed post in more recent versions, but with the version of React I'm using, Typescript will display an error when trying to use the arrow syntax to define the render method.

As such, lifecycle hooks and the render method should be bound in the constructor.

`connect` is also tricky to use when typed.",1541473313.0
vinnl,"This feels like pedantry, but... This isn't an example of TypeScript 'making types real' or TypeScript doing run-time type-checking. The type guards are just Javascript, and all the runtime type-checking that is being done here is being done by Javascript. However, TypeScript understands (or [can be made to understand](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards)) these type guards, and can thus use them for type inference in the following code.

Which is nice, but you don't need to use TypeScript to do the runtime type checking that is being done in this article.",1541431042.0
recursive,"How does this address the hard part?  Namely, my 1000-property interface declaration.  Am I supposed to write a 1000-line type guard and then keep them in sync?  That doesn't sound like a practical way to make types real.",1541438405.0
tortus,"I'm a little leary of user defined type guards as the compiler completely trusts them. They are an area where you can inadvertently add bugs to your code, similar to casting and using `!`.  
  
    function isString(foo: any): foo is string {
        return typeof foo === 'number';
    }
    const a = 123;
    if (isString(a)) {
        console.log(a.substring(4));
    }

Obviously that's a contrived example, but the point is, it's entirely up to the developer to write the type guard correctly. I am finding myself moving towards discriminated unions whenever I can, as they come with some compiler aid.",1541467278.0
BrunnerLivio,"[class-validator](https://github.com/typestack/class-validator) and [class-transform](https://github.com/typestack/class-transformer) are my absolute go to libraries for this problem. They are really easy to use and have a large backing by the TS community.

Example:

```TypeScript

export class Post {

    @Length(10, 20)
    title: string;

    @Contains(""hello"")
    text: string;

    @IsInt()
    @Min(0)
    @Max(10)
    rating: number;

    @IsEmail()
    email: string;

    @IsFQDN()
    site: string;

    @IsDate()
    createDate: Date;

}

```
",1541432525.0
ihsw,"Yup is great for this.

https://www.npmjs.com/package/yup

It can also do type coercion to make sure the values you get back are sane as well as filtering out unknown members when validating objects (to protect from data pollution and accidental persistence of unknown user data/XSS/etc.)",1541434165.0
ArturCzemiel,"Great cpoly55, I like your article. I think I need to add this to my [slothking.online](https://slothking.online) code generation tool to prevent backend from returning invalid data.",1541499243.0
bheklilr,"I had this figured out a while ago, but don't have the code with me. Send me a DM tomorrow and I can send you the pattern you need. I've not had any issues on Chrome/FF/IE 10/Edge. 

EDIT: Here's the pattern I landed on that seemed to work cross browser:

        export class MyError extends Error {
        // You have to extend Error, set the __proto__ to Error, and use
        // Object.setPrototypeOf in order to have a proper custom error type in JS.
        // Because JS/TS are dumb sometimes, and all three are needed to make this
        // work in all browsers.
        __proto__ = Error

        public field?: string

        constructor(field?: string) {
            super(""A custom error message"");
            this.field = field;

            // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
            Object.setPrototypeOf(this, MyError.prototype);
        }
    }",1541382164.0
gamebuster,"`Object.setPrototypeOf(this, new.target.prototype);` What is that line supposed to do? I don't see `new` defined here?

This one seems to work for me in NodeJS environment:

```
export class ValidatorError extends Error {
  constructor(public errors: IValidatorErrorMap) {
    super(""Validator Error for fields ["" + Object.keys(errors).join("", "") + ""] (see .errors)"");
  }
}
```

For the browser environment, see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types

I don't think there is a pretty typescript way to make it work. I'd just use vanilla JS to make it work, and then just add type definitions for typescript. Then you never look at that code again, and maybe you'll forget your sins.",1541412496.0
AngularBeginner,"What browser are you using? It works in Chrome. At least after I fixed the error of assigning `string | undefined` to `string` (the message). But you probably compile without strict type checks.

edit: Apparently it simply won't work on IE10 and before: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work",1541401354.0
drdrero,"I have done this in chrome und typescript on the backend. Where are you trying to do this? 

I can show you my error class in an hour ",1541414945.0
Charles_Stover,You can't extend Error (in all browsers)! Simply a limitation of Error. Took me a while to figure the source of this bug. You'll have to come up with a solution that doesn't extend error.,1541384794.0
icholy,Keep the types close to the code using them. Don’t put them in a “types” folder. That’s like having a “classes” or “functions” folder.,1541358860.0
blukkie,I keep types close to the modules that need it. I then import/export them from a single types.ts file that I have an alias for so all modules can easily reach all types. This makes it easy to maintain while still being very in control of how to reach my types and move them if needed.,1541374407.0
HeylAW,"Recently I started adding folder @types to source folder where I add definition files per every shareable definitions in my project.
ie IPerson or IFlags",1541436984.0
sandiprb,I prefer to have an Interfacepool.ts at the root of my app and define everything there and import from there as and when needed. ,1541366191.0
wafflelator,"Pretty sure grep is not a standard windows command.


    if (process.platform === 'win32') { 
        const res: Buffer = execSync(`netstat -a -n -o | grep '${port}' | grep 'LISTENING'`) as any;

You're probably looking for `findstr`",1541348577.0
thistoohard,A package for two CLI lines?,1541345428.0
radarsu,"Cool idea. I'm in if there is nothing like this yet.

Although I'm having some troubles to connect.",1541337324.0
AngularBeginner,I stick to IRC. :->,1541356172.0
rftz,Check out dtslint: https://github.com/Microsoft/dtslint,1541199358.0
allenthar,This kind of “type exercising” tests are common with the DefinitelyTyped community definitions.  You could look at something like https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react-redux,1541255776.0
theiades,can you share a more complicated case where this could be handy?,1541198710.0
fllr,You want to test types...? Why?,1541254307.0
RegularUser003,"Cool idea using a parent makefile, never tried that, will try it out in the future.

I think your tslint file is better than mine so I'll be using that in the future for sure. 

Consider if you'd want to have typescript in the frontend as well. I really like using typescript with react, and you'll learn it twice as fast if you add it! There's a create-react-app package out there that generates a ts-based react template. 

I also prefer sorting front-end components by function rather than component, style, etc. That way if I decide I want to split off something into its own package, it's easy to drag that folder into a new project and build it. Also find it scales better as a project grows in size. 

Ive been looking for a good template to use for my react/node/QL/ts apps for a couple months now, and this is really close. If you added redux and react-ts I'd use it regularly. I may even fork your work and do it myself. ",1541213578.0
edevil,"I’m doing a similar thing but just for the server. Maybe we can share some ideas?

https://github.com/edevil/node-webapp-sample",1541233810.0
DanielPerezAlvarez,"There is only one tip about typescript, the first one, the rest are about js or code style",1541134824.0
modec,"Another advantage is that unlike constructors, factory methods can be async ...",1541105398.0
heinbau,You can also create a static factory method for interfaces ;),1541130075.0
CSMastermind,"Oh hey.  When I rolled my last company over to TypeScript 2 years ago we encountered a problem with TypeScript constructors.

Check out this code block:

    class Base {
    
        public constructor() {
            this.setup();
        }
    
        protected setup() {
        }
    }
    
    class Child extends Base {
    
        public myVar: string[] = [];
    
        public constructor() {
            super();
        }
    
        protected setup() {
            this.myVar.push('one'); // throws TypeError: Cannot read property 'push' of undefined
        }
    }
    
    var child: Child = new Child();

If you can't tell what's happening let me explain.  When TypeScript is creating the objects it first calls the `Child` constructor which in turn calls `super()` raising it to the base class constructor.  The base class constructor calls `this.setup` and here's where the problem occucrs.  `this.setup` calls *the child's version of `setup`*.  In the `Child`'s `setup` method it references `myVar` which does not exist yet.  

What's the solution?

We used Factory methods for everything.  I found them to be supioror in every way to using normal TypeScript constructors. ",1541161486.0
threemanycats,"> Now don’t confuse this with the stuffy Factory Method pattern from that Design Patterns books. 

These are exactly what the factory pattern is. Its okay, just because there's backlash against the GoF lately doesn't make every pattern bad.",1541171709.0
kurashu89,"Maybe I'm a stuffy curmudgeon (well, not maybe, but maybe on this particular issue), outside of simple value types (value as in Currency, not struct), I think a good ol fashioned Factory class is better. ",1541114884.0
isakdev,"What's up with blog posts having 'le memes' in between paragraphs as if we are reading something that needs a comic relief. It breaks my mental flow and has 0 added benefit. On top of that, it's super cringy.",1541162824.0
scaleable,"use closures instead of classes

&#x200B;

/thread",1541119655.0
callensm,Partial<T> takes the generic type T and makes all properties of it optional. That might fix the issue.,1541097138.0
Charles_Stover,Should it be `myHOC({})(Input)`?,1541097217.0
tehdog,"You want `&` instead of `|` (these props AND those props)

Example:


    class Test extends React.Component<{ a: string, b: number }> {
    	render() {
    		return <div/>
    	}
    }
    
    const myHOC: (config: any) =>
        <B>(c: React.ComponentType<B>) =>
            React.ComponentType<B & { value: string, onChange: (val: string) => void }> = null!;
    
    const Outer = myHOC({})(Test);
    
    
    <Outer a=""a"" b={1} value=""1"" onChange={() => { }} />",1541099522.0
thinkmatt,"Not at all... You have to add a tooling step but that's the worst of it. Typescript is just JavaScript plus types. I leave strict off so I can use types when I want, but that's up to you. Is recommend trying with it on at first anyway. I recommend ts-node if you're a Node.js dev as it will run and compile typescript in memory so it feels like there's no build step",1541026707.0
callensm,"Coming from JS is very easy. The mechanics of the languages are nearly identical, though once you get into advanced typing things make get a bit tricky. You shouldn't have any issues though, good luck!",1541026922.0
sickcodebruh420,"Basic syntax is easy. The bigger issue might be your coding habits and openness to changing the way you think about code to avoid butting heads with the compiler all the time. Many of the people who hate TypeScript do so because they think there’s nothing wrong with the way the write but the compiler says otherwise. If you’re going to learn it, you’d be wise to frequently remind yourself that the compiler is there to help. When you think “this sucks, how do I force it to accept what I want to do,” instead think “how can I approach this problem in a way that makes the compiler happy?”",1541040390.0
jkuhl_prog,"Typescript is super easy to learn from a Javascript background.  You’ll want to learn the type system, interfaces, enums and classes, but it can be learned in about an hour since all valid JavaScript is valid in Typescript ",1541027725.0
r0ck0,"With a strong JS background you should be pretty good.  I went straight in basically, did plain ES/Node for a couple of months then straight to typescript.

You might have some moments every now and then where you're annoyed that it's ""slowing you down""... because you're not exactly sure what the problem is that causing the error (although you'll have less of these moments than me)... but it's absolutely worth it.  Overall it saves time.  It just takes a little bit of learning.

One really nice thing about the error messages is that they all include a code like ""TS2304"" at the start, which helps when Googling.

As someone else mentioned, don't try to go all in with the most strictness from the start.  i.e. You'll see some guides that recommend things like ""noImplicitAny"" ... but I think that's a bad idea for people new to TypeScript.  

I can't imagine writing anything serious in plain JS without Typescript... plain JS is way too loose with what it allows, and I'm coming from PHP.  It also brings a lot more benefits than just typings too.

The only downside is that it's made me hate Microsoft a little bit less, haha. :)

If you're anything like me, you might be spending some time researching the pros and cons to try and figure out if you should use it or not... I suggest stop worrying about that and jump into it today.  I don't see any reason why you wouldn't use it on any non-trivial project, aside from not knowing it and having a tight deadline maybe.

This guide is really nice: https://basarat.gitbooks.io/typescript/
",1541032661.0
AndreDaGiant,"after getting an environment set up, you'll be productive almost immediately. It'll take you like a few days at most to reach the same levels of productivity that you had before switching",1541047363.0
mczernow,The big problem with TS is that they do not maintain language spec. But I assume it might get surprising and annoying when you really get into TS. Or if you really rely on language spec in your lerning. Otherwise the experience feels seamless.,1541054620.0
gamebuster,"Typescript is easiest if you already know Javascript and (C#, Java or another ""explicit/verbose"" typed language). While some people might say Typescript is just Javascript with types, some patterns that work perfectly fine in Javascript are pretty hard to execute well in Typescript (EG magic, meta-programming or deeply nested structures). My typescript code is usually more structured like Java/C# programs than Javascript programs.

Learning Typescript isn't that hard - the language is easy to grasp. Learning to write code with strict typing is hard if you're not experienced with any other typed language.",1541060641.0
SyefufS,"All javascript code is allowed in typescript. Typescript only brings with it the addition of types which, when used correctly, can make your editor really smart!!",1541062598.0
RationalJS,"Here's another perspective.

`Partial<>` makes **all** keys optional. This means an object with *zero* keys will still match. Therefore, `queryParams` matches because it has zero [known] keys.",1541016028.0
Useless-Pickles,"Rather than using Partial<>, consider defining a mapped type that makes all properties allow undefined (but not optional) so that you are forced to provide a value for each property, even if you set it to undefined. This would then force you to implement a function that converts the query parameters Record<string, string> to an object that has the desired properties.  


    type AllowUndefined<T> = { [P in keyof T]: T[P] | undefined };

    type VideoOptions = AllowUndefined<{
         hevc: boolean;
         casting: boolean;
         resolution: string;
         // etc ... 
    }>;

&#x200B;",1541012801.0
Useless-Pickles,"(EDIT: my explanation may be correct, or at least close enough, in terms of why this happening, but it appears that the current behavior is acknowledged as a bug: [https://github.com/Microsoft/TypeScript/issues/27144](https://github.com/Microsoft/TypeScript/issues/27144))  


Record<string, string> produces a type equivalent to { \[key: string\]: string }.

{ \[key: string\]: string } is assignable to your Partial<> type because { \[key: string\]: string } has no named properties, and all the named properties in your Partial<> type are optional. There's no conflict. And when determining assignability, extra properties in the source type (the string index of { \[key: string\]: string }) that do  not exist in the target type (your Partial<> type) are perfectly valid.

&#x200B;",1541011996.0
Useless-Pickles,Looks like this has already been reported on github and acknowledged as a bug: [https://github.com/Microsoft/TypeScript/issues/27144](https://github.com/Microsoft/TypeScript/issues/27144),1541106928.0
,"This honestly feels like a bug, or undesirable behaviour.",1541042483.0
themeanman2,"I am no expert myself, but the class `IEsriColor` seems confusing to me, perhaps you can start by working that class typing.

`class Color {
  private a, r, b, g;
  public static blendColors (start: Color, end: Color, option: Color) {
    // function implementation goes here
  }
}

expprt default Color;`",1541005697.0
AngularBeginner,"[Link to TypeScript playground](https://agentcooper.github.io/typescript-play/#code/MYGwhgzhAEBiCuAjMAnaBvAUNH0AWAlhAC4D2KAngFzRgB2FA3NrgO4EBeqAJjfUyxypghAG4BTPg2a5owUgFsF9XrWmZB0FOOAFxEgMKLldbgAoAlBk2z5dEtAMB5ALIuAggDkAIgGVoALzWsiG4wJDENGbySio0JCgEdADmVgEAfNDEhBAAdDlklNAA1EHZRLnsXCjcueEk0cYqFgA0NqHQ3Il0ANZRMSaqCUmpgZnleQXkFCVlOZWcPLkADqTEABKkINziKLldST0ACmsEpHSNsaat7aGg4qhRaZlYHW8hE7nCYuKBWfNTSgyd4gz6AmZBADkkOBIIAvm0QUIUCICBInmN-hVwX9Pt80b9iljJkRChREUidgAzMDwECRaCWTFg0nTWbQAAGABJ0J8qks6GAFOI4Z1SOIYHQ1oQUgAdOgc27QOEaN52BwAbTkTVMLVowGIZzo0AAurj5gMVLliIkFJZraQADKkVi7AyQcT2iDLEAEYhmSHQSEWWEhAhUy6DQJQ4PBJEskhs0qcnl8xY1XKC4Wi7jiyXSkbyjmh2Si8QgCC-V5I8NmZxuLx+DWW0wmqzVpG4eseHy+Zs67gmsxgA1GkNK0vQcuVuOdnDdxt9yHU2n0yFD8edlVvbe4FVwoA)

The answer is: It doesn't. The type of `COMMANDS` is inferred correctly. The problem is that you then try to access a property of `COMMANDS` using a string key (line 23 in my link). Here the compiler will complain with the `noImplicitAny` compiler flag. There's no way the compiler can figure out the correct type based on a runtime string value, so the type is implicitly any.",1541003748.0
empty_other,"this.command isn't implicitly typed. You could call COMMAND\['dog'\]('kick'), so your compiler complains that COMMANDS doesn't have a type that supports that signature. This fixes it:

    const COMMANDS = {
    	cast: (command: string) => this.history += this.wizard.cast(command),
    	drink: (command: string) => this.history += this.wizard.potHolder.drinkPotion(command),
    	clear: () => {
    		this.archive = this.history;
    		this.history = '';
    	},
    	archive: () => this.history = this.archive + this.history,
    	default: () => this.history += `${this.wizard.name} does nothing\n`
    } as {[key: string]: Function};

Or better typed:

    } as {[key: string]: (command?: string) => any };

Or alternatively you can filter away any strings that isn't one of your 5 chosen ones, the compiler accepts that too (type of the command string becomes 'cast' | 'drink' | 'clear' | 'archive' | 'default' ), but then the parameter ""action"" becomes required:

    } else {
    	if(
    		command !== 'cast' &&
    		command !== 'drink' &&
    		command !== 'clear' &&
    		command !== 'archive' &&
    		command !== 'default'
    	) return;
    	if(COMMANDS[command]) {
    		COMMANDS[command](action);
    	} else {
    		COMMANDS['default']('');
    	}
    }

Or you can cast the command to your type:

    const command = this.command.trim().toLowerCase().split(' ')[0] as 'cast' | 'drink' | 'clear' | 'archive' | 'default' | '';

This is the same as the previous code, except it picks up on COMMANDS' keys instead of you having to specify it manually:

    const command = this.command.trim().toLowerCase().split(' ')[0] as keyof typeof COMMANDS | '';

&#x200B;",1541004668.0
AngularBeginner,I'm skeptical if libraries don't utilize the strict flags of TypeScript.,1541000420.0
Poltras,"2 things I can see;

1. why use this vs JSON Schema? Something like `ajv` can take a schema and validate an value against it, and JSON Schemas already exist for a bunch of interfaces (including package.json and tsconfig.json).
2. you should make a generic version that returns `as Type` already typed, and a validator that returns `is Type`.
",1541002093.0
dmoonfire,"If you are basing your code off a monorepo (single repo for all your projects), you can use the new \`tsc\` features that lets you reference another project easily.

[https://www.typescriptlang.org/docs/handbook/project-references.html](https://www.typescriptlang.org/docs/handbook/project-references.html)

This worked out really nicely for some of my projects.

For multirepos, using a separate contracts package  works. You can also use lerna or \`npm link\` to connect them without having to push up constantly.",1540993337.0
son_of_meat,Namespaces and typeroots are harder to work with. Just use import/export like you would with non-TS code. ,1540991364.0
themeanman2,"If you are looking to shortning your imports, you can do something like this in you tsconfig.json

Give a property named path like:

{
  .......
  ""path"": [
    ""@types"": ""relative path to your type definition with respect to this tsconfig file""
  ]
}

Then you imports will reduce to:

import { SomeType } from '@types/sometype';",1541007340.0
hunyeti,"I have all 3 of these in one repo and use a symlink, works well, simple, no tsc pitfalls. ",1541019433.0
daniand17,"I keep my types in a separate private repository, and clone it alongside both my server and client projects. Then in both the client and server folders I run `npm install ../<types-repo>`

Then I run `tsc --watch` in my types folder, so when I update the interfaces, they rebuild into a `/dist/` folder. Since I've installed that folder in both my server and client, those respective projects will see those changes. Then you can do an  import like `import * as someName from '<name-of-installed-types-module>/dist/<path-to-file-you-are-importing>`.

Once a type is file is rebuilt with tsc, your client/server won't see that change until you navigate to the built file in your project. I typically F12 or cmd+click the import statement in whatever file is using it to get there quickly.

Hope this helps.",1540990869.0
NotLyon,Epic. Lol,1540971081.0
AngularBeginner,What an awful website.,1540973676.0
tvi016,"Really awesome! 
However, one bad effect of including zero runtime is there can't be automatic data validation based on the types

Other than that, i feel like this is something i would use",1540936863.0
vinnl,"Create React App is the primary way with which front-end developers using React set up new apps, so native TypeScript support is bound to be a boon for adoption.

For those using create-react-app-typescript, here's [how to migrate](https://vincenttunru.com/migrate-create-react-app-typescript-to-create-react-app/).",1540885515.0
i_spot_ads,about damn time,1540925444.0
gtheory1,"Hell, it's about time!",1540936115.0
grinde,"Typescript doesn't support higher kinded types (see [here](https://github.com/Microsoft/TypeScript/issues/1213)), but you can get *some* of the functionality with workarounds. A good example is [fp-ts](https://github.com/gcanti/fp-ts/blob/master/HKT.md).",1540945529.0
tweettranscriberbot,"^The linked tweet was tweeted by [@LinguaBrowse](https://twitter.com/LinguaBrowse) on Oct 29, 2018 14:51:39 UTC (1 Retweets | 0 Favorites)

-------------------------------------------------

OCR will be coming to LinguaBrowse! Soon you'll be able to tap-to-define words even if they're just images (e.g. Chinese/Japanese shopping sites).



I made a proof-of-concept as my first [@NativeScript ](https://twitter.com/NativeScript ) app using tesseract.js. Now I just need a solution to circumvent CORS policies… 

[Attached video](https://video.twimg.com/ext_tw_video/1056918278726131712/pu/vid/720x1280/Vip61Zkd2aMAHB7I.mp4?tag=5)

-------------------------------------------------

^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •",1540840570.0
Bamboo_the_plant,"For clarification: I wrote this NativeScript app in TypeScript; I'm not simply posting in the wrong subreddit!

NativeScript is a joy in some ways and a hell in others. It removes so many layers of complexity and magic that competing cross-platform frameworks like React Native add, due to running directly on the UI thread and not being much more than JavaScript bindings to native code (it's easy to make your own subset of it just by using JavaScriptCore). TypeScript makes the platform very discoverable, and the lack of a reactive UI architecture (in fact, it's completely UI-agnostic and so supports various UI frameworks) makes things much simpler to start out with. In dev mode, it doesn't even use code bundling, so you don't have to spend days fighting a packager for trivial reasons that aren't your fault. More than anything, it's really refreshing to have such immensely short cold build times, due to the minimal size of NativeScript!

I'm a big fan. It's far behind React Native in certain ways (not least community size), but it's very exciting to try out nonetheless.",1540841030.0
Drawman101,Some of these packages I'm seeing are not typescript specific. How did you decide to choose what shows up in this list?,1540842790.0
cspotcode,"Very cool, I've wanted something like this to exist for a long time.

It'd be neat if the URL schema was fixed in some way, so that types from various libraries could link between each other.  For example, if I write an API that returns a node Request object, and I publish docs on my site, it would be cool if my docs could link to this site when someone clicks on the ""Request"" return type.",1540860023.0
scaleable,"I thought something about some kind of jsdoc. I personally hate jsdoc, it's so dumb.

&#x200B;

You could create some simple tags to annotate functions so they are included in the docs. And add ways of linking the functions to some textual declaration, maybe from the comments themselves (not a big fan) or through a reference to an external markdown file.  


Or maybe the other way around, allow some way of linking actual definitions from some special syntax inside a markdown file.",1540863862.0
icholy,You can do what Godoc does and only fetch the file once someone tries to look at it.,1540874471.0
shitcanz,"Got some errors, heres one https://tsdoc.io/@types/express/4.16.0/(ESModule)index.d.ts/(Namespace)e/(Function)Router#function-router",1541350975.0
Hath995,"It's cool, but I don't see a lot of utility that vscode's go to definition doesn't already do aside from not having to download the code.

What would be really interesting is if you could search the types! A plain text search would be handy but you could also try to implement something like [Hoogle](https://www.haskell.org/hoogle/) which lets you search for the shape of functions or types.",1540848038.0
Matt23488,"So is the point of this to create instances of existing objects where all of the properties are optional? That's pretty neat, I guess. Not sure how I might use something like that, but I do like seeing complicated generics shenanigans.",1541001749.0
Ebuall,"Those types are not part of a library, they are implemented separately as typings, that's why you won't see them in the doc to a library. Right now most of the time you will have to look at the typings itself, with help of IDE to navigate it. Most of the time it's just one file you have to look at.",1540831717.0
Yonben,"When using library, I usually find that the docs answers most questions. If it's from community type (like your case), you can simply go read the types themselves: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express-serve-static-core/index.d.ts#L454](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express-serve-static-core/index.d.ts#L454)

&#x200B;

I got to express-serve-static-core as I saw it used in the express types: [https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express/index.d.ts](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/express/index.d.ts)

&#x200B;

Hope it helps :)",1540826842.0
themeanman2,"As with gaining popularity of typescript, almost all libraries has typescript definitions. You can search them in definitelytyped

And the basic rule of typescript is to strongly type everything, so you'll find type definition for everything once you have imported the definition in your project through npm.

Like: `npm i @types/express` for express types. Further job will be handled by the IDE itself.",1541008311.0
SyefufS,"If you can add the type definitions (not every library has typedefs) you can navigate to the definition of an object by shift + clicking on the name. 

This is useful because if it’s a function you can see exactly what arguments it takes and what types these arguments are. If it’s an interface you will navigate to the definition of that interface with descriptions of each property.  

You can often get very far with figuring out any library if it’s well documented.

",1540827854.0
demoran,Did you import those types into the document?,1540829985.0
cspotcode,"In your example, I think the types of req and res will be inferred, so you don't need to specify them explicitly.",1540862898.0
AngularBeginner,"I hope people realize that this is a **highly** opiniated *article*, and by far not a best-practice guide.",1540816756.0
babada,"> All members within class are public by default (and always public in runtime, TS private/protected will ""hide"" particular class properties/methods only during compile time). Don't introduce extra churn to your codebase. Also using publicaccessor is not ""valid/idiomatic javascript""

This isn't really a ""why"". It's just describing what `public` does.

I also disagree strongly with point 2. Using `private` is extremely valuable. If you want to use the `_thisIsPrivate` naming convention you can -- and now TypeScript enforces it for you!

Everything else in the post was kind of interesting.",1540814970.0
besthelloworld,So... 11 tips?,1540814572.0
Sipike,"I disagree with some tips here, but I like mixing OOP and functional stuff when it makes sense and the code simplier.",1540817770.0
ibezkrovnyi,"SonarTS is just a set of tslint rules for SonarQube (https://www.sonarqube.org) which we use for all our projects - it supports JavaScript, TypeScript, Java and may be more languages. It not only provides reports like plato does and  even much more reports, but also allows you to see it from time perspective - how complexity has changed with time, etc",1540827742.0
adamgrieger,"I'm not sure if it's what you're looking for, but [Code Climate](https://codeclimate.com/) has maintainability scores and code smell detection.",1540825954.0
zonq,RemindMe!,1540804448.0
rftz,"Another option that would allow the code to read similarly to what you've got in the question:

    const trace = <T>(value: T) => {
        console.log(value)
        return value
    }

    const resolvedThing = await Promise.resolve(1)
        .then(trace);

Doesn't involve messing with prototypes, creating a separate class and you don't have to wrap your whole promise. You basically swap your `.log()`s with `.then(trace)`",1540756274.0
AngularBeginner,"This is not a TypeScript bug, but instead a misunderstand by you. If you look at the TypeScript definition for the `PromiseConstructor.resolve`, you will see that it **always** returns a `Promise<T>`. It does not return `this` or `PromiseWithLog<T>`:  
https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2015.promise.d.ts#L207

I tried to tinker around a bit but found no good way to make it work. To me it seems like code-smell to extend `Promise` anyway.

Wouldn't a simple function be a viable alternative to you?

    // Async version
    async function logPromiseAsync<T>(promiseOrValue: T | PromiseLike<T>): Promise<T> {
        const result: T = await promiseOrValue;

        console.log(result);

        return result;
    }

    // Non-async version
    function logPromise<T>(promiseOrValue: T | PromiseLike<T>): Promise<T> {
        return Promise
            .resolve(promiseOrValue)
            .then(result => {
                console.log(result);
                return result;
            });
    }

    logPromiseAsync(1);
    logPromiseAsync(Promise.resolve(2))
    logPromise(3);
    logPromise(Promise.resolve(4));",1540725347.0
AngularBeginner,I just found this related TypeScript issue: https://github.com/Microsoft/TypeScript/issues/6220,1540727126.0
voidvector,"`Promise.resolve` is a static function, you need to implement your own static version when you extend the base class, otherwise it always behave exactly the same as the version on base class. 

    class PromiseWithLog<T> extends Promise<T>{
        static resolve<T>(): PromiseWithLog<T> {
            // your implementation that returns PromiseWithLog ...
        }
    }

This is the same behavior in other major OOP languages. 
",1540738683.0
blukkie,"If you are using Webpack, try `tsconfig-paths-webpack-plugin`. It solved all the issues I ever had with absolute paths with Typescript and Webpack.",1540677949.0
cspotcode,"The issue is that TSC never transforms or alters module paths, right?  So after transpilation, those absolute paths are still absolute, and your runtime module loader doesn't understand

There are a few TS transformers that can rewrite those absolute paths to relative ones.  https://www.npmjs.com/package/ts-transformer-imports

Custom transformers can be used via ""ttypescript."" (note the extra T)",1540658156.0
scaleable,"In my react setup im currently using babel-plugin-module-resolver. That implies using TS through babel, ofc.

On server-side you can add a hook to the require function, its like 5 lines of code",1540670464.0
tehdog,"Maps of Maps work perfectly fine. You must be doing something else wrong, show a code example.",1540647330.0
davidmdm,I've been doing typescript for 4 months now. What I've learnt is if it doesn't work you probably need to configure it differently. Typescript is configuraiton all the way down. ,1540658308.0
grinde,"Joi is using `Object.keys` which looks at own properties, but defining a getter using ES6 classes will add the getter to the prototype. Joi might have a built-in option to get around this, otherwise you'll probably have to add your getter to each instance of your class in the constructor:

    class Foo {
      public readonly test!: string;
      private _test: string

      constructor(test: string) {
        this._test = test;

        Object.defineProperty(this, 'test', {
          enumerable: true,
          get() {
            return this._test;
          }
        });
      }
    }",1540539842.0
lukeautry,"I find myself using string literals or ""keyof"" more than enums these days. It's much easier to use strings to pass these different states, especially now that the type system can properly constrain string inputs.

It's also pretty tough to wrap your head around the runtime implications of enum usage, whereas strings are just strings no matter what.",1540401219.0
cspotcode,"I think a lot of us simply don't use them.  Literal types and string enums came about long after enums, so it seems pretty clear that enums were made to solve a few problems early on, and then alternatives were added later.  Linter rules can disallow them.

One benefit is that const enum values are inlined, so you avoid the performance hit of a property lookup when you use them at runtime.",1540422062.0
_nebular,"I'm sorry, this is insane.

The main purpose of enums is **not** just to be an object/associative map. It is meant to describe a collection of values with a common base type and more specific value type. An enum definition creates a type and namespace for the members of the enum, and more specific types for each member. For example:

    enum ColorChannel {
        Red,
        Green,
        Blue
    }
    
    namespace ColorChannel {
        export const labels: Map<ColorChannel, string> = new Map([
            [ColorChannel.Red, ""Red""],
            [ColorChannel.Green, ""Green""],
            [ColorChannel.Blue, ""Blue""],
        ])
    }
    
    
    // getLabel should only accept values from the enum ColorChannel
    function getLabel(colorChannel: ColorChannel): string {
        return ColorChannel.labels.get(colorChannel);
    }
    
    // getRedOrBlueLabel should only accept the red or blue channel from ColorChannel.
    function getRedOrBlueLabel(colorChannel: ColorChannel.Red | ColorChannel.Blue): string {
        return ColorChannel.labels.get(colorChannel);
    }
    
    getLabel(ColorChannel.Red) // OK because ColorChannel.Red is of type ColorChannel
    getLabel(ColorChannel.Blue) // OK because ColorChannel.Blue is of type ColorChannel
    getLabel(""Red"") // Error: ""Red"" is not ColorChannel
    
    getRedOrBlueLabel(ColorChannel.Red) // OK because ColorChannel.Red is of type ColorChannel.Red
    getRedOrBlueLabel(ColorChannel.Blue) // OK because ColorChannel.Blue is of type ColorChannel.Blue
    getRedOrBlueLabel(ColorChannel.Green) // Error: ColorChannel.Green is not ColorChannel.Red | ColorChannel.Blue

>Anyway, I can't see that my ColorType class has any major difference in operation/behavior to the Aforementioned ColorType Enum except that the programmer has all the power to how the object is being constructed.

Well, let's see. In this example, we're using your ""enum"":

    // getLabel should only accept values from the enum ColorChannel
    function getLabel(colorChannel: ColorChannel): string {
        return ColorChannel.labels[colorChannel]; // Error: Property 'labels' does not exist on type 'typeof ColorChannel'.
    }
    
    // getRedOrBlueLabel should only accept the red or blue channel from ColorChannel.
    // function getRedOrBlueLabel(colorChannel: ColorChannel.Red | ColorChannel.Blue): string {
    //     return ...;
    // }
    
    getLabel(ColorChannel.Red) // No error. Good!
    getLabel(ColorChannel.Blue) // No error. Good!
    getLabel(""Fart"") // No error. What in the actual fuck?
    
    // Can't even properly define getRedOrBlueLabel
    
    let a: {} = {};
    let b: ColorChannel = a // no error
    
    // great, type ColorChannel is just {}

I know what you're gonna say, you can define a type intersection. Great:

    // lets see:
    type ColorChannel = ... // Error: Duplicate identifier 'ColorChannel'.
    
    // that won't work, so..
    type ColorChannelEnum = ... // No error yet
    
    // ok, so
    type ColorChannelEnum = ColorChannel.Red | ColorChannel.Green | ColorChannel.Blue; // Error: 'ColorChannel' only refers to a type, but is being used as a namespace here.
    
    // that won't work, lets do this:
    type ColorChannelEnum = typeof ColorChannel.Red | typeof ColorChannel.Green | typeof ColorChannel.Blue;
    
    // Seems great! Let's use it
    function getLabel(colorChannel: ColorChannelEnum): string {
        return ...;
    }
    
    getLabel(ColorChannel.Blue) // No error: Suck it!
    getLabel(ColorChannel.Red) // No error: Haha!
    getLabel(""Big fat fart"") // No error: uhhhhh wait a second
    
    type Test = number | string;
    
    let a: Test = ""big fart""
    let b: ColorChannelEnum = a // no error.
    
    // Great, type ColorChannelEnum is just (number | string).

>To that end I think I would propose that ""Enums behavior is that of a class with static properties""

Nope, this is a complete and total misuse of classes in the first place, and misses the point of defining an enum.

The closest you can get is this, which is a hell of a lot more verbose than an enum:

    type ColorChannel = ColorChannel.Red | ColorChannel.Green | ColorChannel.Blue;
    
    namespace ColorChannel {
        export const Red = ""Red"";
        export const Green = ""Green"";
        export const Blue = ""Blue"";
    
        export type Red = typeof Red;
        export type Green = typeof Green;
        export type Blue = typeof Blue;
    }

Should enums allow decorators in some sense? Sure. Otherwise, I'm completely baffled about the sentiment this thread has toward enums and how anyone can look at this ""enum"" implementation and not cringe. Enums have literally 0 complexity to them.

Anyone saying that string intersections are better than enums is also insane. The only possible benefit of string intersections over enums is that you don't have to import anything to use a string value. Otherwise, string intersections are way worse to maintain. Because enum usage is statically analyzable, refactoring is 100x easier with enums vs string intersections (renaming enum keys, changing enum values). You can also find references to both the enum or any of the enum values using tooling, where you have to search for usages of string intersections. This poses a problem when two different string intersections have overlapping values. Consider:

    type ColorChannels = ""red"" | ""green"" | ""blue"";
    type PrimaryColors = ""red"" | ""blue"" | ""yellow"";

It would be a lot harder to find all usages of the ColorChannels ""red"" vs the PrimaryColors ""red"" rather than if you just used an enum.

Furthermore, enums allow you to provide context to what is going on in your code. Consider the following code, and tell me which is more clear:

    // using string intersection
    createStream(connection.config, ""disabled"");
    
    // using enum
    createStream(connection.config, StreamEncryptionStrategy.Disabled);

Forget about the runtime values of enums and everything becomes a little more straightforward. Use enums as if they were collections of unique symbols with a common base type. It is not complicated.",1540473262.0
gammelini,I prefer [expired-storage](https://www.npmjs.com/package/expired-storage). There are typings available from @types. ,1540600544.0
FengShuiAvenger,"Good article, I think you could have cut down the typescript code significantly.

```typescript
interface Tree<T> { left?: Tree<T>, right?: Tree<T>, value: T }
```

Note the optional type is shorthand for `Tree<T> | undefined `, which is the more standard way to represent empty values in typescript. 

```typescript
// Construction of the tree
const tree: Tree<number> = { value: 10, left:{ value:40, right:{ value: 30}}};
// Printing
console.log(JSON.stringify(tree));
```",1540426593.0
,"nit: I'm not sure it's possible to say TypeScript has algebraic data types because of structural subtyping. The inhabitants of the type: `type F = { kind: 'A' } | { kind: 'B' } ` exceed 2, which is not the case in Haskell: `data F = A | B` (*modulo some bottom shenanigans*).

I enjoyed the article, it's always nice to have comparisons between languages which expose people to new things.

The acronym ADT is very unfortunate and not to be confused with abstract data type. It's ironic that two things that are so opposed share the same acronym!",1540401388.0
babada,Why should I change your mind?,1540257237.0
KyleG,"No. There are syntax differences, too. For example,

`const a: boolean = true;`

is impermissible syntax in JavaScript, but contains *zero new keywords*. Accordingly, TypeScript is not just JavaScript + other keywords. QED, bitch.",1540269337.0
_nebular,"In terms of syntax, it's explicitly a design goal of Typescript to introduce as little syntax as possible on top of javascript. In terms of what it accomplishes, it statically analyzes your code at compile time to make sure that the types of values you are using are what you expect. On top of removing the need to do unit tests on object structures or value types, it also provides services to make it dead simple to refactor code. If you remove a property from a type, you'll get an error at compile time showing you where this breaks things, instead of waiting for it to occur during unit tests or during runtime. If I rename a property on a type, it can automatically propagate that name change to all correctly typed uses of that property. Furthermore, it allows you to specify different targets for compilation. This makes it so that you can use many features (including syntax) introduced in newer ECMAScript versions, and the code will be transformed to work in environments which only support earlier ECMAScript versions.

&#x200B;

Side note: it's nice to see grade school children like yourself show an interest in discussing programming topics. Keep it up! Computer science is the future!",1540296880.0
kqadem,"Ok, a little bit of explanation. didn't assume you'll take it that serious, instead I expected reactions like ""wtf this is possible?""

I am actively using TS since v0.9. All of you guys don't need try teach me better. Just wanted to show that the language server still has its flaws. And in my opinion, tsserver should even warn about bullshit stuff like a property called true. ",1540297250.0
Drawman101,What am I looking at here?,1540255304.0
,"How is this different to runtypes, or io-ts, except attached via decorators? ",1540283969.0
_nebular,"You realize that the compiler already does this, right? Via the `--emitDecoratorMetadata` flag. You can achieve the same thing without using your type mappings. Just annotate your class properties appropriately and `Reflect.getMetadata` will get the type. And you can just rely on POTS to complain when you assign the wrong value instead of passing it to the annotation. Read [the docs](https://www.typescriptlang.org/docs/handbook/decorators.html#metadata) for more info.

    function editable<T = any>() {
        return function <C extends { [k in K]: T }, K extends string>(target: C, key: K)
        {
            let valueType = Reflect.getMetadata(""design:type"", target, key);
    
            console.log(""type: "", valueType );
        }
    }
    
    
    export class People
    {
        @editable() // type: String
        public name: string = 'a';
    
        @editable() // type: Date
        public birth: Date = new Date();
    
        @editable() // type: Number
        public age: number = 'a'; // error 
    
        @editable() // type: Url
        public homepage: Url = new Date();// error
    }

&#x200B;",1540319216.0
omril,"Is it useful in some way? Care to elaborate?

It doesn't seem to do run-time type-checking, or am I wrong?",1540266058.0
sittytucker,Can you fix your live demo hyperlink?,1540308284.0
mahade,"Crap like this makes me hate TS even more than I already do. That screenshot is confusing as can be. Why is it sometimes a string value for the type and sometimes a type value for a type? Why is the error underline at the type definition and not on the faulty value? The value is wrong, not the type...

(ノ°Д°）ノ︵ ʇdᴉɹɔSǝdʎ┴",1540300463.0
AngularBeginner,"You're extending `Error` wrong: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work

edit: And it always shocks me if people don't enable the strict-flags in new projects...",1540273861.0
markprobst,"That's neat!  Does it work only with `class` or also with `interface` and `type`?  Can those be mixed, i.e. have a matcher with one `class` and one `interface`, provided they share the same discriminating field?",1540243859.0
bequebed,"Think from the perspective of what a union type accepts. The set of things that can be assigned to a string | number field is the union of the set of all strings and the set of all numbers. The set of things that can be assigned to a string & number is nothing because there is no overlap in the set of all strings and the set of all numbers.

I think you're picturing it as a set operator on the fields rather than a set operator of the sets of what each type represents.",1540216619.0
21October16,"This is mathematical terminology: a ""type"" is a set of all its possible values, e.g. `boolean = {true, false};`. Now union of types T and U is a set consisting of values in T _or_ in U (i.e. T merged with U); similarly intersection of values in both `T` and `U` (i.e. common part of  them).

A member is accessible iff it's on *all* possible values. For union, value of type T|U may be T or may be U. We don't know which so only common attributes are legal. As you can see, operation on **type** implies different but complementary operation on **members**. This is a consequence of de Morgan laws.",1540216441.0
,"Starting point: a type is a set of values. So boolean is the set {true, false}, number is the set of all numbers.

The bit where people get confused is for objects. The set of values for an object type are not just those with *exactly* those properties, but any unrelated properties too. The set is defined by the behavior when accessing an object. 

For example `{x: number}`.
The values in the set of this type are those objects with an `x` field that holds a number, but note, this does not say anything about all the other fields. So `{x: 4}` is in the set, so is `{x: 5}`, but equally, so is `{x:  4, y: true}`.

When you do an intersection type you are never actually adding members to the set of values, they were there all along. What is really going on is that you are adding constraints. Example:

Type:  `{x: number}`.
A set respecting that type[1]: `{ {x:  4, y: true}, {x:  4, y: false, z: ""hello""}, {x:  4, z: false} }`.

Type:  `{y: boolean}`.
A set respecting that type[1]: `{ {x:  4, y: true}, {x:  4, y: false, z: ""hello""}, {y: false, z: true} }`.

The intersection of those sets is: `{ {x:  4, y: true}, {x:  4, y: false, z: ""hello""} }`, so we have constrained the set by making it smaller. 

[1] The sets should really enumerate all possible values.

",1540230361.0
ghillerd,i've been thinking the same thing! glad someone brought it up and we get these good explanations.,1540260425.0
theLaugher,Because they fucked up. They decided to ignore the abstraction people are trying to utilize because they write compilers not consumer software systems,1540310977.0
grauenwolf,"Explicit public says ""I was thinking about this and made a conscious decision that this is a member consumers of my class should use"".

An implicit public leaves me guessing your intention. (Which is why I think they screwed up. The default should have been private.)",1540189071.0
cspotcode,"What's the downside to always being explicit?  If I had a linter reminding me to be explicit, I wouldn't give a crap one way or the other.  I'd add the keyword and call it a day.  No complaints from me.",1540243120.0
hallettj,"Fantastic, now I'm looking forward to the next release!",1540145665.0
Roci89,I guess this means the react scripts ts package is going to be made obsolete soon,1540163597.0
n1arash,"YESSSSS FINALLY

&#x200B;",1540157860.0
MrSpontaneous,"What are people's opinions on CRA? I find that these generators tend to introduce bloat and fragility to the configuration, to the point where adding a plugin/dependency that's not supported out of the box is painful.  Is it fairly innocuous?",1540163488.0
Peter_Storm,Awesome!,1540153775.0
TG__,Can i get my hands on this now somehow?,1540160957.0
skrawg,"Hey /u/joshribakoff , thanks for creating these videos! Would be really interesting to see more advanced Typescript tutorials in the same vein 👍",1540171387.0
sittytucker,"/u/joshribakoff 

Thanks for making this video.

I would suggest a correction. Around 50 second mark: https://youtu.be/hoACSjXP3_U?t=50
 you said ""And that is considered by Typescript"".

This is in incorrect statement to say because `const pp` never had type guidance at that point. Either should should have typed `const pp: IFood` or `const pp = {} as IFood`.

Just my 2 cents.

I encourage you to make more such videos. Advanced would be better, as I think there is a void there. There are not enough videos that does advanced TS. And this is a good opportunity.",1540178191.0
EarlMarshal,Why does it have to be a video? Just give me a source code file,1540142217.0
Alokir,"We mostly found a lot of unused code that were left in the application and even maintained when related changes were requested.

&#x200B;

Also, there were a lot of places that nobody wanted to touch because it was too complex (poorly written). Now we could easily refactor it and make it much easier to read.",1540109076.0
xyrue,"We didn't really count but one of the other teams I work with found so many errors that they had to cancel moving to TS.  
For us it was a few, but some of them were pretty big.",1540108293.0
geon,"When updating a project with a couple of new features, I made sure to port the parts I imported to ts, so that I could write all new code properly typed. 

I ported perhaps a couple thousand lines of code. Mostly I created interfaces for the objects being passed around, and added these to the function signatures. 

I found perhaps 20 trivial bugs, where extra parameters were sent to functions not using them, or functions expected more parameters than they were given, variables were defined and painstakingly calculated, but never used. 

But more importantly, I found messy code where the same object was passed around and used both for input and for storing results and had multiple purposes. 

And because I could no longer call functions with undefined arguments, I found out that a large area of the project was simply broken. It didn’t have the (nonsensical) feature some users were relying on it to have (extrapolation of physical measurements). ",1540112250.0
brtt3000,"Nothing fundamentally broken (or otherwise the JS version would not have worked) but plenty of silly stuff that kinda slips through or works because JS weirdness. Undefined values, missing parameters, extra parameter,  missing return values in branches, mixed return types and that sort of thing.

Also TS helped to reduce ""clever"" JS constructions that confuse both people and the type checker.",1540112599.0
Ebuall,"The bugs are removed not by migrating to type system, but by using this type system to **make illegal states unrepresentable**.",1540122100.0
tamalm,Code has become a lot cleaner. Using TS in backend for 8 months. ,1540131135.0
hackflip,"Lots of missing null guards, lots of dead code, and lots of unused variables.",1540137534.0
fernap3,"I did a conversion project like this a few years ago with a codebase on the order of 250 JavaScript source files.  This took about a week of me working outside of the office at night to add type annotations and access modifiers, convert to some newer syntax (fat arrow functions, etc.), and fix errors.  At the end of the day at least a handful of bugs were found, but the real upside is still being paid out in that we are now developing our user interface using TypeScript, not JavaScript. :)  When dealing with a large codebase, I want the develop/build/test loop to be tight, and having to dig around source files to understand what properties are available on a given object (this was before Flow became popular) sucks.

&#x200B;

TLDR; I'm sure we found some bugs at the time but it's more important that TypeScript is helping us prevent new ones (and speeding up development) now.",1540237171.0
evmar,"Counterintuitively, this is the wrong metric to consider.  If you have an application already, you've worked most of the bugs out by testing (automated and manual), so a type checker is unlikely to find many more.  The real value of a type system is in new code, which you can write more quickly because you discover the new bugs as you write them.",1540105029.0
ThisAccountIs4Reddit,6 man-months worth,1540129219.0
scaleable,"Not many bugs, but a lot of room for refactors that would clean up the code or make it easier to understand. Things like the same data structure represented in many different ways, weird function inputs...

Imho in order to actually leverage all of typescript you have to change a bit your coding style, with things like avoiding mutability etcetera. It may take months or years. A newcomer may not immediately see benefit bc he will still try to code in his old way, or even get annoyed by the incurred overhead.

I can state that all recent code I write with typescript has really few runtime iterations. The code mostly works on the 1st run, and eventual fixes are conceptual instead of typos.",1540210383.0
davidmdm,I've been working in typescript for 4 months now. Everyday I long for pure js. ,1540128208.0
rob_mat,Great!,1540240502.0
hayden592,I’m not sure the exact implementation but your on the right path. A while ago I was looking to write a tsc plugin the converted js to typescript. The main purpose was to help with an angularjs to Angular conversion. I ended up with a solution the leverages eslint rules and wish I had go with a compiler plugin,1539991722.0
evmar,"TypeScript transformer run after type checking, so they can only modify the output of TypeScript, but not what your editor sees.",1540002711.0
cspotcode,You can't plug into or modify TypeScript's typechecking behavior.  So I don't think this will be possible.,1540007545.0
shaberman,"Not sure if its helpful, but https://github.com/cevek/ttypescript/blob/master/README.md is my bookmark for ""some nontrivial complier plugins to learn from"".

Your project sounds cool, would love to see it if you get it all working.",1540054531.0
prozacgod,"I was wanting to do something similar to a project I was working on!! (in JS)

I thought... ""what I really want is a dom model for my ast"", so I was converting the JS to XML and running it through this.

    parser = new DOMParser();
    xmlDoc = parser.parseFromString(text,""text/xml"");

I only did a few of the ast objects as a test, and never finished the tooling...

My plan was to use it to be able to filter code in a dynamic way, to add prefixed/instrumented code readily.

In any event, I could easily just construct the dom nodes directly, but js -> ast -> xml -> parser -> xmlDom -> js  was... adequate... for fiddling.


EDIT: what you really want it ""querySelectorAll"" and ""getElementsByTagName"" - which is what lead me down the above path, I was like ... ""why re-implement those things?""
",1540402572.0
bersimoes,"I never really dig into why, but ng update never works on both the projects I’m working on ( ng cli and nx )

I always go for yarn upgrade-interactive —latest ",1539948579.0
alfredmuffin,Or just switch to React ,1539965260.0
PoshyCool,"Why the Babel dependency when tsc already transpiles all the way down to es3?
",1539907633.0
r0ck0,"What does it do?

Maybe sounds like stupid question to some, but I've only started programming typescript and js/node backend this year.  Coming from the PHP world where a lot of this kind of stuff doesn't exist as much.

One thing I've noticed with a lot of NPM packages and JS libraries in general, is that the description of what they do can be a bit sparse, and often assumes you know some terminology.

Might be helpful to explain what it does on the README.md?  And maybe what makes it different from other things that might sound similar?

",1539943386.0
gamebuster,What does it do? There is no description what problem it solves and how it solves it.,1539984733.0
bertilxi,Readme improved!,1540043354.0
alanjhonnes,"You can use a simple generic type guard that checks for null and undefined:

    function throwsIfNullOrUndefined<T = any>(value: T | null | undefined): value is T {
        if (value === null || value === undefined) {
            throw new Error(""value is not defined"");
        }
        return true;
    }
    
    function someFunction(someParam: number | null | undefined) {
        if(!throwsIfNullOrUndefined(someParam) {
            return;
        }
        someParam // number
    }",1539882351.0
bequebed,"It isn't perfect, but you can make the first one work with an exclamation mark after foo on the return statement. However, that is not optimal if you are referencing foo many times after the assert.

To really get what you're going after TypeScript would need to be upgraded with a way to type exception cases. But it cannot do this yet.

    function assert(value: any): throwsif value is undefined | null {
      // ...
    }",1539883969.0
theiades,"I don't know if there's a way to make the first case run well, but you could do something like this:  

```ts
import assert from ""assert""

function throwsError(_foo: number | null): number {
    const foo = myAssert(_foo)
    return foo + 3 // foo is a number
}

function myAssert<T>(foo: T | null): T {
    assert(foo)
    return foo as T
}
```",1539884153.0
,"No there isn't a way to do this. If you want to track the issue that proposes your behaviour see [here](https://github.com/Microsoft/TypeScript/issues/8655).

The best alternatives are to the one you propose, or the definite assignment assertion `!`.",1539910695.0
cspotcode,"I sometimes make the type guard return the input value instead of returning a boolean.  Then I save the returned value in a variable.  It's not quite the same but it achieves the desired effect.  This was inspired by the `never` type which can indicate that a function never returns. (it throws an exception). I realized that if the function *did* return, it's because it didn't throw, because the type guard succeeded.",1539952854.0
joshribakoff,"Your example works fine, you are confusing **compile time** with **runtime** (I think).

&#x200B;

The real issue is that you are confusing **static \[compile time\]** analysis with **runtime** behavior.

&#x200B;

assert() is a runtime check, meaning the code will be executed by NodeJS on the server(s) in production, when the code is executed. TS is a static analysis, meaning it will look at the local code in your editor/terminal process and will reason about the constraints the typings impose, without executing the code.

&#x200B;

All the types are stripped away at runtime, so there is a case to be made for both static type safety as well as runtime checks. A few reasons typings may not be enough are if you have devs calling your library from plain JS, or if they pass the ""any"" type which satisfies type ""number"", but will only crash at runtime.

&#x200B;

If you may have devs calling your code at runtime with bad values due to devs using JS, or devs using the ""any"" type in TS, then you need more than type safety such as runtime assertions & unit tests.

&#x200B;

Edit - To all those suggesting type changes, with all due respect, I think are missing the point (although you have to read between the lines to see what the real confusion is here, so its easy to answer the wrong question with the correct answer)

&#x200B;

On another note, you can use the ""never"" type. If any code paths are reachable that return a ""never"" type, and the return type is not ""never"", TS will consider this a type error since your function has a return type of ""number"" which is not satisfiable by ""never"". So you can have both static type errors & runtime errors for this if you want.",1540259699.0
AngularBeginner,Write yourself a custom type-guard and use that.,1539878205.0
kredditacc96,"You can use `in` operator

```typescript
type UserRequest = 
    { foo: string, bar: number } | 
    { baz: number }

declare const request: UserRequest

if ('foo' in request) {
    request.foo
    request.bar
}

if ('baz' in request) {
    request.baz
}
```

[playground](https://www.typescriptlang.org/play/#src=type%20UserRequest%20%3D%20%0D%0A%20%20%20%20%7B%20foo%3A%20string%2C%20bar%3A%20number%20%7D%20%7C%20%0D%0A%20%20%20%20%7B%20baz%3A%20number%20%7D%0D%0A%0D%0Adeclare%20const%20request%3A%20UserRequest%0D%0A%0D%0Aif%20('foo'%20in%20request)%20%7B%0D%0A%20%20%20%20request.foo%0D%0A%20%20%20%20request.bar%0D%0A%7D%0D%0A%0D%0Aif%20('baz'%20in%20request)%20%7B%0D%0A%20%20%20%20request.baz%0D%0A%7D)",1539879493.0
rftz,"If you're already using io-ts just use that to define runtime types:

    const FooRequest = t.interface({
        foo: t.string,
        bar: t.number
    });
    const BazRequest = t.interface({
        baz: t.number
    });
    const UserRequest = t.union([FooRequest, BazRequest]);
    type UserRequest = typeof UserRequest._A;
    // now available as a compile-time type too

    class MyController {
         ...
        @Get('/api/v1/test')
        handleRequest(@FromJsonBody() request: UserRequest) {
            if (FooRequest.is(request)) {
                // Handle request using strategy 1, will be strongly typed. 
            } else if (BazRequest.is(request)) {
                // Handle request using strategy 2, will be strongly typed. 
            } else {
                throw new Error('invalid request');
            }
        }
    }

Although it'd be safer to make the signature more like `handleRequest(@FromJsonBody() request: t.mixed)` because you don't want to assume that you're always being sent valid data. ",1540045386.0
monkey-go-code,"Learn html canvas and make a game.
Here is a Tetris game I made in Type script 

https://camccar.github.io/tetris/

And the source 

https://github.com/camccar/tetris
",1539876762.0
BehindTheMath,"https://github.com/getify/You-Dont-Know-JS

It's not TS specifically, but TS is a superset of JS, so everything you learn about JS will help for TS.

https://basarat.gitbooks.io/typescript/",1539875493.0
_Aardvark,The stuff in [here](https://www.typescriptlang.org/docs/handbook/advanced-types.html) is where TS gets really interesting. How much do you know about templates?,1539877660.0
,What are environment diagrams?,1539877592.0
abelincolncodes,"Start learning all of the cool, [advanced](https://www.typescriptlang.org/docs/handbook/advanced-types.html) things you can do with a strong type system. 

Things like literal types, [discriminated unions](https://basarat.gitbooks.io/typescript/content/docs/types/discriminated-unions.html), type guards, [phantom types](https://medium.com/@gcanti/phantom-types-with-flow-828aff73232b), and [mapped types](https://blog.mariusschulz.com/2017/01/20/typescript-2-1-mapped-types) can greatly reduce the errors that are representable in your program. Plus doing type-level programming is fun",1539907042.0
moremattymattmatt,You could have a look on the Typescript track of [https://exercism.io/](https://exercism.io/). ,1539883900.0
Bamboo_the_plant,"Try to properly type a React app with Redux

And god help you on this journey",1539902759.0
andersjoh,Haha 😂 but you can't actually play the music.,1539876647.0
ritajalilip,You do know you're gonna get sued by Blizzard?,1539877060.0
geon,"> delayedIncrement(new ObjectValue(person, ""score""))

Should be `delayedIncrement(new ObjectValue(person, ""name""))` ?",1539865388.0
geon,"The first version works if you disable type checking inside `delayedIncrement`. Which could be acceptable, since it is so small.

    type NumberPropertyNames<T> = { [K in keyof T]: T[K] extends number ? K : never }[keyof T];
    
    function delayedIncrement<TObject, TKey extends NumberPropertyNames<TObject>>(object: TObject, key: TKey) {
    	const oldValue: any = object[key];
    	setTimeout(() => object[key] = oldValue + 1);
    }",1539868741.0
dexie_,"That's a really specific use-case with a specific solution, good job!

&#x200B;

&#x200B;",1539870351.0
AngularBeginner,"To format code properly on Reddit:

- Have an empty line between text and code.
- Indent every line of code by 4 spaces.",1539875364.0
spacejack2114,"Not sure if this is exactly what you want but if you have a `types/my-global.d.ts` with:

    declare global {
        const myGlobal: MyGlobal
    }

Then you can use it in a .ts file:

    /// <reference path=""types/my-global.d.ts"" />

    const a = myGlobal.whatever()
",1539738262.0
cspotcode,Perhaps avoid the import statement and use the new `import()` type syntax.  `type Foo = import('foo').Foo`,1539739831.0
flyingwigs2,+1 for option 1. My team is currently using this method in production to feature detect window.MSInputMethodContext which is only ever defined on the window object by IE11. ,1539718024.0
empty_other,"If someone else defines global.Window.data as a string somewhere else in the code later, they will not get an error in your second example. In the first example they should get an ""property declarations must have the same type"" error (if i remember correctly).",1539704466.0
TYB069,"Option 1, just as mentioned here https://twitter.com/WrocTypeScript/status/1048280618419834880.

1. It describes your actual environment correctly (doesn't hide anything that's actually there).
2. Once `Window` is augmented, your update will be available everywhere without having to drag your custom `WindowWithData` interface everywhere.
3. You get to avoid the type cast.",1539717548.0
JJWesterkamp,"As far as I know you can just use the `const` keyword in a `declare global` block combined with a type constraint for the identifier:

```typescript
declare global {
    const data: {
        foo: string;
    };
}
```

I would suspect that adding to the global declaration of the `Window` interface also applies that to other windows besides your window. For example all iframe elements also have their own window object.",1539902146.0
BehindTheMath,"I'm on mobile, but IINM, class methods aren't bound to the class. You have to use a property assignment and an arrow function: `private runBinOpsExpression = () => {}`. ",1539663720.0
gamebuster,"Without a runnable example, stacktrace nor error, I can only guess what the issue is and where it might go wrong.

What about `this.classMethod`; the first argument when you're invoking `this.readBinOpExpression`? Shouldn't that be `() => this.classMethod()` or `this.classMethod.bind(this)`?

The `this` in a function is determined based on how the function is called. By calling the function unbound (IE `foo()` rather than `this.foo()`), `this` becomes `undefined`. This is a Javascript-behavior and not exclusive to Typescript.",1539676260.0
Charles_Stover,You can also have different return types for the overloaded methods.,1539648520.0
gamebuster,I was wondering how I could do that. Thanks. ,1539619054.0
drdrero,sick topic,1539617434.0
,"> But what if we wanted to express arg? using only types, and not specific syntax? 

Are you not just moving the solution from a syntactic solution that uses `?` to one that uses `..args`.

Though, it is quite a cool solution.",1539624970.0
madcaesar,"Honestly, and this is just my opinion, this is where I check out from Typescript. Once I need to write a book for the next guy looking at my code to understand what is happening, Typescript has lost its usefulness. Put an **any** on it and move on.

I love typescript for 90% of usecases, but it simply isn't mature / advanced enough for complex cases like this, and honestly just reading this article gave me a headache and would cause me to waste an hour trying to fuck with it instead of writing code.

I've had to adopt the same attitude for certain mobx parts and higher order components.

Someday TS will hopefully be good enough where it just works for cases like this as well. It's already made huge strides.",1539659938.0
gamebuster,Using JS docs for type-checking? Yeah why not,1539594142.0
villiger2,😱,1539604296.0
DanielPerezAlvarez,what keyboard is that ?,1539668660.0
Poltras,"You’d need proper typing for the arguments, which cannot be done. It’s not just any if you want to stay type safe. 

I haven’t checked 3.1 too deeply but I think you still cannot variadically infer all the argument types on a function of a generic type. I might be wrong though. 

If you throw typing out the window the constructor type kind of lose its usefulness. Just declare a specialized interface for it instead. ",1539569092.0
snowthunder2018,"I started with small projects.  It's about learning to use the tool more than benefiting from the tool in the beginning. You have to know it reasonably well to understand the best ways to use it in your projects.

After a few small projects I started grabbing JS libraries that I wanted to use that didn't have typescript definitions and I would fork them and make typescript versions of them.  Learned a ton from doing that. ",1539628665.0
SlocketRoth,why do you think the projects are too small to benifit from typescript?,1539558395.0
Jodacola,"1. Prior to jumping on the TypeScript train, I did a lot of web-based projects using regular ol' JavaScript and jQuery.  In my early days, I felt oh-so-powerful in my ability to manipulate and animate DOM objects, but even in my naïveté many years ago, I recognized it was pretty challenging to keep the code in my projects even remotely sane or clean, and refactoring anything was generally a nightmare.  When TS started gaining momentum, I immediately got interested, mostly because my professional background is in C#, and I have a very strong appreciation for strongly-typed languages.  Coupled with the direction of ECMAScript, I finally felt like I could fully flex my C/C++/C# skill in a way that translated quite nicely to clean, maintainable JS (via compilation).
2. Any side projects I could suggest are side projects I'd personally want to do or am doing.  What kind of side projects do *you* want to do?  Do you want to do things that will run in a browser, or build Node applications?  If you want to get more experience with TS, don't about whether TS is going to be a good fit for one of your projects; just force yourself to use it, if you could use JS for it.  Even for really small projects these days, I opt for TS over plain JS, just because I have my workflow down such that the set-up process isn't particularly painful for me.

There are a lot of tutorials and resources online that will give you a little bit of practical experience.  Are you already a JS developer, to some degree?  Do you have any small JS libraries you use that are open source that you could attempt to port over to TS in a much more strongly-typed manner?  Lots of stuff out there.

You note in one of your other comments that you don't believe these small projects are worth the extra overhead.  Do you never expect your projects to grow to a point where something might need to be refactored?  Or, where you don't have method signatures all memorized?  TS, even in small projects, is a great way to build a strong foundation for anything you might want to grow in the future.  Also, you're concerned about overhead... in what sense?  Development speed?  If you're just looking to learn the language, overhead shouldn't be a concern.",1539565700.0
victorz,"As a side note to this question, I found it really helpful to have learned Go (golang) before I started TypeScript. It really helped with the type specifier order.",1539643634.0
Capaj,"I hate that with nodemon I always get zombie processes running in the background and I have to manually kill them quite often.
I use https://www.npmjs.com/package/ts-node-dev which works much faster and you never get any zombies which is nice.",1539522744.0
Dw0,We run locally with ts-node,1539535634.0
smthamazing,"I usually compile to regular JS. Most of my apps are complicated and include things like server-side rendering, so I mostly use webpack to minify and package both back-end and front-end code.",1539529013.0
dvlsg,"I use `ts-node` locally, but I usually make sure CI is running tests with the compiled version.",1539549250.0
EarlMarshal,"I used to do the \`concurrently\` thing but with \`live-server\` instead of \`nodemon\`.  


I think it doesn't matter which of both you are doing but with the \`concurrently\` version you probably have a easier way to replace the server-tool or even your compilation/transpilation-tools (e.g. switch to webpack). ",1539551642.0
scaleable,"I usually just compile to js, setting a watch on VSCode

I'd just trade that simplicity to something like a full webpack HMR thing which would replace modules whitout restarting the whole server (some projects have slow restarts)

Also, the ease of using the debugger (instead of relying on console.logs) is a big plus for staying simple.",1539560594.0
crabmusket,"I'm using a variant of 2, in a Docker container using `npm-run-all`.",1539570051.0
coolcosmos,ts-node ftw,1539891903.0
ebrithil30,"Hi, sadly, tslint do not support rules written in typescript.
All you have to do is to compile your rule and use the .js file",1539472042.0
pancomputationalist,"I feel classes don't bring much to the table except for familiarity for the OOP crowd. You have to work around the quirks of `this` and it's very easy to fall in the trap of tighter coupling than required, since it's a bit more difficult to extract code out into simple functions once everything is cluttered with `this`.
I like to use closures instead. Compose everything with small functions. Build bigger code blocks like a repository into a closure function that returns the public api of the block/module, which can then easily be swapped out for a different function during testing (dependencies are passed as function arguments, just like constructor injection).

The only upside that classes have for me is metaprogramming with decorators, which can unfortunately only be attached to classes and class properties. Other than that, I try to stay away from classes as much as possible. ",1539422422.0
rajajaganathan,Hope this article will helpful. Note nothing specific to typescript. https://blog.kentcdodds.com/classes-complexity-and-functional-programming-a8dd86903747,1539579733.0
cspotcode,"Errors are always of type `any`.  I'm almost positive this is because of how they propagate up the call stack.  When you catch an error, where did it come from?  It could have been thrown a dozen levels down the call stack in code you don't understand.  How would you account for all those possibilities?  Would you annotate every possible function with every possible exception it -- or code that it calls indirectly -- might throw?  Once you start thinking about how the language might deal with types for thrown values, it becomes clear that would be a nightmare.  Promise rejections are just like thrown values, as is made clear by native `async`/`await` syntax.  So that's why caught values and rejection values are of type `any`.

If a promise *might* resolve then the resolution type should not include `never`.  Because there's no way to get access to a `never` value. If that code path is ever executed, it means the promise resolved, meaning the value is not `never`.",1539347442.0
Rollingdownhills,"I have found that using reject to send anything that isn't an Error makes the code hard to follow and maintain. If you want to ""resolve with fallback"" I would just do that. For example when trying to get a list of comments on a post instead of rejecting with an empty array I like to resolve with an empty array but if the post ID is invalid it perhaps is more relevant to reject with an Error to be handled.",1539350196.0
AngularBeginner,"You already got many great answers to your question, so I want to add a suggestion that is not directly answering your question.

You should at least consider following a more functional approach by simply not every throwing an error or rejecting a promise (and wrap existing libraries). Instead you would use something like a `Result<TData, TError>` or `Either<A, B>` structure and make use of [""Railway Oriented Programming""](https://fsharpforfunandprofit.com/rop/) (link has examples in F#).

The basic premise is:

- You have a `Success<TData>` and `Failure<TError>` structures.
- You have a union-type `Result<TData, TError>` which is either `Success<TData>` or `Failure<Terror>`.
- If your method successfully completes you return the `Success<TData>` object.
- If your method has an error you return the `Failure<TData>` object. Don't throw an error.
- You write and use a special `map` function, which takes a `Result<,>` object as first argument and a callback accepting the `Success<>` object as first argument. That map function will then check if your `Result<,>` is a `Success<>` instance and call the callback, or if the `Result<,>` is a `Failure<>` it will simply re-return that failure object.
- Lastly you have an `onError` function that will accept the `Result<,>` and a callback accepting a `Failure<>` argument. It will check if the object is a failure and only then call the callback.

I like this pattern more because it clearly shows in your API what error could be returned from your function, instead of having magical `throw`s somewhere deep inside the function callstack. It will also force the developer to recognize and care about the possible error case, because otherwise you can't access the value stored in the `Success<>` type.

There are already various implementations of this pattern out there. Depending on the implementation it could look something like this pseudo-code:

    function getUser(userName: string): Result<User, UserNotFoundError> { ... }
    function deleteUser(user: User): Result<undefined, MissingAccessRightsError> { ... }
    
    const userNameToDelete: string = 'admin';
    getUser(userNameToDelete)
        .map((user: User) => deleteUser(user))
        .map((_: undefined) => { console.log('User deleted successfully.'); })
        .onError((error: UserNotFoundError | MissingAccessRightsError) => {
            if (error instanceof UserNotFoundError) {
                console.log('The user could not be found.');
            } else if (error instanceof MissingAccessRightsError) {
                console.log('You are missing the required rights to delete users.');
            } else {
                // Unknown error, what to do?
            }
        });",1539603575.0
pyt1m,"T is merely the type of the argument passed to the resolve callback. Meaning the signature of .then is then(onResolve: (value: T) => void, onReject: (error: any) => void). It does by no means dictate the type of the argument passed to the reject callback.",1539377590.0
scaleable,"Errors are not type-safe in typescript.

Clarification:

When you throw an error (try/catch), the error that comes in the catch clause is never inferred, it is always an any unless you specify it.

    interface Promise<T> {
        then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;

        catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    }

In the same fashion the promise class only has 1 argument relative to the success case. When you write a `.then` or a `.catch`, those methods have ""symbolical"" type arguments which allow you to hint an error type, but in the end you'd always have to either annotate the error outcome (or assume any), in the same way you'd do in a try/catch clause.",1539410263.0
longfld,Why don't you use rxjs?,1539347954.0
tristan957,Never heard any complaints. What does this buy you over tsc? How did you write a compiler if MS hasn't updated the TS spec in a while,1539321462.0
thefilmore,"I made this out of sheer frustration with `tsc`. It has four main benefits:

- Simple CLI using standard conventions
- Configurable warnings/errors
- Predictable output
- Automatic/custom relative import path mapping

Needs some testing so please try it out and let me know how it goes.",1539310039.0
Ameobea,This looks really nice!,1539329670.0
davidmdm,you can just use request-promise or request-promise-native... then you can just await the results...,1539308945.0
spacejack2114,How about [node-fetch](https://www.npmjs.com/package/node-fetch)? It works like the browser fetch.,1539312753.0
STRiDEX,got https://github.com/sindresorhus/got with @types/got,1539317544.0
MostKaleidoscoped,"I'd recommend using [fetch](https://developer.mozilla.org/es/docs/Web/API/Fetch_API) directly. 

It's a standard, you can use it across both browsers and node (with https://www.npmjs.com/package/node-fetch) and you can even write code once with fetch that will works in node _and_ browsers at the same time, with libraries like https://github.com/matthew-andrews/isomorphic-fetch.

It's also promisified all the way through already. You can get promisified versions of other tools, but using an API designed around promises from the start often works better.

It also sets you up better for the future - there's lots more development ongoing for fetch (e.g. streaming, cancellable requests, etc etc) and as a standard it's definitely not going away any time soon.",1539342391.0
maninas,"Yes. It's called [r2] (https://github.com/mikeal/r2) and it's built by the same guy, with all the hindsight he has collected.",1539434218.0
gamebuster,"`request-promise` and `request-promise-native`.

But I just use `node-fetch`.",1539594184.0
Useless-Pickles,"Here's a nice counterpoint to this article, which is some of what I was trying to communicate throughout my other various comments here, but this article does a much better job than me.  


[https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578](https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578)",1539292527.0
bboydflo,"thanks for this article, but why is it in the under typescript thread? I do agree with other people here that a demo showing performance measurements would have been useful.",1539763606.0
Useless-Pickles,"My 2 thoughts on this:

1. Where's the measurements to show how much performance is improved? Is this premature optimization?
2. This can cause incorrect behavior if the function you pass down references any props/state of the outer component. (edit: I explained the rest of this extremely wrong/poorly, see [this comment](https://www.reddit.com/r/typescript/comments/9nc5ba/cache_your_react_event_listeners_to_improve/e7lb5h3/) for clarification), In this case, you WANT a new function to be passed down, because the implementation of the function implicitly changes when those props/state change. If there are no other changed props to the inner component, and your function is ""cached"", (and you have setup the component to skip rendering if props are detected to not be changed), then the inner component will incorrectly use stale data when executing that function.

For these 2 reasons, I keep it simple and generally pass arrow functions down as callback/event-handler props. I prefer simplicity, maintainability, and guaranteed correct behavior. If I ever encounter a performance issue and trace it down to a situation that could be improved by caching functions, then I will implement caching on a case-by-case basis (only after proving with measurements that it improves performance significantly), and clearly document that/why I am caching the functions.

Also note that the default behavior of react components is that the render function is always called (probably more times than you expect), even if the values of the props have not changed. You have to put additional effort into setting up a component to skip execution of the render() function if values of props have not changed. So this advice to cache functions does not event prevent ""wasted"" executions of render() in most common cases. It only skips the overhead of creating a new bound function or arrow function.",1539282841.0
,"This has nothing to do with abstract classes. Method parameters are still bivariant so this type checks: see [here](https://github.com/Microsoft/TypeScript/issues/19007#issuecomment-334942048)

The typechecker considers it ok for the parameter in the parent to be less specific than the inheriting child, even though it is unsound.

It's by design because the sound alternative would be a significant inconvenience for array interfaces.",1539268600.0
demoran,"I'd say report it.

An abstract class defines a contact, and that contract is not adhered to by the derived class.

The use case you've provided is a good example of why it's a problem.",1539263061.0
gamebuster,What if you enable strict Null checks? In your tsconfig,1539297471.0
sidi9,Oh man I wish it wasn't so short notice. I'm vegetarian too. Good luck finding a great teacher :),1539268041.0
recursive,"I know more than a few languages, but I don't know any that let you include constructor signatures in an interface.  Could you give an example of how you'd use this?  An object conforming to an interface doesn't really give you a foothold with which to invoke a constructor.  

Edit: It is possible to create a constructor interface like this.

    interface IEzCrudServiceConstructor extends Function {
         new(app: DeApp, resourceUri: string, queryParams: { [key: string]: string; }): IEzCrudService;
    }

Although I'm not sure if that's what you want, because I don't totally understand what you want.  An object satisfying an interface is not its constructor.  So the ""value"" of the object, is not the value of the constructor.  It doesn't really make sense to make in interface that covers object values, and also a way to construct them.",1539207819.0
cspotcode,"    interface FooCtor {
        new (arg1: string, arg2: boolean): Foo;
    }",1539227352.0
gymell,"If I understand what you're trying to do, you could use an abstract class instead of an interface. ",1539217572.0
alsiola,"I use it a lot for typing the result of database queries where there is a relationId stored in an entity, that may or may not be populated.

For example, if we have a Person entity and a Dog entity. Each person has a dog, and this is represented by a ""dog"" property on the person. However, when it is returned from the database, the dog property may be a string (the dogs id, if not joined/populated), or a dog object (if joined/populated).

If we take a first go at typing this, we might get:

        interface Person {
          id: string;
          dog: string | Dog;
        }
        
        interface Dog {
          id: string;
          name: string;
        }

Now we query all people joined with their dogs, and try and find a person who has a dog called Fido:

    const people = getPeopleWithDogs(); // implementation unimportant
    
    const fidosOwner = people.find(person => person.dog.name === ""Fido"");

What do we get? A compiler error, along the lines of ""Property 'name' does not exist on type 'string'"".  This is because the compiler has been told that person.dog may be a string.  What we need is a way to assert that, in this case, person.dog is not a string, but a Dog.

The simple fix is an inline type assertion:

    const people = getPeopleWithDogs(); // implementation unimportant
    
    const fidosOwner = people.find(person => (person.dog as Dog).name === ""Fido"");

This is fine, it compiles and it works. However, it is error-prone, and you will need to make this same assertion in every single place you use person.dog. Combine this with having multiple interfaces and you have a lot of manual type assertion to do.

There is another way.

Let's define a MaybePopulated type alias, that represents a property that may or may not be populated:

    type MaybePopulate<TUnpopulated, TPopulated> = TUnpopulated | TPopulated;

Pretty simple. and we can now update our Person interface to use it:

        interface Person {
          id: string;
          dog: MaybePopulated<string, Dog>;
        }

With conditional types, we can now create types that will cast all MaybePopulated properties into either their populated or unpopulated form (other properties that aren't MaybePopulated we will just leave as they are - that's what T[K] is doing)

    type Populated<T> = {
      [K in keyof T]: T extends MaybePopulated<infer TUnpopulated, infer TPopulated> ? TPopulated : T[K];
    }

    type Unpopulated<T> = {
      [K in keyof T]: T extends MaybePopulated<infer TUnpopulated, infer TPopulated> ? TUnpopulated : T[K];
    }

We can now use these types in our code from above, to find Fido's owner:

    const people: Array<Populated<Person>> = getPeopleWithDogs(); // implementation unimportant
    
    const fidosOwner = people.find(person => person.dog.name === ""Fido"");

This compiles and requires just a single type assertion, on the original people array.  Of course you should get your getPeopleWithDogs method to return a value which is already typed this way, so no type assertion is required at all in the above code.

We can extend our Populated type with more conditionality to only mark specified properties as Populated.  For example, imagine we have added a Cat property to our Person:

        interface Person {
          id: string;
          dog: MaybePopulated<string, Dog>;
          cat: MaybePopulated<string, Cat>;
        }

If now we only populate Dog, but not Cat, we don't want them both typed as the populated version. We can add a second type parameter to Populated to specify which keys are populated.  The following is essentially an AND condition - if the property key is in PopulateKeys AND the property type extends MaybePopulated, only then change the type to the populated variant.

    type Populated<T, PopulateKeys extends keyof T> = {
      [K in keyof T]: K extends PopulateKeys ? 
        T extends MaybePopulated<infer TUnpopulated, infer TPopulated> ?
          TPopulated :
          T[K] : 
        T[K];
    }

Our code would now look like this:

    const people: Array<Populated<Person, ""dog"">> = getPeopleWithDogs(); // implementation unimportant
    
    const fidosOwner = people.find(person => person.dog.name === ""Fido""); // this is fine

    const kitneySpearsOwner = people.find(person => person.cat.name === ""Kittney Spears""); // This does not compile - we have caught a genuine error with the compiler. :)

I have written about a generalisation of this method recently - [Cast types](http://developingthoughts.co.uk/typescript-recursive-conditional-types/) - you might find this useful.",1539192819.0
freebit,"I think it will most often be used to write declaration files for pre-existing libraries. They can get quite hairy. In fact, most of the fancy typing features in TS that are beyond the most basic of ideas are just for this purpose.

I cannot imagine any design where a variable could hold an instance of either a Dog or a string as being a good one. At least I wouldn't write code like that. 

Dog|null sure, it happens. 

Dog|string omgwtfbbq.
",1539199340.0
kwiwksh,"I rarely use them directly in application code, but they are useful when constructing libraries and utilities. 

For example, here is a type ""utility"" to get the Props of a React Component, whether SFC or class component.
```ts
type GetReactProps<T extends React.Component<any, any> | Function> = T extends React.Component<infer P1, any>
    ? P1 : T extends (props: infer P2) => JSX.Element ? P2 : never;
```

",1539191822.0
turkish_gold,"    async function setup() {
    .....
    }
    type IConfig = ReturnType<typeof setup> extends Promise<infer Value> ? Value : never;
    

Getting the inferred return type of an async function (in this case, it returns a configuration object), and using that as a real type.

It saved on having to figure out what the types of everything returned by the code was.",1539221986.0
Drake250,"I've found conditional types to be extremely useful in ensuring that my pure functions remain pure with truly immutable types:


    export type Primitive = undefined | null | boolean | string | number | Function;

    export type Immutable<T> = T extends Primitive
        ? T
        : T extends Array<infer U>
            ? ImmutableArray<U>
            : T extends Map<infer K, infer V>
                ? ImmutableMap<K, V>
                : T extends object
                    ? ImmutableObject<T>
                    : T; // Should only be unknown

    export interface ImmutableArray<T> extends ReadonlyArray<
        Immutable<T>
    > {}

    export interface ImmutableMap<K, V> extends ReadonlyMap<
        Immutable<K>,
        Immutable<V>
    > {}

    export type ImmutableObject<T> = {
        readonly [K in keyof T]: Immutable<T[K]>;
    };

This is nice because you can have something like this:

    type DeepObject = { foo: { bar: { baz: string | string[] } } }

    function pure(obj: Immutable<DeepObject>) {
        obj.foo.bar.baz = ""str""; // TS error!

        if (Array.isArray(obj.foo.bar.baz)) {
            obj.foo.bar.baz.push(""str""); // Also a TS error!
        }
    }

I've started using this pattern in most of my TypeScript projects instead of `Readonly<T>`, which does not deeply recurse into types.",1539275165.0
cloudify,"I find them very useful for extracting generic types, for instance, to get the type for the props of a React component:

    import { Component, ComponentType, StatelessComponent } from ""react"";
    
    export type ComponentProps<C> = C extends StatelessComponent<infer P1>
      ? P1
      : C extends Component<infer P2>
        ? P2
        : C extends ComponentType<infer P3> ? P3 : never;

This is very useful when creating component wrappers.

Another useful use case is for [extracting the type of navigation params](https://github.com/teamdigitale/italia-app/blob/master/ts/types/react.ts#L19) from `react-navigation` aware components, that type can be used for [redux nav actions that provide type safe params](https://github.com/teamdigitale/italia-app/blob/master/ts/store/actions/navigation.ts#L112).

In general it avoids repetition and makes the code more DRY.",1539506406.0
villiger2,Server side render. Google doesn't run your page JS nearly as much as they dumb html crawl. Also not sure how many other crawlers will execute JS either.,1539175747.0
gamebuster,"If you need Google Bot to access your content, make it accessible without Javascript. SPAs - Single Page APPLICATIONs - usually don't need to be crawled.

We have separate code-bases for our SPAs and websites. Our websites are 100% server-side generated code with only minor JS additions (usually small hand-written classic JS). I test & write all our websites with JavaScript disabled, and I only use JS for small enhancements like validation.

For more complex features, we have the server generate a div as a target and inject the SPA in that DIV. Of course, that complex feature is not indexed and it shouldn't be indexed.",1539178218.0
IxD,"About 1 in 20 users will have a browser that does not support const.

[https://caniuse.com/#feat=const](https://caniuse.com/#feat=const)",1539186058.0
SlocketRoth,"Youre gonna wanna pre render your content or use a tool like babel to convert your code to es5. 

Iirc if you target es5 in your tsconfig it should convert some features to valid es5 code but this doesnt work for everything.",1539176046.0
r0ck0,Are you using react or vue?,1539182220.0
yarauuta,"Same happened to me... several times in fact with ReactJs and Angular. Only solution to this is using server side rendering.
Google said they would benefit that used Angular. They can't even crawl it, liars.",1539192831.0
recursive,"Usually, you'd just use `P`.  No need for fancy generics.",1539127872.0
cspotcode,"I use this generic helper that lets me describe any constructor of instances of type `T`.

    type Constructor<T> = {
        new (...args: any[]): T;
    }

Then I can write your `foo` function like this:

    foo(clazz: Constructor<P>) { ...

Note that the `Constructor<>` generic does not enforce any guarantees about the constructor signature nor about static methods.  So for example, if your `foo` function is expecting to `new clazz(1, false)` then you might want to use a type with a more specific constructor signature.  Or if `foo` is expecting to call static methods such as `clazz.createFromNumber(123)` then you can do something like `Constructor<T & {createFromNumber(a: number): whatever}>`

`typeof P` will capture \*all\* of these things about `P`, but it's easy for subclasses to have a different constructor signature than the super-class, so those subclasses might be considered incompatible with `typeof P`.  Think about what your foo function intends to do with the value it receives, and pick a type that enforces the necessary requirements.",1539314818.0
isiteverenough,"This should do it:

foo<T extends typeof P>(clazz: T) {}

&#x200B;

Playground example:

[https://www.typescriptlang.org/play/index.html#src=class%20P%20%7B%7D%0D%0A%0D%0Aclass%20Q%20extends%20P%20%7B%7D%0D%0A%0D%0Afunction%20test%3CT%20extends%20typeof%20P%3E(myClass%3A%20T)%20%7B%0D%0A%0D%0A%7D%0D%0A%0D%0Aconst%20pInstnace%20%3D%20new%20P()%3B%0D%0Aconst%20qInstance%20%3D%20new%20Q()%3B%0D%0A%0D%0Atest(pInstance)%3B%20%2F%2F%20error%0D%0Atest(qInstance)%3B%20%2F%2F%20error%0D%0A%0D%0Atest(P)%3B%20%2F%2F%20happy%0D%0Atest(Q)%3B%20%2F%2F%20happy](https://www.typescriptlang.org/play/index.html#src=class%20P%20%7B%7D%0D%0A%0D%0Aclass%20Q%20extends%20P%20%7B%7D%0D%0A%0D%0Afunction%20test%3CT%20extends%20typeof%20P%3E(myClass%3A%20T)%20%7B%0D%0A%0D%0A%7D%0D%0A%0D%0Aconst%20pInstnace%20%3D%20new%20P()%3B%0D%0Aconst%20qInstance%20%3D%20new%20Q()%3B%0D%0A%0D%0Atest(pInstance)%3B%20%2F%2F%20error%0D%0Atest(qInstance)%3B%20%2F%2F%20error%0D%0A%0D%0Atest(P)%3B%20%2F%2F%20happy%0D%0Atest(Q)%3B%20%2F%2F%20happy)",1539157785.0
tfptfp,function foo(clazz: typeof P) { ...,1539163468.0
,"Try this, not sure if it'll work:

    foo<T extends P>(class: T) { ... }",1539127239.0
ShippingIsMagic,"You mentioned in [the details post](https://medium.com/@urish/diving-into-the-internals-of-typescript-how-i-built-typewiz-d273bbef3565) how the alternative approach involved using debugging and sourcemaps. You listed some reasons why you didn't take that approach, but offhand it seems like it might have made the tool much easier to use without needing to change anything about how code is built or webpack configurations?

""Works with v8, whether in node or chrome, and requires working sourcemaps"" is a reasonable requirement IMHO, especially for generating these types. You don't have to constantly develop against chrome if you don't want, just use it for this scenario to help populate missing types.

I love what you've done with TypeWiz, but in terms of lowering the barrier to adoption, while what you've done here for Angular is certainly simple to use, offhand I wonder if it would have been simpler for most typescript projects if you'd gone the other route.

This isn't meant as criticism by any means, just trying to offer a possible alternative thought on adoption barriers, admittedly from someone not familiar with the problem space nearly as much as you are!",1539145952.0
lukeautry,"Nice. Really like how this starts with type inference, i.e. showing the reader what TypeScript can do ""for free"" without even using additional type annotation syntax. I think this is something that was often missing in previous introductions to TypeScript.",1539027345.0
joonhocho,"If you are using paths in tsconfig.json, you will need to change back absolute paths to relative paths for it to work after compiling typescript into plain javascript using tsc  
.

Most popular solution for this has been [tsconfig-paths](https://github.com/dividab/tsconfig-paths) so far.

I've tried it, but it did not work for me for my complicated setup. Also, it resolves paths in run-time, meaning overhead in terms of your package size and resolve performance.

So, I wrote a solution myself, [tscpaths](https://github.com/joonhocho/tscpaths).

I'd say it's better overall because it replaces paths at compile-time. It means there is no runtime dependency or any performance overhead. It's pretty simple to use. You just need to add a line to your build scripts in package.json  
.

The project is pretty young, so there could be some issues if your setup is very complicated. It works flawlessly for my setup, though my setup is fairly complex.",1538991573.0
cspotcode,Cool!  Did you consider writing it as a custom TS transformer?  ttypescript (https://npm.im/ttypescript) makes it possible to declare and use transformers via your tsconfig.,1538994402.0
xdavehome,"For this kind of stuff, I usually use Ramda's [evolve](https://ramdajs.com/docs/#evolve). Works really well, everything is computed.

  


Install the types as 'types/npm-ramda\#dist' instead of '@types/ramda' to pull better types from GitHub.",1538990242.0
gamebuster,"https://github.com/fcamblor/ts-object-transformer/blob/master/src/ts-object-transformer.ts

That is some interesting code there.

Is there a reason you're importing lodash when you can use `key in fieldMap`, `Object.keys` and `[].forEach`?",1538993099.0
andersjoh,"Why not use a value object, with the validation built in?",1539035896.0
AngularBeginner,"You should post the actual code, because what you posted is not valid code.

Expanded by the necessary ""class"" wrapper and adding the properties it works just fine:

	class ClassName {
		private name: string;
		private id: string;

		constructor(name: string, id: string) {
			this.name = name;
			this.id = id;
		}
	}

	var myClass: ClassName = new ClassName('p', '123');",1538902433.0
AngularBeginner,Why would anyone start a new app with AngularJS? Makes no sense.,1538851487.0
wuzzeb,"I like this approach and use it myself.  I've even extended it to automatically extract the action types from the reducer and provide proper types for connect, checking that mapDispatchToProps uses matching types from the reducer.  [Here is the code](https://gist.github.com/wuzzeb/e8502a6efb4160fa1c20ddf4080968c2).  I am working on a blog post describing the approach.",1538855132.0
vijayshan,"This is a great writeup. Thanks for posting this.

&#x200B;",1538866615.0
scaleable,"I have once written an article following similar lines, maybe it is of your interest

&#x200B;

[https://github.com/wkrueger/wkrueger.github.io/blob/master/md/redux1/20180715-downhill.md](https://github.com/wkrueger/wkrueger.github.io/blob/master/md/redux1/20180715-downhill.md)",1538875627.0
Merad,There’s also the [typesafe-actions](https://github.com/piotrwitek/typesafe-actions) package that handles this for you. ,1538880315.0
Voidsheep,"You should check out the [React & Redux in TypeScript - Static Typing Guide](https://github.com/piotrwitek/react-redux-typescript-guide#react--redux-in-typescript---static-typing-guide) and [typesafe-actions tutorial](https://github.com/piotrwitek/typesafe-actions#behold-the-mighty-tutorial).

Something I really wish I knew about before doing Redux with TS. Eventually adopted the stuff and got rid of thousands of lines of type declarations that were a pain in the ass to maintain.",1538905162.0
s1cklik3,"Great article this has elevated my angular skills, some of these practices come with using the framework after a period of time and I'm glad I came to some of the same conclusions. ",1538797069.0
Arffman,A pull request for some obscure library replacing some of the strongly typed function declarations with weakly typed (`any` everywhere) ones? Ok then.,1538770030.0
vosper1,"Just to nitpick a little, sorry it's not helpful: 

> For React apps, it is advised to normalise the state shape

For *Redux* apps it's advised to normalize the state shape. There are many alternatives to using Redux to manage state in React.",1538765727.0
PferdOne,"I don't get the complexity. For me it's pretty simple. My types would look something like this:

```
type Group = {
  id: string
  name: string
  individualIds: string[]
}

type Individual = {
  id: string
  name: string
  groupIds: string[]
}

type State = {
  groups: { [gid:string]: Group }
  individuals: { [iid:string]: Individual }
}
```

My components would be pretty simple as well and work accordingly to my state. Maybe I don't get it, but I just can't see the complexity of your problem.
",1538765841.0
allenthar,"My preference would be to create normalized and denormalized types for the two (probably an interface for the base type, that the UI type would extend), and then create [selectors](https://github.com/reduxjs/reselect) that produce the denormalized types.

Something like:

    interface Group {
        id: GroupId
        individuals: IndividualId[]
    }
    interface GroupUI {
        id: GroupId
        individuals: Individual[]
    }
    interface Individual {
        id: IndividualId,
    }
    interface IndividualUI extends Individual {
        groups: Group[]
    }
    type State = {
        groups: {
            [id: GroupId]: Group
        }
        individuals: {
            [id: IndividualId]: Individual
        }
    }
    const getGroupUI = createSelector(
        state => state.groups,
        state => state.individuals,
        (_, props) => props.groupId
        (groups, individuals, id) => ({ ...groups[id], individuals: groups[id].individuals.map(individualId => individuals[individualId]) })
    )

&#x200B;",1538766227.0
demoran,"It's enough for the groups to have a list of memberIds.  If you run into performance issues with getting groups for each individual, then you could do the same on the individual side with groupIds.

each slice should have an id-keyed property (eg `byId`) that contains the actual individuals or groups, respectively.",1538778657.0
TYB069,"What you keep in store and what your components use is not always the same and they should not be coupled.

You can achieve proper separation and good performance by keeping the state normalized:

    type Id = string | number;

    type IndividualId = Id;
    type GroupId = Id;

    interface Individual {
        id: IndividualId;
        belongsTo: GroupId[]
    }

    interface Group {
        id: GroupId;
        consistsOf: IndividualId[]
    }

    interface Store {
        individuals: {
            byId: Record<IndividualId, Individual>;
            allIds: IndividualId[];
        };
        groups: {
            byId: Record<GroupId, GroupId>;
            allIds: GroupId[]; 
        }
    }

    const getIndividualById = (state: Store, id: IndividualId): Individual =>
        state.individuals.byId[id];

    const getAllIndividuals = (state: Store): Individual[] =>
        state.individuals.allIds.map(id => getIndividualById(state, id));",1538918814.0
flyingwigs2,i like your ambition,1538679789.0
joonhocho,"Compared to Facebook's DataLoader, BatchLoader is composable and further reduces round trips by handling duplicate keys.",1538641650.0
wllmsaccnt,"Was the title of this supposed to be ""Help Wanted Items in TypeScript's GitHub""?",1538596202.0
GuinnessDraught,This is a good high level summary. I might use this in the future to help explain TS vs JS to neophytes. Thanks!,1538597434.0
vinnl,"Hmm... I don't think function hoisting is due to Javascript being compiled; AFAIK, Javascript even started out with interpreters, who only later started adding JIT. (Which doesn't really have much to do with TypeScript, though, except that JIT might make the term ""compile time"" more confusing...)

Otherwise, excellent article - I think there is a need for introductions like these.",1538640544.0
EarlMarshal,"For me the order of things is somehow confusing. You start asking if it's interpreted or compiled but you never really say that most engines use a Just-In-Time-Compiler. Instead you jump on a example and start talking about hoisting.

Would confuse the fuck out of me if I didn't knew better.",1538647148.0
MrJohz,"This is, from a PL perspective, a lot of misinformation. The examples of what ""compiled"" and ""interpreted"" mean are very unhelpful - other people have already pointed out the fact that interpreted languages can very easily use hoisting. The later distinction of ""runtime"" and ""compile time"" is particularly wrong, given that the JIT interpreters used in most JS engines do their compilation at runtime!

On top of that, the example given of being able to assign values of different types to the same variable is definitely not ""the very definition of a “dynamically typed language”"". In fact, it's almost completely orthogonal. Rust (statically typed) allows reassignment of multiple types to the same variable, Elixir (dynamically typed) doesn't allow *any* reassignment of variables, and TypeScript allows union types to contain as many types as they like, meaning that the code as written, if decorated with the correct types, is completely valid TypeScript code.

There are other cases of odd terminology that aren't particularly helpful either - for example, it isn't the ""parser"" that allows you to rename things, it's the binder that takes the AST and then applies the semantic symbols that determine what variable refers to what other variables.

Moreover, I strongly disagree with describing this as ""the missing introduction"". That implies that this is all stuff that hasn't been explained, but needs to be. A good amount of the content is simply inaccurate, some of it is unnecessary (explaining how interpreted and compiled languages work, for example), and the stuff that is relevant isn't really introductory, but more an attempt to explain the behind the scenes of things that aren't hugely important to understand (at least as a beginner TypeScript user).",1538651637.0
kqadem,"since your architecture is build upon es5 and the dirty global scope style, I doubt there's no simple way to convert it. Bite the bullet and do it the clean way. your benefits:
* you will be able to find out your dependencies. even those that are not intended
* bundler like webpack & co. will even be able to do more optimization (tree shaking etc)
* nobody will hate you anymore ",1538607978.0
cspotcode,Have you checked out codemods via recast or js-codeshift?  They might do the trick.,1538612566.0
cspotcode,"Actually, ignore my other comment.  I think your ""one fell swoop"" approach can be made a tad smarter without a ton of effort.

Programmatically add an export to all top-level functions, classes, and variables.  Also make a list of each export along with the file it's declared in.

Also add `export {}` to every file that doesn't otherwise have an export statement (if there are any) to force it to be a module.

Run the typescript compiler and grep for all ""this is not declared"" errors.  Those should be the imports you need.  Based on your previous list, you know which file to import them from and can generate a specific import statement.

Does that sound like it would work?",1538614401.0
NathanSMB,"I found this stackoverflow thread.

&#x200B;

[https://stackoverflow.com/a/41307319](https://stackoverflow.com/a/41307319)

&#x200B;

What happens if you change the webpack.config.js to this instead:

&#x200B;

    module.exports = {
      // ...
    
      resolve: {
        extensions: ["".js"", "".json"", "".ts""],
        alias: {
          prismjs$: path.resolve(__dirname, ""src"", ""vendor"", ""prism""),
        },
      },
    };

All I did was remove .js from the prismjs alias.

I'm just spitballing here. Let me know if it works or gives you any hints.",1538597113.0
,"Do `npm run test`, or `jake runtests`.

This may cause things to fail if you have added new test files, or the baselines change. You then need to do:

`jake baseline-accept`

which will copy the changed baselines from your local directory to the main testing one. Run the tests again, and they should now pass.

**Before committing: thoroughly go over any baseline changes to check that they are expected.**",1538643700.0
ponchoboy,"If you declare the type as `TableColumn<T,V>`, do you need to specify either `T` or `V` when using? Won’t they both be inferred from the signature of the `value` property lambda?",1538532551.0
DanielPerezAlvarez,"I don't think it's possible, if you find a way please let me know.",1538628227.0
ProdigySim,"
    interface Formatter<T extends (arg: any) => any> {
        getValue: T;
        format: (value: ReturnType<T>) => string;
    }
    
    const fmt = {
        getValue: (x: boolean) => x ? 0 : 1,
        format: (val: number) => '' + val,
    };

    function useFormatter<T, U extends (arg: T) => any>(formatter: Formatter<U>, item: T): string {
        return formatter.format(formatter.getValue(item));
    }
    
    useFormatter(fmt, true);

http://www.typescriptlang.org/play/#src=interface%20Formatter%3CT%20extends%20(arg%3A%20any)%20%3D%3E%20any%3E%20%7B%0D%0A%20%20%20%20getValue%3A%20T%3B%0D%0A%20%20%20%20format%3A%20(value%3A%20ReturnType%3CT%3E)%20%3D%3E%20string%3B%0D%0A%7D%0D%0A%0D%0Aconst%20fmt%20%3D%20%7B%0D%0A%20%20%20%20getValue%3A%20(x%3A%20boolean)%20%3D%3E%20x%20%3F%200%20%3A%201%2C%0D%0A%20%20%20%20format%3A%20(val%3A%20number)%20%3D%3E%20''%20%2B%20val%2C%0D%0A%7D%3B%0D%0A%0D%0Afunction%20useFormatter%3CT%2C%20U%20extends%20(arg%3A%20T)%20%3D%3E%20any%3E(formatter%3A%20Formatter%3CU%3E%2C%20item%3A%20T)%3A%20string%20%7B%0D%0A%20%20%20%20return%20formatter.format(formatter.getValue(item))%3B%0D%0A%7D%0D%0A%0D%0AuseFormatter(fmt%2C%20true)%3B",1538589538.0
Dzsodzsa1996,I think you want to use returnType<T> instead of V in this case. Give ít a try. It might solve your problem :) ,1538542877.0
MaxGabriel,"I'm open to any questions on this! A big potential concern I have is that I come from a Haskell background, and I'm hoping this blog post makes sense to programmers coming from a Javascript/Typescript background",1538521994.0
hallettj,"Nice article! I have seen posts on parsers in Javascript, but only rarely. It is a topic that deserves more visibility. The intersection of combinators and Typescript is especially useful. I think that date parsing is a great choice for illustration.",1538588077.0
BeanzPatio,"Typescript is basically just stricter Javascript. If you're used to statically typed languages then I would recommend starting with Typescript. You'll have a bit more syntax to learn, but it will be more familiar and the compiler will help prevent you from doing things wrong.

",1538491527.0
IxD,"If you are writing typescript, you need to know both javascript and typescript. ",1538507462.0
jkuhl_prog,"You should not do Typescript without knowing Javascript, because Typescript IS JavaScript, but with added features (typing, accessibility modifiers, interfaces, etc.)  Other than the things that make it Typescript, the language follows the same ECMAScript standards and keeps up with each new ES release.  


You won't be able to really follow a good Typescript course without knowing the underlying Javascript.",1538501463.0
blakflag,"Older Javascript relies heavily on closures and callbacks which are unnecessary/antipatterns in Typescript.  Seriously.. don't even look at any Javascript dating back more than about 3-4 years because it will just confuse the issue. 

If you're talking about just looking at very modern ES6+ javascript then, well you could. But as BeansPatio said, you have experience with static typing .. so go right to Typescript.",1538493603.0
gamebuster,Learn JavaScript first,1538599262.0
Dandamis,"I'm longing for the day that Javascript will get the honorable place in programming languages that it deserves. If anything is a conventional programming language it should be javascript. 

Having said that; I would say learn Typescript, since you will work on personal projects. 

However, do realize that you will have a hard time to understand many of the javascript projects that are out there. Which are build with classical prototype systems, callbacks and the likes. Very ugly and weird to understand if you are used to an OOP style of JS with typescript.

Either way, typescript is the way forward. Especially now that 2 of the 3 major front-end frameworks are (will be) build in typescript.",1538499714.0
xdavehome,"Learn typescript first. Typescript is what Javascript is supposed to be, and should actually replace it as the standard. </opinion>

  


Seriously though, Typescript fits on top of Javascript like a glove and I've all but forgotten about JS' existence after coding in TS for more than a year.

  


I can't start a new project unless I choose Typescript. Even small scripts for node.js to do things for which I would have normally chosen bash or python in times past.",1538528776.0
nsonha,"so that you can spot js footguns and understand other people's code that (ab)use low level js concepts:  
\- hoisting of var  
\- lambda vs function (bound vs unbound)  
\- prototype  
\- mixins  
(... there should be a couple more but those should be the most frequently encountered, in that order)  
There is no need to be gradually transitioning though given your background. My advice is to look up articles about problems in es5 that ts fixed then make sure to use tslint when you write ts.",1538637193.0
slashess,"It's valuable to learn modern javascript (ES6+) because in typescript you'll inevitably either run into javascript you will need to understand, or run into situations where you need to know **why** things work the way they are in the front end ecosystem, which is obviously heavily coupled to Javascript.",1538500248.0
QuentinUK,It is best to learn C# first.,1538505626.0
slashess,"    const foo: TypeA | TypeB = ...;
    
    function usesTypeA(value: TypeA): void {
      // do something.
    }
    
    function usesTypeB(value: TypeB): void {
      // do something.
    }
    
    // this is a ""type guard""
    function isTypeA(value: any): value is TypeA {
      return true; // do whatever you need to do to test if a value is type a
    }
    
    // via type guard (safest way)
    if (isTypeA(foo)) {
       usesTypeA(foo) // YES: foo is TypeA
       usesTypeB(foo) // ERROR: foo is TypeA
    }
    
    // via type assertion
    usesTypeA(foo as TypeA);

&#x200B;",1538499999.0
demoran,"You simply need to cast it.  Try using the `as` keyword.

    const x : number | string;
    const y = (x as number);",1538486372.0
vmlf01,"Probably a user defined type guard can help:
https://basarat.gitbooks.io/typescript/docs/types/typeGuard.html",1538483064.0
alwaysdoit,"    if (foo instanceof TypeB) {
        console.log(""this is a B"")
    }
    libFunction(foo);",1538495345.0
gamebuster,"The availability of browser typings is based on your tsconfig. See `--lib` in https://www.typescriptlang.org/docs/handbook/compiler-options.html

I don't know what libs you will need exactly, but it's in there somewhere. Do note that you might need to restart your editor after changing your tsconfig.

IIRC `""lib"": [""es2015""]` includes the DOM typings. (note: NOT `es2015.core` but `es2015`). I'd assume all other ES* variants include DOM typings as well.

All lib typedefs are defined here: https://github.com/Microsoft/TypeScript/tree/master/lib

DOM specific types are defined here:
https://github.com/Microsoft/TypeScript/blob/master/lib/lib.dom.d.ts

",1538476116.0
scaleable,"If you hover over default JSX typedefs you may end up on typedefs from the DOM, it is all reused.",1538506805.0
r0ck0,"Check this out if you haven't already:  https://basarat.gitbooks.io/typescript/

I found a lot of it easier to understand than the official docs, and largely due to being more example-based.",1538486698.0
Wobblycogs,"I'm just going though Max's ""Understanding Typescript"" course on Udemy for the second time (as a refresher after a break from coding). It's a good course especially if you know another language and mostly need to learn the syntax and nuances of TS. You can usually get the course for about 10 (insert currency here).",1538467040.0
tyler_church,"It's not ready yet, but I'm working on something exactly like what you're asking for: [https://typescriptbyexample.com/](https://typescriptbyexample.com/)

I'd love to hear the topics you'd want such a course to cover, or the examples you'd find most helpful to see.",1538527185.0
saladfingers6,Once you go TypeScript you never go back :),1538401871.0
jkuhl_prog,"Glad to hear it.  Fudging with Webpack to get TS and Vue to behave together is never a fun time.  And I love Typescript, it's in that special place where it's got all the awesomeness of JavaScript, and all the type strictness of Java without the pain points of either language.",1538416728.0
mrmanicou,When this happens I'll switch,1538422147.0
Inzire,Yay!,1538402120.0
Dandamis,"Great, just when I masteres Angular because it has native TypeScript.. while I preferres Vue.

Oh well! Not gonna complain. All aboard the TypeScript trolly!",1538470485.0
welkie,I wonder if they'll still insist on not using semicolons.,1538452149.0
haganenorenkin,Take that TS haters! Hahahaha I know many vue lovers who say they hate TS HAHAHA!!!,1538425690.0
gamebuster,"- Global variables: You can't define globals in JAVA, so why try it in Typescript? Do what you would do in Java: Declare a static variable on a class.
- One class per file: That's perfectly fine and I do it all the time. You have to explicitly import files though. I usually have 1 class per file, and an `index.ts` that exports all these things. EG:

```
// core/user/IUserService.ts
import { IUser } from ""./IUser""

export interface IUserService {
  getUserById(id: string): Promise<IUser>
}

// core/user/IUser.ts
export interface IUser {
  id: string;
}

// core/user/index.ts
export * from ""./IUserService""
export * from ""./IUser""

// core/index.ts
export * from ""./user""

// http/HttpUserService.ts
import { IUserService, IUser } from ""../core/user"";

export class HttpUserService implements IUserService {
  constructor(
    private endpoint: string,
    private fetch: Fetch,
  ) {
  }

  async public getUserById(id: string): Promise<IUser|null> {
    const response = await this.fetch(this.endpoint + ""/users/"" + id);
    return response.status === 200 ? parseUserResponse(await response.json()) : null;
  }
}

// essentially a prive function
// no need to embed it in the class since it won't be using `this` either
function parseUserResponse(data: any): IUser {
  return ...;
}

// http/index.ts
export * from ""./HttpUserService"";

// index.ts
export * from ""core"";
export * from ""http"";
```

Also, an example of a ""global"" variable by using a singleton pattern: https://github.com/tobyhinloopen/injector/blob/master/src/core/Injector.ts

```
export class Injector {
  public static readonly instance = new Injector();
  ...
}
```",1538401337.0
hallettj,"In Java everything defined in the same package shares the same scope; so you can reference a class in another file without explicitly importing it. Typescript is different: every file has its own scope; so you must explicitly `export` and `import` classes and variables between files.

A file in a Typescript project is called a ""module"" because it gets its own scope. Javascript works the same way when working with CommonJS or ES modules.

CommonJS is the Node module system - Typescript is typically configured to use this system. A bundler (either tsc, Webpack, or Parcel) combines CommonJS modules into one file for use in a browser.

ES modules are the new ECMAScript standard module system. Browsers are upgrading to be able to consume ES modules natively, which may make bundling unnecessary in some cases. But it will take some time for the community to adjust to this new module system. The old module-less system where all browser scripts share one global namespace has been on the way out for some time.",1538403236.0
crimsonPhantom,Can you show us some code ?,1538395551.0
ClutchHunter,Why do you want your variables to be global?,1538400377.0
TYB069,"Are you talking about Node or the browser? For the former you can just \`declare global\`, for the latter you'd have to do that or extend the \`Window\` interface. If you can present some examples, I will show you how to do it.",1538481712.0
son_of_meat,"The article is disappointing because it discusses the new features that I understood fine in the release notes but not the one that I didn’t, project references",1538333067.0
coskuns,"A blog post announcing an announcement which has been announced several days if not more than a week ago. 

Please, I beg you, stop linking to stupid posts which says nothing. ",1538334716.0
AngularBeginner,"I'm not aware that ES has any plans to add type information, so I would say: No. But TypeScripts goal is to stay compatible with ES and just add type information. So I would say that ES will not turn to TypeScript, but TypeScript will stay relevant ""ES with types"".",1538301019.0
vinnl,"No, TypeScript will keep evolving to keep looking like Javascript. In general, it only implements features that actually make it into the language, and make types explicit. See the [TypeScript design goals](https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals).

In other words: don't worry about it. Writing TypeScript feels like writing Javascript, except that there's less that you need to keep track of by heart, since you can make your assumptions explicit and TypeScript will warn you if you violate them. You can strip the type annotations, and you'll end up with regular Javascript (which is what Babel is doing nowadays).",1538304323.0
LastOfTheMohawkians,You should read the ES4 spec. Then you'll have your answer,1538340616.0
AngularBeginner,The strict compiler flags disabled? Why use a language for type safety and throw away the best type safety features it offers? I'll never understand how people can accept TS projects without `strictNullChecks`.,1538281312.0
kwiwksh," FYI:  As of TS 3.0 introduced project references to fill the ""monorepo"" need.  I don't know what that means for Lerna, but my understanding was the  native TS solution would be preferable moving forward.

[https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/](https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/)",1538166794.0
monkey-go-code,Your site says 404,1538160597.0
Arffman,https://formidable.com/blog/2018/typescript-second-coming-node,1538161448.0
davidmdm,Typescript is not the second coming of node.,1538167767.0
slashess,"For starters, your syntax is all over the place. None of it is valid typescript. Either way, it's possible.

    type NottableFn = (...args: any[]) => boolean | NottableFn;
    
    function not<T extends NottableFn>(fn: T): T {
        return ((arg: any) => {
            const value = fn(arg);
    
            if (typeof value === ""function"") {
                return not(value)
            } else {
                return !value;
            }
        }) as T
    }

Playground (copy and paste, clicking doesn't seem to work, thanks Reddit): [http://www.typescriptlang.org/play/index.html#src=type%20NottableFn%20%3D%20(...args%3A%20any%5B%5D)%20%3D%3E%20boolean%20%7C%20NottableFn%3B%0D%0A%0D%0Afunction%20not%3CT%20extends%20NottableFn%3E(fn%3A%20T)%3A%20T%20%7B%0D%0A%20%20%20%20return%20((arg%3A%20any)%20%3D%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20value%20%3D%20fn(arg)%3B%0D%0A%0D%0A%20%20%20%20%20%20%20%20if%20(typeof%20value%20%3D%3D%3D%20%22function%22)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20not(value)%0D%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20!value%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D](http://www.typescriptlang.org/play/index.html#src=type%20NottableFn%20%3D%20(...args%3A%20any%5B%5D)%20%3D%3E%20boolean%20%7C%20NottableFn%3B%0D%0A%0D%0Afunction%20not%3CT%20extends%20NottableFn%3E(fn%3A%20T)%3A%20T%20%7B%0D%0A%20%20%20%20return%20((arg%3A%20any)%20%3D%3E%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20value%20%3D%20fn(arg)%3B%0D%0A%0D%0A%20%20%20%20%20%20%20%20if%20(typeof%20value%20%3D%3D%3D%20%22function%22)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20not(value)%0D%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20!value%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D))%20as%20T%0D%0A%7D%0D%0A%0D%0Aconst%20isNum%20%3D%20(num%3A%20number)%20%3D%3E%20(arg%3A%20any)%20%3D%3E%20arg%20%3D%3D%3D%20num%3B%0D%0Aconst%20isOne%20%3D%20isNum(1)%3B%0D%0Aconst%20isNotNum%20%3D%20not(isNum)%3B%0D%0A%0D%0Aconst%20isNotOne1%20%3D%20not(isOne)%3B%0D%0Aconst%20isNotOne2%20%3D%20isNotNum(1)%3B%0D%0A%0D%0Aconsole.log(isNotOne1(1))%0D%0Aconsole.log(isNotOne2(1))%0D%0Aconsole.log(isNotOne1(2))%0D%0Aconsole.log(isNotOne2(2))

&#x200B;

&#x200B;",1538163490.0
kaini_shrimp,"Maybe I am missing something, but wouldn't

    function not<Args extends any[]>(fn: (...Args) => boolean): (...Args) => boolean {
        return (...args) => !fn(...args);
    }

do the job?

Edit: Do you really want the explicit currying, then of course this solution would not be enough?",1538483475.0
BehindTheMath,I believe `export = FooBar` is correct. `export default FooBar` is the equivalent of `module.exports.default = FooBar`. ,1538098232.0
AngularBeginner,"Any chance we'll get an updated specification? It's still stuck at 1.8. The last update was 2 years ago. It's really a pity, as the documentation is often really lacking. Only way to find out if a behavior is intentional is to dig through the documentation and search through thousands of GitHub issue comments.",1538061454.0
mendrique2,we want pattern matching already!,1538078267.0
Keith,The video of refactoring from promises to async/await won't play on my iPhone. Broken for anyone else?,1538063856.0
fernap3,"Best new offering IMO, the refactoring from `.then` => `await` in VSCode!",1539311069.0
,The scrolling on that page gave me motion sickness.,1538055213.0
BurritoBashr,"This doesn’t need to be here, most of the readers already know and use TypeScript.",1538055774.0
,"Anyone here used this, either as a student or mentor? Would be interested to hear about it!",1538037281.0
moremattymattmatt,"I've just signed up, I'll get going with some mentoring over the next few days.

&#x200B;

BTW on page [https://exercism.io/mentor/registrations/new](https://exercism.io/mentor/registrations/new) you've got a type: ""Mentors can help on as many tracks as they line"" should be ""Mentors can help on as many tracks as they like""",1539543212.0
CMJunior,Not very familiar with TypeScript but I wouldn't mind joining the Javascript mentoring :),1538038495.0
landandsea,Just signed up. Thanks for posting about this.,1538058716.0
BurritoBashr,how is this related to typescript,1538005582.0
,"Can we have a rule that requires direct links to github repositories come with some context?

- What does the code do?
- What is an interesting feature to look at at?

Otherwise we might as well get a bot that crawls github for high star, high % TypeScript projects.",1538035209.0
Hath995,I feel like this should be pinned in the discussion sidebar. ,1537911119.0
icholy,Cmon guys irc is where it’s at ,1537931780.0
sweetcrutons,"[SpeakJS Discord](https://discord.gg/JMD7Nu4) is pretty good for Typescript also, as well as a whole lot of webdev stuff.",1537929708.0
threemanycats,I like this library just fair warning: the documentation is scant and relies heavily on a strong understanding of FP. It's not a great way to dabble.,1537905264.0
Hath995,"This library is interesting because it contains and is based around a scheme for encoding Higher Kinded Types in TypeScript. This is a feature which TypeScript does not natively support.

I think it is interesting to learn about how to use higher kinded types using JavaScript and explore the patterns using those with type safety. More over this library is quite complete and thorough covering functional programming abstractions, and I mean considerably more fully featured than the majority of functional programming libraries in JavaScript than I've seen. 

It also has a fairly robust example and test samples which help to explain how to use it. 

Also the author, gcanti, is fairly responsive to github issues including just random questions. He also hangouts on the [functional programming slack](https://fpchat-invite.herokuapp.com/) in the TypeScript channel and responds to questions there. ",1537911009.0
AngularBeginner,"It works as you provided it in your code already:

    const obj1 = {
        prop1:2, 
        prop2:3, 
        get computed(){
            return this.prop1 * this.prop2;
        }
    }

You don't access `this.obj1` in the getter, because `this` refers to the object literal you create, and that object literal has no `obj1` property. `obj1` is just the variable you store the object reference in.",1537890866.0
kredditacc96,Are you trying to compute multiplication ahead of time? ,1537887221.0
arilotter,"You could use an IIFE:

    const obj2 = (function() {
      const o = {
        prop1: 2,
        prop2: 3
      };
      o.computed = o.prop1 * o.prop2
      return o
    })()
    
    console.log(obj2.computed) // 6",1537888560.0
saltupz,"> The package was renamed from `pure-ts` because of NSFW search results.

Hahah! 😂",1537872621.0
gigobyte,"I am the author of the library, 2 months ago was the initial release, after a lot of back-and-forth with the TypeScript type system I decided that it's time to release a new version that addresses the issues people most commonly had.",1537871484.0
HeadBee,"Very interested in this package. I was *just* looking for something that strikes a balance between functional convenience/expressability but is easily adopted and communicable for people not familiar with the FP approach.

If you have a sec, I was wondering about this in your Maybe implementation:

```
export type AlwaysJust = {kind: '$$MaybeAlwaysJust'}
```

and

```
    isJust(): this is AlwaysJust {
```

What exactly is going on here? I understand that AlwaysJust refers to a row type that has that field, but it's never set anywhere else.",1537891235.0
,"The webpage has these \lambda signatures for the functions but they are largely undocumented. In the signature for 

    equals :: (a, b) ~> (a, b) -> Bool

what is the difference between the arrows `~>` and `->`?

I think some of the examples without purify are abit contrived, for example:

    let port: number
    let config: Config | null = getConfig()

    if (config && config.port) {
        port = parseInt(config.port)
    } else {
        port = 8080
    }

Is that really a fair representation? It could easily be written as

    const config = getConfig();
    const port = config && config.port ? parseInt(config.port) : 8080;


",1537885807.0
TheHighestKek,"Why not contribute to one of the following repositories or their DefinitelyTyped packages?

* Sanctuary
* Fluture
* Folktale
* fantasy-land",1537881250.0
folekaule,"Microsoft answers your questions in the [Readme](https://github.com/Microsoft/tsdoc)

On JSDoc, they say (my emphasis):
> 
> Why can't JSDoc be the standard? Unfortunately the JSDoc grammar is not rigorously specified, but rather inferred from the behavior of a particular implementation. **The majority of the standard JSDoc tags are preoccupied with providing type annotations for plain JavaScript, which is an irrelevant concern for a strongly-typed language such as TypeScript.** TSDoc addresses these limitations while also tackling a more sophisticated set of goals.
",1537828190.0
gerbosan,"Found an article about [TSDoc in InfoQ](https://www.infoq.com/news/2018/04/tsdoc-format-announced)

> The TSDoc format states the following goals:

>   - Design a grammar for TypeScript while extending JSDoc
>   - Allow Markdown within comments
>   - A common set of documentation tags
>   - Extensible mechanism for adding tags
>   - Interoperable, so custom tags won’t break parsing of non-custom tags and handling Markdown ambiguities
>   - Cross-referencing between packages and dependencies
>   - Open standard

> Additionally, the TSDoc reference parser also aims to provide:

>   - Strict and lax modes, with lax attempting to parse existing JSDoc-based grammar
>   - Bi-directional round-tripping between doc comments and abstract syntax trees
>   - Self-contained, no dependency on the TypeScript compiler API, allowing the abstract syntax tree for comments to be a simple JavaScript object tree

> TypeScript developers should expect that JSDoc type annotations that are redundant with type information already provided > by TypeScript be optional with TSDoc.",1537902997.0
ClutchHunter,"I spend a lot of my spare time working with Rust and when I come back to JS/TS I miss a lot of things, but by far the biggest are the `Result` (values being `Ok(T)` and `Err(E)`) and `Option` (values being `Some(T)` and `None`) ADTs. In essence, these are enums that hold values. For example:

    let x = do_sth(); // returns e.g. Result<String, Error>

Now there is a lot of flexibility with what you do with this. If you're inside a function that returns a compatible error, then you can unwrap and return and propagate the error very ergonomically:

    let x = do_sth()?;

Perhaps you want to continue execution regardless, but do something only if it unwraps to an `Ok`:

    if let Ok(val) = do_sth() {
        do_sth_else(val);
    }

Options are similarly ergonomic:

    struct Example {
        id: i32,
        name: Option<String>,
    }
    
    let example = Example { id: 0i32 };
    
    // Now have access to a lot of helpers:
    example.name.is_some();

    if let Some(name) = example.name {}

    // matches are exhaustive and force you to provide an arm for every possibility, though there is a catch-all available for other situations
    match example.name {
        Some(name) => name,
        None => String::from(""fallback name""),
    }
    // etc

Above all else though, it's nicest because the entire ecosystem - from the standard library to third-party crates - utilises them.

I also really love the fact that the type system is runtime. If you've ever written a backend in TS and had to resort to using io-ts, Joi, etc to verify external data, you'll know how unergonomic that is.

I really enjoy learning new languages, you always learn new concepts!",1537791111.0
apemanzilla,"Definition files are necessary for Typescript to know what members are exported by modules, and their types. Without them, you lose some or all of the type safety, which is the entire point of Typescript in the first place.",1537717275.0
__trixie__,"You can’t ‘import’ js files because js is dynamic - there’s no way to tell what the definitions are of the things you’re importing. 

You don’t have to use definition files if you don’t want to, ‘declare var jslib: any’, but if you want the benefits of static typing you either need to find or create them.",1537723744.0
Jukibom,"If you can't find the declaration files for those that you need and don't have time to build your own, don't be discouraged! Just declare them as `any`, add a `// TODO` and move on with your day. I found getting started to be a little overwhelming at first but remember TypeScript is intended to overall assist your day to day, not hinder. You can still use those libraries like you always did with the proviso that you won't get any benefit *for those libraries*. The _rest of your code_ will still benefit greatly, and it won't get in the way of learning the language.",1537732589.0
cspotcode,"You can `declare module ""yadda-yadda"";` and it'll stop complaining about the yadda-yadda module.",1537735575.0
Rhyek,"How does it work? Is it watching for changes made to package.json? Does it also work with yarn?

Edit: Nvm, it does listen for changes. Guessing it works with yarn just fine. Will definitely be installing this. Great work! ",1537736101.0
Exac,"After installing the addon and reloading, then entering `npm i --save lodash` into my VS Code console, it get an error when I try to import lodash: `import * as _ from 'lodash;`

Error:

>\[ts\] Could not find a declaration file for module 'lodash'.'c:/Users/Exac/Documents/example/node\_modules/lodash/lodash.js' implicitly has an 'any' type. Try `npm install @types/lodash` if it exists or add a new declaration (.d.ts) file containing \`declare module 'lodash';

`@types/lodash` is not added to my `package.json`, as I would expect.

Using React & Typescript.

&#x200B;",1537662507.0
Kenya-West,I prefer [types-checker](https://github.com/salimkayabasi/types-checker),1537707546.0
theTypeScripter,Tell Uber to use OvernightJS instead of NextJS,1537930092.0
grinde,"TypeScript is just annotations - casts don't exist at run time, so best case you're just filling the `children` array with plain objects. You have to go through the child array and instantiate an actual `Panel` instance for each one. That includes having to populate missing properties, as they'll still just be undefined otherwise.

Also, you've cast a string to a `Panel` object? The compiler should raise an error there. And I suspect your use of `Object.assign` is simply bypassing type checking.",1537574861.0
Aior,Look into package class-transformer,1537605067.0
Ebuall,The better way here would be to separate your logic from data. OOP is not the best use-case for tree-like pure data.,1537628313.0
jonnyboyC13,"Have you tried debugging this? my guess is the child objects aren't actually getting constructed. They must still be plain objects because otherwise they would have the Panel prototype and could call add panel. Perhaps you could do something like thing.

&#x200B;

    constructor(json?: Partial<Panel>) {
      if (json) {
        Object.assign(this, json);
        const { children } = json;
        if (children && children.length > 0) {
          this.children = children.map((c) => new Panel(c));
        }
      }
    }

&#x200B;",1538248520.0
demoran,`this.jsonPanel` is a string.  Your constructor expects a `Partial<Panel>`.,1537576917.0
alexendoo,"Because it is part of the DOM API, previously as a de facto implementation by browsers but it does have a WHATWG spec now. Node happens to implement a couple methods from DOM land, for example this and `setTimeout`/`setInterval`

You don't have to include the DOM TypeScript definitions though to get it working, [`@types/node`](https://www.npmjs.com/package/@types/node) has definitions for the console global, as well as all the builtin modules",1537563691.0
cloudify,Unfortunately you lose type information in the passage from the middleware to the controller. I my projects I follow [this approach](https://federicoferoldi.com/2017/12/28/using-the-typescript-type-system-to-validate-express-handlers.html) for maximum type safety (compile time checks for requests params and response types).,1537565399.0
TovrikTheThird,"[class-transformer](https://github.com/typestack/class-transformer) from the same team might be what you are looking for. Typestack has a ton of libraries that all work very cleanly together. I also suggest [routing-controllers](https://github.com/typestack/routing-controllers), [typedi](https://github.com/typestack/typedi), and [typeorm](https://github.com/typeorm/typeorm) (which is technically by the same devs under a different moniker).

",1537567590.0
DuckDesk,"use [class-transformer](https://github.com/typestack/class-transformer) it's made by the same guy who made class-validator and they're designed to work together.

This may be a little off topic but you might want to checkout [nestjs](https://nestjs.com/). It's a framework that that make's what you're doing (plus some other things) easier and much elegant, then if you were to do everything yourself in express",1537579628.0
Ebuall,"1. This is function overloading. A few function signatures can be joined into one interface. In Javascript functions are just objects and in Typescript `interface` can define not only it's properties, but also `callable` and `newable` signatures.
2. In Javascript `this` is dynamically scoped, you might have heard about it strange behaviour. Since you call `get` method on your own `Server`, it will see your `Server` as it's `this` instead of a `Router`.",1537556324.0
surely_not_a_bot,"It's a [generic](https://www.typescriptlang.org/docs/handbook/generics.html); generic classes in your specific examples. Those are classes that can manipulate a certain type of object without needing to be explicit about what types they accept in their declaration. For example, a `list: Array<string>` is an array of strings, which means that doing `list[0]` will return a string, you can only `push()` strings, etc. That's the same class implementation as an `Array<number>` or `Array<SomeCustomClass>`. Otherwise the only solution would be to have a custom class for each type.

Generic parameters apply differently to each class, depending on how they implemented it. `Promise<string>` means that the promise's resolved value is a `string`, so when you do `then((res) => {})` TypeScript knows that `res` will be a string. `React.Component<string>` doesn't make sense, since normally for React components the first generic is the Props type declaring the interface for the component's props (e.g. `React.Component<IProps>`).",1537539355.0
Ebuall,Parametric polymorphism.,1537550153.0
AngularBeginner,"So simple, and yet it requires three dependencies...",1537529488.0
,"How does the implementation of `unwrap` work? If the input is a Promise, does the type not say that it extracts the value from inside the Promise?",1537484895.0
demoran,Surely I'm not the only one who thinks that api paradigm is completely insane.,1537526965.0
MosquitoD4K,"I like to promisify my whole codebase :-), thanks for the Unwrap types. TypeScript is just awesome. This kind of typemapping should also be available in C#

            import { BehaviorSubject, Observable } from 'rxjs';
            
            type primitive = Date | string | number | boolean | undefined | null;
            
            type Unwrap<T> =
                T extends Promise<infer U> ? UnwrapSimple<U> :
                // Optional
                T extends Observable<infer U> ? UnwrapSimple<U> :
                UnwrapSimple<T>;
            
            type UnwrapSimple<T> =
                T extends primitive ? T :
                T extends Array<infer U> ? UnwrappedArray<U> :
                T extends object ? UnwrappedObject<T> :
                T;
            
            interface UnwrappedArray<T> extends Array<Unwrap<T>> { }
            
            type UnwrappedObject<T> = {
                [P in keyof T]: Unwrap<T[P]>;
            };
            
            export const unwrap = async <T>(val: T): Promise<Unwrap<T>> => {
                if (val === undefined || val === null) {
                    return undefined;
                }
            
                if (val instanceof Promise) {
                    return await val;
                }
            
                if (val instanceof Array) {
                    return <any>await Promise.all(val.map(a => unwrap(a)));
                }
            
                // Optional unwrap Behavior
                if (val instanceof BehaviorSubject) {
                    return val.getValue();
                }
            
                // Optional unwrap first element
                if (val instanceof Observable) {
                    return await val.toPromise();
                }
            
                if (typeof val === 'object') {
                    let result = {};
                    for (let key in val) {
                        result[<string>key] = await unwrap(val[key]);
                    }
                    return <any>result;
                }
                return <any>val;
            };
            
            export const example = async () => {
                let unwrapped = await unwrap({
                    promiseTest: new Promise<number>((resolve) => { resolve(10); }),
                    arrayTest: [123, 'Hello', new Promise<string>((resolve) => resolve('abc'))],
                    anything: new Date()
                });
            
                let numb: number = unwrapped.promiseTest;
                
                // Tupples do not work :-(
                let array: number | string = unwrapped.arrayTest[0];
                let array2: number | string = unwrapped.arrayTest[1];
                let array3: number | string = unwrapped.arrayTest[2];
            
                let anything: Date = unwrapped.anything;
            };",1537517265.0
AngularBeginner,"Should mention that the compiler does NOT do any kind of sanity checks. When using function overloading you're responsible yourself that the implementation makes sense.

This compiles just fine:

    function doStuff(kind: 'number'): number;
    function doStuff(kind: 'string'): string;
    function doStuff(kind: 'number' | 'string'): number | string {
        return Math.random() > 0.5 ? 'foo' : 123;
    }",1537475449.0
lukeautry,"Wouldn't generics for the first example be a little simpler?

    function colorShade<T extends RGB | string>(color: T, percent: number): T {
        ...
    }

Type inference works properly, TypeScript will prevent you returning from wrong type, etc.

For isDirty example, I'm not actually sure if this is better, but it could be a cool use case for conditional types, e.g.

    const isDirty = <T extends boolean>(id: number, asObservable: T): T extends true ? IObservable : INotObservable => {
      return {} as any;
    };",1537502135.0
dhruvrajvanshi,"It would've been much nicer if we could have proper recursive types in general. That would make it possible to recurse over regular tuple types instead of hacks using interfaces.

In one of the recent design notes, there's a mention of this but they rejected the idea for now with some explanation.

Meanwhile, they've added special case for mapped types over tuple types which makes them a bit nicer to use but doesn't allow full expressiveness with tuples. So yeah now you can map over proper tuples using mapped types (in pre release) but you can't do something like replace every second element of tuple with string type or something like that.",1537468364.0
hmongoose,"I am looking for suggestions to overcome the limitations stated in the code comments. I didn't expect to get this close to a working snippet. Variable length tuples seemed way out of reach, but this shows it could actually work! Do you guys know of similar attempts? Did anyone succeed in making a useful framework out of something like this?",1537461650.0
alsiola,"Regarding higher-order types, this is not currently possible in TypeScript (although there are some very hacky ways to get close to it). There is an issue in their repo - https://github.com/Microsoft/TypeScript/issues/1213

I can't find any way to get around the recursive type issue, but others might.",1539100835.0
grinde,"Yup it's definitely possible. Use a tuple to describe the desired parameters. Here's a version that should work as a drop-in for your example (works for zero or one arguments) - [playground link](https://www.typescriptlang.org/play/index.html#src=type%20OptionalArgTuple%3CT%3E%20%3D%20T%20extends%20undefined%20%3F%20%5B%5D%20%3A%20%5BT%5D%3B%0D%0Atype%20Callback%3CT%3E%20%3D%20(...params%3A%20OptionalArgTuple%3CT%3E\)%20%3D%3E%20void%3B%0D%0A%0D%0Aexport%20class%20Dispatcher%3CT%20extends%20any%20%3D%20undefined%3E%20%7B%0D%0A%20%20%20%20listeners%3A%20Callback%3CT%3E%5B%5D%20%3D%20%5B%5D%3B%0D%0A%0D%0A%20%20%20%20addListener(callback%3A%20Callback%3CT%3E\)%20%7B%0D%0A%20%20%20%20%20%20%20%20this.listeners.push(callback\)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20dispatch(...params%3A%20OptionalArgTuple%3CT%3E\)%3A%20any%20%7B%0D%0A%20%20%20%20%20%20%20%20for%20(let%20i%20%3D%200%3B%20i%20%3C%20this.listeners.length%3B%20i%2B%2B\)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20this.listeners%5Bi%5D(...params\)%3B%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F%20Dispatcher%20with%20no%20type%20given%0D%0Aconst%20dispatcher%20%3D%20new%20Dispatcher(\)%3B%0D%0Adispatcher.addListener(param%20%3D%3E%20%7B%20%2F%2F%20this%20should%20give%20an%20error%0D%0A%0D%0A%7D\)%3B%0D%0Adispatcher.dispatch(\)%3B%20%2F%2F%20this%20should%20not%20give%20an%20error%0D%0A%0D%0A%2F%2F%20dispatcher%20with%20given%20type%0D%0Aconst%20dispatcher1%20%3D%20new%20Dispatcher%3Cstring%3E(\)%3B%0D%0Adispatcher1.addListener(param%20%3D%3E%20%7B%20%2F%2F%20this%20should%20be%20ok%0D%0A%0D%0A%7D\)%3B%0D%0Adispatcher1.dispatch(\)%3B%20%2F%2F%20this%20should%20give%20an%20error):

    type OptionalArgTuple<T> = T extends undefined ? [] : [T];
    type Callback<T> = (...params: OptionalArgTuple<T>) => void;

    export class Dispatcher<T extends any = undefined> {
        listeners: Callback<T>[] = [];

        addListener(callback: Callback<T>) {
            this.listeners.push(callback);
        }

        dispatch(...params: OptionalArgTuple<T>): any {
            for (let i = 0; i < this.listeners.length; i++) {
                this.listeners[i](...params);
            }
        }
    }

    const noArgDispatcher = new Dispatcher(); // or new Dispatcher<undefined>()
    const stringDispatcher = new Dispatcher<string>();

Note that it might be better to use `never` instead of `undefined` for your no-arg type so that you can use undefined when you need truly optional args (ie `Dispatcher<undefined | number>`).

This simpler version will work for any number of arguments (note your generic type argument should be a tuple for this one):

    type Callback<T extends any[]> = (...params: T) => void;

    export class Dispatcher<T extends any[] = []> {
        listeners: Callback<T>[] = [];

        addListener(callback: Callback<T>) {
            this.listeners.push(callback);
        }

        dispatch(...params: T): any {
            for (let i = 0; i < this.listeners.length; i++) {
                this.listeners[i](...params);
            }
        }
    }

    const noArgDispatcher = new Dispatcher(); // or new Dispatcher<[]>()
    const stringDispatcher = new Dispatcher<[string]>();
    const multiArgDispatcher = new Dispatcher<[string, number]>();",1537454188.0
Ebuall,"Looks like making a type like this

    type Callback<T> = T extends undefined ? (param?: T) => void : (param: T) => void;

makes it completely unusable. Probably bug, but not sure.",1537435721.0
,"I don't think there is a sound way to implement the class (without using `as`). But here is a possible solution that lets you use the class in a way that might work:

    type Callback<T,Default> = T extends Default ? () => void : (param: T) => void;

    declare const dispatchDefault: unique symbol;
    type Default = typeof dispatchDefault;
 
    export class Dispatcher<T = Default> {
        listeners: Callback<T, Default>[] = [];

        addListener(callback: Callback<T, Default>) {
            this.listeners.push(callback);
        }

        dispatch: Callback<T, Default> = ((param: T) => {
            for (let i = 0; i < this.listeners.length; i++) {
                const f = this.listeners[i] as (param: T) => void;
                f(param);
            }
        }) as Callback<T, Default>;
    }",1537436602.0
cspotcode,"If the arguments of dispatch are described by a tuple, you can use conditional types to figure out the tuple.  It might work.

Something like `dispatch (...args: ConditionalTuple<T>)`",1537448583.0
kwiwksh,"Two projects exist in this realm.


TS Node acts as an interpreter for TypeScript, so you can run a server with `ts-node thing.ts`. It will compile/transpile internally.
https://github.com/TypeStrong/ts-node

Deno is still very much in development. I don't know much about it, but as far as I know, its supposed to be a true TypeScript run-time. 
https://github.com/denoland/deno

For production deployments, I would recommend against both of these. I've found TS Node to be useful in running tests, coverage and development environments. Any production deployment or package should have its compiled artifacts distributed.
",1537377511.0
EarlMarshal,Take a look at deno. Still in progress but it will probably make it's way to a mature platform.,1537382523.0
cspotcode,"ts-node is your best bet.  It *technically* transpiles each file on-demand as it loads, but the transformation is totally in memory, so you can kinda think of it like a JIT.  Kinda.

Regardless, it works really well and I use it as a replacement for `node` on most projects.",1537394677.0
twomousepads,"It's possible!  You can run TypeScript modules directly by using [ts-node](https://github.com/TypeStrong/ts-node).  I'll sometimes do this because it's easier to attach a debugger, but I suspect most folks will want you to transpile your code and run it on node proper in production.",1537377427.0
samjmckenzie,Looks great. Nice job!,1537392453.0
welkie,Any advantage to this over Nest?,1537391193.0
BurritoBashr,Any differences with [TypeStack's routing-controllers](https://github.com/typestack/routing-controllers/)?,1537395593.0
pspeter3,This is really interesting. It seems like that you're using method decorators to automatically transition states. The two things I'm not sure about are why you're using a gene analogy and when this would be useful,1537366418.0
AngularBeginner,Disabling strictness features of TypeScript makes the devs sad. :-(,1537374563.0
AngularBeginner,"You have a type bug because you use `Partial<T>` to create a full `T` at: https://github.com/voodooattack/when-ts/blob/master/src/historyManager.ts#L66

`Partial<T>` is not suited for this case.",1537375252.0
,"Re: 

    // If your compiler or linter isn't checking for unused variables, you can do an exhaustiveness check manually.
    // However this won't be necessary if you have strictNullChecks enabled.
    // const _exhaustiveCheck: never = pasta;

It might be worth highlighting the case where you have a switch that does something in each case but doesn't necessarily return, in which case you cannot use implicit exhaustiveness checking and you might want to do it explicitly to ensure each case gets handled. Something like:

    export const placeOrder = (pasta: Pasta): void => {
        let company: string;
        let tel: string;
        switch (pasta.name) {
            case PastaName.Spaghetti:
            case PastaName.Linguini:
                company = ""Strand Pasta Co."";
                tel = ""111111111"";
                break;
            case PastaName.Rigatoni:
            case PastaName.Shells:
                // Set some variables, do some side-effects
                break;
            case PastaName.Ravioli:
            case PastaName.Tortellini:
                // Set some variables, do some side-effects
                break;
            default: const _assertNever: never = pasta;
        }
        order(company, tel);
    }

(Sorry if this is covered and I missed, and also sorry for the horribly contrived example).",1537291469.0
unsung_unshift,"Yeah, build a time machine, go back a week or more, and start preparing then",1537314776.0
WebDevLikeNoOther,Looks pretty shit to me.,1537249550.0
JoshuaScript,"Feedback is welcome. Also, I'd love to see what themes everyone makes with these, especially if you end up publishing them to the VS Code marketplace/Sublime Package Control.

Here's a link to the live site: [http://pictheme.herokuapp.com/](http://pictheme.herokuapp.com/)

&#x200B;",1537186857.0
son_of_meat,Downvoted because the README doesn't do a good job of explaining what the project does or what it's good for.,1537132225.0
Charles_Stover,"Read some documentation in typing, then dive right in. TypeScript is pretty good at telling you what it expects.",1536967683.0
Devcon4,"It's pretty easy, I imagine when you write code you already think in ""objects"" but now you don't have to Ctrl+f all the time to remember what it looks like. And writing advanced types is fun. I think of them like a little puzzle, I could use a bunch of anys and pass but if I want to get a gold star and 100% I figure out how to do some advanced types. ",1536969107.0
r0ck0,"This is great: https://basarat.gitbooks.io/typescript/ - in fact one of the best guides I've found on any subject about anything.  I rate it up there with the Arch wiki.

I'd recommend reading through all of it if you can, even the sections you might already know about.  Will probably pick up some extra tips along the way.  

The amount of detail for something like this is ""just right"" I think... covers the kind of stuff you want to know while getting into TS, not too little, or too much.    

For more detail, you can go to the official TypeScript docs afterwards (some of which I found confusing when starting with that as my 1st source of info).

That's one issue I've found with a lot JS documentation in general, and even the one-liner NPM package descriptions... they assume you know about a bunch of other things before you read their stuff, it makes it all very confusing when getting started when there's about 10 terms being used that you're not familiar with (I'm coming from 19 years of PHP, and this has been a bit of a frustration with JS doco/READMEs etc in general).  I've found this TS guide makes much fewer assumptions like that.

Also, so many guides explain the ""what"" and ""how"", but miss the important ""when"" and ""why"" explanations that help you remember stuff.  

I find it very hard to remember much if I can't envisage what I would actually use it for.",1536984447.0
villiger2,"Echoing what everyone else said, also use VSCode. It's the best editor for typescript (it's made by people who made typescript and written in typescript).",1536984697.0
ThisAccountIs4Reddit,"If you want some help from the compiler, set some [strict flags](https://www.typescriptlang.org/docs/handbook/compiler-options.html) like 'noImplicitAny' and 'noUnusedLocals'. That helped me when converting old JavaScript to TypeScript. Other than that, start making some classes and functions with explicit typings, and import them around. Try some abstract classes and interfaces as well to get some good architecture going. Once you get those designs down, you can start some advanced features like optional parameters. ",1536970746.0
i_spot_ads,"Extremely easy, just read the manual",1536990988.0
cspotcode,"Do you have a CS education?  My career made me a JS  expert; my education taught me about generics, type systems, and design patterns.  That made TypeScript feel like a no-brainer.",1537048022.0
joncaris,"If you've been using a lot of the es6 features already, you're most of the way there. The type system is pretty easy to get the hang of, just avoid using 'any'. I agree with others that the feedback you get from the compiler will have you up to speed in no time.",1536978780.0
pagalvin,"I wrote a free book that you may find helpful: [https://pagalvin.gitbooks.io/yet-another-typescript-book/content/](https://pagalvin.gitbooks.io/yet-another-typescript-book/content/)

As previously mentioned, the Basarat book is also great :).",1537011774.0
theTypeScripter,"I'm writing a book on full-stack development with TypeScript. [PeatTutorial.com](https://PeatTutorial.com). It's not finished yet, still got about 2 more chapters. ",1537392454.0
demoran,"Types describe the shape of an object.  Generics are simply types baked into the class or function definition, to describe the stuff that goes in or out.

For example, I have a generic post method to help build my api methods:

    export async function apiPost<TDto, TResult>(
      path: string,
      dto: TDto
    ): Promise<TResult> {
      const init = await getInit('POST');
    
      init.body = JSON.stringify(dto);
    
      return api<TResult>(getApiUrl(path), init);
    }

This way the stuff that uses apiPost knows what goes in and what goes out.

In the case of React, you'll move away from using PropTypes and into `Component<Props, State>`, which will give you strong typing on your component.

",1536972527.0
slipwalker,"if i understood you correctly, you want to split each line ( on the comma ) into an array of columns, and process the resulting data whichever way your heart desires...

take a look at this module: 
https://www.npmjs.com/package/rawiki-parse-csv

hope it helps.",1536943937.0
Yxven,Am I missing something? Can't you just split the row with a comma and then the 4th index will be the translation?,1536943994.0
EarlMarshal,"I think the other people here already pointed out how you could achieve it but in my opinion you should just use a library for that (if it isn't about just learning stuff). CSV is an old topic and there are probably hundreds of libs for that.

What I would also propose is to use a library that directly works with buffers & views because that will be a lot faster than string manipulation. A quick Google gave me this:

https://www.npmjs.com/package/csv-parser",1536959405.0
Aduvanas,Thank you everyone for your time and input. I had a feeling that I am over complicating things. Nice to hear other people opinion and their approach on the same topic. Much appreciated!,1536998325.0
cspotcode,"I'm curious, is it reproducible in the TypeScript playground?",1536939998.0
,It does. Look up the `abstract` keyword. You can have abstract classes and methods in it.,1536898348.0
cspotcode,It does support abstract classes.  Try it out in the TypeScript playground and let us know what you think.  Google is your friend for this.,1536902778.0
wrensdad,"I'm sorry this doesn't answer your question and is just an unsolicited personal opinion.

&#x200B;

I try not to treat typescript as a ""full"" OO language. Minimal usage of inheritance class state. I write more functionally because I think it's a style better suited to the language.",1536899706.0
kwiwksh,"Calling TypeScript ""object oriented"" doesn't seem right. It has object oriented elements, in the same way it has functional elements. Its not as multi-paradigm as C++, but in a similar vein. As others have mentioned. TS definitely has the concept of abstract classes; however I tend to not use them in preference of interfaces as its easier to initialize from them since they more accurately represent JSON.",1536948938.0
UnityNorway,"It does support abstract classes (untested);

    export abstract class Person {
        protected readonly firstName: string;
        protected readonly lastName: string;
    
        protected constructor(firstName: string, lastName: string) {
            this.firstName = firstName;
            this.lastName = lastName;
        }
    
        public greet() {
            return ""Hello, "" + this.firstName + "" "" + this.lastName;
        }
    }
    
    export class Student extends Person {
        public constructor(firstName: string, lastName: string) {
            super(firstName, lastName);
        }
    }
    
Then:

    const student = new Student(""John"", ""Doe"");
    console.log(student.greet());
    ",1537010383.0
empty_other,"About extending the Error object and filter by ""instanceof"", it doesn't work. You will need a workaround. Read more here:

[https://stackoverflow.com/questions/47941324/inherited-exceptions-and-instanceof](https://stackoverflow.com/questions/47941324/inherited-exceptions-and-instanceof)  
[https://stackoverflow.com/questions/41102060/typescript-extending-error-class](https://stackoverflow.com/questions/41102060/typescript-extending-error-class)

I created a new class ""BaseError"", then manually set the \_\_proto\_\_ property (like they described in those posts), and have all my custom errors extending the new BaseError class. Then it worked.",1537067048.0
Max_Stern,">Given all of this, we felt that it would be better to make TypeScript a  bit “smarter” about these sorts of patterns. In TypeScript 3.1, for any  function declaration or const declaration that’s initialized with a function, the type-checker will  analyze the containing scope to track any added properties.

Nice.",1536916145.0
recursive,It still shows `BigInt` in the [3.1 milestone](https://github.com/Microsoft/TypeScript/milestone/74) but it's not in the RC.  Is it getting bumped again?,1536945225.0
mikejoro,"Really not liking the breaking change regarding function type checking. Why wouldn't that code work? This seems like they couldn't fix a bug, so they called it a breaking change. Solid stuff otherwise, but I just don't understand why typescript should choke on the example given. Could someone explain if I am misunderstanding? ",1536927474.0
,"I'm not sure if this fits your spec but I gave it a go.

    enum Toppings {
        pepperoni,
        cheese
    }

    function toArray(x: { [idx: number]: string }): string[] {
        const result: string[] = [];
        let i = 0;
        while (x[i] !== undefined) {
            result.push(x[i]);
            i++;
        }
        return result;
    } 

    const asArray = toArray(Toppings); // asArray = [ 'pepperoni', 'cheese' ]

",1536865211.0
loopsdeer,"I'm new to typescript, so I'm gonna throw out my thinking for commentary:

&#x200B;

I think what you're looking for is Enums (enumerations), a common pattern that describes a group of unique items: [https://www.typescriptlang.org/docs/handbook/enums.html](https://www.typescriptlang.org/docs/handbook/enums.html)

&#x200B;

The problem with enums is that you can't add info/functionality to them. So later if you want each topping to also have a ""applyToPizza"" method, you're SOL unless you want to use a switch/case statement which will have to be edited for each new topping type. In general, I would suggest an OOP hierarchy like:

    const toppings : object = {};
    
    interface ITopping
    {
        name : string;
    }
    
    class Pepperoni implements ITopping
    {
        name : string = ""pepperoni"";
    }

Now you can add new features to ITopping and know exactly where to implement it. If you want Intellisense, just make that `class ToppingPepperoni`. If you really want to remove this duplication, you can make a class-generating factory.

    function createTopping(name : string)
    {
        // Create an anonymous class
        let clazz =
            class implements ITopping 
            {
              name : string = name;
            }
    
         // Add to your list of toppings (though this wouldn't auto-generate a list for you)
         toppings[name] = clazz;
    
         return clazz;
    }
    
    // No duplication :-D
    createTopping(""pepperoni"");

Consider that (even in the basic Enum case) your issue is not really duplication, though, in the DRY sense. DRY refers to repetition in functionality, not merely the code itself. The class name and static property ""name"" have different functions: to communicate info in two different domains, one human-readable and the other type-checkable.

&#x200B;

Again, I'm also new to TypeScript so would love commentary (since I use this approach). I do hope this helps, though, OP. Cheers.",1536866053.0
grinde,"Something like this maybe?

    interface ResultInterface<T extends (...args: any[]) => any> {
        fn: T;
    }

    function someFactory<T extends (...args: any[]) => any>(fn: T): ResultInterface<T> {
        return { fn };
    };",1536835902.0
Arthanos,"If I'm understanding you correctly, [hopefully something like this is what you mean](http://www.typescriptlang.org/play/#src=%2F%2F%20%22some%20keys%20who's%20types%20are%20easy%22%0D%0Ainterface%20WellKnownObj%20%7B%0D%0A%20%20a%3A%20any%3B%0D%0A%20%20b%3A%20any%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20Bar%3CT%20%3D%20\(...args%3A%20any%5B%5D\)%20%3D%3E%20any%3E%20%7B%0D%0A%20%20\(fn%3A%20T\)%3A%20WellKnownObj%20%26%20%7B%20originalFunctionArgument%3A%20T%20%7D%0D%0A%7D%0D%0A%0D%0Aconst%20Foo%3A%20Bar%20%3D%20\(fnArg\)%20%3D%3E%20%7B%0D%0A%20%20const%20wellKnownObj%3A%20WellKnownObj%20%3D%20%7B%0D%0A%20%20%20%20a%3A%201%2C%0D%0A%20%20%20%20b%3A%202%0D%0A%20%20%7D%0D%0A%0D%0A%20%20return%20%7B%0D%0A%20%20%20%20...wellKnownObj%2C%0D%0A%20%20%20%20originalFunctionArgument%3A%20fnArg%0D%0A%20%20%7D%0D%0A%7D).

",1536819436.0
Exac,"Does something like this work for you?

    yourFunction(handler: (...args: any[]) => void) {
      // function
    }",1536818273.0
cspotcode,"The TypeScript compiler is written in a merged namespace style, but they don't use es6 exports or imports.  So all the code is essentially concatenated together.",1536804447.0
cspotcode,"I use a no-op decorator to statically enforce constructor interfaces.

[https://github.com/cspotcode/typescript-toolbelt/blob/master/src/classes-and-mixins-values.ts#L7-L23](https://github.com/cspotcode/typescript-toolbelt/blob/master/src/classes-and-mixins-values.ts#L7-L23)

You can install it from here, along with a bunch of other goodies: [https://www.npmjs.com/package/typescript-toolbelt](https://www.npmjs.com/package/typescript-toolbelt)

...but it's just a one-liner.

Usage looks like this:

    import {AssertConstructorImplements} from 'typescript-toolbelt';
    @AssertConstructorImplements<CMyClass>()
    export class MyClass implements IMyClass {
        //...

If you really don't want to enable decorators, you can do this:

    import {AssertConstructorImplements} from 'typescript-toolbelt';
    // wrap in a function that is never executed, because we only care about the static typecheck, and we want to write this near the top of the class, not wait till after the class body when it's declared
    () => {AssertConstructorImplements<CMyClass>()(MyClass);}
    export class MyClass implements IMyClass {
        // ...

Or if you're ok placing the assertion after the class body:

    } // end of MyClass body
    AssertConstructorImplements<CMyClass>()(MyClass);

Let me know if you have any questions.",1536801119.0
loopsdeer,The \`instanceof\` type guard does not seem to work with \`myInstance instanceof MyClass\`. Really wanted this to be a complete solution.,1536791237.0
Kritner,Hey it's a me! ❤️ Hopefully these are useful for someone! ,1536964339.0
AngularBeginner,Those packages are really spreading like weed these last days.,1536767131.0
cspotcode,"Did you figure out a way to remove the last item from a tuple?  I occasionally need to do this with APIs that accept a callback as a last argument, if I pass them through a promisifier.

I guess I can do this:

    type Tuple = [1, 2, 3, 4];
    type AllButLast = Reverse<RemoveFirst<Reverse<Tuple>>>; // [1, 2, 3]
    
    type RemoveFirst<T extends any[]> = ((...args: T) => void) extends ((a: any, ...rest: infer Rest) => void) ? Rest : never;

Also, why is there a utils namespace and then other types with the same name that delegate to utils?  Is it to make type tooltips look cleaner?",1536804078.0
slikts,"Here's [a TypeScript a tuples implementation][tuplerone] for runtime. How difficult would it be to adapt these helpers to work with that custom tuple type?

[tuplerone]: https://github.com/slikts/tuplerone",1536848000.0
cspotcode,"Nice!  Lots of cool stuff here, and I learned something new checking out the code: you can index into `SomeTupleType['length']` and get a numeric literal type.",1536801849.0
slashess,Types don't exist at runtime. There are libraries to validate the structure of objects though: [io-ts (for example)](https://github.com/gcanti/io-ts).,1536763630.0
,"Generally having a generic parameter only appearing in a covariant position is a red-flag because you're asking the program to conjure everything out of nothing. You need a way to inform the program what you expect `T` to be at runtime: something like:

    function request<T>(url: string, check: (val: any) => T): Promise<T> {
        return fetch(url)
            .then((resp) => resp.json())
            .then((result: any) => check(result));
    }

Note that there is now a `T` in a contravariant position, this is where information flows in. The `check` function can be implemented in a multitude of ways (JSON validation seems to be the 'in' thing right now with a wide variety of libraries, I'll just write a basic function).

    function checkChar(val: any): Car {
        if (typeof val === ""object"" &&
            typeof val.model === ""string"" &&
            typeof val.year === ""number"") {    
            return val;    
        }
        throw ""not a car -- you'll want to handle this gracefully!""
    }

This is the function that checks if an object is a `Car`. A more type-safe version would be to replace `any` with `unknown`, but the narrowing for `unknown` is pretty sparse currently so it's not that easy to work with.

Now I can do a request and validate the response, with no cast on the result:

    const car: Promise<Car> = request(""/api/car/1.json"", checkChar);

I'm not entirely sure this is what you meant, but I hope it helps!",1536763792.0
Thought_Ninja,"Neat; I'll have to give it a whirl when I have some free time. I'm most curious about your approach to the ""blueprint"" feature implementation. BTW, you have a typo in the last paragraph where you mention ""blueprint"".

I've actually been working on something similar as a personal typescript boilerplate: react (w/ ssr & code splitting similar to next.js), redux & rxjs for state, hapi.js, socket.io, redis for pubsub across cluster, postgres, and nginx. I'm using docker-compose for local development, and kompose for kubernetes deployment.",1536780797.0
sindresorhus,"You might also like [`emittery`](https://github.com/sindresorhus/emittery) which also is type-safe, but has other benefits like being fully async.",1536730155.0
1alex1131,Aren't they typed already?,1536698886.0
MellerTime,"Well my first question would be why you’re dynamically importing it and whether you need to be. Assuming you do...

My other comment would be that you probably shouldn’t extend something if you’re dynamically importing it (or if it’s not part of your codebase in general), you should provide a wrapper around it instead so you can more easily adapt to changes in the underlying codebase with your abstracted class without changing the contract it provides. ",1536683762.0
evmar,"You never declare any relation between Dog, Test, or TestProps, so TypeScript thinks they're all unrelated.  I think this is not a TypeScript question, but rather a question about how to use this vue-property-decorator thingy.",1536678785.0
PhysicalRedHead,"TypeScript doesn't exist at runtime, so what you're trying to do is impossible. If you don't care about getting inference on property access, then you could do something like this:
```ts
interface Config {
  [key: string]: string
}
```",1536621894.0
AngularBeginner,"To properly format code on Reddit:

- Have an empty line between code and regular text.
- Indent every line by 4 spaces.

The ```-syntax does not work here. Reddit is not using Common Markdown.",1536645703.0
pobbly,Nice article for an exciting new API,1536648460.0
slashess,No documentation. ,1536758378.0
fllr,"What is this for, exactly?",1536592226.0
elprophet,"TL;Dr a variety of utilities to help with typing tuples, including First, Last, Reverse, Append, and Prepend",1536495489.0
slashess,"Tuple type operations are potentially useful for dynamically typing function factories. In other words, using this utility I can remove or insert the first parameter of a function in a generic and type safe way. The complex type system is there to make it easier to represent what is possible in javascript. While it's use case isn't for everyone directly, these type operations will allow some libraries to be properly typed.",1536758744.0
son_of_meat,"As far as I can tell, you wouldn't want or need to get webpack involved since in Node.js there's little/no advantage to minifying/concatenating. As far as production dependencies only, couldn't you just use the normal dependencies/devDependencies fields in package.json? Specifically on the build machine, do a full `npm install` and then generate the js from the ts using the TypeScript compiler (`tsc`) for your build step, then package up the whole directory using `npm pack` or whatever and upload it to AWS, which I assume will run `npm install --production` in the Lambda's container.",1536464031.0
info_dev,The Serverless framework will do all of that for you - they even have a template with that exact setup - use ‘serverless create -t aws-nodejs-typescript’ ,1536522033.0
jschr,[I have](https://github.com/jschr/vscodethemes). Happy to answer any specific questions you might have.,1536463873.0
toxi,"maybe you'll find this TS mono repo setup useful: http://thi.ng/umbrella - I'm using scoped packages, yarn workspaces & Lerna to be able to work on different packages at the same time, then compile them all in topological order into CJS modules. Take a look at the 25+ standalone example projects, which all use Parcel to bundle & minify. Also look at `scripts/build-example` for additional post-processing of bundles...",1536799236.0
cspotcode,"Setting up a webpack config to bundle your node code isn't crazy complex and should only take a couple hours to tweak, unless you have a lot of code doing stuff that webpack can't magically bundle.  E.g. relying on `__dirname` relative paths to read files via `fs` calls instead of `require()`.  Or some third-party dependencies might use native modules which webpack can't bundle.  For those, just declare them as an ""external"" in the webpack config and include their directory in the Lambda zip.  So most of you code will be bundled and minified, but those will be copied verbatim and loaded externally.

No need to compile your typescript via webpack's ts loader unless you really want to.  You can just `tsc` like normal and webpack the output in a second step.

But as others have mentioned, ""serverless"" is a tool to take care of all this stuff, and it sounds like exactly what you're looking for.",1537234119.0
BehindTheMath,"Look into generic rest parameters, introduced in TS 3.0.

https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#generic-rest-parameters",1536336393.0
grinde,"You're not actually constraining the type of the function passed into your constructor. `Function` will allow literally any function of any shape. Since you have a desired shape for your function you need to specify that because right now you could still instantiate any version of your class with any function (ie `new MyClass<[number, string]>((a: boolean) => ({ foo: 'bar' }))` will compile). If you tell the type system what you actually want, it's usually pretty good at inferring from generics:

    class MyClass<T extends any[], U extends any> {
        func: (...args: T) => U;

        constructor(func: (...args: T) => U) {
            this.func = func;
        }

        getValue(...args: T) {
            return this.func(...args);
        }
    }

    const add = new MyClass((a: number, b: number) => a + b);
    const cat = new MyClass((...strings: string[]) => strings.join(''));

    console.log(add.getValue(1, 2));
    // 3

    console.log(cat.getValue('Hello', ', ', 'world', '!'));
    // Hello, world!

",1536337694.0
LeanderT,"Instead of callback, use Promises, or better yet use Observables (rxjs).

The problem with callback is that your code can get very messy.

Promises/Observables on the other hand result in much more readable code.  
",1536667648.0
tme321,Are interfaces not enough?  You describe the methods you expect to see and the arguments you expect them to return.  What about that doesn't work (if possible provide an example)?,1536347100.0
Cmacu,"1. Create a node module (factory) that can install and load other node modules
2. Write detailed documentation of this module including all the available APIs of your application and how to access them
3. Create detailed tests and examples
4. Integrate your factory module into your application adding security, validations and settings",1536437177.0
elprophet,"For `Object.assign`, the spread operator does this better already.

    const a = { foo: 1, bar: 2 };
    const b = { bar: '', baz: 3 };

    const c = { ...a, ...b };
    // const c: {bar: string, baz: number, foo: number}

`Object.values` is already correctly typed (in [lib.es2017.d.ts](https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2017.object.d.ts#L26)):

    interface ObjectConstructor {
      values<T>(o: { [s: string]: T } | ArrayLike<T>): T[];
    }
    const d = Object.values(c);
    // const d: (string|number)[]


`isObjectEmpty` cannot work the way you want, because .length is runtime information. TSC cannot elide that property. Try simplifying this to `isArrayEmpty` and see what luck you have.

",1536323446.0
cspotcode,valuesOf is simple.  Return value is `Array<T[keyof T]>`,1536323030.0
cspotcode,"`isObjectEmpty` has to be boolean.  The problem is that type {} is compatible with {foo: any}.  The type system never forbids an object from having additional runtime properties.  So even if you made a conditional typing hack to detect when the type doesn't declare properties, it wouldn't match runtime behavior.

Plus the type system doesn't differentiate between enumerable and non-enumerable properties.",1536323443.0
RustyX,"I think a problem with your Object.assign is when the same property exists on Source and Target types, but is optional on Target, the result would keep the Source version whenever the Target version of that property is undefined. ",1536326799.0
flaccidopinion,"Following on from @cspotcode's answer; `isObjectEmpty` only makes sense at runtime because at compile time Typescript is trying to make compile time guarantees.

Imagine the type ..
```
type A {
  name: string;
}
```

If you passed an object/instance which satisfies `type A`, you are telling Typescript that this object *definitely* has a property `name` which has a value. There is no way for an object of type A to be empty; unless it's not actually an object of type A.

It may make sense for something which has only optional properties, eg.
```
type B = {
  name?: string;
  age?: number;
}
```

This allows for `isObjectEmpty` receiving `{}`, in the same you could assign `{}` to `type B` as well.
`const b: B = {}` is a valid assignment.

I'm not sure how this would work for a similar, but slightly differently stated type B ...
```
type B2 = {
  name: string | undefined;
  age: number | undefined;
}
```

Because looking up a value which isn't defined will give you `undefined`, but, when making an object of type B2, Typescript will force you to give the properties values, but you *can* give them the value `undefined`.. eg.
```
const b2: B2 = {
    name: undefined,
    age: undefined
};
```
This obviously plays out a little weird at run time ... is this object empty or not?
JS `for..in` still shows them; which makes sense, to me anyway.
And the generated JS code matches up as expected.

Some playing around in this playground link ... 
http://www.typescriptlang.org/play/#src=type%20B%20%3D%20%7B%0D%0A%20%20%20%20name%3F%3A%20string%3B%0D%0A%20%20%20%20age%3F%3A%20number%3B%0D%0A%7D%0D%0Aconst%20b%3A%20B%20%3D%20%7B%7D%3B%0D%0Aconsole.log('b%20..')%3B%0D%0Afor%20(const%20k%20in%20b)%20%7B%0D%0A%20%20%20%20console.log(k)%3B%0D%0A%7D%0D%0A%0D%0A%0D%0Atype%20B2%20%3D%20%7B%0D%0A%20%20%20%20name%3A%20string%20%7C%20undefined%3B%0D%0A%20%20%20%20age%3A%20number%20%7C%20undefined%3B%0D%0A%7D%0D%0Aconst%20b2%3A%20B2%20%3D%20%7B%0D%0A%20%20%20%20name%3A%20undefined%2C%0D%0A%20%20%20%20age%3A%20undefined%0D%0A%7D%3B%0D%0Aconsole.log('b2%20%20..')%3B%0D%0Afor%20(const%20k%20in%20b2)%20%7B%0D%0A%20%20%20%20console.log(k)%3B%0D%0A%7D%0D%0A",1536342386.0
cspotcode,The built-in typings for `Object.assign` preserve any function or construct signatures of the first argument.,1536323536.0
_xiphiaz,"It is more discoverable, as in when you’re typing the reducer you can type ‘ActionTypes.’ And your IDE will prompt with all the possible actions on that enum. This also helps in your components where the action is dispatched",1536307721.0
demoran,I use a discriminated union of string literals.,1536327421.0
xela88,"Benefits:
  - Because it forces you to use enum value, you can change it's value in one place vs. find+text replace, makes refactoring super easy. If you are disciplined about using the constant then pretty much the same.
  - Exhaustive checking, can verify all actions are covered easily
  - Gives you a runtime obj to play with

Downsides:
 - When you compare the enum to string for some reason, can be tricky
 - In TS2.4 at least, objects can only be keyed by string or number, not enums. This is a huge PITA. So a mapping from action types will not be possible easily e.g. {[enum.ACTION]: () => ...} Will throw an error in most cases.

Personally I find the benefits of using enums (as string unions with a runtime element) outweigh the downsides, and even moreso in TS3.0 ",1536599734.0
cspotcode,Framework for what?  Headline doesn't give any indication.,1536338405.0
,"Using the standard definition of Pick.

    declare function pick<T, K extends (keyof T)[]>(obj: T, ...keys: K): Pick<T, K[number]>;

Alternatively, replace `???` with `K[number]` in your custom definition.",1536255056.0
,"Maybe something like?

    declare namespace ReturnCode {
        type Ok = 1;
        type Cancel = 2;
        type Abort = 3;
        type Retry = 4;
        type Ignore = 5;
        type Yes = 6;
        type No = 7;
        type TryAgain = 10;
        type Continue = 11;
    }

    declare function MessageBox(message: string, title: string, type: 0): ReturnCode.Ok;
    declare function MessageBox(message: string, title: string, type: 1): ReturnCode.Ok | ReturnCode.Cancel;
    declare function MessageBox(message: string, title: string, type: 2): ReturnCode.Abort | ReturnCode.Retry | ReturnCode.Ignore;
    declare function MessageBox(message: string, title: string, type: 3): ReturnCode.Yes | ReturnCode.No | ReturnCode.Cancel;
    declare function MessageBox(message: string, title: string, type: 4): ReturnCode.Yes | ReturnCode.No;
    declare function MessageBox(message: string, title: string, type: 5): ReturnCode.Retry | ReturnCode.Cancel;
    declare function MessageBox(message: string, title: string, type: 6): ReturnCode.Cancel | ReturnCode.TryAgain | ReturnCode.Continue;
    declare function MessageBox(message: string, title: string, type: number): number;",1536249295.0
twomousepads,"It sounds like you want to use TypeScript to interact with the DOM.  You're in luck!  TypeScript has the DOM types built in!  All you need to do is add 'dom' to the lib configuration in your tsconfig and you'll have access to all the DOM types.

[Here's an example of a tsconfig](https://github.com/jmptr/ephemeral-dough/blob/master/tsconfig.json) I use for my front-end projects.  You'll notice I use the dom, es2015 and es2016 libs.

Check out the [compiler options on the TypeScript site](https://www.typescriptlang.org/docs/handbook/compiler-options.html), too.",1536179333.0
AndyRoth,"Its fairly easy to setup for simple JS compilation once you've experimented  a bit with which options you'd like. You can run ""tsc"" either whenever you need a build, or in watcher mode. Sounds to me like your use case would probably fit watcher mode best. I know VS Code also has some TypeScript watching functionality built in but I can't tell you too much more about it because I haven't used that feature much. Will you be using webpack? If so you might like ""ts-loader"" or ""awesome-typescript-loader"". Best of luck!",1536179761.0
Drunken__Master,"I use this boilerplate - https://github.com/lomboboo/webpack-typescript-boilerplate it's certainly overkill for what you seem to be looking for, but it's the best that I've found that includes TS, SASS, Bootstrap and a nice testing suite.",1536183367.0
Hath995,"Post what you've done so far somewhere, give people a place to start. ",1536109860.0
TotesMessenger,"I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:

- [/r/relayforreddit] [This post doesn't have content when viewing in Relay but has it when viewing in browser](https://www.reddit.com/r/RelayForReddit/comments/9d65be/this_post_doesnt_have_content_when_viewing_in/)

&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",1536151499.0
cannyshammy,"Okay, I have just had another go at it... I think this just about as good as im going to get it: [https://gist.github.com/mikecann/c5aeabf619312bfb670efc3a3fbaced0](https://gist.github.com/mikecann/c5aeabf619312bfb670efc3a3fbaced0)

&#x200B;

The typings probably can be neater but at least it works!",1536198516.0
DanielPerezAlvarez,"hey, i recently made a little redux library that looks a bit like that, and it has types! [https://github.com/danielpa9708/redux-helper](https://github.com/danielpa9708/redux-helper) , hope this helps, types are here [https://github.com/danielpa9708/redux-helper/blob/master/src/type-helpers.ts](https://github.com/danielpa9708/redux-helper/blob/master/src/type-helpers.ts)",1536162922.0
trevorsg,"When your value is not assignable to any of the unioned types, it just picks one for the error message. The error message is not _wrong_, although a more complete error message might be ""Type {} is not assignable to type 'string', nor is it assignable to type { name: string } -- Property 'name' is missing in type '{}', nor is it assignable to type any[]. 

There is definitely some logic that helps choose the more likely of the unioned types that you are trying to match for the first and 3rd examples, but for the second, the inclusion of that array type is aborting this logic and causing it pick a different type. I have no clue what this logic actually looks like, but I'm curious, so I had a look at the compiler source. All snippets below are from [checker.ts](https://raw.githubusercontent.com/Microsoft/TypeScript/master/src/compiler/checker.ts).

    if (reportErrors) {
        const bestMatchingType =
            findMatchingDiscriminantType(source, target) ||
            findMatchingTypeReferenceOrTypeAliasReference(source, target) ||
            findBestTypeForObjectLiteral(source, target);

        isRelatedTo(source, bestMatchingType || targetTypes[targetTypes.length - 1], /*reportErrors*/ true);
    }

    // and later

    function findBestTypeForObjectLiteral(source: Type, unionTarget: UnionOrIntersectionType) {
        if (getObjectFlags(source) & ObjectFlags.ObjectLiteral && forEachType(unionTarget, isArrayLikeType)) {
            return find(unionTarget.types, t => !isArrayLikeType(t));
        }
    }

So that's pretty interesting. Source is your `{}` and target is `Foo`. So, in `findBestTypeForObjectLiteral`, IF there is an array type in the union, it returns the first non-array type. In your second example, this would be `string`. But if there are no array types, that function returns nothing, so when `isRelatedTo` is called, `bestMatchingType` is undefined, so it falls back to the _last_ type in the union (seems a bit inconsistent, but it's an arbitrary decision anyway so it probably doesn't really matter).

My guess is that they do this because assigning an object to an array is probably not correct. However, I was still perplexed why adding the array causes `findMatchingTypeReferenceOrTypeAliasReference` to fail. I was about to the point of giving up or hooking up a debugger when I found this:

    // We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
    // flag is specified we also reduce the constituent type set to only include types that aren't subtypes
    // of other types. Subtype reduction is expensive for large union types and is possible only when union
    // types are known not to circularly reference themselves (as is the case with union types created by
    // expression constructs such as array literals and the || and ?: operators). Named types can
    // circularly reference themselves and therefore cannot be subtype reduced during their declaration.
    // For example, ""type Item = string | (() => Item"" is a named type that circularly references itself.
    function getUnionType(types: ReadonlyArray<Type>, unionReduction: UnionReduction = UnionReduction.Literal, aliasSymbol?: Symbol, aliasTypeArguments?: ReadonlyArray<Type>): Type { 

Yay! A nice comment. Specifically, ""we also reduce the constituent type set to only include types that aren't subtypes of other types."" My guess is that the `source` type that gets passed around in the first snipped is REALLY only `string | any[]` when the `any[]` is included, which causes the logic to fall to the third method of finding the ""best matching type"".",1536122524.0
cspotcode,"Just a guess: In the first example, it's obvious when you specify an object literal that you're trying to make an object value, not a string.  There are only 2 options in the union.  Easy peasy.

But in the second option, an object literal could be either an Array-like object or an object-like value, since Arrays are just a different kind of object. (non-primitive).

So maybe in the second case, TS can't narrow the union to a single option, so it falls back to matching on the union's 3 options in order.  Since they all fail, it shows the failure for the first one.",1536112373.0
demoran,"> type Bar = string | { name: string } | any[];

Try putting the `string` part at the end; maybe it's positional",1536111640.0
drdrero,Just a side question. Difference between types and interfaces ?,1536151460.0
,[deleted],1536110857.0
Hath995,"You can just assign the type to stuff and it will typecheck. 

    interface IProperties {
      name?: string;
    }

    abstract class Model<T> {
      public abstract stuff?: Array<keyof T>;
    }

    class AwesomeThing extends Model<IProperties> {
      public stuff: Array<keyof IProperties>  = ['name'];
    }

or

    class AwesomeThing extends Model<IProperties> {
      public stuff: Array<keyof IProperties>;
      constructor() {
        super();
        this.stuff = ['name']
      }
    }

Typescript has some problems detecting that array containing a string is an array of only a string literal unless you add the type to the variable. It widens the type to string by default. ",1536097057.0
Azr-79,"type `name` != value `""name""` which is of type string",1536097911.0
drRouman,"You could look into backstopjs or exquisite-sst.

You generate ""reference"" pictures and will notify if something changes when you run the tests again.",1536097477.0
EarlMarshal,"You can just get the jmagedata and assert the pixel values. If it's about subtle color difference which you can't really prevent you apply some CIE magic and calculate color difference. Everything under a certain threshold (JND) is okay.

But probably the best solution is instead of really drawing on a canvas just record all instructions and then compare them if they are in the right order",1536175722.0
ClickableLinkBot,"##r/javascript
---------------------------------------------
^(For mobile and non-RES users) ^| 
[^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| 
^(-1 to Remove) ^| 
[^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)",1536079731.0
xyrue,"Overall it seems pretty nice but I do have a few minor comments:

&nbsp;

1. Style is of type `object` which isn't great IMO. If it's styling to be passed for react they have a type for that (I think it's `React.CSSProperties` or something like that), if not, I think you should use an interface or type (If possible).  
2. Color is `string`. Is it limited to a certain type of colors? if it is a **short** list I would consider using it as a type instead of `string`.  
3. This is more of a React thing and depends a lot on your code but for me the type `string | number` is a code smell. In many cases there isn't a need for one of them and it just creates a lot of extra work. With that said, this comment could be completely irrelevant in your case.

&nbsp;

All of mycomments are pretty minor and are more suggestions, but other than that it looks nice!",1536072278.0
demoran,"Looks good!

I think there's a bit of a semantic issue with `ModeOptions`: this should more properly be called `Mode`.",1536077989.0
xdavehome,I really wish something good like this existed with the same API as ramda.,1536084780.0
bdchauvette,"Try putting your build stuff in the `prepare` script of your `package.json`:

    {
      ""scripts"": {
        ""build"": ""tsc"",
        ""prepare"": ""npm run build""
      }
    }

From the [npm 5.0.0 changelog](https://blog.npmjs.org/post/161081169345/v500) :

> Git dependencies with prepare scripts will have their devDependencies installed, and npm install run in their directory before being packed.",1536058379.0
vizzoor,"Back in the day (a few years ago) people would commit the JavaScript files under a different branch or tag to ""reduce the mess,"" but ultimately you should look at a private npm repository instead.",1536056609.0
tanguy_k,"With a npm package, the transpiled code is inside the npm package, not inside your repo. See `prepublishOnly`: https://docs.npmjs.com/misc/scripts

To sump up: the npm package content is different from your Git repo.

If you import directly the repo (`git+ssh://`), well you don't have a choice: you need to have the transpiled code inside your repo (or the app that uses your library needs TypeScript).",1536052086.0
metamorph23,"You either have to publish the output to an npm registry as a package or commit the output to github, the former is preferable imho, but involves more work setting everything up.",1536054601.0
BrushyAmoeba,Are all of the apps consuming this library guaranteed to be TS? If you have any potential consumers that are just regular JS then you have to commit the files built by TSC. another way would be to have a repo for source code and a separate repo for the built files,1536051562.0
rognam,Just include the folders you don't want to commit in your .gitignore file. I include my build directory as well as node_modules/ and typings/,1536050706.0
toymachine11861,"I'm interested to see what other people think about InversifyJS and IoC patterns in Typescript.  


Earlier this year I started a greenfield project, and I wrote it with Typescript using InversifyJS.  By the end of the project, I felt like it was a mistake to introduce that dependency, because in the end it introduced a ton of boilerplate and it didn't feel totally necessary in most cases.  


Has anyone else been more successful than I?",1535997095.0
AngularBeginner,"The example does not work.

> git clone https://github.com/tswistak/react-inversify-example.git  
> cd react-inversify-example  
> yarn  
> yarn build

Results in:

> Failed to load tsconfig.json: Missing baseUrl in compilerOptions",1536003131.0
cspotcode,"Use the declarations generated by typescript.  Make sure your package.json's ""types"" field points to them (just like how the ""main"" field points to your main js entry point, ""types"" points to the main declarations file corresponding to the entry point js). Declare all your @types dependencies as regular dependencies, not devDependencies.  That way, when someone npm installs your library, npm will also install the necessary devDependencies.  The declarations generated by TypeScript will refer to them, `""moduleResolution"": ""node""` will do the right thing, and everything should ""just work.""",1535923888.0
abelincolncodes,"I usually generate type declarations and include them using the “types” field in your package.json. If you don’t want declarations for internal functions to be emitted, you can use the `@internal` jsdoc comment and the `—-stripInternal` compiler flag. If your library is already written in typescript, don’t rewrite the types separately. That just increases the chances of errors and then no one can use your module correctly.  

As for including types, if you use the “types” package.json field and make sure the .d.ts files are packaged, then tsc will pick them up automatically. Your current trick should work, but it’s definitely not the optimal route. I only do that when I’m working with someone else’s untyped module and I haven’t yet published the types I wrote for it to DefinitelyTyped",1535924304.0
LetterBoxSnatch,"TypeScript tracks *very* closely with ECMAScript. It is strictly a superset. Removing the “this” declaration would be a break in syntax.

There’s a handleful of TC39 proposals that I would love to see make it into TypeScript, but TypeScript will not adopt until the proposal is level 4. The best ways to get syntactic change into TypeScript (that is not strictly Type syntax) is to influence ECMAScript.",1535915932.0
smthamazing,"Even disregarding the desire of TypeScript team to follow the ECMAScript standard closely, I'm not sure this is a good idea for a language. While I rarely use `this` in Java or C#, I certainly see its benefit in distinguishing between local/global/closure variables and class instance fields. In my opinion, always using `this` is superior to occasional inclusion of it for disambiguation of name conflicts.

It also feels somewhat less clear for beginners, because variables and fields have important differences, so it makes sense to use different syntax for them.",1535917854.0
notNullOrVoid,"It is necessary. TypeScript would not be able to reliably transform code in order to add `this.`. There's no reliable way of knowing what global variables exist, that may cause conflicts.

For example:
```
Class Foo {
  $: number;
  get$ () {
    return $;
  }
}
```

There isn't a reliable way to know if `$` refers to `this.$` or jQuery. If you were to transform all instances of `$` within the class that would be a breaking change. There will undoubtedly be existing TypeScript code out there that references global variables which match the name of a property.",1536286770.0
cspotcode,"They have intentionally designed the language so that type information doesn't affect emitted js code, or in other words, correct type information is neither used nor required for code emit.

They do, however, use type information to suggest when you accidentally omitted `this.`, so you can click or hit a key and the language service will add it for you.

EDIT: theoretically, you could hack the compiler to scan an entire codebase for those `this.` quick-fixes and apply them as a pre-emit step.  It'd be an interesting experiment.",1536371518.0
spacejack2114,"> Do you think using 'this' is absolutely necessary?

No. I rarely use `this` because closures are usually better than classes.",1536035392.0
nsonha,"this is exactly the kind of thing I was annoyed back when I learnt JavaScript a few years back. To answer your question, now I think the ""this."" is absolutely necessary, not for the compiler to work but for you to be really aware of the dependencies that your methods have on the instance. Over time I learnt to go out of my way to reduce the amount of states that I jam on the instance, and typing ""this"" every time I do so is a good reminder.

Another reason this is good is when you code review some big class on github you can actually track where thing comes from at the first glance, and not have to run a compiler in the brain to infer the context.",1538461596.0
blakflag,"I asked this on day one when I first started with Typescript 0.9. I got some nonsense answers about language design that didn't pass the smell test. It's slightly annoying because, as you said, a language can be designed perfectly well with this-less class vars with local var overrides, and this. as a disambiguator. It's definitely more pleasant that way.  AS3 does it. Java does it (for method arguments)

Sadly, it is what it is, and since Javascript doesn't work like that, Typescript is never going to work like that. It's a minor (well medium sized) annoyance that I still get caught by sometimes, but my IDE tells me I goofed and I move on.",1535923336.0
cspotcode,"I know that tagged unions are narrowed down when you test `if(""prop"" in data) {`. It's a slightly different situation, though.  I don't have an answer to your exact question.",1535819499.0
,"If you narrowed the type then it would not be possible to set the property to undefined later.

There is also the issue that the reference might be captured elsewhere and mutated under your feet.",1535821111.0
info_dev,"The reason that `someFunction(data)` fails is that you're passing a reference to the data object, which is mutable. But `someFunction({ prop: data.prop })` works because you're taking a reference to the non-undefined value of `prop`.

An example of how the first statement could fail in practice is if some function does some deferred execution on `prop`, and the original data object was modified. 

```
interface Test {
    prop?: string;
}

function someFunction(data: { prop: string }) {
    setTimeout(function() { console.log(data.prop); }, 100);
}

function otherFunction(data: Test) {
    if (data.prop) {
        someFunction(data); // assuming TS did allow this
        delete data.prop;
    }
}
```

If this was allowed to compile, this would log `undefined`, even though `prop` should always have a value. However if you were to write:

```
someFunction({ prop: data.prop });
delete data.prop
```

The value passed to `someFunction` would still have the original value of `data.prop`.",1535837296.0
jadbox,"Looks great! I've been using mst-react-router, which is an adaptor to using react-router with mobx-state-tree. It works rather well for my use-cases.",1535647154.0
n0rs,Just had a quick look and was wondering if there is anything preventing the children of not-shown routes from being executed even if they aren't shown?,1535702626.0
Dw0,Something along the lines of ‘export * from ‘projectA’ in the client or extract types from A into separate package and refer to it in all 3,1535638440.0
,[deleted],1535660991.0
threemanycats,How about creating a `projectA-common` which is shared by both?,1536035953.0
QuanHodges,Why would anyone use Javascript when Typescript exists ,1535555242.0
demoran,"Hmm, I inherited a js based React Native project and am gradulally migrating the components to .tsx files and putting typing in.

I don't have any problem consuming the js components, though admittedly there are (thankfully) few SFC.

Could you maybe give an example of how you're trying to use them?

",1535492612.0
geon,"So the components you import from js are typed?

When I did the same thing, anything from js would be typed as any. 

Either way, start from the leaf nodes in your dependency tree. ",1535518683.0
rollocks,"This might help: https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files

If you want type checking but also want to make some props optional look at adding JSDoc comments to your components. TypeScript pretty much fully understands the type information provided in JSDoc.",1535527720.0
netcraft,I feel like im missing something.  Even if you are already using babel today - is the idea that you would just use your ide to do your type checking and babel just to strip the extra syntax?,1535461078.0
hmongoose,"I still don't get why people use babel with TypeScript. TypeScript can already transpile modern JS down to the oldest runtimes, and a basic TS project setup is really simple. Why bother adding another million packages and build steps?",1535483119.0
blakflag,"It would be nice. I love Typescript, I've been rooting for it since 0.9 came out and I realized I didn't need to suffer legacy Javascript anymore.  I'd gladly write a middleware API in Typescript. 

But I take issue with the author's slagging on Java (& C#, which is essentially MS-Java). I like Java 8+ just as much as I like Typescript. Why? Because it's evolved well over the years. The Java we can write now bears little resemblance to the overly verbose syntax we had to write 10 years ago. And the library maturity is second to none.  And a good IDE practically writes the Java for you! The only thing I hate doing in Java is manually parsing XML and Json, but even that isn't so bad if you use a few tricks.

I never left Java for Node.js because I understand what makes a large backend codebase maintainable over a span of years... and it's easy, safe refactorability, which Java has in spades and Javascript IMHO does not.
",1535452888.0
AngularBeginner,"> With CLR now cross-platform drop the C# ball and write us a Typescript Native compiler. In my opinion Microsoft has better odds of success with a huge community that already understands and writes Typescript!

The CLR does not support many features that TypeScript offers, e.g. prototypical inheritance and union types. And changing the CLR to support such things is beyond any reasonable scope.

And dropping C#? Are you nuts? What about the huge community that already understands and writes C#?",1535436086.0
xdavehome,"If they can figure out a way to keep innovating the typescript language while also maintaining a typescript AST native code generator, I'm game.  I'll live with whatever runtime library is necessary if I can link it with C.

The #1 thing I've loved typescript for is definately the release cycle and tooling based on the amazing progress they've made over the last few years alone.

And for all of the people saying that we should just target WASM, I'll say that there's lots of people who couldn't give less of a shit about running WASM on their server.  The main focus here is platform native code like Rust or Go --- no VM.
",1535522573.0
psxpaul,"I recently setup a typescript SAM project, and I used these 2 projects as examples:  
[https://github.com/alukach/aws-sam-typescript-boilerplate](https://github.com/alukach/aws-sam-typescript-boilerplate)

[https://github.com/Giftbit/sam-scaffold/tree/master/typescript](https://github.com/Giftbit/sam-scaffold/tree/master/typescript)

&#x200B;

They both seem to use webpack for what you're talking about, which has worked fine for me so far.",1535482841.0
cspotcode,"I'm unfamiliar with SAM, but have you told AWS to include node_modules in the .zip file?  It's a node-specific concept (e.g. python doesn't use it) so I'm just guessing that SAM doesn't bundle it unless you specifically configure it.  Is there somewhere you're listing all the files that should go in the zip?

EDIT: I just realized how old this question is; nevermind!",1536378481.0
AngularBeginner,"> You can still abuse union and any types to avoid true strict typing.

How would you abuse union types to avoid strict typing? Unions are still typed.",1535435628.0
dlq84,">Not every library you use will use TypeScript. This means that you'll either have to build your own [Declaration File](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html) or lose the advantage of strong typing in the part of your code that interfaces with the third party code.

&#x200B;

You are forgetting the third option of using @types over at npmjs",1535460604.0
Move_Zig,"I use Joi.

    app.use('/login', (req, res) => {
      const bodySchema = Joi.object({
        email: Joi.string().email().min(6).required(),
        password: Joi.string().min(6).required(),
      });
      bodySchema.validate(req.body, (err, value) => {
        if (err) { throw err; }
        // do stuff here
      });
    });

It can also be used in promise form:

    bodySchema.validate(req.body).then((value) => {
      // do stuff here
    }).catch((err) => {
      throw err;
    });

One nice thing about Joi is that it can convert variables into the expected type

    const schema = Joi.object({
      name: Joi.string().required(),
      age: Joi.number().integer().positive().required(),
    });
    schema.validate({ name: 'Fred', age: '32' }, (err, value) => {
      if (err) { throw err; }
      console.log(typeof value.age); // 'number'
    });
",1535398054.0
DuckDesk,"[https://github.com/typestack/class-validator](https://github.com/typestack/class-validator)

[https://github.com/nestjs/nest](https://github.com/nestjs/nest) is a full solution that might be worth checking out",1535400311.0
ristof,Also there is one great library https://github.com/gcanti/io-ts.,1535487682.0
calomer,"I am confused on what do you mean by a valid e-mail and password. Are you checking if this is ""any"" e-mail, or one from a database? Do you have a list of valid or invalid e-mails that you want to check against?

Regularly you want to have a middleware that received the posted data, and in the body of the middleware check using your list / database. If you just want to validate the data structure or type /u/Move_Zig already mentioned joi that I would suggest as well. This would help you use the same validation code on the browser, and return errors (e.g. mistypes) immediately without sending a request to server and getting a response. 

However, if you want to validate against your own data on the server, then you should first keep a map of valid e-mail addresses and passwords and validate that way. What are you planning to do once you have validated the entry? I think a good starting point would be to use [passportjs](http://www.passportjs.org/docs/username-password/) middleware.",1535524376.0
lukeautry,Check out https://github.com/lukeautry/tsoa. Payloads are validated according to their implementation to TypeScript interfaces/classes.,1535428962.0
IMayBeAutistic2,No....just no. This code is a needlessly complicated mess. Stop trying to use generics as a replacement for functions.,1538776086.0
AngularBeginner,"You're not exporting your namespace. If you export it, you get a form that can be included. `export var ABC;`.",1535355221.0
empty_other,"If the file doesn't have a top-level export or import statement, the Typescript compiler doesn't recognize it as a module. It gets compiled to global scope instead.",1535359482.0
villiger2,"Look on the ts compiler options page: https://www.typescriptlang.org/docs/handbook/compiler-options.html, specifically for `--module`. I usually use `esnext`. This is an option you'll set in your tsconfig file.",1535360515.0
Auxx,What's the difference with RxJS?,1535300290.0
vinnl,"I love that more and more libraries are getting written in TypeScript - the upsides far outweigh the downsides (the latter being mostly a somewhat higher barrier to contribution), in my opinion, even for those simply using the Javascript version.",1535363797.0
lenswipe,">Personally, I found it hard to get consistent code coverage results with Istanbul when I used it.

It's interesting to hear you say that. I've had coverage results from Jest(which I think uses Istanbul for coverage) that are alllllll over the place....maybe that's why",1535226384.0
AngularBeginner,Any chance you'll support npm instead of yarn?,1535227247.0
rotharius,"I have a working TypeScript, mocha, chai setup that generates reliable code coverage using nyc/istanbul. It uses ts-node for testing.

What is the advantage of this boilerplate?

",1535277988.0
info_dev,Have a look at io-ts - provides runtime types and validation. The learning curve is a little higher due to building on top of fp-ts.,1535196744.0
smthamazing,"I use [io-ts](https://github.com/gcanti/io-ts) for validation a lot, and I love it. I don't know how convenient their runtime inspection API is, but you should check it out.",1535201786.0
metamorph23,You could check out ‘class-validator’.,1535189151.0
esamatti,Another one is Runtypes [https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes),1535281274.0
fecal_brunch,"I'm working on [ts-auto-guard](https://github.com/rhys-vdw/ts-auto-guard) that's similar to those suggested. The use case is different though. It doesn't add runtime types, but instead generates type guards from standard TypeScript types. Not yet production ready but I'm getting there!

My intention is just to use it in development/CI to ensure we're correctly typing our untyped server data, and then strip all the generated code in production.",1535329537.0
TekNoir08,There's a whole section on testing async functions in the Angular documentation. Have a look there.,1535145281.0
bluefire2121,"Look at your Subject. If the component that is waiting to receive the broadcast isn't awake when the subscription message is sent, then that component will miss the message. Use BehaviorSubject to have the message heard when the component wakes up. BehaviorSubject is like having a mailbox. It'll hold the most recent message. 

ReplaySubject allows you to save more than one message in the mailbox. ",1535215756.0
55555,Don't be that guy. Post what you did to resolve your issue. ,1535144907.0
BehindTheMath,"If you want to use an unknown variable as a key, the object needs an index signature. ",1535139741.0
cspotcode,"What are the values of element and varString?  Can you console.dir them?

EDIT: also you're not doing anything with the value you retrieve.  Not returning it from the function or logging it or anything.  Is that intentional?",1535139891.0
Hath995,"I think you're asking about Lookup types or Indexable types. 

* https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html
* https://www.typescriptlang.org/docs/handbook/interfaces.html",1535140061.0
welkie,That is literally the most 2018 headline ever.,1535062297.0
DuckDesk,The guy who created this project is the same person who created the nodejs project. For information about this project you can see [his talk from JSConf](https://www.youtube.com/watch?v=M3BM9TB-8yA).,1535077023.0
i_spot_ads,"This shit could potentially be amazing!
",1535122204.0
spacejack2114,I wonder what the startup time overhead is for large/complex typescript apps.,1535154868.0
swardson,Are you already using typescript 3 in a production environment?,1535092206.0
demoran,"Blog is the best source of info for newer features:

https://blogs.msdn.microsoft.com/typescript/2018/07/30/announcing-typescript-3-0/#controlling-output-structure",1535123088.0
thorn0,"""T extends FirstOrSecond"" doesn't have the same implications as ""type T = FirstOfSecond"". The former means that if you replace T in the code of your class with any type assignable to FirstOrSecond, the code should compile. Hopefully, now you can see why it doesn't compile. To make the compiler accept the assignments, you can use type assertions. [playground](http://www.typescriptlang.org/play/#src=class%20First%20%7B%0D%0A%20%20first%3A%20string%3B%0D%0A%20%20constructor(data%3A%20any%29%20%7B%0D%0A%20%20%20%20this.first%20%3D%20data.first%3B%0D%0A%20%20%7D%0D%0A%7D%0D%0Aclass%20Second%20%7B%0D%0A%20%20second%3A%20string%3B%0D%0A%20%20constructor(data%3A%20any%29%20%7B%0D%0A%20%20%20%20this.second%20%3D%20data.first%3B%0D%0A%20%20%7D%0D%0A%7D%0D%0A%0D%0Atype%20FirstOrSecond%20%3D%20First%20%7C%20Second%3B%0D%0A%0D%0Ainterface%20IWrapped%3CT%3E%20%7B%0D%0A%20%20info%3A%20T%3B%0D%0A%7D%0D%0A%0D%0Aclass%20Wrapped%3CT%20extends%20FirstOrSecond%3E%20implements%20IWrapped%3CT%3E%20%7B%0D%0A%20%20info%3A%20T%3B%0D%0A%0D%0A%20%20constructor(data%3A%20any%29%20%7B%0D%0A%20%20%20%20if%20(data%29%20%7B%0D%0A%20%20%20%20%20%20if%20(data.info.first%29%20%7B%0D%0A%20%20%20%20%20%20%20%20this.info%20%3D%20new%20First(data.info%29%20as%20T%3B%0D%0A%20%20%20%20%20%20%7D%20else%20%7B%0D%0A%20%20%20%20%20%20%20%20this.info%20%3D%20new%20Second(data.info%29%20as%20T%3B%0D%0A%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%20%20%7D%0D%0A%7D)",1535050998.0
zlumer,"In your example T does not ""extend"" FirstOrSecond, it actually IS either First or Second.

The error message is trying to tell you that if you create a class Third (extending First), and wrap it into IWrapper<Third>, then IWrapper<Third>.info is expected to be Third, but it will actually be either First or Second, based on passed parameters.",1535050600.0
grinde,"Imagine a language that has only two types (`A` and `B`) that are incompatible with each other. `A` is assignable to `A | B` but not necessarily to a type that is itself is assignable to `A | B`. To illustrate, these are fine:

    (A | B) <-- A
    (A | B) <-- B
    (A | B) <-- A | B

But then consider the generic case:

    (A | B) <-- T <-- A

In this case our generic `T` could be *any* of the valid cases we just came up with. Meaning `T` could be `B`, and `A` is not assignable to `B`. IE

    (A | B) <-- B <-- A

Which is obviously not valid.

There's a name for this idea, but it escapes me at the moment.",1535055604.0
BehindTheMath,"I think the issue is that T is typed as the union, and First can't be assigned to that. 

You can either use a typeguard function that will force T to be typed more narrowly, or use a type assertion to assert that First is type T. ",1535047742.0
bobinux,"do you u mean, you want to compile the TS import syntax to ES6, instead of cjs?",1535033758.0
neofreeman,Anyone using Firebird in production?,1535034419.0
fecal_brunch,"Probably not, tbh. It's not that often that I deal with type unions with more than two types and I'm happy to use if statements or other native constructs.",1535009630.0
Shadowvines,"I do something like this to create generic inputs in a dynamic form creator.

      createGenericFormInput(key) {
    let input;
    switch (typeof this.data.properties[key]) {
      case ""string"": {
        input = new DynamicInputModel({
          id: key,
          label: key,
          value: this.data.properties[key]
        });
        break;
      }
      case ""number"": {
        input = new DynamicInputModel({
          id: key,
          label: key,
          value: this.data.properties[key],
          min: 0,
          mask: [/\d/, /\d/, /\d/, /\d/]
        });
        break;
      }
      case ""boolean"": {
        input = new DynamicCheckboxModel({
          id: key,
          label: key,
          value: this.data.properties[key]
        });
        break;
      }
    }
    return input;
    }    

Your method appears it would have the advantage of not comparing to a string. Another situation I could see this being used is in a pure pipe for Angular where you may have different types of objects being passed into a template and you would like to transform that data depending on the type that is passed in.",1535019887.0
shaberman,"I haven't tried it yet but seems like getting back a tuple of {tag: type, value: value} where type was the same type union that I passed in, and value matched the type, would be nice as I could do a switch and tag and get an exhaustiveness check. So the typeswitch return type would have to be something like {'int', Val: int} | {'string', Val: string}, etc. ",1535030866.0
,[deleted],1534950356.0
chrismatheson,i don't think there is a link to the project on the blog post?,1534949342.0
ponchoboy,"This looks awesome. We just switched to using NSubstitute for C# code too, so this would fit in nicely. ",1534988570.0
,It would really help me to have a tl;dr in the article with bullet points of why this is better than the alternatives.,1534958608.0
cspotcode,"Use ` ""moduleResolution"": ""node""`. It'll tell TypeScript to look within ""node_modules"" just like node does, and you won't need to explicitly reference any @types packages.

If you still need the triple slash reference, instead of reference path, use ` /// <reference types=""angular-mocks"" />`",1535849153.0
midrus,"This setup will lead you to a lot of problems in the long term. What I do, which has worked really well, is to have two top level directories like ""server"" and ""client"" and just have two totally independent project roots, each one with their own concerns, configurations, dependencies, scripts, etc.

If for some reason you want to share code somehow, you can always create a third root ""shared"", or even better, extract a library, publish it to npm and add it as a dependencies of your two independent projects.",1535023942.0
j3wxx,Typescript doesn’t affect redux. Not sure what you’re asking here. ,1534846374.0
demoran,Check out [mobx-state-tree](https://github.com/mobxjs/mobx-state-tree) or maybe just `mobx`.,1534848964.0
ClutchHunter,TypeScript aside - though I did write the typings for this library - there are simpler state management libraries such as `react-copy-write`. (Better typings are coming - no more any! - just haven't been merged yet.),1534859436.0
Dw0,We have a (gulp) task that after compilation does an equivalent of ‘npm install —production’ into the target directory. Takes longer but the artifacts are controlled. ,1534838860.0
BTOdell,"I've started converting my client-server project into a monorepo with three packages that used to each be a separate git repo. I've been running into a lot of the same issues you mentioned, so it's good to know I'm not going crazy. So many things seem awkward with this new project references feature.

My project is a client server model so the client package uses webpack to generate a bundle while the server code needs to be able to run directly in node without any loader or bundler.
This means I have to use these massive relative paths because I can't use path mapping (that's a loader/bundler feature). It's really ugly having ""../../../../../../shared/src/index"" for my imports but it's the only way that 'Just Works' even though it pollutes the code.

It would be so nice if TypeScript was able to support some kind of ""virtual package"" system that was like path mapping but it would resolve the path during the build step back to normal relative paths. It would allow the TS code to be clean while still compiling for maximum compatibility.

I'll have to take a look at Yarn workspaces. I've been using Lerna for hoisting but it doesn't seem like a production ready solution.",1534844312.0
cangoektas,"Sounds like an interesting problem. Have you thought about bundling your depependencies? I think that might work as during bundling you'd be using Node's module resolution and don't need everything in the individual node_modules  of your packages. I'd also check out Rollup. You can define multiple configs in a single file at the root level and build all your packages at once. Works great with the watch mode as well.

If you can share some code maybe we can look at it together :)",1534837752.0
zergUser1,"Hey, I am having the exact same issue and tearing my hair out. Can you share some code on how exactly you solved this? My use case is so unbelievably simple, I have 3 Lambda functions, each function needs to share a single class from a ""shared"" directory. AND NOW THE WORLD ENDS, HOW DARE YOU TRY SHARE CODE.......",1535110244.0
aa93,"You've got a couple simple options off the top of my head:

Put your definitions in index.d.ts in the project root, ala the DefinitelyTyped packages (or just re-export them there)

Populate the `types` field of your package.json, as shown in the [docs](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html)",1534801381.0
cspotcode,"The simplest option is: put the types in a file called `index.ts` in the same folder as `package.json`.  publish it to npm, install it via npm in the projects that need it.  Use ES6 exports and imports.  For example, `export namespace MyCompany {...`

EDIT: Specifically, I think the problem you're having is that you haven't`export`ed the namespace.",1534803401.0
kontrax,This topic has been in my head also for a while. I have a (redacted prefix for practical reasons) library full of utility types to help development cross projects and have found no real standard outside ambient module typings.,1534803089.0
vinnl,"My approach would be to define a `Car` as a union type of e.g. `WithWheels`, `WithEngine`, `WithSteeringWheel`, etc. You can then use generics for the input parameter and use the specific type in the return type, e.g.:

    const installEngine<C extends Partial<Car>>: (car: C) => C & WithEngine = // ...function definition...

`finishedCar` can then simply be of type `Car`, and TypeScript can deduce whether all the required functions have been called on it.

(In practice, I'd probably avoid getting in a situation in which different functions together build up a single object, but we don't have enough information about your code structure to suggest an alternative.)",1534764305.0
coopaliscious,"I mean you could just literally initialize the object with default values and a validator to say if it's a 'valid car' if you didn't want to go through all of that.

Without knowing more of the context in terms of why you're taking that approach or why values aren't optional that seem to be optional (the partial is the object with optional fields), I can't say anything more.",1534764190.0
Hath995,Here is an article which does something similar to create type enforcing construction methods. https://medium.com/@mvaldesdeleon/using-ixmonad-to-enforce-good-hamburger-building-in-typescript-bcd584236dd4,1534797710.0
TYB069,"    /**
     * Your domain model.
     */
    type Engine = {};
    type Wheel = {};
    type SteeringWheel = {};
    type Chassis = {};
    type Seat = {};
    
    interface Car {
        engine: Engine;
        wheels: Wheel[];
        steeringWheel: SteeringWheel;
        chassis: Chassis;
        seats: Seat[];
    }
    
    /**
     * Enhancers.
     */
    const addWheels = <T extends Partial<Car>>(base: T): T & { wheels: Wheel[] } => {
        return Object.assign({}, base, { wheels: [] });
    }
    
    const addSeats = <T extends Partial<Car>>(base: T): T & { seats: Seat[] } => {
        return Object.assign({}, base, { seats: [] });
    }
    
    /**
     * Some seed for your car.
     */
    const base = {
        engine: {},
        steeringWheel: {},
        chassis: {},
    }
    
    /**
     * Our assembly line.
     */
    const main: Car[] =
        [base]
            .map(addSeats)
            .map(addWheels)

[TypeScript Playground](https://agentcooper.github.io/typescript-play/?target=5#code/PQKhCgAIUhNB7ArgJ0gE3gWwIYEsB2km8aApgDYB0UIw4ALgJ4AOpkAovgOYFsC8kAN4BfANwMWbAOoALUhUgCR4pq0gBlevOQEus+eUVCxEtQGEZ2AM5XcVo8tNt1pbPQcnwBLcgBm2AGM2M2xUQShISNJuXgAuDhj8UnFIyIB3OQoreP0KAG0AXRTUqy1SHW5c8njNbV0q4siAyxs7eItrWytGyCtXemyNfsLxYXBwUAhoBMt8IOQramg6APh8UshsNDQq+wEAHgAVSFIADy18NHsABVD6XGxyfZDkAD5XgAoAI2tSeMOAJT-SAAMiEkAyBkGVUKkGEileQgikWQpHoKEIAHkvgArUgBeiUTq4Lj4D4iAA0kB+fSpgghmXIg1hwgBo3Gq3W7i2aBcbj2kCOJ3O0SukFuyHuj2eoXe31+-yBkGOYPpfX5NWGBThCKRqUgqPRyCxuPxhOJpPJwipNNIdN6-WZ2tZ7ImYBoGiwbD6pDQkF88FQjCQqACoSWtHAnI2tocyJOiT+xgp8dKdUqjPilPjzWJg2zYzdUxgmJQmxspEwX3IjEg5F4EZWaw2OAI7VCsL48bytoK8f1lBwzA+PL5AwB-dSg+ww55uwnQA)",1534808221.0
,"My quick solution:

    interface Car {
        engine: Engine;
        wheels: Wheel[];
    }
    
    function addWheels<O>(o: O): O & Pick<Car, ""wheels""> {
        return Object.assign(o, { wheels: ... });
    }
    
    function addEngine<O>(o: O): O & Pick<Car, ""engine""> {
        return Object.assign(o, { engine: .... });
    }

    function buildCar(): Car {
        return addEngine(addWheels({}));
    }",1534804274.0
endjynn,Any way is fine as long as it's consistent. Personally I prefer kebab-case (foo-bar.ts).,1534762296.0
kredditacc96,There is no universal conventions. Use whatever make most sense to you. I personally use `FooBar.ts` for React components and `foo-bar.ts` for the rest.,1534762785.0
scaleable,"I more often see dash-case file naming on javascript.

But since the introduction of the “extract to function” and “move to another file” refactors, camelCase may become really tempting since it saves you some file renames (move to another file will create a camel cased file, since variable convention is camel case)",1534776413.0
ThisAccountIs4Reddit,"I use the backbone.js implementation for my site, and I recently changed everything to use camel case with a suffix of what it represents. 

E.g. DashboardView.ts, DashboardCollection.ts, DashboardModel.ts

They are in separate packages, but I use Eclipse (don't kill me) and the resource finder makes it easy to type in and find what I'm going to work on. Also makes it easier for noobier developers to know what the purpose of the file is.",1534795266.0
vadistics,"As other mentioned - it's quite arbitrary, but there is one good rule: refactor each major function into its own file and keep filename the same as the function name.

So - the naming convention for react components and js classes is TitleCase.

For normal js functions files you would use camelCase.

For directories, libraries or files with e.g. many of util finctions it's usual to use kebab-case.",1534798093.0
kozakluke,"If `FooBar.ts` has inside class `FooBar` then name of file should be `FooBar.ts`,

if file has inside function like function `className () {}` then name should be `className.ts`,

here you can read more about file names

[http://beginwithjava.blogspot.com/2011/01/javas-file-names-and-class-names.html](http://beginwithjava.blogspot.com/2011/01/javas-file-names-and-class-names.html)",1534762828.0
drdrero,"Please format your source code correctly. Here is it in a fiddle [https://jsfiddle.net/L9u2qnw0/1/](https://jsfiddle.net/L9u2qnw0/1/)  


You used ""this"" in a function scope. Convert the onmessage function to an arrow function and it will work. Just try to avoid functions inside typescript classes.    


`this.ws.onmessage = function(message) {`

becomes  
`this.ws.onmessage = (message) => {`",1534755709.0
scaleable,"for validators I like yup, I also hear a lot about io-ts

(you wont be always validating data, but when you do , some types are inferred from the schema defs, reducing duplication)",1534754332.0
CouthlessWonder,"in TypeScript/js just use `JSON.parse()` and `JSON.stringify()`. It is built in.

It would work something like

    const jsonString = '{""name"":""Joe""}';
    const obj = JSON.parse(jsonString) as IMyObject;

I make it a personal rule to always parse as a very basic interface, and never a class.

Remember, TypeScript is not a typed language in the way C# is, so `as IMyObject` is only telling TypeScript what type it should presume the result is, it will not construct an object of that type. If you have a class with custom methods or properties, they will __not__ accessible after `JSON.parse()`.

Shout if I didn't answer your question, or you need more help.",1534751262.0
aflatter,"https://github.com/mojotech/json-type-validation has been working very well for us. From the README:


    import {Decoder, object, string, optional, number, boolean} from 'json-type-validation'

    const petDecoder: Decoder<Pet> = object({
      name: string(),
      species: string(),
      age: optional(number()),
      isCute: optional(boolean())
    })
    
    const lyle: Pet = petDecoder.runWithException(croc)",1534757251.0
andantonyan,"It might help

https://github.com/typestack/class-transformer

```
import { Type, plainToClass } from ""class-transformer""; 

export class Album { 
    id: number; 
    name: string; 
    @Type(() => Photo) 
    photos: Photo[]; 
} 

export class Photo {
    id: number; 
    filename: string; 
} 

let album = plainToClass(Album, albumJson); 

// now album is Album object with Photo objects inside

```",1534780738.0
STRiDEX,I’d still use hapijs joi in ts. It’s just vanilla js but it’s the leader in json validation https://github.com/hapijs/joi there’s types available in @types/joi,1534784396.0
fecal_brunch,"Currently working on [ts-auto-guard](https://github.com/rhys-vdw/ts-auto-guard). It automatically generates type guards for raw data from your interfaces.

Still WIP but I'm moving towards putting it into production for validating our server supplied redux store. Should work for this too.",1534776992.0
newreddit0r,Check out class-validator,1534780611.0
kontrax,I have just started using https://github.com/Microsoft/node-jsonc-parser and can absolutely recommend it. I have not explored it's ast plugin system but it seems more than capable of what you're looking for if you are open to write plugins (might already exist for what I know) I found the basic documentation to be lacking but I will answer what little I can and probably other people with more knowledge on here.,1534803650.0
DuckDesk,"[joi](https://github.com/hapijs/joi) is the standard validator in the JS world.

If you want to turn the json into classes then you may want to check out [class transformer](https://github.com/typestack/class-transformer) and [class validator](https://github.com/typestack/class-validator).",1534865303.0
fecal_brunch,You can use `DefinePlugin` if you build your project with webpack. There might be an easier way I'm not aware of.,1534723725.0
AndyRoth,"What I've seen is people including a boolean flag or configuration object which can be set on the class, or on an instance of the class, to change those sorts of values. As an example...

const mySdk = new MySdk({ host: ""dev.mysdk.com, port: 3000 }):

Usually each option has a default value (which would be the prod config) so some or all options can be omitted. This allows others to use it easily in any environment.

Would that work for your use case?",1534727906.0
spacejack2114,"I use browserify, which has an envify plugin. This allows you to get `process.env.VAR` values from system environment variables or from a .env file while compiling client-side code.

You can almost do `#ifdef`s with this. For example:

    if (process.env.NODE_ENV === ""development"") {...}

when compiled for production would be:

    if (""production"" === ""development"") {...}

and uglify.js is smart enough to omit that whole block from the final bundle.",1534728962.0
incurious,"Use an await on the nba,getPlayerInfo call, or actually await the promise by using nba.getPlayerInfo().then((foo) => {})",1534712537.0
8solutions,"Once you use a promise in your code, everything that executes after the promise will need to be promise-aware.

The modern way to solve your problem is to use async/await functions. Async/await will force your code to finish getting the player info before it moves on to the following steps.",1534719955.0
Dw0,"can confirm, your getPlayerInfo is itself returning a promise",1534712469.0
moocat,"`getPlayerInfo` is returning a promise to a JSON object so you have to put your call into a then:

    nba.getPlayerInfo('LeBron James').then((foo) => {
        console.log(foo);
    });
",1534718360.0
,"The problem is that `BaseNode` is open and could be arbitrarily extended: there is no guarantee that a value of type `BaseNode` with kind `NodeType.circle` is a `CircleNode`, and not some other type created elsewhere. 

Your user-defined type guard is making the promise that the kind `NodeType.circle` is used uniquely and it is therefore safe to narrow, but in general TypeScript cannot assume this so the literal type guard does not narrow.

If you want narrowing you need to ensure the type is closed, you can do that by using a union type instead of inheritance.

    type NodeUnion = PointNode | CircleNode
    let node: NodeUnion = {kind:NodeType.circle, pos:[10,10], size: 10} as CircleNode;
    if (node.kind === NodeType.circle) {
        console.log(node.size); // ok, node is CircleNode
    }
",1534675668.0
night_of_knee,"The way type-guards work is that you define a function that communicates whether the object is of a specific type (this is the `node is CircleNode` part of the deceleration of `isCircleNode`. TypeScript doesn't look into the function and check the logic and then assume this logic is true elsewhere. So when you say `if (node.kind == NodeType.circle)` this doesn't communicate anything about the type of `node` to the compiler (it only tells it about the value of `node.kind`).

The type-guard function doesn't enforce that the object is of that type it just tells the compiler to treat it as if it was. The following function is a syntactically valid type guard although it's obviously wrong.

    let counter = 0;
    function isCircleNode(node:BaseNode): node is CircleNode {
        return !!(counter++ %2); // It's a CircleNode every other time
    }

Then the output of:
    
     let node: BaseNode = { kind: NodeType.point, pos: [1, 2] };
     
     if (isCircleNode(node)) {
         console.log(""first: "", node.size)
     }
     
     if (isCircleNode(node)) {
         console.log(""second: "", node.size)
     }

Would be:
> second: undefined",1534673745.0
DerGernTod,Haven't tried it out but I think it's because you explicitly declare `node` as `BaseNode` which overrides the possibility to infer the type later,1534669729.0
itslenny,Anybody used this? Is it any good? Documentation is super lacking so I have no idea what I'm looking at,1534667698.0
dinoloop,how it is better than [http://dinoloop.com](http://dinoloop.com) ?,1534688370.0
cspotcode,"I could be wrong, but at a glance, it looks like those type declarations are written to declare global types within a namespace rather than as an external module.  

Try removing the import statement and writing this as a type annotation: `chrome.<use code completion here>` and see what pops up.",1534594909.0
AngularBeginner,Nowadays I don't really trust projects anymore that don't utilize TypeScripts strict compiler flags.,1534604176.0
MuppetMaster42,"I rambled a bit, sorry. TL;DR refractor to smaller functions.


Unit testing sucks. It really does. But trust me when I say that it is invaluable tool in creating a maintainable code base. At my last job I created a large GraphQL API, and refactored it 4 times. Because of unit tests I was never fearful of pushing a 5 digit refractor to production. The tests are well worth the pain.

When I write unit tests, as with any code I write, I look at how many times I write a piece of code. Once or twice? Whatever. Three or more times and it's a candidate for refactoring to a function.

Moving code to a shared function has two benefits for testing: firstly you only have to specifically test a code block once, even if it's used in 1000 places. Second it means that you now only need to mock one thing.
In normal code this can increase readability by encapsulating many lines inside a nice function name. In tests this can reduce pain by saving you setting up the same things multiple times.

Another thing to be careful of is writing functions that do too many things. Just because you can write a 1000 line function, doesn't mean you should. Can you logically split up the function into smaller functions that are called from a main function? This sort of refractor makes your code easier to unit test because instead of having one test file with thousands of lines testing one file, you can have several smaller files each testing one small unit of code. Smaller units of code means less dependencies which means less mocks to set up per test.

Finally, when writing your tests, there's a pattern you should follow to make your tests easy to read and more useful: 3 A's (Assemble, Act, Assert). Assemble your data (prepare your mocks and function inputs). Act on your data (could just be call the mock function, could be a series of steps). Assert(/expect) on your state/output.

The important thing is that you should ideally only assert on ONE thing. That doesn't mean just one assertion, but it means all the assertions should be checking a common thing.
",1534522164.0
phunktional,"Use the pain to drive the design of your system. This is one of the reasons I prefer to write the tests first, otherwise you get no design feedback from your tests.

Remember that unit tests are developer tests and the primary purpose is to drive the design of your functions/objects. ",1534521717.0
gtheory1,You're doing it wrong. You don't unit test routes. You integration test routes and run the integration tests whenever someone pushes. Superagent/supertest makes it really easy for any node framework. Including the bloated pile of shit that you use (express).,1534513181.0
ihsw,"It's tempting to copy and paste, feel free to create test helper funcs that abstract that away.",1534516612.0
thinkmatt,"I'm not sure where the js community stands on it, but we use plain objects with methods instead of dependency injection. DI is a relic of languages where you can't just stub or override methods. We have AngularJS too, but at least it's built into the framework so you often don't have to write stubs. So my recommendation is get rid of the classes. Use sinon to stub methods like you're doing but only as necessary (like it the function makes an http call), and supertest is flat out the best library for testing express routes. Only unit test things that have logic, like these services you are injecting.",1534530342.0
mattdw,Unit tests are a pain in general. But you'll come to like them after you work with a codebase that didn't have any (or had incorrectly implemented ones).,1534568366.0
sime,"If unit tests are a big pain and too little ROI, then don't do it. It is probably better to invest the energy in something else like integration tests or bigger system tests, or in some cases leaving it up to manual testing.

I find that when mocks start appearing it is a good sign that you think about stopping and spending your time elsewhere with a different testing strategy. Basically, the more you mock stuff, the less confidence you should have that your unit will work correctly in the context of the greater system.

Mocks suggest that your unit depends heavily on the behaviour of other systems. In which case you should think integration or higher level tests. 

Secondly, mocks often repeat the kinds of incorrect assumptions you baked into the unit you are testing and want to detect. The more you fake, the less confidence you should have in your testing. The closer your testing is to how your system will be used in the real world, the better.
",1534576375.0
blakflag,"Yeah I agree, unit testing is messy and a pain. Especially in JS which IMO still lags a bit in the sophistication of the unit test libraries.  Part of why I like Typescript is to replace the need for the more trivial tests (is my number really a number?) with type assurances.

Have you tried a base class for your unit tests so that you can just set up one mock of each type and reuse the setup for all your tests? That's my usual first line of defense.",1534511084.0
_eps1lon,"Take a look at https://github.com/dalinarkholin/example-typescript-monorepo

You can still use per package configs. The important part is that you should use the `paths` option in `compilerOptions`. I'm not sure what you want to achieve with `references` or what this is even used for. I never needed that option.",1534396784.0
,"You have lowercase ""login"" in the first file and use it as capitalized ""Login"" in the second file. Change it in the first.",1534341237.0
Hath995,"I would start by making your function parametric.

    const betterConnect = <T,Q,R,S>(mapStateToProps: T, mapDispatchToProps: Q, mergeProps:R , options:S) => {
    //*defines your custom behavior as types
      return connect<T & Custom1, Q & Custom2, R & Custom3, S & Custom4>(mapStateToProps, mapDispatchToProps, mergeProps, options)
    }",1534286663.0
Devcon4,"So with Typescript 3.0 you can have rest parameters with tuple types, we can use that to make Variadic functions. Varadic is similar to Parametric but instead of having a set number of types you can have any number (Ideal for function args!). There are some proposals open talking about Variadics in typescript, The rest tuples almost gets us to full variadic.

This is prop how I would do it. Everything should be types by doing this. The magic is the `U extends unknown[]`. unknown is similar to any but type-safe, and the [] is saying we are making a tuple. It's type is infered from args.

    function connect(mapStateToProps: string, mapDispatchToProps: number, mergeProps: {prop: string}, options?: {extra?: string}) {}
    
    // Helper func.
    function wrap<U extends unknown[], V>(typeFunc: (...args: U) => V, newFunc: (...args: U) => V) {
        return newFunc;
    };
    
    // Implementation.
    const betterConnect = wrap(connect, (mapStateToProps, mapDispatchToProps, mergeProps, options = {extra: 'stuff!'}) => {
        connect(mapStateToProps, mapDispatchToProps, mergeProps, options);
    });

The caveat to this is you need typescript 3.0.
Good luck!",1534296039.0
calebegg,"You want nominal types. Unfortunately, TS just doesn't have that, so it's hard.

There are a few techniques here to get something like what you want: https://michalzalecki.com/nominal-typing-in-typescript/

Brands may seem hacky, but note that even the TS team uses them in the [implementation of TypeScript itself](https://github.com/Microsoft/TypeScript/blob/c5b74db78bad78722aa6336b7db1df7be4bd2ecf/src/compiler/types.ts#L4).",1534284296.0
Dw0,There's a compilation flag to emit also typings,1534279333.0
vlaaivlaai,"Not sure what exactly you want, but you can export types:

    export type Path = string;

works just fine, and can be imported, iirc.

You can also create a `window.d.ts`-file where you define those types globally, and then include that file with a `///<reference />`-comment.

With that you can make your custom types available globally.",1534303077.0
defenestrant,"I don’t know why it works like it does in my projects; but if I make a .ts file (whatever its name) in my projects that don’t export or import anything, all interfaces/types declared in that file are useable anywhere else in my project without having to explicitly import them.",1534312975.0
fcrick,"I've been enjoying this:


    fnThatExpectsSomeClosure(
        (...args) => someFn(addMeToClosure, ...args)
    )

Pretty sure this only works in the nightly builds at the moment, but it's a lot better than the old way:

    (a, b, c, d) => someFn(addMeToClosure, a, b, c, d)",1535170371.0
doomboy1000,"Top is a function that returns a function (that returns void), bottom is a function (that returns void) ",1534085844.0
kredditacc96,"> Are those interfaces similar?

**No.** The first one is a function that returns a function, the second one is a function that returns `void`.

> how are they implemented?

[1](https://www.typescriptlang.org/play/#src=interface%20ILogger%20%7B%0D%0A%20%20()%3A%20()%20%3D%3E%20void%0D%0A%7D%0D%0A%0D%0Aconst%20logger%3A%20ILogger%20%3D%20()%20%3D%3E%20()%20%3D%3E%20undefined) and [2](https://www.typescriptlang.org/play/#src=interface%20ILogger%20%7B%0D%0A%20%20()%3A%20void%0D%0A%7D%0D%0A%0D%0Aconst%20logger%3A%20ILogger%20%3D%20()%20%3D%3E%20undefined)",1534088199.0
,[deleted],1534093455.0
kingdaro,"For the record, the both of these can also be written as such, using type aliases and arrow function syntax

    type ILogger = () => () => void

    type ILogger = () => void",1534094482.0
kozakluke,"3. You should not use "" I "" prefix for interfaces, it look really ugly.
",1534093050.0
TYB069,This library bundles its own types. You don't have to download them yourself. They should just work.,1534023114.0
PhysicalRedHead,"It depends on the contents of the `.d.ts` file I think.

It would be easier to help you if you could describe a specific problem that you're having, instead of asking a somewhat vague question.",1534023002.0
stun,You can configure where TypeScript finds the type def files in the \`tsconfig.json\`.,1534032698.0
galkowskit,"There are three main ways you get types.

1. Library itself has a .d.ts file and will work right after installing it.
2. Library doesn't have typings and you have to download them by `yarn @types/package-name`.
3. Library doesn't have typings nor community created one. You are either out of luck or need to create your own.",1534080961.0
moocat,"A tuple is implemented as an array. So a tuple of `[string, number]` will always have a string at index 0 and a number at index 1. But since it's an array, it could have an element at index 2 or beyond. For those elements, the type is a union of the earlier types.",1534021633.0
fcrick,"you can now do this more explicitly since tuples can have optional tails:

    let x: [string, number, ...(string|number)[]]

and next release

    type px = Partial<typeof x> // [string?, number?, ...(string|number)[]]",1535170988.0
,What in particular needs more explanation?,1534019199.0
modec,The incoming parameters does not have any typeinfo. Try adding :string after stateName,1533939262.0
Shadowvines,"I'm dealing with an issue where I am trying to use the google maps types and I would like to be able to set variables to and extend the classes from those typings. The problem I have is if I try to use the classes from google maps before the map is initialized the javascript for those types doesnt exist yet so I get a ""google is not defined"" error. I currently have functions that create the class that do things after a promise is returned from google maps but the but its a hacky solution and the objects arent reusable outside the function that creates them in the dom they show as class_1 and I have no way to reference that class later so im forced to use any to edit it later. I wonder if this would be able to solve that issue for me.",1533931666.0
scaleable,"I couldnt get what is this supposed to do. Auto generate typings from javascript?  


edit: seems one of those cases of guys coming from C# which still didnt get the nature of ""structural typing""",1533967257.0
Hath995,"Have you taken a look at [fp-ts](https://github.com/gcanti/fp-ts)?

Here is an explanation of how he constructed higher kinded types. 
https://github.com/gcanti/fp-ts/blob/master/HKT.md",1533913280.0
WorldsBegin,"I've update the script just now. The only remaining problem for me are rest parameters (types that somewhere have the form `[T, ...R[]]`). All other things seem to work fine. If you find any problems, feel free to point that out and if you can solve rest parameters, I would really appreciate that.",1533999872.0
AngularBeginner,"No, you were not able to perform reflection using TypeScript 3.0. You even say it yourself in the readme:

> TypeScript can not acquire type information at runtime.

Reflection is a defined term that you can't just make up a new meaning for: https://en.wikipedia.org/wiki/Reflection_(computer_programming)

> In computer science, reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.",1533878082.0
AngularBeginner,Also pointing out that these kind of type operators should be used sparingly. Heavy usage of them can lead to incredible slow compile times. I've experienced such things with io-ts already.,1533879494.0
newreddit0r,"This is not reflection, but it is very interesting anyway so here comes my upvote.",1533887806.0
zaaack2048,It looks like io-ts and runtypes. Dose it support recursive types?,1533939733.0
Dested,"I dont have a use for this right now, but this is truly incredible. ",1533877801.0
kgtkr,"In the case of the JSON schema, it is not possible to check that the schema and type are the same, which causes a bug However, you can prevent such bugs by generating types from type information",1533879237.0
LowB0b,"Sorry but this isn't an issue with NPM. NPM literally just runs the commands you specified, something somewhere in your config is wrong",1533850861.0
cspotcode,Pretty sure it's referring to webpack loader rules.,1533939979.0
AngularBeginner,It's still React after the conversion. Magic!,1533837375.0
,Isn't Nashorn deprecated and about to be removed soon?,1533819823.0
stewsters,"Heads up, Nashorn is being deprecated in [java 11](http://openjdk.java.net/jeps/335) and being replaced by this stuff: https://www.graalvm.org/

You may want to see if your stuff can work with that if you want a more long term solution.",1533821029.0
blakflag,"I like the idea. I'm not very familiar with how Nashorn tech works, can scripts be ingested dynamically at runtime or does application need to be restarted? Is sandbox reasonably secure (cant blow anything up with script)

I think this could replace homegrown DSL's, for instance I work with linguists that aren't necessarily comfortable with a language as big and complicated as Java and they need to play with things at runtime. I cobbled together a REPL but it's really crappy.  Typescript is a bit friendlier IMO and could provide a richer experience than my crappy  DSL.",1533811562.0
cspotcode,Can you enable inlineSources and disable inlineSourceMap?,1533779393.0
,"This is the entire source code:


    export type TJsonValue = string | number | boolean | null | TJsonArray | TJsonMap
    export interface TJsonMap { [key: string]: TJsonValue }
    export interface TJsonArray extends Array<TJsonValue> {}
    
    export const jsonParse = (str: string): TJsonValue => JSON.parse(str)
    export const jsonStringify = (value: TJsonValue): string => JSON.stringify(value)

What problems does it solve? It's not actually validating the types at runtime. It doesn't even validate types. Usually when you get JSON data, it's type is `any`, and you can still get it wrong by assigning an array of numbers to a string. Here, you've just moved that layer into your library and hid it from the developer using it.",1533753994.0
omril,So it's replacing `any` with a `TJsonValue` which is a poor man's `unknown` type.,1533757126.0
Max_Stern,"Solution: 

    type Overwrite<T, K> = Pick<T, Exclude<keyof T, keyof K>> & K;
    type Test = Overwrite<SendMessage, { chat_id?: ChatID }>;

Allows to overwrite any amount of fields to any types (if I'm not missing something).  

---

And this allows to make fields optional:

    type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
    type MakeOptional<T, K> = Omit<T, K> & Partial<T>; // works because ""optional"" & ""required"" = ""required""
    
    type Test = MakeOptional<SendMessage, ""chat_id"">; // works with several fields -- ""chat_id"" | ""text""   

Maybe it will be helpful for someone.",1533729362.0
Max_Stern,"Just realized that I can do something like this:   

    type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
    type Test = Omit<SendMessage, 'chat_id'> & {chat_id?: ChatID};

Basically remove `chat_id` from `SendMessage` and then add it back as optional.  
Still, looking for more elegant solution if possible.",1533728472.0
000ber,"Probably a better idea to use 
```
{
     chatId?: SendMessage[""chatId""]
}
```",1533798027.0
ProdigySim,"I don't think you can do quite this, because if you did for example:

    const input = Array.from(document.querySelectorAll('div')).
        map(x => x.textContent);
    myfunc(input, ""hello"");


There is no way the typescript compiler could guess what the elements of `input` might be.

However, for completely static arrays, you can pass it as the type parameter:

    function myFunc<T extends string | string[]>(item: Flatten<T>) {
      // Snipped
    }
    
    myFunc<[""hello"", ""world""]>(""foo"") // bad
    myFunc<[""hello"", ""world""]>(""hello"") // ok


You could even do:


    type ValidInput = ['foo', 'bar'];

    const input2 = ['foo', 'bar'] as ValidInput
    myFunc<ValidInput>('bar'); // ok
    myFunc<ValidInput>('hello'); // bad
    myFunc<typeof input2>('foo'); // ok
    myFunc<typeof input2>('hello'); // bad

But in that case, you might as well just do: 

    type ValidStrings = 'hello' | 'world';
    myFunc<ValidStrings>('foo');


[TSPlayground link for better highlighting](https://www.typescriptlang.org/play/#src=type%20Flatten%3CT%20extends%20string%20%7C%20string%5B%5D%3E%20%3D%20T%20extends%20string%20%3F%20T%20%3A%20T%5Bnumber%5D%3B%0D%0A%0D%0Afunction%20myFunc%3CT%20extends%20string%20%7C%20string%5B%5D%3E\(item%3A%20Flatten%3CT%3E\)%20%7B%0D%0A%20%20%2F%2F%20Snipped%0D%0A%7D%0D%0A%0D%0AmyFunc%3C%5B%22hello%22%2C%20%22world%22%5D%3E\(%22foo%22\)%0D%0A%0D%0AmyFunc%3C%5B%22hello%22%2C%20%22world%22%5D%3E\(%22hello%22\)%0D%0A%0D%0Aconst%20input%20%3D%20%5B'foo'%2C%20'bar'%5D%0D%0A%0D%0AmyFunc%3Ctypeof%20input%3E\('bar'\)%3B%0D%0AmyFunc%3Ctypeof%20input%3E\('hello'\)%3B%0D%0A%0D%0Atype%20ValidInput%20%3D%20%5B'foo'%2C%20'bar'%5D%3B%0D%0A%0D%0Aconst%20input2%20%3D%20%5B'foo'%2C%20'bar'%5D%20as%20ValidInput%0D%0AmyFunc%3CValidInput%3E\('bar'\)%3B%0D%0AmyFunc%3CValidInput%3E\('hello'\)%3B%0D%0AmyFunc%3Ctypeof%20input2%3E\('foo'\)%3B%0D%0AmyFunc%3Ctypeof%20input2%3E\('hello'\)%3B%0D%0A%0D%0A%0D%0Atype%20ValidStrings%20%3D%20'hello'%20%7C%20'world'%3B%0D%0AmyFunc%3CValidStrings%3E\('hello'\)%3B%0D%0AmyFunc%3CValidStrings%3E\('foo'\)%3B%0D%0A)

Edit: nice link syntax reddit/tsplayground",1533701998.0
AngularBeginner,"To format code properly on Reddit:

- Indent every line with 4 spaces.
- Have an empty line between code and text (before and after).

> const input = [""hello"", ""world""]  
> This should fail because ""foo"" is not in the array. However, it works because the type is just string instead of ""hello"" | ""world"" myFunc(input, ""foo"")

The type is `string` because that is correct. You have no string literal types here. The type of `input` is not `('hello' | 'world')[]` or `['hello', 'world']`, the type is `string[]`. So the literal information is already lost.",1533701958.0
TYB069,"It happenes because this:

    const input = [""hello"", ""world""]

is inferred to be of type `string[]`. TypeScript _widens_ the type of some _concrete_ strings into _any_ strings.
To make it type safe, you need to tell TypeScritpt their literal types should be preserved.


    type AllowedKeyword =
      | ""hello""
      | ""world""

    const input: AllowedKeyword[] = [""hello"", ""world""];

Complete solution:

    type Unboxed<T> =
      T extends (infer U)[]
        ? U
        : T;

    function myFunc<T>(input: T | T[], item: Unboxed<T>) {
        // Snipped
    }

    type AllowedKeyword =
      | ""hello""
      | ""world""

    const input: AllowedKeyword[] = [""hello"", ""world""];

    myFunc<AllowedKeyword>(input, ""foo"");     // Fails (correct)
    myFunc<AllowedKeyword>(input, ""hello"");   // Works (correct)
    myFunc<AllowedKeyword>(""hello"", ""world""); // Works (correct) 
    myFunc<AllowedKeyword>(""hello"", ""foo"");   // Fails (correct) 
",1533761480.0
Hath995,"Assuming you have a rough idea of the shape the json you're getting then just create a type or an interface.


    type HiJson = {name: string, data: number[]};
    /*or*/
    interface IHiJson {
      name: string;
      data: number[];
    }
    let j: hiJson = {name:""hi"", data:[1,2,3]};
    function test(l: HiJson): void {
    ...
    }
    //To get really fancy you can say anything has at least those properties but possibly more
    function test<T extends IHiJson>(l: T): void {
      ...
    }",1533687861.0
ProdigySim,"[TypeScript 2.9 added a --resolveJsonModule flag](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html), which will extract some basic type information from JSON. I've never used it, but you may be able to leverage it to get typed JSON in your tests if you import it.",1533702778.0
TYB069,You can also check [Typed JSON parse and stringify for TypeScript.](https://github.com/deepsweet/typeon) out.,1533760360.0
spacejack2114,I can't believe Go is growing faster.,1533688804.0
kreebog,I'm too busy playing with typescript to learn go! ,1533689195.0
alialtun14,The link: [https://madnight.github.io/githut/#/pull\_requests/2018/2](https://madnight.github.io/githut/#/pull_requests/2018/2),1533676432.0
dangerzone2,"Go and TS are my 2 preferred backend languages!  I must admit, Go has been favored lately.  ",1533741628.0
,"This gives me an idea of how we can go even further than this. You can use keyof to specify the keys on a whole object (like the `fs` module). If we can figure out how to ""rename"" a key in TypeScript, this will give us the ability for actual type-safe promisifying!",1533656622.0
scaleable,Hand written Markdown files,1533648625.0
PhysicalRedHead,"I see TypeScript as the documentation generator. When TypeScript code gets compiled, it saves the doc strings attached to the specific nodes in the AST, then inserts it into the produced \`.d.ts\` files. Doing jump-to-definition goes right to this generated document. I'm not sure what anybody needs outside of this, tbh.  


EDIT: Also worth mentioning that TypeScript reads jsdoc comments and uses it for type information.",1533649442.0
kwiwksh,"I use TypeDoc. Its not perfect and it has a lot of problems but its easy to generate and include in a CI process to automatically upload to something like GitHub pages. 

I'll also have an examples folder (usually containing some minimal viable working example) and a README detailing some more high level things like motivation.

https://github.com/TypeStrong/typedoc  
https://docs.travis-ci.com/user/deployment/pages/",1533651628.0
zajrik,"I use jsdoc on my compiled JavaScript. It's kind of clunky to do so, and I have to jump through a lot of hoops sometimes to keep certain doc blocks from being removed (like any documentation block physically touching an interface or type at compile time will be removed, so I have to explicitly export the type so a js file will be generated for it and make sure the documentation block is separated from the type/interface)",1533698848.0
gevik,"I have used Dart in the very beginning and did't like the fact that I had to create all kinds of wrappers/interops for JS functionality. To me it was counter productive. Next to that, Dart felt like a completely new language to master at the time. With typescript you don't have these challenges (more or less) . I develop my code mostly in typescript. At the moment I am working on a large framework that is all written and tested in TS.",1533634039.0
corgrath,"TS builds on JavaScript and its benefits and language flaws. Same syntax, same data types, etc, etc.

TS is basically just typing on top of JavaScript.

Dart is a new language, which its own syntax and data types, features etc that does not exist in TypeScript.

Dart is more Java-ish than Typescript, for example in JavaScript there is ""undefined"" and ""null"", while Dart only has ""null"".

Here is a list of differences, language wise:

[https://softwareengineering.stackexchange.com/questions/167070/differences-between-typescript-and-dart](https://softwareengineering.stackexchange.com/questions/167070/differences-between-typescript-and-dart)

Like TypeScript, Dart can be used in both frontend and backend.

If Dart is used in BE, it has its own platform, like Node.js. If you use Dart in front end you compile it with ""dart2js"".

I agree on that the bridge between Dart and other JavaScript is a pain. TypeScript typings and regular JavaScript is annoying too, but Dart can be way more annoying to get right.

But if you compare Dart vs JavaScript, Dart is, imo, a better designed language.

Both are great, just depends on what you like.",1533636476.0
Trout_Tickler,You wouldn't.,1533635860.0
gee5ive,"Off the top of my head,

&#x200B;

1. Interop with JS is not your primary concern and you want to use a better language not the same language with syntactic sugar
2. you want to use a real type system that can't be bent to anyone's will or totally bypassed
3. You feel like you could benefit from reified generics 
4. You want to run the same code that you are writing on the backend and benefit from more predictable runtime behavior
5. Your into programming language design and feel like the goals of dart are more in line with your taste
6. You don't feel like choosing which language you write code in is about winning a popularity contest
7. You want to use flutter to create cross platform apps 

That's just off the top of my head, but Dart 2 trumps TS 3 in just about every way, and I really like TS, in the end though, it always bothered me knowing that all of it ""features"" were just a facade and in the end I was just dealing with  JS , which I'm not really a big fan of. ",1540918465.0
tudor07,"I have used all of them, Javascript, Typescript and Dart.

I am not a fan of Javascript at all and I would avoid it at all cost.

Currently on the project I am working on I am using Dart (specifically AngularDart) for web mostly because we use Flutter on mobile and we can reuse some code between web and mobile if we go with Dart on both of them.

I also used Typescript in the past for React Native projects and I really liked it.

From a web perspective, I liked more Typescript+React than AngularDart. It really helps that Typescript is a little bit closer to Javascript so you don't have to write/use so many wrappers.

Also I really like React over Angular so maybe because of this I am a little biased. I would really like a nice Dart+React solution. There is [OverReact](https://github.com/Workiva/over_react) but it is not used by many people and it isn't backed by some big company like Goole/Facebook so I am a bit more sceptical.

If I wouldn't have a Flutter mobile app I would go with Typescript, but because Flutter uses Dart it really helps using AngularDart because of code sharing.",1533639056.0
jincheker,Dart is like the son of google’s GWT (new developers may never heard of it). And I believe Dart will have the same destiny like his father.,1539299942.0
gamebuster,"Besides the obvious fact Dart! is dead... (it is, right?) Typescript is much closer to the actual language you're writing. Typescript embraces Javascript, making it more safe without trying to change it.

Dart! performs much more magic, trying to hide you're actually writing Javascript. JSFlow is on the other side of this spectrum: Even more close to JS.

edit: TIL, Dart is still very much alive :D ",1533635916.0
lenswipe,"Happy to help, but I don't really understand what it is that you're trying to accomplish here.

Personally, I'd just rewrite your tests manually in Jest.",1533574094.0
scaleable,"(not very experienced at it but...) jest seems to have really good ""pluggability"". You can do things like defining your own global testing functions/environment (maybe even putting tape into it). You probably wont be able to get away with refactoring nested tests, but that might cut a bit of the rewrites.",1533593695.0
fecal_brunch,"Seems nobody has read the title of your post. I'm not aware of any tools to automatically change from jest to tape, but I'll take tape over jest any day of the week.",1533613263.0
AngularBeginner,"> If I specify ""ES2015"" as target, why are all consts still converted to vars?

Are you sure you are specified `ES2015` as the target, and not `ES5`? Did you really set the `target` value to it, and not `lib`? Are you sure your tsconfig is used? Do you perhaps use additional tooling like Babel or Webpack?

Because it works fine.  
- ES2015: https://agentcooper.github.io/typescript-play/?target=2#code/MYewdgzgLgBAtgUwhAhgcwQLhtATgSzDRgF4YByACwQBsaQYB3EXGgE3IG4AoUSEGggB09NAApEydAgCUnIA  
- ES5: https://agentcooper.github.io/typescript-play/?target=1#code/MYewdgzgLgBAtgUwhAhgcwQLhtATgSzDRgF4YByACwQBsaQYB3EXGgE3IG4AoUSEGggB09NAApEydAgCUnIA

> why does the following assignment not cause an error?

It does, at least in my setup, using `@types/lodash` in version 4.14.116, `lodash` in 4.17.10 and TypeScript in 3.0.1, with all strict flags enabled.

The code is:

    import * as _ from 'lodash';
    function merge(num: number, str: string): string { return ''; }
    const curriedMerge: number = _.curryRight(merge);

And the error is:

> index.ts(3,7): error TS2322: Type 'RightCurriedFunction2<number, string, string>' is not assignable to type 'number'.

So it seems something in your setup is broken.",1533485285.0
AngularBeginner,"Perhaps the [project references/composite projects](https://github.com/Microsoft/TypeScript/issues/3469#issuecomment-400439520) introduced in TypeScript 3.0 could do what you want? I did not check it out in detail myself yet, so I can't tell.",1533485413.0
spacejack2114,"If you use npm-run-all you can fire up both watches in parallel with one npm command.

    ""scripts"" {
        ""watch:foo"": ""tsc -w foo"",
        ""watch:bar"": ""tsc -w bar"",
        ""watch"": ""run-p watch:*""
    }

    $ npm run watch",1533482258.0
incurious,I always run two. Never been much of a problem.,1533471122.0
tortus,This really reminds me of ExtJS.,1533390461.0
dvlsg,"Neat. I made a library that does something very similar to this a couple years ago.

Using iterators/yield was _so_ much slower than just using arrays and not worrying about lazy execution. Wonder if that's changed with improvements to engines like V8.",1533405515.0
AngularBeginner,A reference app with `strict` mode not enabled? Really?,1533313510.0
rheadit,"couldn't start the server...

no such file or directory, open './config.json'
",1533331889.0
spacejack2114,I used to use socket.io but discovered that it was actually a very heavy library with a lot of uneccessary abstraction for modern browsers. Using ws on node and plain WebSockets on the client is just about as easy and much more efficient.,1533338013.0
empty_other,"> Does anybody know to change the project type from node.js to typescript? 

If you already have a Nodejs project in Visual Studio, this is simple. Open up your \*.njsproj as a regular xml file. Search for the `</NodejsPort>` tag. On the line below it add` <EnableTypeScript>true</EnableTypeScript`\>. Then open up your solution, right click on the project and select ""Properties"", and you should be able to set a few typescript options.

I found this by creating both a ts and a js project, and doing a diff between the generated \*.njsproj files.",1533840754.0
Hath995,"Change the extension of your js files to ts. run `tsc --init` to create a tsconfig.json. Edit the config to your liking, then run `tsc` to compile your code.",1533324578.0
rift95,"> Does anybody know to change the project type from node.js to typescript?

Typescript is a transpiler not a runtime. 
I suggest looking up what typescript actually is before trying to use it. 

",1533280985.0
OlderThanReddit,Pretty sure this is the 'Generic Parameter Default' introduced in TypeScript 2.3.  It means if you omit the T then the type of T will be 'any'.,1533267326.0
sasmithjr,"`ForwardReference<T = WithAName>` sets a default generic type. If your example was `let a: ForwardReference = { forwardRef: myAnimal }`, it'd throw an error, but `let a: ForwardReference = { forwardRef: myX }` works just fine.",1533267378.0
jason0x43,"That syntax declares a default value for the generic `T`. You can optionally specify a type for `T`when you use the type. If you don’t, `T` will be `any`.",1533267431.0
surely_not_a_bot,"Like everyone said, it's the default generic type [introduced in TypeScript 2.3](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html#generic-parameter-defaults). And you're right, I don't think it's the handbook. Might as well open a PR for that...",1533303263.0
Saddddas,"You could try something like this:

    type OutputCallbacks<T> = {
        [K in keyof T]: T[K] extends EventEmitter<infer U> ? () => void : never;
    };

**outTest** will still have bar and biz with type **never,** IDE will show it but it will be not possible to implement or invoke them.",1533160942.0
cspotcode,"I do this in 2 steps.  First, I filter the keys I care about.  Second, I use the filtered union of keys to create a mapped type.  The second step is easy.  For the first step, I do it like this:

    type FilteredKeys<T, Criteria> = {[K in keyof T]: T[K] extends Criteria ? K : never}[keyof T];

Basically, the value for each key is either the key itself (if it passes the filter) or else `never`.  Then I subscript with `keyof T` to extract a union type.  `never` magically disappears from union types, leaving only the keys that pass the filter.

EDIT: this looks like exactly what /u/AngularBeginner already posted.",1533268751.0
AngularBeginner,"As a top-level comment, so I'm sure you see it:

    type OutputCallbackKeys<T> = {
        [K in keyof T]: T[K] extends EventEmitter<any> ? K : never
    }[keyof T];
    type OutputCallbacks<T> = {
        [K in OutputCallbackKeys<T>]: T[K] extends EventEmitter<any> ? () => void : never;
    };",1533228158.0
kaelwd,"https://github.com/vuetifyjs/vuetify/blob/4395c3b66ace8b6f4e52380a34aceb0702d95e21/src/util/mixins.ts

---
Edit: oh, `Gen<[T1, T2]>` instead of  `Gen<T1 & T2>`, ezpz.

    myFun<T extends Gen<any>[]> (...g: T): T extends Gen<infer U>[] ? Gen<U> : never

---
Edit again: nvm, that's still wrong - ends up being `Gen<T1 | T2>`. I don't think this is possible yet, we need [mapped tuple types](https://github.com/Microsoft/TypeScript/issues/25947):

    myFun<T extends Gen<any>[]> (...g: T): Gen<{ [E in keyof T]: T[E] extends Gen<infer U> ? U : never }>",1533194601.0
ndubien,I finally found my way through this problem but I need for that https://github.com/Microsoft/TypeScript/pull/26063/,1536220626.0
welkie,Understandable 👏 error 👏 messages 👏,1533170029.0
AngularBeginner,"Question 10 is **awful** code and I'm honestly shocked that this is even supported. It can lead to fallacy where you believe you have a value at runtime that you don't actually have. Another one of the type-traps of TypeScript.

    class Point { x: number; y: number; }
    interface Point3d extends Point { z: number; }
    
    const point3d: Point3d = { x: 0, y: 0, z: 0 };
    
    const realPoint: Point = new Point();
    const fakePoint: Point = point3d;
    
    // Will print true, as the ""Point"" is really a ""Point"""" instance.
    console.log(realPoint instanceof Point);
    
    // Will print false, as the ""Point"" is not really a ""Point"" instance.
    console.log(fakePoint instanceof Point);

Besides, with the strict checks enabled the code won't even compile.

The answer to question 17 is wrong. You can extend from a `type`, as long as it fulfills some requirements. This works just fine:

    type Foo = { a: string };
    interface Bar extends Foo { b: string; }

",1533228954.0
ower89,"I don't have a video but I do have some slides about it [https://docs.google.com/presentation/d/1RoPd4zlNd8sIHPmkd0umlHvNU1Mp5Lu\_3SpUpoJZgCE/p](https://docs.google.com/presentation/d/1RoPd4zlNd8sIHPmkd0umlHvNU1Mp5Lu_3SpUpoJZgCE/edit?usp=sharing)resent

Also a couple of videos that might help:

\- [https://www.youtube.com/watch?v=CTpKZgy0dpo](https://www.youtube.com/watch?v=CTpKZgy0dpo)

\- [https://www.youtube.com/watch?v=WkJagE7b5U0](https://www.youtube.com/watch?v=WkJagE7b5U0)

If you want to contribute to the TS compiler check out this as well [https://dev.to/remojansen/learn-how-to-contribute-to-the-typescript-compiler-on-github-through-a-real-world-example-4df0](https://dev.to/remojansen/learn-how-to-contribute-to-the-typescript-compiler-on-github-through-a-real-world-example-4df0)",1533120844.0
ClutchHunter,"I'd personally recommend the official handbook in the sidebar, it covers how the type system works under the hood enough for you to understand how to use it (e.g. it explains that due to how TS works there's no casting, merely assertion).",1533118975.0
BehindTheMath,Just run tsc with different parameters. ,1533092679.0
Spiritual_Dragonfly,I think the latest TypeScript 3.0 added a new feature called project references that would help you compile like this. You should google the announcement and read if it would work for your project.,1533522440.0
LetterBoxSnatch,"I think the easiest way to accomplish what you want is to serve your files via a server. One easy way to do this is to run “python -m SimpleHTTPServer” which will serve up the directory in which it sits.

If you really want to “compile to a single distributable,” you might want to look into using Webpack instead of SystemJS, which you could leverage to inline all of your code and assets into one single html file.

That makes it all sound simpler than it is. Good luck!",1533084208.0
RighteousRaichu,"This is a CORs thing. Essentially, what you did would’ve worked in years yonder, but is being blocked by security policies. (Which I believe you can disable with a flag in Chrome)",1533084868.0
verticalellipsis,"To get this working I think you need to:

1. Move `main.js` and `circle.js` out from `static` into a `src` dir, and rename them with `.ts` extensions

2. In `tsconfig.json`, set `outFile` to `static/main.js`

3. Also in `tsconfig.json`, set `include` to `[src/**/*]`

4. Compile the project using the `tsc` command. This will create `main.js`",1533105303.0
So_Brave,"Thanks so much for taking the time to focus on error messages this release, Daniel. It's been a real pain point for some of the more junior members of our team, and it would have been very easy for you to chalk it up to ""complex types beget complex errors"", so thanks again for doing the unsexy work (in comparison to the oh so sexy features you all have been including in every release)!",1532985674.0
recursive,`unknown` looks pretty cool.  I'm disappointed to see `BigInt` was cut though.,1532971894.0
wil2200,Relatively new to TS. The improved error message is a HUGE win for me. Thanks everyone!,1532988775.0
spacejack2114,Was wondering if `JSON.parse` would eventually change its return type to `unknown`?,1532999332.0
8solutions,"Hi Daniel, does the team have any opinions about how the Project references should coincide with Build servers/pipelines? My AWS CodeDeploy pipeline is triggered when I push a specific project to GitHub, so it does not have code access to the other projects (in my current paradigm). 

Is the project reference concept based off of any existing package management tools?

The tool is very convenient but I wonder if the convenience is at odds with NPM or Yarn's package management?",1533095347.0
8solutions,"Hi Daniel, I have been attempting to integrate Project References into my monorepo project and VSCode/TSLint are not finiding the referenced packages properly. I am not sure whether my code is wrong or if VSCode and TSLint simply don't support TS 3.0 yet.

Do you know if the latest versions of VSCode and TSLint should be able to index Project References? Does a watch/build command need to be running in the background?",1534441690.0
BehindTheMath,"`<any>result` casts `result` to type `any`. You're basically saying to the compiler, trust me that the type of `result` should be `any`.

That syntax actually isn't recommended anymore, since it looks similar to generics. Instead you should use `result as any`. ",1532945901.0
osgardia,For anyone else who stumbles across here: it's in the documentation: [https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions](https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions),1532941945.0
QW4K,Check out TypeStrict — https://github.com/krzkaczor/TypeStrict It consists of various rules that improve type checking and catch bugs.,1532943287.0
alfredmuffin,Tslint-config-airbnb is my favorite ,1532948136.0
ocawa,Google has an unofficial version right now that they use for their projects,1532979452.0
rssfrncs,{},1533033859.0
demonizah,"The `{ [clientId: string]: IConnection & { client } }` is, of course, the type that `connections` is said to be.

From the outermost braces, we can see that it is an object. So `connections` is meant to be an object.

The stuff inside describes additional requirements on the shape of the objects that can be assigned to `connections`.

`[clientId: string]` is what is called an 'index signature'. It's a bit like a 'catch-all' for unknown key-names. It says that this object can have any number of keys which should be strings. The `clientId` just indicates to us what those string keys are conceptually.

The `IConnection & { client }` describes the shape of the values that are allowed on the object. It means for each `clientId` string key that we had on our object, the value should be an object that matches the shape of whatever the `IConnection` interface requires, AND the object should also have a key called `client`, whose value can be anything (since no specific type has been specified).

The `&` lets you create a type that combines requirements from two (or more) existing types.

",1532926587.0
dungone,"You're declaring an interface for an indexable type (i.e. for an object).

The first part shows you the index signature.   `[clientId: string]` means that your keys can be any string. The syntax seems weird at first but you could do a lot of things with it.  You could do `[clientid in someList]` to indicate that the key has to be found in some whitelist that you provided,, or you could do `[clientId in keyof someObject]` to indicate that the keys in your object have to match one of the keys in some other kind of object that you have.

The second part is your value signature.   The `&` indicates an intersection type and all it means is that you want your value to have all the properties from IConnection plus one called ""client"".",1532929824.0
stun,"`[clientId: string]` is the first part.  

`: IConnection & { client }` describes the return type of calling the first part.  


    const key = “amazonClient”;  
    const myObject = myType[key];  
    myObject.client.callApi();

The `myObject` object above complies with `IConnection` interface AND it also has an object property `client` on it, but it doesn’t have any type annotation on it. So it is considered `any` in TypeScript.",1532923271.0
demoran,"I tried to run the code you pasted in node.  With a few additions I was able to make it work:

    import * as promptSync from 'prompt-sync';
    
    const prompt = promptSync({});
    const alert = console.log;

Aside from that, answering 'Attack' did indeed attack.

Keep in mind that 'Attack' is different from 'attack'.  Did you use the proper casing?",1532902833.0
GoliathMcDoogle,"To start, this is amazing, love it.

I've used / tried out all the various redux-typescript boilerplate reducer things, and have tried making my own. I was at a time doing something very similar to this but kept getting hung up on not being able to get it quite right and had to scrap it.

This approach is pretty exactly what I would want for typescript with redux, simple, elegant, easy to use. It's pretty clear what is going on, single file simplicity.

Will be using this over redoodle / alternatives going forwards, mostly because it is pretty much exactly what I was trying to get working myself, but just wasn't looking at it quite the way this library does.",1532969104.0
PhysicalRedHead,I'm not so sure that jsfiddle is the correct format to get help on this problem. I think what you're hitting is a tslint error. ([no-unused-variable tslint rule](https://palantir.github.io/tslint/rules/no-unused-variable/)),1532834110.0
Pingudiem,Stackblitz ,1532852364.0
superdopey,"I tried your code, and on line 53: 

`XP = 100 * zone`

Zone is not declared.",1532854014.0
,[deleted],1532799038.0
celmaigri,"I've been wondering a similar thing myself. We have a large react app that we did start effectively from scratch, I tried to convince the others to use Typescript, but for some reason they were against it then. Fast forward to now and they've realized that typing it is a good idea. We've messed around with flow, but honestly it kinda sucks in my opinion.

I'm wondering how I would go about converting the project to typescript in a piece-by-piece fashion.
",1532792570.0
the47thsense,"I'm preparing this step now for an almost100 LOC angularjs codebase. My current plan is to take each step slowly, the entire process will probably take a year as we're also still adding new features regularly.

The first couple of step is the hardest, once I've ironed out the various build steps and compiler settings, it's simply a matter of creating a few examples for the rest of the team to follow.

- first thing we'll do is simply run the entire thing through the tsc compiler as a build step before babel with the `allowJS` flags
- next step is to add `@ts-check` to a single file and reply on inferred types and JSDOC types, and expand from there
- also incrementally add types using `@types`
- once we cross 75% type coverage, turn on the `checkJS` flag in the compiler remove the `@ts-check` flags and instead add `@ts-ignore` to the remaining files
- convert files that are 100% typed to ts",1532861740.0
unshipped-outfit,"Just as a side note, are you already using the TypeScript compiler to check your ECMAScript? (// @ts-check in Code)

Output from that should help show why typescript is a good idea. ",1532790174.0
cspotcode,"Why do you specifically want to write external .d.ts?  You can enable checkJs and add JSDoc annotations, which I think will work really well.  You can check out the relevant TypeScript wiki page for details.  I'm on mobile so I can't get the link.

EDIT: for tone",1532797127.0
pe8ter,"I don’t know of any guides or blogs, but one place to start to get some traction is [dts-gen](https://www.npmjs.com/package/dts-gen). It takes JavaScript and does its best to create typings. Then you’ll need to go in and refine them.

After that, you can make sure your typings are well tested with [dtslint](https://www.npmjs.com/package/dtslint).",1532802070.0
Ameobea,"```ts
interface IMyInterface {
    pushToHistory: typeof push;
}
```",1532682830.0
TYB069,"As of TypeScript 2.9, you can also import types ad-hoc. It's useful when you want your file to be recognized as a script and not a module (any import/export statement in your file turns it into a module).

    interface IMyInterface {
      pushToHistory: typeof import('connected-react-router').push;
    }",1532891946.0
smthamazing,"I'm not sure if you really need a class here.

Generally, you use classes when you're going to create several similar objects that all have state and share some methods. If you don't need state, you use plain functions. None of these is more ""correct"", and TypeScript is not opinionated about using object-oriented, procedural or functional paradigm. 

A library can still provide classes to its users, but you shouldn't just ""wrap"" a library into a class by default. If what you need to provide your users is a callable function, just do that. If your function is somehow configurable, just provide a factory for this function (e.g. `createMyFunction(...)`). Using `new` to instantiate something callable would be unexpected and not very clear.",1532742218.0
saltupz,"IIUC You should then have the constructor return a function if you want the resulting to be a callable. However this does not suit a class, why not just use a plain old function, in fact the class syntax is sugar for a function, javascript is prototype based and does not have javalike semantics.",1532680359.0
scaleable,"Typescript JUST\* adds types to javascript, you should write TS code in the same way you write JS code.",1532710404.0
fecal_brunch,"Bit late, but don't let java experience confuse you, classes are noise unless you have a strong case for them.",1533770494.0
r0ck0,"This has been fantastic for me:  https://basarat.gitbooks.io/typescript/

Unlike most official docs, and even many articles/blogs etc, it's not just the ""what"" and ""how""... but for me at least, more importantly the ""when"" and ""why"" to use these features.

I find it very hard to learn/remember things unless I have a clear understanding of when and why I'm going to use them.

I've just been reading it online at the URL above.  You can also download epub/mobi/pdf files, or the source/markdown from Github: https://github.com/basarat/typescript-book ... being a github project it's constantly being updated and improved, and you can post github issues with suggestions etc.

Here's the dude's donation link: https://www.paypal.me/basaratali - I've got no affiliation, I've just got a lot of value from how easy this is to read.  Coming from PHP, I've found a lot of JS doco and especially NPM package descriptions to be quite vague, and make assumptions about knowing things.  This is one of the few JS resources I'm come across that explains things well.

Also there's quite a lot of stuff in there that's just good general JS learning (not just TypeScript) coming from another language.",1532677203.0
ower89,"Hi, I'm the author of Learning TypeScript 2.x you can learn more about it at [http://learningtypescript.com](http://learningtypescript.com)  Please feel free to ask me here any questions about the book if you are interested.",1532684929.0
demoran,I've found the [Typescript Release Notes](https://blogs.msdn.microsoft.com/typescript/) to be a good source of info. ,1532724151.0
polydev,"Notwithstanding the fact that you asked for a book recommendation and I am about to recommend not a book, have a look at

* [https://stackoverflow.com/tags/typescript](https://stackoverflow.com/tags/typescript)
* [https://stackoverflow.com/tags/typescript2.0](https://stackoverflow.com/tags/typescript2.0)

Much of my TypeScript sharpening has happened there.

TypeScript also evolves, and Stack Overflow answers often link to features-in-progress in [Microsoft's GitHub Issue Tracker](https://github.com/microsoft/typescript/issues), and *those* discussions also often informative ([example](https://github.com/Microsoft/TypeScript/issues/10727)).",1532704965.0
r0ck0,"Hey cool.... I just happen to be looking for things along these lines right now, I think?...

Basically I have fuckloads of JSON data that I've been collecting for years, some my own schemas and data that I've generated, and others have been scraped from the web.

I want to build a system with some kind of automation that I can just throw all the JSON files at, and it somehow makes schema fingerprints with a UUID for each one that identifies each unique schema.  Also many of the schemas from the scraped data especially won't be ***exactly*** the same, but very close... so I somehow want to have some way to get a ""score"" for how close schemas are to others... kind of like fuzzy image hashing, but for JSON structures.

So JSON files with the same structure will automatically be grouped together, and for each unique schema I've been thinking I'll autogenerate:

1. [JSON schemas](http://json-schema.org/)
1. [Joi schemas](https://github.com/hapijs/joi)
1. TypeScript interfaces

...to assist me with writing the code that will actually process the data in the end.

There's tools to convert between the 3 things above, and I'm guessing I'll first generate that JSON schema or Joi, and from there generate the TS interfaces, seeing TS interfaces support the least complexity (validation rules).

Could your library be a part of what I'm looking for in terms of assigning the schemas a fingerprint each, and also maybe detect closeness?  

I'm not expecting to find anything that does everything for me... just trying to figure out the best pieces to put together.

Also what are your thoughts on what I'm trying to achieve in general?  

Your project does sound like it's quite relevant to what I'm doing here... but the README.md could perhaps explain a little more ""why"" your library would be useful, and maybe some examples of situations people would use it for.  Perhaps some more tangible examples could help.  

Once I get a better understanding of what your library does I might have some suggestions there.  For example, database articles that use examples like ""company/department/manager/staff-member"", or ""animals/dogs/dog-breeds"" are much easier to understand than examples like ""foo/bar"".

Also curious if you use any of the 3 things above and your opinions of JSON schema -vs- Joi etc ... and how does your library differ from them? (not implying it's the same thing, just trying to get my head around what is used for what)

...and any other thoughts you have on the subject in general.  Thanks!",1532675710.0
AngularBeginner,"> The recommended IDEs for Flutter app development include Android Studio and IntelliJ Idea.

Ouch.",1532611708.0
nikcorg,The Functional Programming Slack also has a somewhat active TypeScript channel https://fpchat-invite.herokuapp.com/,1532621082.0
AngularBeginner,"The ##typescript channel on Freenode is fairly active too, for people that care about their memory usage and don't want to use Slack.",1532600597.0
spacejack2114,The [gitter channel](https://gitter.im/Microsoft/TypeScript) is pretty active.,1532795412.0
konaraddio,Sounds like this was inspired by Flutter. I think you should build and share a proof of concept.,1532523173.0
tme321,"It definitely looks interesting but it's hard to tell how it works as an entire system.

How do you handle routing?  How do you handle things like forms?  How do I make a component with a custom layout or am I constrained to only use the widgets the framework already provides?

I'm intrigued but can't tell from the example code what's possible and how.",1532524884.0
janaagaard,"A bit annoying that you are sharing screenshots, but I guess that this was the easiest way for you. Anyways:

You specify the name of the method as a string when calling createAction('doSomeWork'). This looks to me like there won't be a compile type error if I wrote a type, e.g. createAction('doSomeWokr'), and it also means that if I want to rename doSomeWork to showAlert, then I would have to remember to change the string. If these points are correct, I am sorry, but I think you are doing it wrong. One of the points of using TypeScript over JavaScript is to avoid these kinds of errors, and frameworks written in TypeScript should leverage that advantage.",1532592682.0
ThisAccountIs4Reddit,Would the derived classes support use of third-party libraries like [DataTables](https://datatables.net/) or [JSTree](https://www.jstree.com/)? Or would you build a base wrapper for that? ,1532527199.0
phyllotaxis,What problem does your framework solve?,1532550815.0
,[deleted],1532519036.0
Jodacola,"Are you using anything like [Babel](https://babeljs.io/) in your Webpack config?  I target es6 in my tsconfig and use Babel to go down to es5.  I honestly don't know whether I'm doing things optimally in my projects, but what I'm doing works for me.  Here are my rules in my Webpack config:

            rules: [
                // Node modules
                {
                    test: /\.jsx?$/,
                    use: [
                        'babel-loader'
                    ]
                },
                // TypeScript code
                {
                    test: /\.tsx?$/,
                    use: [
                        'babel-loader',
                        'ts-loader?{configFile:""tsconfig.json""}'
                    ]
                }
            ]

Since I'm including other non-TS libs from NPM, I have that ""Node modules"" rule for also making sure I have all those files covered upon import.

I prefer to do it this way is because it allows me to use more advanced [code splitting](https://webpack.js.org/guides/code-splitting/) features via Webpack.",1532522832.0
cspotcode,"Is awesome-typescript-loader configured to load the imported module?  (I'll call it ""foo"")  What is the file extension of ""foo""?  What are the ""include"", ""files"", and ""exclude"" arrays in your tsconfig?

You have ""allowJs"" set to false, meaning Typescript will not transpile .js files.

You don't need babel for this, but you might need to tweak your awesome-typescript-loader configuration or your tsconfig to ensure that Typescript downlevels all the files you want converted to ES5.",1533302280.0
interphx,"If I understand your issue correctly, you can do it like this (since TypeScript 2.8):

    type ValidKeys<T, TValue> = {
        [Key in keyof T]: T[Key] extends TValue ? Key : never
    }[keyof T];
    
    type ValidValueType = B['value'];
    const mapData =
        <TData, TKey extends ValidKeys<TData, ValidValueType>>
        (data: TData[], valueKey: TKey, labelKey: keyof TData) => {
        return data.map(v => {
            return {
                value: v[valueKey],
                label: v[labelKey]
            }
        })
    }
    
    const myData = [
        { a: 'qwe', b: 123, c: true, d: { bar: 0 } },
        { a: 'rty', b: 456, c: true, d: { bar: 0 } },
        { a: 'uio', b: 789, c: true, d: { bar: 0 } }
    ];
    
    mapData(myData, 'a', 'b'); // Ok
    mapData(myData, 'd', 'b'); // Error (at 'd')

Another option is to to make sure that `TData` extends what you want (an object where the field has a valid value) instead of filtering keys based on some condition.

    type ValidValueType = B['value'];
    const mapData =
        <TKey extends string, TData extends { [key in TKey]: ValidValueType }>
        (data: TData[], valueKey: TKey, labelKey: keyof TData) => {
        return data.map(v => {
            return {
                value: v[valueKey],
                label: v[labelKey]
            }
        })
    }
    
    mapData(myData, 'a', 'b'); // Ok
    mapData(myData, 'd', 'b'); // Error (at myData)",1532512040.0
BehindTheMath,I think what you're looking for is index signatures. ,1532498041.0
Charles_Stover,I'd make them an npm package and just npm install them onto each the front and back end.,1532455419.0
geon,"We usually have both front and back end in the same repo with the folders /backend, /frontend and /common .",1532457587.0
IZEDx,"Check out [project references in typescript 3.0](https://blogs.msdn.microsoft.com/typescript/2018/07/12/announcing-typescript-3-0-rc/), the examples given should solve what you're trying to achieve.",1532467177.0
illyrianHero,"From experience, only models are suited for share between back end and front end, either JS or TS. To answer your quesrion, yes you can use TS classes",1532458445.0
rduncan12345,"If you haven’t already - check out Nest Js

https://nestjs.com/",1532483806.0
PM_ME_YOUR_HIGHFIVE,"I usually have 2 classes, for example UserDTO and User (or UserViewModel)

In UserDTO you have fields that you don't want to display on the page (salt, hash, createdDate)

In User you have fields, methods that you need only on the page (getFullName(), getDefaultAvatarByGender())",1532503314.0
rduncan12345,Don’t think so. I added the project website to the original post,1532549477.0
KamiShikkaku,"This doesn't answer your question, but... You should really restructure your code so that class and function definitions are not right in the middle of your program flow. For your functions, try to use parameters rather than closures.",1532253976.0
demoran,"I got a little carried away

https://gist.github.com/demoran23/147825a02f5c569f9d36025081733b66",1532265144.0
geon,"The `if` on line 16 is a method named `if`, with an argument named `_EHP`, defaulting to `0`. It looks like you meant ot have an if-statement...",1532263544.0
cspotcode,"Click the variable's identifier and hit shift+F12 to see all references.  It'll show you all places where the variable is declared so you can see where it's being ""re-declared"" from.",1532234912.0
geon,vscode gives me no warning. What line and what word exactly is it? What version of vscode is it?,1532263228.0
tortus,"This is because `React.TouchEvent` and `React.MouseEvent` only live in the type space. Once the compiler converts everything to JS, they no longer exist.
  
You should be able to do something like  
  
    function isTouch(e: React.TouchEvent | React.MouseEvent): e is React.TouchEvent {
        return e.nativeEvent instanceof TouchEvent;
    }

Find something that exists at runtime that lets you confirm it's a touch event, and then `e is React.TouchEvent` lets the ts compiler be happy at compile time.

You can then do `if(isTouch(evt)) { /* inside here the ts compiler knows it's a React.TouchEvent */ } else { /* inside here it knows it's a React.MouseEvent */ }`
  
and btw, `typeof` always returns a string and would just be `""object""` if you did `typeof evt`, `instanceof` is probably what you want in this situation.",1532212322.0
Arffman,"You can do it in the exact same way. There is no difference to the APIs. TypeScript is just JavaScript with type checking, it doesn't take anything away from it.",1532153730.0
LastOfTheMohawkians,"I'm seems surprising you can't find this. So it makes me question what tool you're using to write your Typescript? 

I would highly recommend you downloading VSCode if you haven't already and write your code using that. It'll light up all your coding experience. ",1532156004.0
ClutchHunter,"I suspect the difficulty you're experiencing is not understanding why TS doesn't let you work with the variable to which you've assigned the value of your `getElementById` call. TS is actually helping you here; what if the element doesn't exist?

If you chuck it inside an if statement (e.g. `if (myElement) {}`) then it should let you work with it as it acts as a type guard.",1532177505.0
ghillerd,"> ""GetElementbyId"", and manipulate it in JS, but in TypeScript there does not seem to be an equalivant(I'm probably wrong though...)

i think this means you're thinking about typescript wrong. typescript is a superset of javascript - anything you can do in javascript, you can do in typescript, you just have to annotate.

    const elem: HTMLElement = document.getElementById('my-element');
    const child: HTMLEelement = document.createElement('p');
    child.textContent = 'You made this? I made this.'; // typescript knows this should be a string
    elem.appendChild(child);",1532163911.0
welkie,"With the correct setup, TypeScript will help you with the standard JavaScript browser code like `document.getElementById`. It's actually pretty clever. They've even got types for specific types of HTML elements. For example, the return type of `document.getElementsByTagName('script')` is actually `HTMLScriptElement[]`.

You just need to make sure that ""dom"" is included in the ""lib"" property of your tsconfig file, so that the compiler will pick up the DOM d.ts files. The JS code you generate will be capable of running in web browsers. Just keep in mind that if you do importing and exporting with multiple .ts files, you'll have to use Webpack etc to produce the final JS file so that everything is configured to still be importable and exportable in the browser.",1532204916.0
endjynn,"Once you feel a bit more comfortable using vanilla JavaScript to manipulate the DOM you could then add a JavaScript framework. I recommend Vuejs as it's the easiest to get started with.

[https://vuejs.org/](https://vuejs.org/)",1532164901.0
briangonzalez,Does `ts-node ./server/server.ts` work if invoked directly?,1532148322.0
ClutchHunter,Try changing your script to use nodemon's `--exec` argument pointing to ts-node.,1532192487.0
spacejack2114,"I think ts-node isn't using your server/tsconfig.json file. It's probably using the root level tsconfig that has `""module"": ""esnext""` which won't work for node. Try this in your nodemon.json file:

        ""exec"": ""ts-node --project ./server/tsconfig.json ./server/server.ts""
",1532229287.0
IZEDx,"I dunno about the default libraries in tsconfig, but the node one you gotta explicitly install using @types/node and the dom one should only be available when included in your libs in tsconfig",1532101985.0
BehindTheMath,"They are 2 different APIs. One is a WebAPI used for fetch, so it's only native to browsers. The other is a Node API used for streams, so it's only available in Node. ",1532103718.0
WestCoastDweller,So then I have something set wrong in my configs. For a node app vscode shouldn't be auto polling in that lib. ,1532103986.0
geon,"There is no reason to use classes. Use typescript to describe what you already have, instead of trying to rewrite the existing code. 

And you can do this on a file-by-file basis. Just rename to .ts, add types to all function arguments and fix any errors. Make sure you have full strictness enabled. 

Remember that typescript is just type annotations added to normal js. Ideally, when you are done, the compiled output should be identical to the js you started with. 

But you will obviously find type-bugs while porting. I like to make a separate commit for each bug fix instead of cramming it in with the ts port. Often it is nonsense, like too many arguments sent to functions, or strings instead of numbers. 

Sometimes you will find code that is just plain wrong and needs to be rewritten. You can ignore it for later by just typing everything as any. But make sure you actually come back and fix it, or it will poison all of your well typed code. 

It makes sense to start with the utility functions that are used everywhere, or all code importing them will still be partially untyped. 

I’ve done this and it works. 

To run the backend, I recommend ts-node. It is a drop-in replacement for node, that runs typescript. ",1531984557.0
__gc,"I don't really think using Typescript should drive you to using different approaches such as using a class or using functions. If you feel that what you're doing now is sane, than keep doing it. 

I feel like this really depends on what your ""certain functions"" do. If they are small, reusable, testable and easy to compose, then I would definitely export them one by one.

In regards to ""export the class itself and then instantiate the class inside of my controller"", that's generally seen an anti-pattern. If you need a certain class in a controller, don't instantiate it, pass the instance down as a dependency. ",1532008026.0
Drunken__Master,"Sorry I don't have any advice, just leaving a comment because I think what I currently don't understand about TS might also be answered here and I wanted to bookmark the discussion. ",1531984611.0
johnny0055,"Almost all advice in the thread so far seems to be about two things.

1. ""Best Practices"" they think you should already be doing even were typescript not even in the picture, like dependency injection or es6 modules.
2. The act of converting your js to ts shouldn't change much of your code on it's own.

It'd probably be best for you to do the least amount of work you can to achieve these as separate actions rather than attempting to do them together.",1532318757.0
geon,Don't use any. It won't save you time.,1531985542.0
Axohn,Tslint has a rule to forbid any typing. Its part of the rules from create react app typescript. ,1531985946.0
SimplyBilly,Enable “strict” and never look back.,1532050959.0
tme321,"I don't think you even need anything typescript specific here just use some standard js destructuring on the passed in parameter:

    function someRequestHandler(
        { body: {id, status} }: { body: Toaster}){  
        updateToasterInDb(id, status);
    }

Unless I'm misunderstanding what you are trying to achieve with the typing here?",1531870757.0
scaleable,"(not self-promotion, useful article)

One test done today: Page uses `pick`, `groupBy` and `toPairs`. Next.js app.

  - Direct import (es6 syntax): ~500kB
  - Babel plugin + webpack plugin: ~70kB
  - Approach 2 from article (use slash paths): 150kB

Conclusion: for that case not using lodash, ill have to rewrite those functions...",1531837318.0
gcanti,"I would add the return type, remove the default case and let TypeScript do its built-in exhaustivity checking",1531844174.0
kingcub,"I do something similar but just with a function in my personal typescript helpers library:

```
export function unreachable(x : never) {
  throw new Error(`This should be unreachable! but got ${x}`)
}
```",1531855191.0
overtowed,"This is neat, cleaner than what I was doing. I made a little modification because it's sometimes helpful to have a more descriptive message.


    export class UnreachableError extends Error {
      constructor(value: never, message = `Unreachable case: ${value}`) {
        super(message);
      }
    }


before, I was doing a type assertion with a typed identity function:

    default:
      throw Error(`Unreachable: ${never(val)}`);",1531868531.0
johnny0055,I'm just waiting to see how https://github.com/tc39/proposal-pattern-matching goes. It'd be cool to have something like this in typescript.,1532319023.0
emmanueltouzery,"it seems to me that what you want is a library with better JS collections. there are already several such libraries, like https://facebook.github.io/immutable-js/ https://github.com/funkia/list or my own https://github.com/emmanueltouzery/prelude.ts/

It is the way you say it, you have two types instead of extending the JS builtin array, and the compiler makes sure you don't mix-up. All these libraries also offer convenient back-and-forth conversion functions.",1531825420.0
LastOfTheMohawkians,"We do this, we use an common extendedArray function to wrap the underlying type. It works well. 

Btw the use of the term standard library is confusing here. Are you suggesting all browser APIs be abstracted? 

",1531806097.0
denistakeda,I would vote against it. In case of _.orderBy lodash can easily handle null and undefined values and return correct output. In case of someArray.orderBy we will have undefined doesn’t have orderBy function. And even with strict-null-checks option we have to wrap everything into if-else every now and then ,1531806821.0
smthamazing,"First of all, a usual disclamer about making sure your class doesn't have too many responsibilities applies.
    
As for your specific problem, if you have lots of methods in your class, chances are they belong to different ""responsibility zones"", and this is usually solved by interfaces:
    
    interface Foo {
        foo();
        // Other foo-related methods
    }

    interface Bar {
        bar();
        // Other bar-related methods
    }

    interface Baz {
        baz();
        // Other baz-related methods
    }

    class MyClass implements Foo, Bar, Baz {
        // Implementations for all the methods
    }

Alternatively, you can use composition:

    class MyClass {
        foo: Foo;
        bar: Bar;
        baz: Baz;
    }
    
Technically, you can access `MyClass.prototype` and add methods to it after the class declaration, but TypeScript won't see them, and it will hurt readability.",1531807911.0
oreppp,"Maybe use an interface.

Interface IBigOleClass { 
function1(param1: string): string; function2(param2: Number): Number;
... 
}


class BigOleClass : IBigOleClass { 
function1 = (param1) => { return param1 + ""somerhing""; }; 
function2 = (param2) => { return param2 + 1; };
... 
} 


",1531805909.0
TYB069,"It's called a _lookup type_. Just as you would access values in a hash table using the square bracket notation:

```
{ example: 1}[""example""] // => 1
```

You can ""look up"" the right-hand side of a type or interface.

```
type T1 = {
    example: string;
    anotherExample: number
}

type T2 = T1[""example""]; // => string
type T3 = T1[""example"" | ""anotherExample""]; // => string | number
```

But we don't have to provide the property names manually. Since `keyof T1` resolves to `""example"" | ""anotherExample""`, we can just type `T1[keyof T1` and it will do the same job as `T3`.

In your case, `FunctionPropertyNames<T>` does the following:

1. Loops through all properties of `T`.
2. When the value assigned to the currently inspected property is of type `Function`, it maps this property to its name. If it isn't, it's assigned `never`.
3. It performs the lookup, finding the union of all right-hand values just as in the above example. Note than the union of some `T` and `never` is just `T`.

In your case the right-hand values are `never | never | never | ""updatePart""`, which sums up to just `""updatePart""`.",1531769042.0
,"I think it filters for which attributes extend the function.

E: It may be a union of the attributes which meet that condition",1531766657.0
mingp,"Is this a wrapper around `prettier` and `eslint`, or is it its own app? What would be the motivation to choose this over `prettier` and `eslint`, other than it being 2-in-1?",1531681379.0
vivainio,"Out of curiosity, have you tried Immer?",1531559875.0
tehdog,"The problem is that generic types in typescripts are all bivariant (both co and contravariant). A read only array would be contravariant (ReadonlyArray<Cat> is assignable to ReadonlyArray<Animal>) but in this case, you want the T in Array<T>  to be neither (""invariant""). [See here](https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance).

Implementing proper covariance and contravariance is [an open issue](https://github.com/Microsoft/TypeScript/issues/10717), though I don't think it's being worked on.

",1531485291.0
xyrue,"I don't think there's a bug here. In line 9 you are telling TS that `animals` is of type `Array<Animal>` and it is technically true, but now it is up to you to enforce that.  
If you remove the type from animals, you will see an error.  
How is this different from `animals: any = cats`or `animals: Array<object> = cats`? since `Cat` extends both, this is completely correct, there is no point in extending a class otherwise...  ",1531482320.0
scaleable,"When assigning objects, it just checks the existence of *at least* the properties (the presence of an extra property wont make it unassignable).

There are some hacks into providing exact types (flow has `{| ... |}` syntax for that).

from https://github.com/Microsoft/TypeScript/issues/12936

You may mitigate that by just using less assignments and mutable types, and letting more inference kick in (each assignment is an oportunity for erasure).",1531485910.0
kodijo,"That is due to [type erasure](https://en.wikipedia.org/wiki/Type_erasure). I think this [FAQ](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-this-incorrect-cast-throw-a-runtime-error) should clarify the reason.

>TypeScript has type assertions, not type casts. The intent of <T>x is to say ""TypeScript, please treat x as a T"", not to perform a type-safe run-time conversion.

In Java you can perform similar bestialities, however the compiler usually warns you about the ""unsafe"" cast.

So it's up to the developer in such cases to not shoot his own foot when doing this.",1531483511.0
CouthlessWonder,"Cats are Animals, so you should be able to push a Cat onto an Animal array.  
I don't see what the problem is, `animals` is still true to `Array<Animal>`

It is the other way around that should not work, if you already had `animals`, you should not be able to assign it to `cats`, but what you are doing should be okay.",1531479648.0
CouthlessWonder,"I agree with what you are saying, `animals.push(dog);` is now adding a dog to cats.
TS is not a true language in the usual sense though, I think they just do a hell of a lot of work to try not let JS bight you.

Have you tried running ts with strict on?

",1531479778.0
LastOfTheMohawkians,"Imho this is not a bug but a feature of JavaScript. Arrays are not strongly typed and therefore pushing a dog into a cat array is perfectly legal.  

Typescript will save you from many bad things but bad JScript features..... Maybe not",1531515350.0
kwiwksh,I thought I had a pretty good understanding of what is coming in TS v3. I don't see what TS v3 is buying here that v2 wouldn't.,1531431821.0
tortus,At first glance this looks great. I have been looking for a better mocking library.,1531459393.0
alakazan,project references at last! Thanks Typescript team!,1531417995.0
squiffs,"Support for React’s defaultProps is pretty great, hoping it will also infer `props` types for lifecycle methods.",1531419341.0
thepiggz,"https://blogs.msdn.microsoft.com/typescript/2018/07/12/announcing-typescript-3-0-rc/#tuples-and-parameters

This makes me veeery happy to see!",1531456259.0
,[deleted],1531438398.0
smthamazing,"I'm so excited to see the progress on the type system features! It seems like the team might actually consider implementing higher-kindred types after the next few releases, which would allow to get rid of lots of developer nightmares, like typing `_.mapValues` manually. And the new tuples in 3.0 and named/partial template inference scheduled for 3.1 are super cool.",1531453993.0
iFarmGolems,Is it just me or is the type system getting more and more complex in each release?,1531457178.0
,"A slight nitpick (IMO) in the description of `unknown`.

> The any type is the most-capable type in TypeScript.

> There are often times where we want to describe the least-capable type in TypeScript.

If `unknown` is being described as the least-capable type, then if `never` is dual to `unknown` surely `never` must be the most-capable type?

I sometimes find the triangle between `any`, `never`, and `unknown` confusing.",1531470358.0
vinnl,"/u/DanielRosenwasser there are a couple of typo's in the code examples. 

When describing richer tuple types, type `LineNumberAndSomeStrings` is defined, but the text below that refers to it as `OneNumberAndSomeStrings`.

In any case, it looks to become an excellent release once again, thanks!

The first code example for the `unknown` type defines the function `bar`, even though it's called as `upperCase`.",1531470520.0
TypeScriptIsAwesome,Announcing TypeScript 1.8: [https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md),1531416347.0
CouthlessWonder,"Something like this maybe?

```
abstract class EntityBase {}
interface IRepository<T extends EntityBase> {}
class Repository<T extends EntityBase> implements IRepository<T> {}
```

edit: Code fix",1531399334.0
Yard_Gnome_Ninja,"Given enough time in the industry, I think we all inevitably run into someone we feel ""just doesn't get it"". Whatever ""it"" may be. And, sometimes/someday, it may even be us.

With that in mind, I think there are some things you can do and keep in mind when trying to help others understand something new to them.

First, I'd like to preface this by saying I hover somewhere slightly above a ""duct tape developer"". I'm no ""rockstar"" by any means, so take this as you will.

* Consider misunderstandings as a teaching opportunity

It may be frustrating, annoying or disheartening to feel like a team member is simply incapable of even pulling their weight. You have two options, try to help or try to get rid of them. Since firing someone isn't usually an option; As someone who understands the problem, if falls on you to try to teach, which you are. So, good work!

* Show how you expect it to be done

Again, I think you've got this covered, based on your post.

* Different people learn differently

I've known a number of developers that can pick up a 1k page book, read it over a day or two, and come in the next day and implement something none of the rest of the team knew we needed.

I, personally, am almost completely incapable of learning via a favorite exclamation by many developers: RTFM (Read The F#$king Manual). The words between blocks of example code are generally noise, at least until after I've banged it out myself and really savored the concept in practice. I'm not proud of this fact, but it's how I function.

* Some ""fundamentals"" can be easy to gloss over, especially if you didn't RTFM

""By Reference"" vs. ""By Value"" is easy to gloss over, imo, as are a number of other fundamental features of any language. You can easily write something that works just fine without realizing you are passing around a reference. It may not until they experience a mind-bending bug that they realize or can even appreciate what they've done.

* Different people have different values

You see this as bad code, because it is bad code. They may see this as ""good enough"" because ""it works"". You may value some code because, ""it's less error prone"", ""it's extensible"", ""it follows DRY"", ""it's small"", ""it's encapsulated"", etc. To them, possibly, ""getting it to work"" is enough to get them to the weekend and on to their next paycheck. When it breaks or needs updating because it doesn't do ""the thing"" correctly anymore, they'll figure out how to get it to ""just work"" again. Attempt to determine their values and it will go a long way to helping you understand how to work with them and what expectations you can have for them.

* Keep at it, continue code reviews, set expectations

Unfortunately, giving up on them isn't an option, unless you can remove/replace them or minimize their damage by distancing them from work that really matters. Their code and understanding may not get better without intervention. 

I would recommend requiring, not asking, them (and potentially the team) to get take a Pluralsight course (or the like), reading a book, or what have you. 

Allow it to be done during work hours if at all possible. Either a set number of hours or, heaven forbid, all day. I know a lot of people frown on this for numerous reasons, but if a person has issues valuing the work they do more than ""it works"", they're going to be resistant to doing the training on their own time. Also consider that the alternative is to not provide training time and there is a, likely higher, cost to an underperforming team member in the long run.

If allowing during work hours, stagger scheduling among team members (with this person being the first) so not everyone is doing it at the same time and actual work can get done.

Make sure you set a timeframe. I would suggest no more than a week or two; Shorter depending on their ability to do it during work hours.

Hopefully this was the tiniest bit valuable. There's no panacea, but I think understanding the person goes a long way. 

And unfortunately, I believe, there are people who really aren't cut out for certain work, development or otherwise. That valuation is, of course, up to you.",1531408847.0
geon,"Does this coworker use an editor with type hints, lke vscode?

If you can demonstrate how immensly useful that is compared to everything being `any`, perhaps it will help?",1531405633.0
moremattymattmatt,Is their code more buggy than other people's? Types help on larger projects with multiple people so may be some hard stats about their flaky code would help them focus.,1531407508.0
vinnl,"If he has a Javascript background, then I think the main think you should tell him is: write your code as if it's Javascript. Because it is. I find that considering TypeScript a tool to help communicate otherwise implicit assumptions to your coworkers really helps writing it ""properly"".

The above code is something he'd probably never write in Javascript, so he shouldn't usually write it in TypeScript either. (That said, I don't usually use enums either, so maybe that would be a tip you can give as well. Then again, that's probably because I'd use a union type over a string, which is basically how I'd write it in Javascript as well.",1531407922.0
Heka_FOF,"You can assign custom values for enums like this

`enum Gender {   Male = 'male',   Female = 'female',   Other = 'other' }`

Does that help?",1531388948.0
,[deleted],1531414156.0
y2bd,"First glance makes it look like Ok and Err are structurally equivalent, which means that TS can not distinguish between them (TS has no nominal typing and considers any two objects with the same shape to be the same type even if they have different names). 

If you change their `kind`s to `public kind: “ok”` and `public kind: “err”` respectively I feel it should wok. ",1531355378.0
kqadem,"Right(""hello"") -> Right<any, string> implements -> Either<any, string> . So:
Right.value = string which is valid since the return is Either.value = string|number. 
Same for left. regardless of interface or type version, both are working. 
Your approach is wrong. Have a look at conditional types. ",1531355478.0
vinnl,"Looks nice. One suggestion: I had to spend several clicks to find a code example to see what this project could bring me. It would be nice if you included one in all that empty space on your homepage :) Perhaps a common use case using Maybe might be a good idea, e.g. fetching an API response or something.",1531380377.0
gigobyte,This is the first release of a FP library I wrote. I really tried to create something that takes advantage of powerful functional programming constructs but doesn't feel overwhelming to beginners and people with no FP experience.,1531333176.0
slikts,How does this library compare to Sanctuary?,1531340359.0
mustafaekim,"hi, how does it compare to fp-ts ?",1531407795.0
bdchauvette,"The node module resolution algorithm basically crawls upwards until it finds a directory with a `node_modules` folder containing the package it's looking for.

I'm not sure how faithfully the TS compiler follows that resolution algorithm, but if there's no `@types/graphql` in your repo's own `node_modules`, it's possible it might be looking at a directory *above* your repo. The `../../../../../../` seems to indicate that might be the case. If you haven't already, try `cd ../../../../../../` to see what's going on in that dir.

I would also try copying the repo to a different directory that has no directories containing `node_modules` anywhere above it in the hierarchy.
",1531271080.0
tuxracer,Make sure you're committing either `package-lock.json` or `yarn.lock` to your repo. It's possible they're actually installing different versions of @types or other packages than you -- either at the top level in node_modules or a subdependency.,1531286120.0
sevenclev,"Just to be sure: You tried adding the esnext-lib for AsyncIterator?

    ""compilerOptions"": {
      ""lib"": [
         ""esnext.asynciterable""
       ],",1531342585.0
,[deleted],1531307842.0
slashess,"The ""unpacked"" example is a little overkill for you, I think. It gets the return value of functions and promises as well.

There's a couple ways to do what you need. 

The most straightforward way takes advantage of the fact that arrays are basically `type Array<T> = { [i: number]: T }`.

    // T must be some kind of array. This returns the type of T when indexed by a number. 
    type ElementType<T extends ArrayLike<any>> = T[number];

A second option  is using conditional types. Conditional types are mostly useful for inferring types or situations where you want to end up with different types based on what you pass in. This is more complex then the next solution.

    type ElementType<T> = 
        // is type T an array of elements of type U? If so, return U. Otherwise, return the ""never"" type (the input is not an array).
        T extends (infer U)[]
            ? U
            : never

The ""Unpacked"" type uses conditional types because it accepts many inputs and does a similar type-level operation to all of them. It uses the ""infer"" syntax just to show off the conditional type mechanism.",1531232741.0
scaleable,"    type UnwrapArray<T> = T extends Array<infer R> ? R : never

(99% when I use conditional types is for the infer things, and I just put a never there)",1531269961.0
smackfu,Very cool. Will need to try this. We used to do something similar in our angular.js app but couldn’t get the typing to work when we converted to Angular / TypeScript and had to just create separate mocks of each service.,1531223046.0
itslenny,"This and much more is already built in to jasmine's type defs

* `const whatever: jasmine.SpyObj<Http> = ...`
* `spyOn<MyType>(...)`
* `jasmine.createSpy<MyType>(...)`
* `jasmine.createSpyObj<MyType>(...)`
* `spyOnProperty<MyType>(...)`
* `expect<T>(...).toBe(...)`
* etc...

[Jasmine TypeDefs](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jasmine/index.d.ts)",1531283397.0
Artraxes,"Using a decorator, e.g. https://github.com/bet365/override-linting-rule, seems like a better approach than jsdoc comments.",1531080034.0
LastOfTheMohawkians,You can't argue these points but that says nothing bad about typescript imho. ,1530985791.0
scaleable,"Could we add ""typedefs authoring and maintenance"" to that list?",1531025213.0
mnasyrov,"Looks nice! Do you consider to support high-resolution timestamps by [`performance.now`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)? There is [""myrne/performance-now""](https://github.com/myrne/performance-now) github project where you can take a look how they use `performance.now` and fallback to node's `process.uptime` and `Date.now()`.",1530952458.0
kubicals,"I use console.time() and console.timeEnd() to read the time elapsed between 2 points. 

Check out  https://developer.mozilla.org/en-US/docs/Web/API/console",1530943426.0
tme321,"Having had a chance to do anything with It, just glancing at the code.  Two things stick out:

1.  It's very thoroughly documented so that's excellent.  I might argue that some of the documentation is too superfluous but as long as you keep the documentation up to date that's not a huge deal.

2.  Namespaces have mostly fallen out of favor since es6 added a module system.  Consider just using export or export default instead of using a namespace.  It doesn't really add anything to the code.",1530943961.0
scaleable,"This worked for me for your intent, after some headhammering

    const useStringAsKey = <In extends {}, K extends string>(
      previous: In,
      key: K,
    ) => {
      return Object.assign(previous, {[key]: 'someValue'}) as In & Record<K, string>
    }

    const test = useStringAsKey({ a: 2}, ""test"" as 'test')",1530929699.0
elderapo,Hey! I created this little library because I was getting annoyed by non strongly typed nature of normal EventEmitter. Let me know what you think.,1530895905.0
pspeter3,"This is really cool, thanks!",1530913929.0
cspotcode,"All the events and their argument types are declared in an interface?  I guess that works really well with subclassing, too.  Nifty!",1530915250.0
Zenosex,"very nice, thanks",1531342759.0
scaleable,"If you skim through express’ types, youll come across a couple of empty interfaces. Those are left there on purpose for augmentation.

So youd write something like declare global > namespace Express > interface Request and that would get merged into the existing one.",1530880472.0
cspotcode,It will not polyfill Array methods and stuff like that.  You'll need to load a polyfill like corejs.,1530846980.0
hmongoose,"A good rule of thumb: tsc makes up for missing syntax (eg. async/await, class), but won't provide missing APIs (eg. Promise, Array.prototype.find, ...)",1531046793.0
xealot,"Yes. It will inline the downlevel conversion.

Also, if you have lots of modules you should check out [https://github.com/Microsoft/tslib](https://github.com/Microsoft/tslib) as well, which is basically a centralized version of the things Typescript needs.",1530835196.0
Amos47,"Is there a single file or some way to check all the routes that are generated like this? I feel like it's a great system, but I dislike the decorators.

Of course I'm just a single redditor, I liked being able to easily find all the routes of an application and the `sendsResponse` decorator seems a little much. Why not just pass the typed express request, response and next?

I also want to say that this is great work and I appreciate this. I will be digging deeper.",1530829538.0
madcaesar,"Hahaha fuck me this made me laugh more than it should have. Took me way too long to get this shit sorted out, especially when you throw on prettier! Oh boy.....",1530828395.0
tehdog,"Something similar by me, though specifically for socket.io: https://github.com/phiresky/typed-socket.io

Can be used to

1. Fully type socket.io communication (without any runtime changes, example in readme)
2. Automatic runtime type checks for any amount of different client messages / remote calls with a single server/client schema definition ([example](https://github.com/phiresky/typed-socket.io/blob/master/example/chat-with-runtime-checks/common.ts#L12-L32))

",1530651135.0
Auronon,"So this is like protobuf, but it isn't protobuf.",1530649675.0
Bamboo_the_plant,"Set your tsconfig.json to use strict null checks and as many other strict options as you can stomach.

1. Make a single class, with those global variables as its static fields.

2. Every global function now becomes a static function on that class.

3. Add typings to the functions.

4. Determine whether any static variables/functions should become static/instance variables.

5. Refactor the class out into separate classes in separate files, if you're feeling brave.",1530710047.0
ClutchHunter,"I personally would find it easier to rebuild this from scratch, using the old source file as reference for any non-obvious business logic. Once you have it working within a sane boilerplate, improve said business logic.

YMMV.",1530728808.0
gieter,"Identify these first. Routes, models
/entities, views, business logic. Work from these. ",1530644414.0
iBlacky,My tip is to use vs-code for your editor - it’s typescript support is unbeatable ,1530657092.0
empty_other,"Document classes, methods and etc with jsdoc. The typescript compiler (in vscode or visual studio) can pick up types from jsdoc and make it easier to convert to typescript later. If you need to add properties to `window` then you can use `(window as any).fooBar`. But doing it like [this](https://stackoverflow.com/questions/12709074/how-do-you-explicitly-set-a-new-property-on-window-in-typescript) is safer.

Look for classes that can be split into separate files. Then you can convert those into typescript. If the ts files refer to something in the js files, declare them in a \*.d.ts file.

If your javascript don't use modules then don't use it in typescript either, until you are ready to convert the entire thing to modules. Typescript files become modules if they either contain a `import` statement or a top-level `export` statement. You can use `export` statement inside namespaces.",1530711160.0
ClutchHunter,"I personally would find it easier to rebuild this from scratch, using the old source file as reference for any non-obvious business logic. Once you have it working within a sane boilerplate, improve said business logic.

YMMV.",1530728815.0
kwiwksh,"Use tsc to build. Run with node.

~~TS-Node will evaluate the typescript on every run, whereas transpiling it only requires typescript to be evaluated once.~~
Edit: TS-Node should cache the compilation however it most certainly will be slower on initial execution.

Also this is better practice when deploying or distributing your application. This is extremely true when your application is a library to be consumed by others. 

TS-Node does have its use-cases, however I view it strictly as a development tool, not a deployment strategy. Specifically, I use TS-Node when running tests or coverage as it seems to play better with the NYC coverage utility and in development, would require a recompile anyways (since I'd be making changes to the code between runs).

",1530556070.0
,"I have always used `tsc --watch` in the background, and `node` to run the result. I feel this is cleaner, and also I don't really know what `ts-node` is doing for me so it's too much magic for me. But that's a secondary reason.",1530809685.0
misterlively,For local development I use nodemon with ts-node. Before deploying I run tsc with an output directory and source maps. Then to run the app I run node in that output directory.,1530594618.0
,[deleted],1530740176.0
vladjjj,"As someone who's never used TS on the backend, I'm curious does VS Code node debugging work transparently with TS?",1530606866.0
welkie,"Ooooh dear you've just opened this year's tabs-vs-spaces can of worms.

*grabs popcorn*",1530580842.0
i_spot_ads,"I use Nest, it's a little bit advanced, for large scale apps, but it works great with TypeScript out of the box: https://nestjs.com/",1530571410.0
_eps1lon,If you're already using create-react-app why not go all the way and use create-react-app-typescript?,1530559341.0
i_spot_ads,"how to add typescript to Angular:

Step 1:

    $ ng new myapp

Step 2:

there is no step 2",1530549454.0
j________,You might need to do something like this: https://www.typescriptlang.org/play/index.html#src=enum%20Types%20%7B%0D%0A%20%20%20%20SELECT_TAG%20%3D%20'SELECT_TAG'%2C%0D%0A%20%20%20%20SELECT_TAGS%20%3D%20'SELECT_TAGS'%0D%0A%7D%0D%0A%0D%0Afunction%20createAction%3CT%20extends%20string%2C%20P%3E(type%3A%20T%2C%20fn%3A%20(payload%3A%20P)%20%3D%3E%20P)%20%7B%0D%0A%20%20%20%20return%20(payload%3A%20P)%20%3D%3E%20(%7Btype%2C%20payload%3A%20fn(payload)%7D)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20selectTag%20%3D%20createAction(Types.SELECT_TAG%2C%20(payload%3A%20string)%20%3D%3E%20payload)%3B%0D%0A%0D%0Aconst%20action%20%3D%20selectTag('test'),1530483189.0
scaleable,"Enum is one of the early typescript constructs that creates both a runtime and a type element... which may cause some confusion.

  - (after TS ~1.5 they quite committed on not deviating from javascript)  
  - (classes are one of these special constructs)  

Let's say you write something like

    function send<T = 'something'>(t: T) {
        return t
    }

Even if T can ONLY be `something`, you still have to explicitly pass it to the argument, because otherwise TS would be ""magically"" adding runtime code instead of just type checking. TS commits on not adding ""non-JS magic features"". Reading from type info (which is soon to be removed on compilation) and generating ""concrete"" code from them would be classified as something out of TS scope. (the most notable deviation from that may be decorator metadata, which is tagged experimental).

I'm quite sure at the moment there are quite of a dozen of redux helpers for typescript out there (at this right moment 5 people might be writing a new lib so solve the same problem). Even with that - damn - it seems so hard to find those libs -- sometimes one or another pop on social media around and I get quite pissed off how couldnt I find them before. (I myself have written another redux helper bc my searches were improductive at the time...).",1530489883.0
sunra,"Type-signatures and type-arguments (the bits in between angle brackets) only exist at compile time - at run-time you are left with JavaScript code with all of the static-types striped out. So no, you can't do anything like that in TypeScript as it exists today.",1530494045.0
cspotcode,"It sounds like this is what you're asking:

> How do I infer one generic from function arguments and specify the other generic between angle brackets?

I'm basing this on your last code example, where you don't want to repeat `T`:

    function createAction<T, P>(type: T) {

The only way to do that is to split the generic binding over two function calls.  One function call binds generics via inference, the other passes them explicitly.  Something like this:

    function createAction<P>() {
        return function <T>(type: T) {
            return (payload: P) => ({ type, payload });
        }
    }
    let selectTag = createAction<string>()(Types.SELECT_TAG);

Did I understand the question correctly?",1530552011.0
PhysicalRedHead,"You can use an enum value directly if that's what you mean?
https://www.typescriptlang.org/play/index.html#src=enum%20ActionType%20%7B%0D%0A%20%20%20%20SELECT_TAG%20%3D%20'SELECT_TAG'%2C%0D%0A%20%20%20%20SELECT_TAGS%20%3D%20'SELECT_TAGS'%0D%0A%7D%0D%0A%0D%0Atype%20Key%20%3D%20keyof%20typeof%20ActionType%0D%0A%0D%0Atype%20Payload%20%3D%20any%0D%0A%0D%0Aconst%20createAction%20%3D%20%3CK%20extends%20Key%2C%20P%20extends%20Payload%3E(type%3A%20K%2C%20payload%3A%20P)%20%3D%3E%20(%7B%0D%0A%20%20%20%20type%2C%0D%0A%20%20%20%20payload%2C%0D%0A%7D)",1530486392.0
evertrooftop,"Hi everyone! I just made this. I'm interested to hear what people think of it. Is it just another pointless framework? My hope was that putting Typescript first, and having deep support for weirder HTTP features like `103 Early Hints` and HTTP/2 push made it enough of a unique thing to be worth building, but I'm curious what the community thinks.
",1530468699.0
tme321,I'm curious what is it you are looking for help with from contributors?,1530629930.0
tclineks,"This is an initial version. You can see output generated here: https://github.com/tmc/grpcutil/tree/master/protoc-gen-tstypes/testdata/output/defaults

Variations in flags are demonstrated in https://github.com/tmc/grpcutil/blob/master/protoc-gen-tstypes/examples.sh and their corresponding output is here: https://github.com/tmc/grpcutil/tree/master/protoc-gen-tstypes/testdata/output

The main thing id like feedback on is 1. What’s the cleanest way to express the types and semantics of https://github.com/tmc/grpcutil/blob/master/protoc-gen-tstypes/testdata/route_guide.proto and 2. Should I be declaring/generating modules instead of namespaces?",1530424920.0
misterlively,I just use default constructor arguments. For singletons I create a simple getInstance() static method. No framework needed.,1530424818.0
to_wit_to_who,"[InversifyJS](https://github.com/inversify/InversifyJS) is probably the most popular.  It's decent.  Maybe I'm just a dumbass, but I have had issues with it before and had trouble figuring out how to diagnose runtime errors with it.  
  
I actually prefer to use [TypeDI](https://github.com/typestack/typedi).  It's not as popular, but it's easier and simpler IMO.  It also has great integration with TypeORM and TypeGraphQL.",1530388325.0
dvlsg,"I prefer Inversify, mostly because it's very easy to set up [child containers](https://github.com/inversify/InversifyJS/blob/master/wiki/hierarchical_di.md), which are handy for request-specific resolutions without having to get into really weird, repetitive factory patterns.",1530393337.0
moltar,Awilix is great,1531000455.0
unshipped-outfit,What makes it confusing?,1530385674.0
ReddiPlex,To each their own. I honestly miss it when I switch back to C# on the server side. I think it pairs very well with constructor injection.,1530400237.0
pleerock,"of course it brings another way to do the same thing, but it is very convenient in most cases. You simply need to make a convention and use it as you wish. TypeScript isn't the only language that supports such syntax, Scala for example does it as well.",1530464958.0
cspotcode,"There's a tslint rule to disallow it.

https://palantir.github.io/tslint/rules/no-parameter-properties/

Personally I don't think they're so bad, especially in personal projects.  But for something larger, if my team was getting confused, I might enable that tslint rule.",1530552168.0
UberAtlas,"Very cool! Record<K, V> looks much simpler than:

{ [key: string]: string }

Definitely gonna be using that one instead from now on. ",1530371990.0
treyhuffine,The author's GitHub repo with examples - [https://github.com/ainalain/sandbox](https://github.com/ainalain/sandbox),1530381623.0
bterlson_,"Once you've got it, puzzle out how https://github.com/bterlson/strict-event-emitter-types works!",1530380833.0
tsuijten,"Some background info. For a project we wrote a code generator which generates decoders to decode JSON to Typescript types.

We use this to validate data we retrieve from REST api's. This way we are sure the JSON response matches the Typescript definitions and we get nice error messages when the JSON response is invalid.

We use [json-schema-to-typescript](https://github.com/bcherny/json-schema-to-typescript) and [Ajv and Ajv-Pack](https://github.com/epoberezkin/ajv) together with some lightweight custom code generation to convert a JSON schema to Typescript. This really helped us out in our project so we decided to opensource it.",1530263917.0
son_of_meat,"I argued against using decorators at my company based on the information presented in [this readme](https://www.npmjs.com/package/core-decorators)

>While the decorators spec has changed and is now stage-2, no transpiler has yet to implement these changes and until they do, this library won't either. Although the TypeScript documentation uses the phrase ""Decorators are a stage 2 proposal for JavaScript"" this is misleading because TypeScript still only implements the stage-0 version of the spec, which is very incompatible with stage-2 (as of this writing).""",1530243041.0
scaleable,"In what you call ""node.js communnity"", you could split them in some groups:

  1. Defenders of javascript'y style, which means - use functional-y constructs to build things (closures, proto inheritance, no use of `new` and classes);  
  2. Guys who just can't unstick OOPish style;
  3. Guys who don't care;

Guys from 1 were heavily against the addition of classes in JS. And they will be against decorators. A common thought is: if you are migrating to javascript, learn the damn javascript style, don't try to sew you previous language into it, please. On the other hand, guys from 1 would love the addition of heavier func style contructs, like the pipe operator.

Guys from 2 either don't get the JS style either can't get rid of their habits. They want features they used in Java/C# into JS.

As you can see, I'm mostly a guy from 1.",1530310115.0
synalx,"My vote is for using them. The downleveling of decorators via the `__decorate` helper is pretty simple. If the API changed in the future (which is a pretty big if) in some incompatible way and you had to migrate your decorators to something else, you could easily accomplish this through a one-time automated code transformation. Since there's a straightforward way out, there's no harm in using the feature.",1530230223.0
,[deleted],1530356875.0
fantara,"I’m still learning, so excuse my ignorance. 
What does this mean from a TypeScript usability standpoint? 
What takeaways can and should be applied to real world projects?

I understand you can construct custom interfaces and types, but I’m feeling there is some nuanced concept from this specific example that I’m not picking up.

I hope that made sense.

Great article!!
",1530236893.0
AlexVallat,How does this compare to [https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts) which seems to be doing something similar?,1530192907.0
Imposter1,Nice! Where'd you learn how to make something like this? Always curious as to how people go from CRUD side projects into games / more interactive apps.,1530284454.0
jaredvar,"I enjoyed looking through your code, nice job.",1530155744.0
RickyMarou,"I was thinking of doing something similar.
I'll be having a look at your implementation it looks solid :)",1530175962.0
HackerCrackerSlacker,Looks very nice. Perfect for C# devs moving to TypeScript. I like the extensible driver model. I wonder how difficult it would be to make a driver for Azure SQL.,1530195337.0
david370,"Hey on a side note, how do you find typescript as compared to c# ?",1530208285.0
lechatsportif,So pretty.  ,1530219267.0
Tiberisx,Very nice!,1530225787.0
ltray,"I would strongly recommend using vscode with the vim extension. While it doesn't perfectly emulate vim, it now does a pretty good job, and vscode is the best editor for integration with typescript (its written in typescript, after all).

From there you would install various intellisense extensions (npm intellisense, path intellisense, etc.), which will typeahead complete your imports.",1530122410.0
iloveboxcutters,https://www.npmjs.com/package/typesync,1530120620.0
trevorsg,https://aka.ms/types is pretty good for searching through public type definitions. ,1530122258.0
tfptfp,"German here. Subtitles are wrong because he speaks in a strong dialect (bavarian).

He points out oddities compared to other srong typed languages.

The oddities:

* if a function returns void, you can still use the function to set a variable. So a void function does not return nothing, it does return undefined. Equally it is okay to return undefined in a function that is defined to return void.

* you can use void to skip paranthesis to write a self invoked function (well this is more a javascript odditiy than typescript - but it get's extra confusing because of the void type in typescript)

* you can define a function that does only define a front part of a declared function signature and still give that as a valid parameter into the function with the longer singature (eg. callback functions)

* you can even define a different return type and value like boolean if the function signature needs to return void. And it works.

* intersection types and union types he finds pretty odd (but he finds it kind of cool) - in that part he describes also how types and interfaces can be used almost identicaly

* the whole concept of conditional types is mindblowing for him

* ""next level conditional type shit"" on the example of the JSONified type.

* case default statements generates warnings if, according to your conditional types, all cases are already covered - or shows you all the uncovered values (this is something he finds really cool)

conclusion for him: typescript is an unbelievable mighty tool even for javascript developers, if only for using it together with typed librarys to reduce errors.
",1530269246.0
Rollingdownhills,"I jumped around a bit and he explains the type system and how it can help you even if it is a bit scary and sometimes can seems like it is in the way.

It feels like an introduction to TS for sceptics of both TS and JS.",1530132002.0
SpoilerAlertsAhead,"As someone who is primarily a Java Developer who pretends to be a front end developer at times, I like Typescript because it makes my JavaScript more like Java.  It forces me to think about an actual API rather than

`function (value, success, error)`

What value does this function want?  What are the success and error callback functions going to look like?  What data can they expect as input?  If this is a small project, or only one or two devs will ever see this the problem isn't as big.

`function (value: number, success: (httpResult:string => string), error (httpResult:string => number))`

is instantly more valuable.  I can at a glance understand exactly what the function wants and will produce.  ",1530105044.0
bit_cmdr,"I have a bit of a chip on my shoulder when it comes to TypeScript for the same reason I have a chip on my shoulder about any typed language. I've had arguments ad-nauseam with devs and managers claiming that typed languages prevent bugs and runtime errors. I've used typed languages for over 14 years. I know that those claims are patently untrue. I really appreciated the author touching on those points and listing them as bad reasons. The nod to TDD was an excellent touch. I'm a firm believer in unit tests no matter what language you're using. I was all ready to jump in with more bad reasons, and I got a really good article that was very well written. TypeScript will save teams time, especially if they are already familiar with Intellisense/Content Assist. For those saying that TypeScript forces you into OO, I would have to disagree. I've used Scala for functional programming for a little over a year and it's just as easy to do typed functional programming as it is to write functional javascript. Great read!",1530210386.0
__gc,You can use the class as an interface instead. ,1530031566.0
kwiwksh,The best thing to do here is create the interface and have the class itself extend the interface. This is a common OOP practice.,1530031624.0
tme321,"Depends on how much effort you are willing to put in but if you want to deep dive you can walk the ts ast for a class and then create a new ast for an interface with the same members.

I've used [this lib](https://www.npmjs.com/package/ts-simple-ast) to work with the ast in a bit simpler of a manner.  That library is a little slow, although apparently performance improvements are on their road map, but it works well enough otherwise.  And if you are only going to generate the interfaces when you publish a build then the slow run times really shouldn't be an issue at all.  I'd just hate to have to do something with that lib while hot reloading changes or some workflow like that.",1530032812.0
avejack,"I am totally with you! I don't come from an C#/Java background but I also hate those nested '.then' and '.catch' syntaxes. It also can lead to a 'Callback hell'!

For me it's like this:
If I don't need to catch the specific error I am just surrounding my async tasks with a try/catch and break the operation on catch.

If I need a specific error then I am trying to resolve my promise with my own 'Error Object' rather than rejecting it. Then I would get the Custom Error Object as return and immediately after that I will check if my return is an instance of my Error Object and will goon with that information.

If it is mandatory for me to get an rejected promise... Well than I use the .then .catch syntax...

Hope my experience helps you!",1529991990.0
Capaj,"Sure this simple case looks less verbose. In real backend apps you typically do many async calls in tandem. Even if you don't today, you might want to add in the future. I'd say show your team more complex examples and demonstrate how much simpler async flow is.

For frontend code I'd say it's allright because you split by components anyway and usually a component only does one our two async code so it's not a big deal.",1530001837.0
toymachine11861,I'd say just make a compromise for the team and use whatever the group wants.  It _is_ for work.  It's cool.  Good job getting them to adopt ts.,1529990876.0
,"If I am attempting to get and map a result from the database I tend to use an await with a chained then.

```typescript
try {
    const people = await getPeopleFromDb().then(rows => rows.map(personFromRow));
    // Use `people`
} catch (e)
    // handle err
}
```",1530023325.0
RoHMaX,"A bit hacky, but, if you're interested, someone have made a library to catch error like in Go (it's compatible with TypeScript):

>\[ err, data\] **=** await to(getMyDat**a**());  
>  
>**if**(err) **return** new Error(""bad error"")

[https://www.npmjs.com/package/await-to-js](https://www.npmjs.com/package/await-to-js)

Blog about it:

[https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/](https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/)",1530066494.0
AngularBeginner,"Additionally to what the others said, I'd suggest to actually adopt a proper functional style: Don't use errors at all. Instead use a result object, which either is a success or a failure - but not throwing errors.

There are several FP (functional programming) libraries out there. You can take a look here: https://www.reddit.com/r/typescript/comments/7kgagy/looking_for_welltyped_functional_programming/

The code would be cleaner and easier to reason with. Another huge advantage is that you can actually properly type your error cases. With the promises as-is you simply can't type the error case - the error is always of type `any` (since you can throw anything in JS). It's not visible from the interfaces if a function can throw, and what it can throw. By applying more functional programming principles you could have a function return `Result<MyData, InvalidDataError | NoConnectionError>`, meaning the function either returns a success with the type `MyData`, or it may return a failure with either a `InvalidDataError` or a `NoConnectionError`. This also forces the developer to properly recognize and handle the error cases.",1529994077.0
AndyRoth,I've used it and have found that it works very well.,1529980722.0
AngularBeginner,Your link points to the Reddit post itself.,1530002773.0
trevorsg,"I'm having some trouble understanding what you're asking for. You can specify ""module"": ""es6"" to have TypeScript emit regular import statements in your JavaScript. If your deployment paths are different from what you have in source, you may need to use the ""paths"" compiler option to specify the mappings.",1529946652.0
andywer,"Have a look at the parcel bundler ([https://parceljs.org/](https://parceljs.org/)) and parcel-plugin-typescript. It's really easy to get started and requires almost no configuration!

Run

```
npm install --save-dev parcel-bundler parcel-plugin-typescript typescript
```

Create a `tsconfig.json`:
```json
{
  ""compilerOptions"": {
    ""module"": ""commonjs"",
    ""esModuleInterop"": true,
    ""target"": ""es5"",
    ""lib"": [
      ""es6"",
      ""dom""
    ]
  },
  ""include"": [
    ""./src/**/*""
  ]
}
```

Create an `index.html`:
```html
<!doctype html>
<html>
  <head>
    <meta charset=""UTF-8"">
  </head>
  <body>
    <script src=""./src/index.ts""></script>
  </body>
</html>
```

Finally, create the `src/index.ts`:

```ts
function add (...numbers: number[]) {
  return numbers.reduce((sum: number, n: number) => sum + n, 0)
}

console.log(`2 + 3 = `, add(2, 3))
```

Run with: `npx parcel index.html`

Create a static build with: `npx parcel build --public-url=./ --detailed-report index.html`

Hope that will get you started 😉",1529963309.0
evmar,Can you describe what you've done and why it's not acceptable?  Your description is pretty vague.,1529946642.0
empty_other,"Yes, you still need to add a module loader if you want to use javascript modules. I prefer SystemJS. Browser-support for module loading is right around the corner (except for IE11). 

You will need to target ""ES5"" in your tsconfig because neither browsers nor nodejs fully support ES6 yet. You will also need a Promise polyfill. [I used this one](https://github.com/lahmatiy/es6-promise-polyfill).

To load your first module, add this javascript to your `index.html`. Thats the entry point.

    System.import('Application').then(function(exportedItems) {
        var myJsApp = new exportedItems.Application();
    });

This will attempt to load the file ""./Application.js"" if it hasn't been loaded yet (a module is only loaded once, then the loader keeps the exported items in memory). The callback will return an object with the exported items from that file, and you can do whatever you would do to start your app.

The ""triple slash references"" when using an outfile works too. But it can cause problems with circular references. And the feature is deprecated.",1529960850.0
EarlMarshal,Afaik import should be supported in new version of all good browsers but you can still rely on es5/commonly and just load the transpired is files over http. Should work pretty straight forward and out of the box. ,1529974924.0
scaleable,"If you don't want to use any module bundler (webpack/parcel/requirejs) you could fall back to ""vanilla module-less"" files -- TS files without any root `import` or `exports`. You would be the one in control of the files you load by using `<script>` tags. Kick the compiler using `tsc -w`, choose whether you wish him to output the `.js` into the same folder or in a separate folder.

I'd list two approaches on listing which types are available for each file:
  - You can add all your TS files into the `include` section of your `tsconfig.json`, which means all types are global to every file;
  - Or you can add only ""entry points"" to your tsconfig, then use `///< reference >` tags;

3rd party typings (like jquery) usually declare both ""module"" and ""ambient""-scoped typings. Translating, just by having `@types/jquery` installed, you'd already have the `JQuery` global type avaliable for such use case.

When not using modules, the `namespace` tags are really suited to scope files and quite replace the pattern of wrapping a file in an IIFE.

Module-less JS scales bad and you will be afraid of splitting code into small files. You would probably regret not using any module system soon. But could be OK for small front-end napkin code.

Curiosity: The TS compiler itself does not use commonjs or es modules (or better, it uses ""vanilla"" global modules and namespaces and some custom build tool).",1529980698.0
seepel,"Got curious and found this issue https://github.com/Microsoft/TypeScript/issues/13422. Seems like if you aren’t working with node modules, then using the .js extension for your imports is your best bet, otherwise you’ll probably need to use a bundler or some other post build step. ",1530948135.0
itslenny,"Kinda cool proof of concept that shows how powerful the vs code plug in system is, but I'd NEVER want to do this. It's hard enough keeping track of all my open files without having one of the tabs being chat. ",1529982357.0
spacejack2114,"Maybe I'm imagining it, but I seem to be noticing a steady decline of Typescript criticism/hostility over on /r/javascript, especially over the past year or so.",1529900182.0
namesandfaces,"One doesn't even need to use TypeScript to benefit from it. As more and more library authors convert, and as people use intelligent IDE's like Visual Studio Code, they will get free benefits without doing anything to their project.",1529889790.0
gieter,I am a recent convert to Typescript. The developer experience is amazing. ,1529910369.0
sanity,In other words: He finally understood the purpose of static typing.,1529938949.0
AngularBeginner,"I strongly dislike your code style, but that's preference.

Tho I have a few constructive suggestions:

- Don't use `console` in your library. I'd immediately drop any library that dumps output to the console that I can't control. If you want to be able to log some output, let the user pass a `onError` or `onWarning` callback.
- Spreading an empty object literal is pointless, don't do that. In `envOverlay.ts` line 87 you have `{ ...{} }`. That makes no sense.
- You have a type-bug in your handling regarding the optional settings. In `envOverlay.ts` line 87 you create a new object by spreading your default options and the provided `options` type. In the target type `IEnvOverlaySettings` most properties are non-optional, and in the source type `IEnvOverlayOptions` all properties are optional. The huge issue here is that an optional property **can be set to `undefined` explicitly**, and the spread you use will use that explicit `undefined` value. So if I call `envOverlay('test', { disallow: undefined })` it's perfectly valid code (and is according to the types), but it will produce a bug in your library as the value is `undefined` in your target `settings: IEnvOverlaySettings`. Instead of having two types, one with required and one without optional properties, you should use the standard `Pick<>` type instead.
- Instead of accessing the DOM yourself, provide a way to just return the created HTML node.
- The signature for the `envOverlay` call is wrong in your readme. It mentions `options?: IEnvOverlayOptions`, but looking at the source I can see that it's **not** an optional argument, but it's a **required** argument with a default value. That's a difference. With `options?: ..` I could pass `undefined`, but with `options: IEnvOverlayOptions = {}` I could not.",1529917139.0
Splynx,Those downvoting please say why so I/it can improve,1529796375.0
cmcaboy,Very nice! I was just looking into this.,1542548875.0
SpoilerAlertsAhead,"While I cannot speak for tslint, my personal opinion is that doing too much in a file makes the code harder to read/understand and it's much easier to blur responsibility of one class ends and the other begins.

I am primarily a Java programmer where you can only have one public class per file, and when I use other languages like Kotlin that allow more, I still find myself generally limiting each file to one class.  ",1529673523.0
slashess,"Under the header ""rationale"".

[https://palantir.github.io/tslint/rules/max-classes-per-file/](https://palantir.github.io/tslint/rules/max-classes-per-file/)

Edit: I guess they don't explain *why* though. It's for two purposes: 

1. Organize code in a way that if you're looking for the definition of the class BookController, it's probably in a filed named something like \`BookController.ts\`.
2. Create a clear context for the responsibility of the file/class. ",1529673564.0
vinnl,"I haven't read the article, but just wanted to get this off my chest: who the hell creates awards for charting libraries? :P",1529669824.0
sickcodebruh420,The preview of their v4 on their site looks fantastic. I’ve never used a charting library that I love and really look forward to trying this one. ,1529678686.0
Dw0,"I'll join those who is not going to read the article and will try to guess the answer (if it starts with ""how"" is the sentence a question) instead: they sat in front of computers and wrote some typescript code.",1529700182.0
AngularBeginner,And keep in mind that the order of Google's search results is adjusted based on your previous searches. ;-) Your first result won't be the same for everyone else.,1529649524.0
kyranjamie,The same happened to me.  Quite an unfortunate error 😂,1529647448.0
trevorsg,"More like ""don't click any of the links on the entire first page of results."" :D",1529639448.0
tme321,"If you were just going to click the first link without looking why not hit ""I'm feeling lucky""?",1529637077.0
Max_Stern,Thanks for this post,1529680257.0
Bamboo_the_plant,"Just spent this evening fixing up the typings for my Redux store only to find this now. I've come to a similar solution, albeit likely with more boilerplate in exchange for less black-box/'magic' functions.

I like a lot of the design choices here. Finally, a solid, holistic approach to integrating React-Redux into a TypeScript project. Allow me to give that GitHub repo it's hundredth star! 🌠",1529628725.0
coskuns,"The following is supposed to work in Typescript and is the syntax to import things dynamically. 

let foo = import('foo')",1529616957.0
andywer,"There is an easier way when dealing with CoomonJS modules (= node modules):

```ts
import foo = require('./foo')
```

No `await` necessary, since node's `require()` is synchronous.",1529990144.0
AngularBeginner,`DeepReadonly<T>`,1529645910.0
,"Something like this?

    type DeepImmutable<T> = { readonly [K in keyof T]: Immutable<T[K]> };
    type Immutable<T> = T extends (infer U)[] ? List<DeepImmutable<U>> : DeepImmutable<T>;",1529793930.0
Auronon,"If you have feedback about my writing style or my content I am all ears.

I hoped you liked it.",1529648742.0
alex9158,"You can strip out null/undefined union cases by either doing an explicit undefined/null or ""falsey"" check

    const result = squareValueMap.get(key);
    if(result){
        spaces.top.left = result;  
    }
    
or by using the non null assertation operator (!)


        spaces.top.left = squareValueMap.get(key)!;     ",1529596455.0
iloveboxcutters,"    spaces.top.left = squareValueMap.get(key) as string;

or use an intermediary and a Type Guard

    const temp = squareValueMap.get('test');
    if (temp === undefined) { 
        // return or throw or handle here
    }
    else {
       spaces.top.left  = temp; 
    }",1529596556.0
ClutchHunter,"This awkwardness is why I replaced my maps with readonly objects.

e.g. from:

    const cfg = new Map<string, string>();
    cfg.set('name', 'Hodor');

to:

    interface Config { name: string; }
    const cfg: Readonly<Config> = { name: 'hodor' };",1529660511.0
marcelowa,"Try to remove the typeRoots completely from your tsconfig, it should automatically detect the types
Also can you paste the command you running ?",1529602674.0
LastOfTheMohawkians,"We use our home grown Maybe monad all the time in our Typescript. 

Since introducing we've noticed a few things. 

1.) Code is more correct and less error prone
2.) It's more efficient as better use of short circuiting
3.) Cyclic complexity is way down
4.) It's help spread functional programming practices through the team

",1529558157.0
,I'm not sure this is 100% Monad or Functor compliant because there is no way to distinguish a value of type `Nullable<undefined>` and a value of type `None`.,1529572029.0
Useless-Pickles,"Pro Tip: You can get rid of the need for all the typecasts in the code by changing the signature of nullableIsNone to be a type guard:

function nullableIsNone<T> (nullable: Nullable<T>): nullable is None { ... }",1529711727.0
AngularBeginner,Poor naming choice. `Nullable<T>` by your library and an incompatible NonNullable<T>` by the standard library.,1529564268.0
y2bd,"[io-ts](https://lorefnon.tech/2018/03/25/typescript-and-validations-at-runtime-boundaries/) is one that I’ve seen as well.

For JavaScript validation in general I know [joi](https://github.com/hapijs/joi) is popular. It doesn’t have any typescript type generation, but if you’ve already written out the interfaces you don’t really need that to be honest. ",1529511369.0
ihsw,"I cry and pray.

I'm serious, TypeScript's type-safety doesn't extend beyond compile-time. Yes you can perform your own client-side type checking but then you might as well be performing proper object validation with [yup](https://www.npmjs.com/package/yup) or something equivalent.",1529513850.0
Aior,"Class-validator, class-sanitizer and class-transformer by pleerock are very good tools.",1529511435.0
danvk,"You might want to look at https://quicktype.io/, I believe it can generate runtime checks from your interface.",1529527007.0
karptonite,"I've been using [normalizr](https://github.com/paularmstrong/normalizr), but the typescript integration isn't great, unfortunately.
Mainly, I wanted to say that now [this song](https://www.youtube.com/watch?v=JQNv2sY7Ge0) is stuck in my head.",1529512638.0
demoran,"So you're looking for dynamic static analysis on an object retrieved via an API?

I'm not sure that's possible.",1529515424.0
minus0,"What's your backend and IDE? For example, we use C# and Visual Studio. Typewriter will auto generate TS files based off of a template. 

There are NPM packages to work with swagger as well, which might cover your case.",1529587297.0
steveokay,"I experimented with a few different solutions, and in the end decided on using [https://github.com/ooesili/type-safe-json-decoder](https://github.com/ooesili/type-safe-json-decoder) .  It is heavily influenced by Elm's decoders.  It takes a little while to learn the pattern, but once you get the hang of it, it makes writing decoders pretty simple & fast.  I would recommend it.  Only bummer is that it doesn't have a huge amount of npm downloads or github stars.",1529510651.0
dmeadows1217,Seems kind of odd to hate typescript due to an issue you are having with VSCode,1529490153.0
,"The problem is not type script but the bundle system you use for transpiling the code.

Try webpack 4.",1529486737.0
tudor07,You have a problem with your local machine. Blaming this on TypeScript is childish.,1529498200.0
AngularBeginner,"How large are the projects? Two minutes sounds really excessive. The projects would need to have several million lines of code, and even then it's questionable.

Make sure your VSCode is updated. Also check if perhaps those projects are configured to use the local TypeScript SDK and if that TypeScript version is perhaps slow. You already said you disabled all extensions, so that should be ruled out (especially disable any angular and tslint extension).

Do your co-workers have the same issues? Could you try another machine?",1529492481.0
ToxicalToast,To Answer your Question: Yes.,1529500777.0
hobozilla,Looks interesting. Web3.js (the Ethereum JS client) uses a similar system.,1529474753.0
spacejack2114,"I've needed something similar myself, but instead I just composed a simple object: `{promise, emitter}`",1529496731.0
AngularBeginner,"So similar to io-ts. That's great, we need more options. I'm working on an alternative version too. :-)",1529492567.0
Dandamis,I must admit I find myself guilty of using async/await in some scenarios. But for 90% of the async data you probably want to use RxJs. Otherwise your code will look like callback hell again when things get a bit more complicated with async data.,1529443817.0
grauenwolf,Explicit cast? https://tutorialstown.com/typescript-explicit-casting/,1529367339.0
kingdaro,"Unless I'm missing something, [the example given seems to compile without any errors](https://www.typescriptlang.org/play/index.html#src=abstract%20class%20Test%3CA%3E%20%7B%0D%0A%20%20%20%20abstract%20get\(z\)%3A%20A%20%7C%20undefined%0D%0A%0D%0A%20%20%20%20abstract%20create\(z\)%3A%20A%0D%0A%0D%0A%20%20%20%20getOrCreate\(z\)%3A%20A%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20a%20%3D%20this.get\(z\)%0D%0A%20%20%20%20%20%20%20%20return%20a%20%3F%20a%20%3A%20this.create\(z\)%0D%0A%20%20%20%20%7D%0D%0A%7D)

Maybe... upgrade your TS version? Not sure what could be the problem here.

EDIT: Oof, just saw your reply to the other comment that you'd gotten it working. Yeah, the TS server can be slow like that sometimes",1529376613.0
qadbap,"You could do ""get(z) as A"" in getOrCreate function",1529376790.0
guncha,Just return the promise and change the return type of the function to `Promise<string>`.,1529350533.0
Move_Zig,"I'll take a crack at it. (Note: I didn't test any of this.)

I changed some `let`s to `const`s because they weren't changing. Also, when you're initializing a variable, it's considered best practice to not explicitly declare the type.

---

**callback**

    const getCFPrice = (cardName: string, cb: (err: Error | null, result?: string) => void): void => {
    
      const options = {
        uri: cfSearchPageWithCardName(cardName),
        transform: (body: any) => { return cheerio.load(body); },
      };
    
      rp(options).then(($: any) => {
        const cardPrice: string = $('h3.grid-item-price').html();
        console.log(cardPrice + 'test2');
        cb(null, cardPrice);
      }).catch((err: any) => {
        console.log(err);
        cb(err);
      });
    
    }

Use it like this:

    getCFPrice('foo', (err, cardPrice) => {
      if (err) throw err;
      console.log(cardPrice);
    });

---

**promise**

Another way would be to just return the promise you are using inside the function. But if you are just returning the promise from `rp`, you won't have your string and you'll have to do additional processing outside the function:

    const getCFPrice = (cardName: string): Promise<any> => {
    
      const options = {
        uri: cfSearchPageWithCardName(cardName),
        transform: (body: any) => { return cheerio.load(body); },
      };
    
      return rp(options);
    
    }

And use it like this:

    getCFPrice('foo').then(($) => {
      const cardPrice: string = $('h3.grid-item-price').html();
      // do stuff
    }).catch((err) => {
      // other stuff
    });

But if you want to do that processing you're doing and return a Promise<string>:

    const getCFPrice = (cardName: string): Promise<string> => {
    
      const options = {
        uri: cfSearchPageWithCardName(cardName),
        transform: (body: any) => { return cheerio.load(body); },
      };
    
      return new Promise((resolve, reject) => {
        rp(options).then(($: any) => {
          const cardPrice: string = $('h3.grid-item-price').html();
          console.log(cardPrice + 'test2');
          resolve(cardPrice);
        }).catch((err) => {
          console.log(err);
          reject(err);
        });
      });
    
    }

Used like this:

    getCFPrice('foo').then((cardPrice) => {
      // do stuff
    }).catch((err) => {
      // other stuff
    });    

---

**async/await**

But my favorite way is to use async/await syntax:

    const getCFPrice = async (cardName: string): Promise<string> => {
    
      const options = {
        uri: cfSearchPageWithCardName(cardName),
        transform: (body: any) => { return cheerio.load(body); },
      };
    
      const $ = await rp(options);
      const cardPrice: string = $('h3.grid-item-price').html();
      console.log(cardPrice + 'test2');
      return cardPrice;
    
    }

Then either

    getCFPrice('foo').then((cardPrice) => {
      // do stuff
    }).catch((err) => {
      // other stuff
    });

or (if you're in an async function already)

    try {
      const cardPrice = await getCFPrice('foo');
      // do stuff
    } catch(err) {
      // other stuff
    });
",1529350798.0
kingdaro,"If you can, I think having two separate functions would be a better idea, e.g. `returnObject(): object` and `returnString(): string`, and you can extract shared logic into a function. It's easier to type and much more readable than using a flag argument. In a vacuum, it's unclear what `doThing(true)` means; do the thing true-ly?",1529360684.0
icholy,Don't write code like that ...,1529381570.0
guncha,"1. All function arguments should have an explicit type
2. Return types can usually be inferred, but sometimes you want to check that the function actually returns what you're thinking it does, especially during development. Also contextual typing is useful with the return types.
3. Initializers can usually infer the correct type so writing `const x: string = ""foo""` doesn't add any clarity - it in fact reduces it.
4. The exception to 3. is when you initialize inherited class properties like React's state - you always want to explicitly repeat the type since the type system will just let you add undeclared properties willy nilly.",1529345147.0
vinnl,"Function parameters, preferably return types, everything that is `any` (e.g. `fetch` responses), the rest somewhat according to intuition.",1529341366.0
BehindTheMath,"I try to be as explicit as possible, for 2 reasons:

1. It ensures that the actual type matches what I expect it to be.
2. It makes it easy to see with a glance what the type is, without using Intellisense. ",1529342542.0
littlecodebites,"When I use TS in small projects I just make type declarations where it matters the most, this is for small projects, personal tools. On big projects tho, I make everything very explicit, to avoid lot of dumb bugs.",1529363299.0
empty_other,"Intellisense on Visual Studio is faster when you explicitly define types, i noticed when i was working on converting a project from js to ts.",1529415110.0
scaleable,Maximum type inference. Less code = less bugs.,1529347709.0
RickyMarou,"I believe that people with these opinions never worked on big code base with a type system and proper tooling.
They just don't know what they miss.

If you have a big project without typing and it does not have an excellent test coverage, you are just insane.
Types and static analysis does not make tests optional, but without them you have to heavily rely on tests to be sure that you are not breaking half your codebase every time you change something.",1529303078.0
vinnl,"I don't really let it bother me (other than enjoying discussing it only sometimes, but that doesn't really emotionally affect me). The only moment it is relevant is with direct colleagues, but I'd just categorise that under the general challenge of inter-colleague-interactions.",1529305541.0
gieter,"That somehow newer is always better and thus the creation of gazillion new JS frameworks. Each dying a silent death after a few years. And guess who has to pick up where they left off.

Everybody thinks their shit smells the nicest. The community as a whole needs to come together and create a default JS core api. It is insane we need strpad, Date or HTTP community libraries. 
",1529308588.0
moremattymattmatt,"What bothers me is that every man and his dog seems to want to publish endless snippets of code to npm.

It can make it hard to find the good quality code that is being maintained.
 ",1529310506.0
thinkmatt,"I used to be that guy. I always relied on the name of my variables/arguments to know what data was being passed around, for example. We have a shared library with models, core logic, and utils used by about 20 apps of variying complexity.  Even though the code is clear as day to me (so I assume),  no one else can work on the core parts without my help.

As a tech lead though my goal now is to make sure other people can be effective without me. Typescript has been a godsend in this sense, and helps me find bugs in my own code all the time. Devs who are used to types have quickly taken advantage it, but we are still working to show the benefits to most of the junior devs. I find that VS Code makes a big difference. Those that use atom or Sublime are not setting their editors up for typescript so they don't see as much benefit.

Another huge win with the non js crowd is async/await, we are moving away from callbacks now and it feels similar... Easy for me to follow but not for others. Now I'm growing to enjoy it as well",1529324051.0
icholy,A lot of the js community is very green. The dunning kruger effect is strong.,1529334624.0
Randdist,"There are so many issues with no static typing, apart from being more error prone. 
Static typing gives you fast compiled code for free, whereas with dynamic typing the JIT compiler has to work everything out, which may and will fail in many cases. Static typing also allows method overloading which is an amazing feature that javascript misses out on. But knowing with what kind of objects you're dealing with is still one of the best things ever about static typing. Dynamic typing should be optional, not mandatory.

JS could be the best thing ever, if it just had static types. Typescript is okay, but it would need to be supported by browsers and V8.",1529319526.0
scaleable,"With that silly response he just let out that he doesn't know a sh\*t about type checkers.

One can have solid arguments againtst the use of type checkers, but that absolutely is not one. I'd quote solid arguments ones in the lines of:

\- Question that the complexity that it adds still dont outweigh its benefits. (Complexity which is comprised of much more than the types themselves, but also build tools, 3rd party typings, fresh/ustable/unpopular/unmantained tech, etc)

\- Question that one still has to write tests in the end, which overlap a bit in purpose with typings;

\- Question that types may encourage the use of determinate patterns;

(All of those questions can be countered or at least discussed)

From people like that I know IRL, I sometimes guess that some of these guys who have grown fear of type systems usually have transitioned out of some bad type system/pattern (like Java), and now they assume that all type systems are bad.",1529348296.0
mirhagk,"One of the major problems is that most people haven't experienced a type system anywhere near as nice as TypeScript. If you're experience with type systems is Java then the stance that type systems are restricting is entirely valid.

The best part about TypeScript IMO is it's embrace of the JavaScript development model. Defining classes is not necessary and you really don't need to change how you code to get the immense type benefits. Heck even things like string's as enums works flawlessly in typescript.

The early attempts at bringing types to javascript didn't work this way. They acted as Java in javascript and they didn't work very well. There was even libraries that defined types using JSON, and then didn't even give any compile time tools for it. It was a terrible world and anyone who experienced that would (rightly so) be hesitant of anything that claimed they bring type safety to the web. ",1529375429.0
,[deleted],1529379300.0
,"We use Typescript for type safety, and auto completion. Not because we don't/do know our code. Many people work on the same codebase and they need t be able to alt click and know what type that variable is.   
What bothers me is the worthless medium articles spammed so that their CVs have a Medium link",1529339287.0
SkyGG,"\> I feel the proponents of just javascript (and sometimes Flow)

I don't see how this extends to Flow, which is extremely similar to TypeScript. ",1529353821.0
rodrigoelp,"Apparently, this topic has offended somebody (is the internet nevertheless... that was to be expected), but I would love to know your point of view random anonymous that downvoted the topic. Would you mind sharing your thoughts? I really want to have a level-headed conversation with the community to see if there is something we can all improve.",1529309648.0
sithiss,http://lmgtfy.com/?q=typescript,1529228326.0
Lambda7,"JavaScript is loosely typed; programmers do not declare a type when defining a variable. 


TypeScript is a strongly typed superset of JavaScript. 


Here is a bit from a book I'm reading. [The Essentials of Object-Oriented JavaScript Programming](https://www.amazon.com/Pro-JavaScript-Design-Patterns-Object-Oriented)

**-----**

>The interface is one of the most useful tools in the object-oriented JavaScript programmer’s
toolbox. The first principle of reusable object-oriented design mentioned in the Gang of Four’s
Design Patterns says “Program to an interface, not an implementation,” telling you how fundamental
this concept is. The problem is that JavaScript has no built-in way of creating or implementing interfaces.
It also lacks built-in methods for determining whether an object implements the same set of
methods as another object, making it difficult to use objects interchangeably. Luckily, JavaScript
is extremely flexible, making it easy to add these features. 

**-----**

>Interfaces are not always needed. One of JavaScript’s greatest strengths is its flexibility, and enforcing
strict type checking where it is not needed reduces this flexibility. But careful use of the
Interface class can create more robust classes and more stable code.

**-----**

>Creating objects with private members is one of the most basic and useful features of any
object-oriented language. Declaring a method or attribute as private allows you to shield your
implementation details from other objects and promotes a loose coupling between them. It
allows you to maintain the integrity of your data and impose constraints on how it can be
modified. It also makes your code more reliable and easier to debug in environments where
many people are working on the same code base. In short, encapsulation is a cornerstone of
object-oriented design

**-----**

>Despite the fact that JavaScript is an object-oriented language, it does not have any builtin
mechanisms for declaring members to be public or private.",1529214716.0
geon,"Having the type to help you is amazing, and having a great ide like vscode is even amazinger. 

It will show you exactly what type everything is, and what they should be. ",1529220339.0
haytherecharlie,"Flow and Babel are part of the JS ecosystem, their transpilation and compilation process tools. I always compile JS these days, weather using Node or React. TypeScript offers the TSC cli interface, which acts the same as the Babel Cli interface. Flow is a static typing library and works the same with vs code. But I still stand by my @types import statement. That will always suck.",1529315241.0
guidojo,"In simple English: Typescript is almost the same as javascript, but it has some extra's. These extra's will make it more strict for you to prevent you from making simple mistakes.

Example:

In javascript you can only created untyped variables, meaning; variables that allow it have the value of type text, number, boolean etc. In typescript you can say: well this is my variable, BUT  it can only be a boolean and nothing else. If you then try to say that the new value will be some text, typescript will say: ""You said it can only be a boolean, so this is an error"".

There are a lot more rules you can setup for yourself which prevents a lot of errors and you having to check the type of stuff. Typescript in the end always compiles to normal javascript. So it's mostly helping you, the developer.",1529229422.0
haytherecharlie,"TypeScript became really popular at the dawn of es6 (es2015). Using the new features of the language meant that you would only get partial browser support. TypeScript offered a way to write modern es6 but also introduced strict typing. People lost their minds. 
However JavaScript caught up with things like “flow”, “Babel” and in the case of react. I honestly switch between TypeScript and JavaScript all the time and barely notice a difference these days.  Except in my opinion TypeScript adds a bunch of dependencies to my package.json which kinda sucks. 
People in programming are always elitist about what they think is best, it’s because we’re passionate. But honestly JavaScript+Babel+Flow and TypeScript are the same thing in the end. ",1529257429.0
PerfectOrphan31,"The main draw of Typescript is that it allows object oriented practices like classes, inheritance, and interfaces that pure JavaScript doesn't understand. Then it compiles into pure JS and runs with no problem. It also allows for more declarative typings, meaning when you say `const name = 'some string'` you will not be able to later assign it the value `508` because it is not a string. Really helps you from assigning bad values to your variables and makes your code (usually) run smoother.",1529212784.0
kkweon,"Assuming you have read the official TS documentation, it will be easier if you provide what you understand and which part you don’t understand...",1529212377.0
kaelwd,"> Java Script

Maybe learn JS first",1529243325.0
geon,"There really is no point in learning js as a separate language. Ts is just js, but with a compiler helping you avoid mistakes. 

And I do not agree with enabling ts features one by one. The great benefit is having all the safety checks at once. 

And learning how to code in js *without* types is a big hurdle in itself, since you need to rely on your own discipline a lot. Having the types makes it *easier*, not harder. ",1529218891.0
kingdaro,"Here's my recommendation: JS -> TS -> Framework

95% of TypeScript is just normal JavaScript, the rest is learning how the type system works and how to use the tooling around it.

On frameworks: it doesn't really matter which one you start out with, since most of them have a lot in common nowadays (components, one-way dataflow, reactivity of some kind).

If you want something easy to start with and pick up, go with Vue. Vue also works well with simpler setups that have less build steps; you can throw a script tag on a page and roll with that, if that's your thing.

If you care about the size of an ecosystem with lots of support/tutorials, go with React. React is my personal favorite, which happens to work especially well with TS. Since the HTML is created through JSX, which is really just a bunch of JS function calls, this allows pretty much everything to be strongly and safely typed, plus giving autocomplete on props and such.

If you want a cohesive framework with lots of functionality and conventions out of the box, go with Angular. A lot of people aren't a fan of rigidly having to do things ""the Angular way"", but for some, it's nice not having to make all of the architectural decisions yourself.

Others, feel free to correct me on any points here, or add anything that's worth a mention.",1529206206.0
littlecodebites,"You *could* learn first TypeScript, but I think it might be hard to come to JavaScript to unlearn some TypeScript features. TypeScript is more than just adding types to your JavaScript code, but it is made so that you can slowly progress integrating it's features. You can use the TS config file to tell it to accept normal JavaScript files for example. Basically use a TS config file that allows you to start with less strict features. Quoting the TS site:

>TypeScript starts from the same syntax and semantics that millions of JavaScript developers know today. Use existing JavaScript code, incorporate popular JavaScript libraries, and call TypeScript code from JavaScript.

That means you can learn JS and TS at the same time, just make a note in your mind what is TS. 

**Disclaimer**: I love TS, specially for big code bases.",1529206276.0
moremattymattmatt,"In a similar situation (I was writing Java backends), I learnt Typescript + Angular. I didn't, and still don't, feel any need to learn pure JS as a task in itself. I've had to learn some aspects of JS that aren't covered by the usual TS manuals but not often enough to make it worth doing as an initial task. I went with Angular specifically because its opinionated.

For what its worth I'm doing TS back ends now as well.",1529223253.0
apatheticonion,"Being doing front end for a little while now, have used all the major frameworks. They are about the same, despite what people say.

React is a little more hands on, Angular has lots of boilerplate, Vue is a less boilerplate-y Angular with some strange-ities.

All support typescript, they will all do what you want them to.

What's more important is understanding patterns. 

If you don't like JS much or don't want to set up an environment, go angular. It has ts/scss out of the box with the cli.",1529275251.0
Dandamis,"Try them all out. What have you got to lose? Then determine for yourself. Everbody will give different opinions.

Untill vue 3.0 launches, Angular is a no brainer if you got a brain. We'll see about vue 3, but I doubt they can ""beat"" angular. Probably will remain what it is now; a simple clear way to develop cute apps.",1529278181.0
r0ck0,"I'm coming from PHP.  Been doing webdev on & off for 20 years now, and I never really took the time to learn JS properly, so I always hated it.

Here's what I did:

* Started with just writing some CLI sysadmin type scripts (kind of like my own a very simple config/deployment system like ansible/puppet/chef etc)... so that I could focus on just learning JS itself (latest ES version), without even thinking about browser stuff.  

There's a book + video series called ""javascript for php developers"" that really helped me... i.e. it's not super basic ""learn to program"" stuff... it just focuses on telling you what is different.  It might even be useful for you as a Python programmer, and there's probably similar resources along the same lines too coming from Python.

I think if I jumped straight into webdev stuff that I would have a number of misconceptions of what is pure JS functionality vs browser stuff, so backend code would be a bit more confusing.

* Then about 2 weeks in, I changed my CLI system to use Typescript.  Again, I think it was helpful doing this outside the context of webdev.  I kind of felt like I should have just started it in Typescript from the start at the time, but I think it was good doing a couple of weeks of pure JS first... as it has helped me understand what Typescript is doing vs what JS already does.

* Now I'm building a site using Vue/Nuxt/Typescript.  Vue is easier to get started with than React I think seeing there's more n00b friendly guides etc.  Also makes it easier to test out Vue libraries etc seeing that it's very easy to set up jsfiddle etc pages that demo it (still possible with React, but not as common).  The main Vue documentation is really all you need to get started.  Nice thing about Nuxt is that I'm doing both some backend + frontend code in the same project.  Changing whether some code executes and renders HTML serverside -vs- in the browser is as simple as moving where the `<no-ssr></no-ssr>` tags are in the templates.  Pretty cool coming from the world where your backend is an entirely different language.  Note however that it's recommended that you do your backend API code in a separate project to the Nuxt project.  Although it is possible to do it all in the one project... but I'm probably going to set up a separate project with Koa for all the API calls.  Also looking at using Postgraphile too, which may largely negate a lot of backend code being written to begin with.
",1529651928.0
PerfectOrphan31,"The Angular [Tour of Heroes](https://angular.io/tutorial) gives a pretty good walk-through of what a Typescript/Angular project can look like. If you'd like to see a personal code base with a working example you can check out [my project's codebase](https://github.com/jmcdo29/zeldaPlay) and [corresponding web app](https://zeldaplay.herokuapp.com).
",1529212356.0
Arthanos,"You mentioned you're looking at Angular codebases, but if you'd like to see a real world TypeScript + React + Redux application, [here's \~7000 lines of code of that for an application with \~350 daily users ](https://github.com/Anveio/mturk-engine)that I'm working on. It also has a [guide](https://github.com/Anveio/mturk-engine/blob/master/DEVELOPERS.md) for reading the source code and running the application locally.",1529252456.0
mueller2004,Visual Studio Code,1529265314.0
vinnl,"Here's on, though I'm not sure how approachable it is: https://gitlab.com/Flockademic/Flockademic/

Note that it's actually three separate projects, located in the `/stacks` folder. Two back-ends and a front-end. The nice thing is that they can share some code, but especially [type definitions for the API endpoints](https://gitlab.com/Flockademic/Flockademic/tree/dev/lib/interfaces/endpoints). That means that if I change the API responses (or expected parameters) in the back-end, I know where to make changes in the front-end as well.",1529256309.0
scaleable,Github client,1529268138.0
Dandamis,Take some of your production code and turn it into typescript. ,1529274864.0
tehdog,You can use [io-ts](https://github.com/gcanti/io-ts). It works well.,1529188126.0
BTOdell,You can write a user-defined type guard function that manually checks the properties of the object to determine if it has the properties of the interface.,1529188001.0
nawitus,You can try this: https://github.com/typestack/class-validator,1529190911.0
alirobe,"I know it's not the simplest way, but I've found understaning & working with JSON Schema invaluable for that sort of stuff. There are tools that will convert a TS interface to a JSON schema. You can then validate using the schema... and even do awesome stuff like [this](https://github.com/mozilla-services/react-jsonschema-form). Many APIs and services provide a JSON schema.",1529217732.0
theluk246,Typescript is after transpiling pure JavaScript. You need to validate data by yourself or use libraries. ,1529185806.0
SimplyBilly,Class validator and class transformer (they are libs for converting and validating data / classes in both the browser and server),1529191520.0
dvlsg,"[joi](https://github.com/hapijs/joi) worked fine for me, last time I needed that (you'll need to add `@types/joi` too, though).

I know it's not quite what you're looking for, since you have to declare the interface in typescript, and then you basically have to declare the ""interface"" in joi as well. It does work, though.

I do really miss stuff like JSON.net's deserialization, where you can set it up to throw if properties are missing / invalid types / etc.",1529215688.0
_eps1lon,"Pass your `IState` as the second generic argument to `React.Component`.

Edit: Explanation: Not setting the generic state argument causes TS to infer `{}` as the state type. `IState` is assignable to `{}` so everything is fine. And you can assign any property to empty interfaces it seems like.",1529183452.0
jazpermo,"If you have the latest VS2017 along with ASP.NET Core 2.1, you can create an Angular project (In VS) that has everything setup to be able to use Angular CLI.",1529154892.0
Dannyboyng,I haven't tried the angular template inside VS2017 yet but my preference is to maintain 2 separate projects. One for the front-end (angular in VS Code) and one for the back-end (asp net core web api in VS2017). If I ever felt like I needed to switch back-end technologies like PHP Slim or Python Django or Ruby Rails or Java Spring. I can just throw away my old back-end and switch it out with another one. That should be one of the advantages of a SPA. That your front-end and back-end are decoupled and not so tightly coupled that you need to rewrite the whole thing.,1529158401.0
Aya409,"The vs2017 angular template has a very steep learning curve to it, it does both server side and client side rendering, hot module replacement, disabled on save typescript transpiling in favour of webpack instead. It’s a very good template but not for beginners imo.

You’d be better off learning angular first in visual studio code, when your comfortable with that, learn webpack. Once you’re comfortable with that, then have a look at the vs2017 template",1529167987.0
Dandamis,"This is actually great news! I'm an angular guy because of TypeScript. I'd love to see more competition. This coupled with the endorsement of TypeScript that Ryan Dahl just gave makes me really happy. 

It's the only logical way forward. Dynamic language is here to stay, especially for web-projects. And JavaScript does it best. Add an optional type-safety layer on top, to act as IDE support and mini unit-tests is just common sense. With the optional benefit of creating pretty decorators and things like implementing common programming paradigms.

Looking forward to the release!",1529094557.0
nikaone,"Damn it, this is a strong excuse  for me to learn ts.",1529074725.0
vinnl,"One thing that's interesting is: as a library author, how strict are you going to make your public interfaces if you also want your library to be used by ES users? For example, let's say you have a public method like this:

    publicMethod (someValue: SomeInterface) { /* ... */ }

Now, if `publicMethod` is to be called from a TypeScript codebase, this is fine. However, since it might be called from a Javascript codebase, you might want to also check whether `someValue` is not `null` or some other unexpected value. Would you then update the public interface to be

    publicMethod (someValue?: SomeInterface | null) { /* ... */ }

? Or would you do a cast inside the implementation, then do your assertions to get it back to `SomeInterface`? Or would you not do the cast at all and simply add the assertions and hope you don't forget any?",1529074093.0
hatepoorpeople,"This is great. One of the reasons I left Vue was TS seemed like an afterthought and it was a real pain to get it working. Hopefully now that it's a first class citizen, the TS support will be much better.",1529096737.0
arbroath_chokie,Do we know if there's any word on timescale for the 3.0 release?,1529146389.0
5arToto,"I'll copy my comment from there here if someone has something to add: 

It makes sense on larger projects in the long run.

I have been working on a Node + React app for almost a year now, there are around 4 programers in the team on average (there were some changes in the team structure a few times) and I can't begin to describe how happy I am we are using TS. A lot of new functionalities the client asks from us involve adding or refactoring something in a controller you haven't touched for a month but someone has possibly refactored it completely, or reusing a complex component with around 20 props that you took no part in developing. And from experience, the more specific the types were in the code (no any, or Object, or Function without parameters and returns defined) the easier and faster I could write the new feature. And if the task was a bug fix, half of the time somebody somewhere wasn't specific with the types and another person made some wrong assumption on what something is and the thing propagated God knows where and caused some unpredicted behaviour. And yes, we had typing issues, around once a month we add something larger to the project or do a major package update, but losing that 1-2 days of a single persons time to fix the typings (or write our own) and possibly refactor something is a lot better than losing around 3-4 days of everyone's time on finding an error that could have easily been avoided or noticed earlier by using types. ",1529065790.0
m12s,"I too found TypeScript really tedious and hindering to start with. My first eye-opener was turning ""noImplicitAny"" to false. It really helps the flow of the code get going.

Now, I never even consider doing a project without TypeScript, it's just so extremely fast and easy to write. It's also a dream when handing over a project, fewer hidden bugs and really easy to read once you get used to it. ",1529059180.0
unsung_unshift,"To the down-voters, I posted this primarily to show just how clueless some people are.  Anybody that refers to ""silly ... errors"" emitted by *any* programming language, probably needs to find a new craft.",1529065862.0
scaleable,"Copying my comment:

I wouldn't expect Ionic to be hard to get on typescript, since Angular is a lot simpler in terms of typing (OOP). ( ... )

On the other hand, React on typescript definitely feels quite immature.

  1. The type system itself is still lackluster for some of the heavy inference cases of React (mostly HOCs);

  2. You rely on 3rd party typings that sometimes are not first-class for the developer who wrote the lib;

  3. The language is constantly adding new features to address item 1, yet the 3rd party typings have to follow up. Also, DefinitelyTyped has no thing like a ""type definition TS version target"", which makes things even more messy.",1529070807.0
to_pe,"If you are an agency, don't bother.

If you are building a product, it is essential.",1529582215.0
stephen_yrk,"I agree with you - I want to love TypeScript but it’s frustrating to even set up with any tools in the React ecosystem, let alone use.

I’m trying to use the TypeScript with common React tools & it fights me every step of the way due to lack of documentation or Typescript-friendly versions of tools.

I'm convinced no one has ever successfully set up, say, a basic (unejected) Create React App + TypeScript app with basic tools such as Jest, Emotion/Styled Components, and Storybook. Something that would be so simple to do with the vanilla Create React App.
",1529069984.0
illyrianHero,"I highly appreciate it. Hope you dive with an advanced project as there aren't many resources for Node with Typescript.
Thanks
",1529015496.0
geon,Tiny but very useful library my boss wrote. I use it all the time. Great for Redux reducers. ,1528987591.0
recursive,"I can't figure out what the use for this is.  It says it saves a line, but it seems to me, you can just take the entire `case` out and not even use a library.  It seems to work even with `strictNullChecks`.  I don't get it.",1528991041.0
AngularBeginner,This is a variant of a function I've simply written in every code base. Definitely not worth adding yet another dependency. And using `JSON.stringify` for something like this is fairly silly. The data structure might not be serializable.,1529011687.0
turkish_gold,"This is a  library of one function, with two short statements. This should be a blog post or a tweet, not an npm package.",1528994609.0
lnri,This looks like it could really help out with some of my project ideas. I'll keep it in mind :),1529004104.0
welkie,I like this. I'll definitely be using it.,1529012442.0
banciur,pretty cool mate,1528985030.0
night_of_knee,"This looks great! I was thinking of this feature as _variadic generics_ after C++'s variadic templates but from my understanding it has the same functionality.

> With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists (such as JavaScript's `bind`, `call`, and `apply`).

I see it says that it's _possible_ to strongly define `bind` et al. Will TypeScript actually change the definition for these functions? 

It will greatly improve the safety of the language but I fear it will break many existing programs. Arguably these programs are already broken without knowing it, I hope they don't shy away from making the change.

--- 
**Note to self, read till the end next time**: 
>With this PR it becomes possible to strongly type the `bind`, `call`, and `apply` methods on function objects. This is however a breaking change for some existing code so we need to investigate the repercussions.",1528879461.0
jineshshah36,"Import everything directly into that file from a and b and export from there. What you want is

    export * from “../a”

Which I think is being considered but not standardized.",1528825514.0
TYB069,"    export * from ""../a"";
    export * from ""../b"";
    
    export as namespace myNamespace;

There's always that, but it makes `myNamespace` a global entity.",1528838383.0
coskuns,"I wouldn't trust vscode since it sometimes cannot show errors before you open a file. Seen this behavior many times. What's is more one's code doesn't always get packaged in an IDE environment. I get my packages packed using CI tools for instance. So vscode displaying errors is of no help there. 

I wrote ""if you are not using typescript first"" but obviously you are since you mentioned tsc running fine. 

Problem solved I believe. 

",1528833553.0
jineshshah36,"I’ve done something like this. I use yarn workspaces though, but for the TS part, you need a root tsconfig that covers all code within subpackages. That’s how you get your editor to properly see everything. Then in each subpackage, you can extend a base tsconfig and properly sets paths relative to that subpackage. This allows you to go into a subpackage and run tsc. You can opt not to have per package tsconfigs but you will lose some flexibility and may have trouble with the relative paths. ",1528825044.0
coskuns,"You might have a ""base"" tsconfig and extend it using other tsconfig files - see extends property of the tsconfig options. 

Then the rest should be easy. tsc accepts an argument called --project which expects a path to a tsconfig file. ",1528832194.0
tobegiannis,Good article but I am not adding webpack or similar tool so I can have short relatives paths in server side code.  It is fantastic for client side code and pretty easy to set up.  I wish they would add a feature so it could transpile `utils/config` to `../.../../utils/config` but I don’t think ts will ever implement this.  ,1528858800.0
,"The problem with the *no inferable types* rule is that you push your specification into the inference engine rather than your program. If inference changes between versions, the specification of your program changes. Omitting annotations also makes it harder to read code in plain-text.

I think there is a balance; personally, I'm against blanket rules like this.",1528814176.0
AngularBeginner,"> Only Type where Necessary

Be sure to **always** explicitly type variables that are initialized with an object literal. Do not use the inferred type here, that's just bad practice.",1528806976.0
geon,"Just to be clear; are you trying to create a custom type for an existing js module without typings?

Otherwise, you should not use a .d.ts file, nor the declare syntax. ",1528778383.0
AaronFriel,"I believe you can import them from the file:

```
import { oneType, twoType, RedType, BlueType } from ./types
```

You can also rename the file to just `.ts` or `.tsx` and use it as a module, exporting the types from that. Can you show me how you're trying to use the types?

Edit: Are you exporting the types from the `.d.ts` file?

e.g.:

`types.d.ts`:


    export type oneType = …

    export type twoType = ...

    export interface RedType {
    ...
    }

    export interface BlueType {
    ...
    }


And then in the other file, doing an import like above?
",1528760866.0
Devcon4,"Are you writing .d.ts files by hand? Tsc will generate those for you, and you only need to do that if you need to expose your types (library, npm package, etc). When your dealing within your own code you just import `import { OtherClass } from './Other class.ts';` you need to also make sure that your exporting your classes `export OtherClass { //implementation }` you can export multiple times so what you will see some ppl do is have an index.ts or public_api.ts that has `export * from './Other class.ts';` this is just a trick to make imports easier when you have multiple classes. ",1528777731.0
jshen,It’s terribly confusing to figure out how all of this works the first time. I spent many hours trying to figure out how to provide types for a library whose @types were out if date and wrong. ,1528777229.0
ClutchHunter,"Basically:

- If you're typing an untyped npm module, use `d.ts` with `declare module` anywhere within the project scope.
- If you're trying to add types that are globally available, use a `.d.ts` anywhere within the project scope.
- If you're trying to create a module of types (as you would ""regular"" code), then just add them to any `.ts` file and export/import like you would anything else.",1528836964.0
cspotcode,"I kept adding useful one-line type declarations to a markdown file on GitHub, until I finally published it to npm.  Most of these are purely typed -- no runtime overhead -- but a few have a runtime component.  This will be an identity or no-op function, so it compiles down to `function(a) {return a}`.  These shouldn't be a problem for any VM to optimize or minifier to compress or remove.

A very notable omissions is `DeepReadonly`, `DeepPartial`, etc.  I know various implementations have been posted here and there; I need to find a good one and include it.",1528752476.0
cannyshammy,"Some really clever stuff in here mate, nice work. Not sure when I would use half of them but good to know that they are there regardless :)",1528760919.0
AngularBeginner,You should add a LICENSE file..,1528782456.0
,Exporting all the argument types functions e.g. `ArgumentNType` seems quite verbose. Is it possible to export a single type that accepts a number literal type `N`?,1528814903.0
tbranyen,"Just built an API using tsoa for generation, but it has a few issues around model definition not accepting Pick or Partial interfaces. Maybe this will work better? Anyone used it?",1528777996.0
lnri,"So unlike the Typescript Quickstart for Node.js this doesn't automatically setup a template engine, password with facebook, and a bunch of other unnecessary things?",1528986390.0
cspotcode,"How about this?

    class EndObject extends BaseClass implements A, C {
        // error: type EndObject does not satisfy the constraint ""B""
        public prop = new PropRequiringB<this>();

You have to pass the generic param, but you use `this` so it always looks the same and shouldn't ever require refactoring.

EDIT: better yet, you're going to pass a reference to `this` to the prop, right?  So you can pass `this` to the constructor and bind the generic that way.

            public prop = new PropRequiringB(this);",1528738990.0
AngularBeginner,"No license, and thus not usable by anyone.",1528716310.0
esamatti,"I've found Immer to be the best solution for immutable updates with Typescript. Not a collection library but it's even better as it uses just regular js objects. 

https://github.com/mweststrate/immer",1528548710.0
emmanueltouzery,"looking at your example, i would say that you should use a plain typed JS object, using object spreads to add items to it?

    // definition
    const m = { foo: 1, bar: 'a' };
    // adding elements
    const m2 = { ...m, baz: -1};
    // removing elements
    const {foo, ...m3} = m2;

that's gonna be 100% fully type-safe. I don't know about having super-precise key types for ""general-purpose"" maps. What you want is pretty much a static object it seems to me, compile-time known, so JS objects seem a nice fit to me.

regarding immutable.js loose types, I felt the same frustration (well, for me it was more about its awkward types, and yes sometimes weak types too), and I also wanted an Option type, so I wrote a [typescript immutable collections library](https://github.com/emmanueltouzery/prelude.ts). It does have a `HashMap` but in this case I don't know if I would advise it. Reading from it would return Option<number|string>, because it doesn't know if the key's inside, so in fact it's even worse for your than the immutable.js one :-)",1528553219.0
ais04,https://github.com/emmanueltouzery/prelude.ts,1528570141.0
Gustorn,"If you want JS objects but with Immutable.js's benefits you should take a look at the [`Record`](https://facebook.github.io/immutable-js/docs/#/Record) type instead of `Map`. Make sure that you use the latest RC (v4.0.0-rc.9), it has _far_ better TS definitions than v3.",1528566802.0
spacejack2114,[monolite](https://github.com/kube/monolite) if you don't need to target browsers without Proxy support (no IE.),1528554237.0
bear1728,"I've been using [icepick](https://github.com/aearly/icepick) and it's been working well for me. I wrote my own [typings](https://github.com/tscholl2/cookbook/blob/master/frontend/typings/icepick.d.ts) so that I could get the docstrings to appear inline in VSCode. There are still places that could be improved, but it's been working well. Like some of the others mentioned, it also acts like plain js objects.",1528610456.0
paulkoer,"Hi r/typescript! About two weeks ago I posted a link on [how to use dtslint for testing type operators](http://koerbitz.me/posts/unit-testing-typescript-types-with-dtslint.html). That approach had a few drawbacks. u/AngularBeginner had a great comment on he used type typescript compiler API to get the resolved types of some type definitions. This works much better with existing test suites. It took me a lot longer than it should have to throw together this solution, so I decided to wrap it up as a library and put it on npm for the next guy. Here it is. All credit to u/AngularBeginner for the idea ;)",1528408312.0
recursive,"I've changed it to a `function` instead of `const` declaration, since it's more idiomatic.  But here you go.

    function toggleInSet<T>(xs: Set<T>, x: T) {
        (xs.delete(x) && xs) || xs.add(x);
    }",1528404299.0
fecal_brunch,"AFAIK it's not possible, but I've often wondered...",1528545174.0
endjynn,Really useful. Thanks for the submission :),1528310485.0
funkdr42,"To summarize the article:

Set `module=esnext` in your tsconfig file to allow webpack to recognize dynamic import statements for code-splitting. ",1528373593.0
kqadem,"Yeah, like 1 week ago... ",1528309902.0
guncha,"I can see your point and how it could be useful, though I've personally never felt the pain, but you have to ask yourself - if the Typescript team could only work on a single issue until the next release, would this be it? ",1528301463.0
adrianjord,"Personally I'm not a fan of any sort of bare words being converted to strings. It's an anti-pattern in most languages that allow it like Ruby. I'm not too familiar with React+Redux, but couldn't you just assign your enum values to a string representation of a number? It's not elegant in most languages, but it seems to be a pretty normal idiom in JavaScript to do stuff like this, hence why actions are denoted as strings. ",1528308275.0
demoran,"I think the solution to this may hide in:

    enum test { A, B }
    type stringenum = { [K in keyof typeof test]: string };

A helper function would compose an object to use in place of the enum from the enum itself.",1528310186.0
thomasmost,"Hey r/typescript! Just some background; I raised this issue over a year ago and I find it to be really obnoxious in my own TypeScript projects, but I understand that the team has some reluctance to really discuss it till more people weigh in. To that end, I'm posting this here hoping to get a better read on the temperature for what I perceive to be a flaw in the enum implementation. Also, if there's a better workaround I haven't thought of, please let me know! 

Thanks!",1528300632.0
G3n3r0,"Fuck, why didn't this exist six months ago? I had to manually create TS type annotations for like the entirety of the bcoin library.",1528162872.0
bitjson,"Hey /r/typescript – I've been working on a Bitcoin/Bitcoin Cash library written in TypeScript, and I just released the first production\-ready feature: a WebAssembly version of Secp256k1, the digital signature and verification system used by most cryptocurrencies. You can find more details and benchmarks at the link. If you're interested, please watch/star the [`bitcoin-ts` project on GitHub](https://github.com/bitjson/bitcoin-ts). I'm also happy to answer questions here. Thanks!",1528132637.0
Woolbrick,What a waste.,1528159694.0
esamatti,"This reminds me of [redutser]( https://github.com/wkrueger/redutser) although this seems more flexible but maybe a bit more complicated. Good see new projects poping up in redux+typescript scene.
",1528402688.0
namesandfaces,"Could someone explain to me the Redux prescription of basically inverting typical OO style, and not having the methods on the Redux state object itself?

It seems to be just a matter of ""where you put things"". Both styles are more or less logically equivalent and equally organized. But if were just then a matter of ""where you put things,"" having the method on the state object itself seems to make sense in removing the question of ""where is the appropriate method?"". The reason why I say these styles are basically equivalent is because the Redux answer to this question is, ""It's in a separate file,"" versus ""It's on the same object."" The data flow of your app is still basically the same, though the ergonomics may have changed a little.

So how does separating out the methods lead to a difference in app organization, scalability, etc?

When things are on the same object, IDE's are also a lot smarter on providing hints about the structure of your program. That's why people are complaining about Redux and TypeScript.",1528156238.0
tfptfp,"These ""squared letters"" are not a problem of Unicode. They are valid code points. The problem lies in the font you are using to display them. If your font does not support the unicode code points you are generating, they are displayed as ""squared letters"".

Best way to avoid this is probably to define ranges of code points your font supports. and then just generating in these ranges or converting your random number to a number in these ranges.",1528120936.0
BrunchWithBubbles,"This is really interesting! The title is a bit misleading though. You _parsed_ 1,000,000 files, not compiled. There is no typechecking, code generation, module resolution etc.",1528131070.0
STRiDEX,Compiled so many angular hello world applications,1528128860.0
xdavehome,"Wonder if it does non-divergent forks, too.",1528130967.0
AngularBeginner,"In the first example you write:

> There is no way to guarantee that your property is going to be on the source object.

But actually the compiler **does** emit an error, if you enable sane options in your tsconfig:

> Element implicitly has an 'any'  type because '{ a: number; b: number }' has no index signature.

Also, your `_safeNameOf` function has a bug: If the value of the property is falsy (`""""`, `0`, `false`, `undefined`, `null`), then it will return `null`, so it will report that the key does not exist even when it does.

> we still add an extra check in _safeNameOf to make sure the key really does exist on the source.

You don't check if the key exists, you check if a property with the given key exists and is truthy.",1528105560.0
Auronon,"""Magic string"", that is a fancy way to say ""variable name"".",1528135943.0
kingdaro,"My preference would be for top-level exports in a module file:

    // helpers.ts
    export function helperMethod1(): void {}
    export function helperMethod2(): void {}
    export function helperMethod3(): void {}

    // main.ts
    import { helperMethod1 } from './helpers'
    helperMethod1()

If a module system isn't available for whatever reason, the object (fifth option there) would be my next preference. Reason for both being, it aligns most with how it would be done in normal JS, and using a class for it seems unnecessary. That, and it enables tree-shaking if using a bundler.",1528053772.0
voidvector,"There are other options

* Just export functions - there is no need to make everything an object in JavaScript
* Use a DI framework - if somehow you like OOP and want to isolate side-effects for testing or whatnot, so you make helpers injectable (*cough* Angular *cough*)

Generally, your last example or ""just export functions"" are preferred choices",1528068576.0
Auxx,"Depends on a context of your task. If you're creating a set of helper functions, then use simple functions, no need for name spacing. But if you're creating factories and you want to know the context behind the function, then I prefer option one.",1528201271.0
fecal_brunch,Don't use a `class ` unless you want it to be instantiable with `new`.,1528506311.0
BenSantalucia,"I opted for the 1st one, even if Microsoft tslint rules discourage it. In my current setup it makes more sense.
Method 3 and 4 will probably allow a better tree shaking... Although `namespace` is preferred over modules ( https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html )",1528049848.0
FurryFingers,"I thought Modules are recommended over namespaces or anything else, without a doubt... The only issue is whether you have a build system that can deal/parse them

>>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism

https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html
",1528155438.0
kingdaro,repost? https://www.reddit.com/r/typescript/comments/8nk87m/announcing_typescript_29/,1528054901.0
gradual_alzheimers,I'm very interested in a runtime where TS is a first class citizen instead of transpilation ,1527876528.0
ElDiseaso,Seems like a good opportunity to have better concurrency. ,1527888415.0
haCkFaSe,I've been surprised Microsoft hasn't jumped on this earlier.,1527899226.0
circlebust,"Neat. I sincerily believe TypeScript + Node is the future of backend. I can see it being dominant in 10 years, maybe sooner.",1527898875.0
pietvanzoen,Ryan Dahl gave a talk at JSConfEU today about “10 things I regret about node.js”. Really nice honest talk about the things he would do differently now. My sense is that deno is an experiment in what could be done by learning from those lessons. ,1527979876.0
illyrianHero,Eagerly waiting for it.,1527885650.0
manzanita2,Why not just use Graal ?,1527909050.0
pietvanzoen,"I was at JSConfEU this last weekend where he introduced it. Here are the slides: http://tinyclouds.org/jsconf2018.pdf 

This is more than just another `ts-node`. What Ryan Dahl is building actually skips node entirely. And he’s making backwards incompatible changes that address some of the regrets he had about how node was built. Particularly around requiring and package management. 

Pretty excited about this. ",1528096323.0
GFandango,super cool,1527913603.0
,[deleted],1527924383.0
sime,"This appears to be more of a sandbox than anything else.

There is also https://github.com/AssemblyScript/assemblyscript which compiles a subset of TS to web assembly.
",1527925515.0
andythedev,Is there a need for this? I've never found typescript build times to take very long.,1527891289.0
feihcsim,thank you ryan for choosing typescript and not flow,1527910969.0
demoran,"okay, well typed json is pretty cool",1527789150.0
vinnl,"Ooh, TypeScript 3 coming up! With the [`unknown` type and strict `any`](https://github.com/Microsoft/TypeScript/wiki/Roadmap#30-july-2018), which sound like excellent improvements that shouldn't be too breaking.",1527800846.0
Dested,Generic JSX component support!,1527793828.0
welkie,"I gotta say, I love how frequent these updates are. This is nothing like the old Microsoft.",1527822076.0
,[deleted],1527924438.0
VortexSuitUp,"Solid writeup, fumbled my way through this a while ago, something like this would've been quite helpful",1527774260.0
Gackt,"Cool but any realistic project will use webpack/etc.

And there's still no way for webpack/etc to generate a nice typings file for you yet :S",1527781385.0
russleyshaw,"Considering `tsc --init` constructs the file with comments, you should be able to use comments too. Anything that doesn't parse the file with comments will most likely fail on many projects as the default behavior is to generate the file with comments.",1527713249.0
,[deleted],1527700408.0
Code_wizard,"It's JSONC (Json with comments). But like has been already said. It's their own parser, it doesn't fuckin matter.",1527719693.0
cspotcode,"Yes, use comments as much as you want.  `require('typescript').parseConfigFileTextToJson()` exposed TypeScript's config parser for any third-party libraries who care to use it.  As far as I've seen, it's understood that tsconfig files usually contain comments.",1527727693.0
inu-no-policemen,"JSON doesn't support comments which makes it unsuitable for configs.

Comments are often supported where ""JSON"" is used for configuration.

Pretty annoying, really. Crockford really screwed this up. Omitting comments was a huge mistake.",1527782702.0
Balduracuir," ~~If someone in your team is using an IDE like webstorm for example. It will probably have a built-in validator for json files.
So this people will open your file with comment and will have loads of errors. Not really cool for new comers in the team.~~

Never mind it works in webstorm. You can use comments :)",1527762817.0
xdavehome,It's JSON5.  https://json5.org ... I think.,1527701180.0
sime,"You need to ask the TypeScript what the intended format actually is, and which format they are going to adhere to in the future.
",1527758911.0
trevorsg,"Any tools that are ""doing it right"" shouldn't be parsing the config file themselves, so I'd say go nuts with comments and trailing commas.",1527707444.0
AngularBeginner,There's close to no content in this post. And there's no explanation why you'd want to opt-out of those tslint rules.,1527662227.0
AngularBeginner,"Pretty weird to use `Array.prototype.reduce.call(list, ...args)` instead of `list.reduce(...args)`.

edit: This is especially weird as you're referring to TypeScript, and using `.call()` is generally **bad practice** in TypeScript. The call signature of `.call()` is untyped: It accepts `any`. So if you accidentally pass in a wrong type... you won't notice.

To adapt the example a bit:

    function sumSquare(sum: number, item: number): number {
        return sum + item*2;
    }
    
    const list = ['one', 'two', 'three'];
    const result = Array.prototype.reduce.call(list, sumSquare); // --> 'oneNaNNaN'

Compiles fine, even the signatures don't match.",1527588542.0
a_simple_pie,This is a very clever and useful idea. I imagine a ‘jquery for the typescript ast’ could result in some great new tools popping up.,1527665103.0
welkie,I have no idea what the heck this is but this is cool.,1527646375.0
cspotcode,"Are you able to post a complete code example in a Github Gist or PasteBin?  I'm curious exactly how you're moving expression nodes from one SourceFile to another.  I think I can give you a better answer if I can see the code.

One super-hacky thing you can do: create an identifier that's actually not an identifier but prints some code verbatim.  Something like `createIdentifier('2 + 2 - getNumber(w5)')`",1527550447.0
rftz,"Use generics rather than any:

    class BookData<T> {
        data: T;
        constructor (settings: { data: T }) {
            this.data = settings.data;
        }
    }",1527509229.0
besthelloworld,"My team uses a generic definition.

`abstract class Model<DetailsT>`

Model has a constructor that takes one `DetailsT` and assigns it to the class as an element `public data: DetailsT`.

Then all of our models extend that.  Optionally, I suppose DetailsT could be fulfilled as any but I wouldn't recommend it.",1527517031.0
verticalellipsis,"    interface BookSettings {
      data: {
        page: number;
        author: string;
        [key: string]: any;
      };
    }",1527495791.0
AngularBeginner,"> Contributors will be rewarded with Mount Olympus token,

So no payment.",1527451960.0
rya_nc,"> Contributors will be rewarded with Mount Olympus token, MOT There's no upper **or lower** limit on the reward

Fixed that for you. If you believe in your project, put up some cash to go with the tokens. ",1527452055.0
PhroznGaming,Soooo you want free labor/ideas essentially?,1527452448.0
GFandango,Stick the tokens up your butt and get out.,1527486526.0
alfredmuffin,Crypto is a scam ,1527453593.0
AngularBeginner,Unfortunately not a free resource.,1527341856.0
vinz243,"The main difficulty in writing decorators is that you can't augment your types so all your types need to be defined in the decorated class. Also if you have it enabled, the linter may throw errors if your variables aren't initialized in the body.",1527358155.0
ozeki,"You can use the Mixin mechanics of TS to achieve this. Sadly, native ""traits"" can't be added as it seems the TS team do not want to include non-standard grammar for things that aren't types.

That said someone took the applyMixins idea and made it into a lib. Maybe that works out? Seems like it allows for both inheritance and function composition which is great. Php's traits work really well and this seems to be inspired by them.

https://www.typescriptlang.org/docs/handbook/mixins.html

https://github.com/michaelolof/typescript-mix/blob/master/README.md 

Edit:

Another interesting lib:

https://github.com/kobiburnley/ts-trait",1527337420.0
GFandango,Not 100% sure but I bet languages with strong type systems like Haskell have it.,1527325521.0
Aior,"Yes, OCaml, Scala, maybe even Rust (but it works a little differently than you might expect)...",1527328311.0
,"Haskell doesn't have subtyping (at least in the style of TypeScript), so there is no exact equivalent of a conditional type. Haskell does have type-level booleans and type-families, that let you do something similar, but it's less ergonomic.

As for mapped types, I believe they could be emulated but as with conditional types, they will take quite a lot of work to define and will not come out as crisp.

These features are unique, precisely  because TypeScript is trying to solve a unique problem of assigning types to a highly dynamic and reflective language. Consequently it offers these built it and very useful operators that work well for JavaScript code.

Something like Haskell started from a place where all programs had types that were strongly enforced, relying more on data abstract and parametricity, where conditional types and mapped types are less useful. ",1527335436.0
smthamazing,"Any language with a type system strong enough has conditional types, even C++ (via SFINAE and template specialization), not to mention Haskell, D, Rust, Idris, Agda, Coq, OCaml...

As for mapped types, it's a bit trickier. Technically, all those languages support mapped types as well. However, they do not by default have a notion of type-level dictionary/map, because, unlike JavaScript, most objects in these languages are not dictionaries. So you need to define a type-level dictionary and a corresponding runtime data structure first, and then you can define a mapping over its entries. It's a bit more clunky with templates than with builtin syntax of TypeScript, but surely doable, and probably more flexible.

Strong macro systems, like those of D and Rust, make it much easier to define these sorts of transformations.",1527364341.0
,[deleted],1527274759.0
coskuns,"Well the ""!"" mark only means ""I have initialized this somehow, don't you worry about it, it is never undefined"" to my knowledge. So that typescript stops checking it within the constructor. I don't think it provides any runtime check, just fooling the compiler. ",1527595103.0
miloszpiechocki,"This feature seems to be great in combination with `readonly` modifier.

Interestingly, TypeScript in strict mode allows me to do this:
```
export class Cat {
    readonly name!: string;
}
```",1527429761.0
cspotcode,"Sourcegraph runs language servers to understand code in Github and offer the same IDE intelligence right in the browser.  So you can be reviewing a pull request, hover over an identifier, and SourceGraph will give you the same documentation and type info that TypeScript does, because it's running the same language service.

It integrates with Github via a browser extension.  To use it on private repositories, you need to host the sourcegraph server yourself.  The browser extension will then connect to your private sourcegraph server to get code intelligence.",1527270430.0
moocat,Looks like there's a 4 year old feature request for that which is still open: https://github.com/Microsoft/TypeScript/issues/449,1527114477.0
cspotcode,"TS can't, but tools like uglify can do this.  You can define certain variables as constants and uglify will inline the constant value; then dead code elimination will remove conditionals that never execute.  For example, `if(IS_DEBUG_BUILD) {logExtraInfo();}`",1527125954.0
cspotcode,"The short answer is no.

It might be possible to extract the `this` type from a function signature using conditional types, but that would not do what you want.  It might do something *similar* in a few specific situations.  But probably not.",1527008368.0
infostruct,"I don't believe this is possible. Properties on a Javascript object have no concept of their parent.

Math.pow is just a reference to a method. When you set f to = Math.pow, f now references that same method directly. ",1527008743.0
,[deleted],1527011674.0
Shadowvines,This might not be a good idea. Certain libraries used inside different projects might have a dependency on a certain version of typescript. If that is not a concern then building a script to pull down the repo npm i the specific version of TS you want and commit is very easy solution. further more you could do the same thing to enforce a certain tsconfig if you wanted by just copying in the tsconfig and pushing it.,1527003899.0
gamebuster,"Even if there was a one-click upgrade, don't you at least have to run some tests before upgrading? Either run the test-suite of test it manually.

Or update the project as soon as you need to make a change in the project. That is my preferred approach: Update libs and/or refactor upon touching it. Refactoring and updating code is usually not a dedicated task at our place; it is only done ""on-demand"", upon touching relevant projects or code.",1526993835.0
enkarta,I've been banging my head against this wall for the past week or so and haven't had any luck on StackOverflow. Hoping someone here may have some insight!,1526949889.0
paulkoer,"I needed a way to unit test my type operators. dtslint does this, but I couldn't find a really good description on how to set this up \(the readme was a bit lacking IMO\), so I wrote this up. Hope that somebody finds this helpful.",1526939750.0
AngularBeginner,"I stumbled upon the same issue this weekend, but using comments for tests seems a bit nasty.

My solution was just to use the TypeScript compiler API. I wrote a function that takes source code and returns the type of an marked node.

This way I continue to utilize my regular test-suite (Jest in this case):

    it('MyOperator<T> always resolves to string', () => {
        const typeName = getResolvedTypeName(`
            import { MyOperator } from './src/index';
            type ##Test_01_number_is_not_string = MyOperator<number>;
        `);
        expect(typeName).toEqual('string');
    });

The `##` prefixes the node whose type I want to get.

Could also utilize template literals:

    const [typeNameOne, typeNameTwo] = resolveTypeNames`
        type ${'TypeOne'} = MyOperator<number>;
        type ${'TypeTwo'} = MyOperator<object>;
    `;
    expect(typeNameOne).toEqual('string');
    expect(typeNameTwo).toEqual('string');",1526971416.0
GeeWengel,"Little off topic, but typeful-redux seems nice. Typing redux has always been a major pain for me - to the degree where I sometimes just.. don't.",1527173458.0
danvk,This is a great post! You inspired me to write another one that goes into a little bit more detail about how to effectively use dtslint: [https://medium.com/@danvdk/testing\-types\-an\-introduction\-to\-dtslint\-b178f9b18ac8](https://medium.com/@danvdk/testing-types-an-introduction-to-dtslint-b178f9b18ac8),1528409055.0
alsiola,"I like to use a Result wrapper as a return type from functions that may fail.  I get where you are coming from with Promises, but I would be wary of (ab)using them here.  Firstly, it could well confuse anyone else who works on your code to use them in an atypical manner, secondly (as mentioned in another comment) the error cannot be typed, and thirdly you may get some edge case bugs because the functions passed to ""then"" and ""catch"" will run on the next pass through the event loop.  

A Result type like the following gives a nice (to me) interface to work with.

    interface MapFns<T, E, TResult, EResult> {
        success: (a: T) => TResult;
        failure: (e: E) => EResult;
    }
    
    class Result<TSuccess, TError> {
        public static Success<T>(success: T) {
            return new Result<T, any>(success, null, false);
        }
    
        public static Failure<T>(error: T) {
            return new Result<any, T>(null, error, true);
        }
    
        constructor(
            private success: TSuccess,
            private error: TError,
            private isError: boolean
        ) {}
    
        when<T, E>(mapFns: MapFns<TSuccess, TError, T, E>) {
            return this.isError
                ? mapFns.failure(this.error)
                : mapFns.success(this.success);
        }
    }

Which you can use something like:

    const foo = (): Result<number, string> => {
        if (Math.random() < 0.5) {
            return Result.Success(5);
        }
    
        return Result.Failure(""oh no"");
    };
    
    foo().when({
        success: result => console.log(result), // result typed as number
        failure: error => console.log(error)    // result typed as string
    });

If you want to integrate actual promises into your Results, then it is handy to add a static curried When function to the Result class:

    class Result<TSuccess, TError> {
        public static Success<T>(success: T) {
            return new Result<T, any>(success, null, false);
        }
    
        public static Failure<T>(error: T) {
            return new Result<any, T>(null, error, true);
        }
    
        public static When = <T, E, TResult, TError>(
            mapFns: MapFns<T, E, TResult, TError>
        ) => (result: Result<T, E>) => {
            return result.when(mapFns);
        };
    
        constructor(
            private success: TSuccess,
            private error: TError,
            private isError: boolean
        ) {}
    
        public when<T, E>(mapFns: MapFns<TSuccess, TError, T, E>) {
            return this.isError
                ? mapFns.failure(this.error)
                : mapFns.success(this.success);
        }
    }

This allows you to use Result.When point-free in a ""then"":

    const foo = (): Promise<Result<number, string>> => {
        if (Math.random() < 0.5) {
            return Promise.resolve(5).then(Result.Success);
        }
    
        return Promise.resolve(Result.Failure(""oh no""));
    };
    
    foo().then(
        Result.When({
            success: result => console.log(result), // result typed as number
            failure: error => console.log(error)     // result typed as string
        })
    );",1526935134.0
BrunchWithBubbles,"Calling `reject` is pretty much the same as throwing an exception if you think about it. The consumer has to explicitly call `catch` to handle reject, just like thrown exceptions are handled with and explicit try-catch block, and it can be unclear where the `reject` was called, just like it can be unclear where the exception was thrown.",1526932735.0
AngularBeginner,"You can't type the error case of a promise. It's always `any`, because you can throw any value in JavaScript (even number).

I prefer the functional approach where you have a result object that is either a typed value or a typed error, and you chain calls using a map function that applies a method if the result is a value and just returns the original error if it's an error. Unfortunately functional programming has not yet arrived much in the JavaScript world (except of the poor man's map and filter).",1526932736.0
evmar,"Promises are for delayed action, and difficult to compose.

E.g. if I wanted to call your function five times in a row, I couldn't do:

    for (var i = 0; i < 5; i++) {
      foo().then(...
        // how do I wait for it to complete before the next
        // iteration of the loop?
      )
    }

The answer to that is making the function async, but that is a lot of extra code and allocation.",1526932847.0
scaleable,"I prefer to just throw errors. It's simple, it works for the most cases. (Thrown errors must always be `Error` instances).

EDIT: For async code, just use async/await. You should not be using `.then` when you can write async/await.

If you need you can add some metadata to the error manually, or with a helper like `ono`, or come up with your ""default error factory"" for the project.

If you want some type safety when catching errors, you can build some type guard functions (although that rarely is needed).

If you receive an error from an HTTP request, ""standardize"" that error by creating an error object from it, than throw it. (An HTTP API request should be, in the end, just an abstraction for a function call).

If you generate an error on the server-side (say, express), you can send that error to the error middleware `next(error)`, which should do things like content negotiation (HTML or JSON), formatting and filtering. You can catch+rethrow the errors midway to format things, or add info.

Async code? Promises already are structures with error handling concerns (a promise is sort of an ""error monad""), so unless you want an extra feature like cancellation (you could use rx on that case), it's pointless to rewrite another error structure. Isolate any code that works with callbacks into separate functions, then your main function threads will end up becoming sync-like code (with`async-await`), including the way you write try-throw-catch.",1526937820.0
cspotcode,"Promises do not allow you to retrieve their resolution or rejection synchronously, so you're forced to wait an extra lap around the event loop.  This can be a problem for performance and also makes it impossible to write synchronous code in the style you're describing.

You could always write your own, synchronous return value class that mimics promises' then and catch methods.",1527223147.0
miloszpiechocki,"Your questions is awesome at showing how Promise is part of a wider, more general abstraction - monads. While the idea to use Promise for error handling might have some drawbacks (as mentioned in other comments), there are other data types that can be used exactly for that. 

The type is called Result (or Either) and can either hold a successful or failed result. Simillarly to Promises, you can provide a callback to do something with the result with either `map` or `flatMap` operations.

If you'd like to learn more, I wrote an article about it on my blog:
https://codewithstyle.info/advanced-functional-programming-typescript-functional-exceptions/ ",1527428615.0
GeeWengel,You can definitely tell that TypeScript isn't a first class citizen in the facebook part of the eco-system. Though fortunately nowadays it should work in RN via the wonderful [react-native-typescript-transformer](https://github.com/ds300/react-native-typescript-transformer) - not sure about using custom transformers in CRNA though!,1527175815.0
turkish_gold,"I am not a fan of the decorator syntax, but that's more of a personal taste issue. Otherwise, the framework is fairly simply and easy to follow. It's a definite improvement on bare ExpressJS, and the only suggestion I'd make is that you should have an opinionated default as to templating\-\-\-if templates are to be used at all.

If not, then, having some kind of helpers for return values like JSON serializers/deserializers would be nice.

Since it's not listed there\-\-\-or i missed it\-\-\-what motivated you to make this framework? And what's your previous experience in web frameworks?",1526922056.0
Angulant,But we already have nestjs??,1526937821.0
turkish_gold,"I always liked AmCharts. They have always been at the cutting edge of technology \(e.g. they had HTML5 charting when everyone else was in Flash\), and their pricing is a lot more reasonable now adays.",1526916985.0
pimterry,"How easy is it to integrate this with React? I can't see any mention of that anywhere, but it's pretty key for a lot of modern web projects.",1526918233.0
perrylaj,"We've been using AmCharts in production react applications for a couple years now, which required building some simple wrapper components to provide nicer prop signatures and actually render the charts.  Been working great.

The new version looks really nice and we're already using it in new products currently under development. We've hit a couple type errors that we had to workaround (had to disable strict mode and some implicit type checking), but sounds like they are working toward support of stricter compiler settings for the release.  

All in all we've been pretty happy with amcharts and really look forward to first-class TS and React support.

 ",1527001419.0
MrStLouis,"I'm new to ts and was going to dedicate today to learning this concept, but this popped up on my feed and I learned it on my morning deuce. Thanks! ",1527862135.0
,"    type Foo = Extract<MyType, { kind: 'foo' }>;",1526843988.0
huffy1,"Just learn React and Typescript separately, putting the 2 together is as simple as applying a prop and state type to your components.

You don't need a video for it although [egghead](https://egghead.io/courses/use-typescript-to-develop-react-applications) do have a short course ",1526885390.0
zajrik,"I'm actually very frustrated by this feature currently. I've enabled it in my tsconfig but am not seeing any compiler errors as a result of it. I was looking forward to that reminder when writing new classes, and taking care of that cleanup for all of my old classes but it just doesn't seem to work.

When I say it's not reporting errors, I mean via gulp-typescript, the typescript server itself in vscode, and directly via `tsc`. Nothing.",1526890046.0
unsung_unshift,https://www.youtube.com/watch?v=anwy2MPT5RE,1526815565.0
unsung_unshift,"/r/typescript this makes 6 -- this user is a nuisance, I even think this behavior is enough to get entirely banned from reddit (let alone a single subreddit)",1526815649.0
unsung_unshift,https://www.youtube.com/watch?v=anwy2MPT5RE,1526814531.0
unsung_unshift,/r/typescript This redditor has posted 5 articles to in a row to their own blog,1526814794.0
unsung_unshift,r/typescript This redditor has posted 5 articles to in a row to their own blog,1526814834.0
unsung_unshift,https://www.youtube.com/watch?v=anwy2MPT5RE,1526814545.0
unsung_unshift,https://www.youtube.com/watch?v=anwy2MPT5RE,1526814556.0
unsung_unshift,r/typescript This redditor has posted 5 articles to in a row to their own blog,1526814846.0
unsung_unshift,r/typescript This redditor has posted 5 articles to in a row to their own blog,1526814857.0
unsung_unshift,https://www.youtube.com/watch?v=anwy2MPT5RE,1526814568.0
unsung_unshift,https://www.youtube.com/watch?v=anwy2MPT5RE,1526814689.0
unsung_unshift,r/typescript This redditor has posted 5 articles to in a row to their own blog,1526814813.0
scaleable,"Yeah, thats what ‘typeof’ does, but since we’re working with structural typing, this actually means “any object which agreed to the same shape/imprementation” instead of “this exact class reference”.

Isnt it beautiful? Mostly any TS type check is an “interface check” not a “reference check”.",1526770533.0
Dw0,"why not just provide the defaults for constructor parameters?
at least that way you'll save yourself the inevitable head scratching trying to remember if it's
    import PasswordSecurity from './PasswordSecurity';
or 
    import { PasswordSecurity } from './PasswordSecurity';

but still it's a poor man's DI. ""works, but""™",1526758333.0
thepointer,I'm interested in a comparison to RxJS. The examples strike me as things I'd typically use RxJS to solve. I'm curious if LINQ has any advantages (e.g. how are errors handled). Neat project.,1526765398.0
bluishred,I love the syntax. Are there benchmarks comparing it to lodash?,1526795503.0
turkish_gold,"I checked it out. On NPM, there appear to be dozens of similar LinQ implementations, but out of the top 10 by popularity, I think yours is the best.

I prefer your syntax of lowercased method names; it seems to embrace JS style more. Also, I love that you've added quite a bit of documentation rather than assuming everyone knows C# LinQ to begin with. Lastly, your examples are compelling\-\-\-and existant which many packages don't seem to have.

Overall, awesome job.",1526922328.0
coskuns,"Please excuse my ignorance, why would one target es6 instead of es5? Is it because the script you developed is not ""primitive enough"" to be transpiled into es5?",1527123112.0
jinhduongg,"I think your job is awesome base on your commits and docs.

Bcoz also developing a lib same like your lib: [https://github.com/jinhduong/linq\-fns](https://github.com/jinhduong/linq-fns) but it more simply than yours and provide some drivers to work with db like as `firebase` `gists files` and can use the `queryable` is variable which can use later. 

I think because almost input data is `Promise` so we will face and should be focusing about `Promise` like as 
```js
.from(Promise).join(Promise).join(Promise)
```
I using `Promise.all` and `collection` to do it and which way you use to resolve it and keep the performance enough good?

Thanks.",1527146081.0
coskuns,"Thanks for the information. 

I see point 1. Makes sense. Point 3 also makes sense if the library consuming your library targets es5. 

Point 2 is just a dream for now since there are still customers out there using IE. ",1527163616.0
rduncan12345,I didn’t see this mentioned yet but Visual Studio Code is outstanding. It has excellent support for TS. It will feel comfortable to you with your VS background. I’m using it for Angular and a Node backend. Also agree that Max’s courses on UDemy are the way to go. ,1526737539.0
smthamazing,"I think a good way is learning TS/React/Redux separately, using their official docs and ""getting started"" guides (which are quite good). At least this works for me much better than any tutorials and allows to get the fundamentals quickly.

After that, if you don't have a good idea of how to do this yourself, you may refer to a guide ([like this one](https://github.com/piotrwitek/react-redux-typescript-guide)) to integrate all 3 technologies in one app.

You may refer to [this article](https://medium.com/@martin_hotell/improved-redux-type-safety-with-typescript-2-8-2c11a8062575) for the most concise way to get typesafe Redux actions at the moment (with TypeScript 2.8). At this point you should be familiar with such concepts as TypeScript union types, (conditional) mapped types and, preferably, `infer`. They are all described in the docs, and you can experiment in [TypeScript playground](http://www.typescriptlang.org/playground).

You may use an approach like [ducks](https://github.com/erikras/ducks-modular-redux) for large-scale Redux apps (tl;dr split your project to domain-related modules instead of ""actions""/""reducers""/etc folders; make each module export its own actions, reducer, views and other stuff).

If you intend to build larger apps, you'll also need to learn `react-router (v4)`, `reselect` and React server-side rendering.",1526729417.0
Bamboo_the_plant,"Have you any experience with TypeScript, React, and/or Redux on their own yet? Jumping straight into a React-Redux stack with TypeScript typings is not for the faint-hearted (React and Redux alone have actually driven many new feature updates to TypeScript itself).

* Here's the best cheatsheet around to tide you along: https://github.com/piotrwitek/react-redux-typescript-guide

* This boilerplate seems to have the most stars of any projects I can find with a quick glance: https://github.com/rokoroku/react-redux-typescript-boilerplate

* I myself work on React Native with TypeScript (React Native patterns are equally applicable to React), and you can see how I've approached a few patterns such as navigation and platform-specifics: https://github.com/shirakaba/react-native-typescript-2d-game",1526730997.0
Fullstack_Questions,"Go to Udemy.com , download the latest React Redux course by Maximilian Schwarzmuller or Andrew Meade, solve the challenges and make frequent commits, fix their code as you go, and when you are done, build a few production quality apps in couple weeks and keep reading learning hacking :) I think you will like Typescript + React more though. ",1526728186.0
Wobblycogs,"Fully signed up old time dev that's just gone though / is going though the same learning experience. The courses by Maximilian Schwarzmuller on Udemy are well worth the money (can usually be had for about $11), I've sat the TypeScript and Angular courses and I'm signed up for his Angular FullApp course. 

In terms of IDE I use WebStorm for Angular and IDEA for the Java back end so probably not your cup of tea but might be worth a look.

I let my skills get a bit out of date hence the recent upgrading. I've been doing web-dev work since about '99 and the frameworks have pretty much always been a mess and I don't see it getting better any time soon. IMHO TypeScript / Angular is a massive improvement on what has gone before though.",1526729351.0
blakflag,"I suggest grabbing one of the boilerplates listed below. Build it. Run it. Dissect it. Modify it. If you have a breadth of knowledge I am guessing you'll start to see how the pieces fit together through this process.   One of the online courses can also help, for sure.",1526731844.0
bheklilr,"I've been using pluralsight lately, and they have a pretty solid set of react courses. A few weeks ago I knew very little about react (and a bit about typescript) but now I've written a couple of react apps and am currently writing a relatively simple react native app to help me keep up with some stuff at my new job. You can get a trial period, but they limit you by hours watched too so you won't be able to cheat them out of all the material. It is a bit more expensive, 30$/mo, but I've found it very valuable since there's a lot of other web technologies I need to get up to speed on anyway. ",1526733213.0
sdmitry,"Everyone is pushing redux, but after using it on a big scale project and seeing what kind of nightmare it becomes, we switched to mobx-state-tree and couldn’t be happier. Mobx is also written in TypeScript, not just typed as an afterthought.",1526745526.0
ReeMann,"Don't start with react/redux/ts together!

First try React. It is probably most unique thing, and you probably didn't develop in something similiar to it. Good starting point is DOCUMENTATION! It is really well written and really that big, please make sure you understand state/props, some lifecycle methods and function/class componenents. Wes Bos has also some good videos about it. Good thing would be to build something like todo list (on react state!). 

Then move to redux. Documentation is also very good, but I will recommend you eggheads videos by dan abramov (redux creator, now developing react @fb). Use app you built before and change it so it now uses redux state - you will see that react components will stay the same, only logic will move somewhere else.

Finally! Typescript. Don't know about any good resources beside docs. Just try to type your whole app. 
Overall it shouldnt take u long. For experienced dev, learning React is 2-4 days (just to use it, best practises and hacks take longer), redux might take more.",1526730911.0
OddCoincidence,">So of the many types of enums which do I recommend using? Trick question: none.

Strongly disagree with this. TS enums are actually one of the main reasons I made the switch from Flow.

* Much nicer to declare
* Better completion in IDEs \(really just more IDE\-friendly in general\)
* Arguably more readable
* They can be iterated over \(with some effort\)

You can pry my enums from my cold dead hands.",1526710190.0
Spam_Detector_Bot,"*Beep boop*

I am a bot that sniffs out spammers, and this smells like spam.

At least 51.0% out of the 100 submissions from /u/udemyfreebies appear to be for Udemy affiliate links. 

Don't let spam take over Reddit! Throw it out!

*Bee bop*",1526652795.0
cspotcode,"Creating properties that don't exist at runtime is known as ""branding."" The TypeScript compiler's source code uses the branding trick.

https://basarat.gitbooks.io/typescript/docs/tips/nominalTyping.html",1526594624.0
slashess,"    const BEHAVIOR_TAG = Symbol();

    interface Behavior<T extends string | symbol | number> {
        [BEHAVIOR_TAG]: T;    
    }

    type RetrievableFromDatabase = ""@RetrievableFromDatabase"";

    interface BaseModel {
    id: string;
    updatedAt: Date;
    deletedAt: Date | null;
    }

    // Not an Entity but a Subpart of Category so no id and timestamps here
    interface Bar {
        something: string;
    }

    // A sample model
    interface Category extends Behavior<RetrievableFromDatabase> {
    name: string;
    color: string;
    foo: Bar;
    }

    // Another related sample model
    interface Item extends Behavior<RetrievableFromDatabase> {
    name: string;
    price: number;
    category: Category;
    }

    // Decorate our type with metadata from BaseModel (recursively for all relations)
    declare type FromDB<T> = T extends object 
        ? {
        [K in keyof T]: T[K] extends Behavior<RetrievableFromDatabase> ? FromDB<T[K]> : T[K]; 
        } & BaseModel
        : T;

    let localCopy: Item; // = createLocalCopy()

    // Normal attributes from local copy can be accessed
    localCopy.category.name

    // Attributes that are set by the server/api/db are not yet present
    localCopy.id // error: Property 'id' does not exist on type 'Item'

    // Lets pretend we fetch a specific model from the server/api/db
    let itemFromDB: FromDB<Item>; // = await getItemFromDb({ id: 123 })

    // Normal attributes from remote copy can be accessed
    itemFromDB.category.name

    // As well as all the metadata
    itemFromDB.id

    // This is also true for all relations that inherit from RetrievableFromDatabase
    itemFromDB.category.updatedAt

    // But not for objects that don't inherit from RetrievableFromDatabase
    itemFromDB.category.foo.id // error: Property 'id' does not exist on type 'Bar'.

Similar pattern but you can have multiple ""behaviors"" with this.

Edit: In what universe is it logical to require lines to start with 4 spaces if you want them to display as code yet you can't tab over multiple lines in the reddit text box. Bad UX.",1526581002.0
hmongoose,"tl;dr:
- use ""baseUrl"" in tsconfig.json to let tsc know where your packages are located  
- use the ""NODE_PATH"" env variable to let node know where your packages are located  
- be extra careful with the ""types"" property in package.json  
- Use GNU Make to handle dependency tracking and build tasks  
- Deploy or publish to an npm compatible artifact repository, you need to script your deployment sequence to inject dependencies and version numbers into each package.json  

This is a collection of tips I gathered while trying to put together a decent multi-package TS project architecture, and it works pretty damn well.  
However, the way I figured this out seemed extremely DIY and I wonder if there is a popular way to achieve the same result. How are you guys doing this?",1526566116.0
Sephinator,Nice post! I've used `yarn workspaces` for this. Worked really great out of the box for me. ,1526568520.0
desktop-app,"Btw TS is going to support ""composite"" projects starting from 3.0, see Anders Hejlsberg's talk at TSConf 2018 here [https://youtu.be/wpgKd\-rwnMw?t=3294](https://youtu.be/wpgKd-rwnMw?t=3294)",1528375102.0
geon,"It is often simpler to just have a normal component and pass it a render-prop. 

```
render(){
  return this.props.render(someDataPrividedByThisClass);
}
```

This approach removes all of the weird typing issues. ",1526568370.0
cspotcode,"    return class WithDeepCompare extends React.Component<Props, null> {

Where is `Props` declared?",1526569310.0
MZDisaster,"I can't remember exactly what was wrong with my own HOC but I eventually got to a solution by inferring the generic type arguments with connect()
example:
> connect<IPropsFromState, IDispatchFromProps, IOwnProps>(...)(...)
  
you could also use a generic connect (which i'm using and if i remove the type arguments from it it doesn't work)
> export default function funcName<T extends sometype<any>>() {  return connect<IPropsFromState<T>, IDispatchFromProps<T>, IOwnProps>(...)(...); }

",1526569653.0
cspotcode,"Something like this should do the trick:

    function withDeepCompare<WrappedProps>(WrappedComponent: React.ComponentClass<WrappedProps>) {
        type WithDeepCompareProps = WrappedProps & Props;
        return class WithDeepCompare extends React.Component<WithDeepCompareProps, null> {

Make it a generic to extract the type of WrappedComponent's props.  Derive a new interface for Props based on the extracted type, with any modifications introduced by withDeepCompare.  (in this case, just add additional props, but you could also do funky things like removing or replacing props via mapped types, `keyof`, `Exclude`, or `Extract`)  Then declare and return the HOC class.",1526571440.0
LastOfTheMohawkians,I was there at this talk. Great to hear the history and design goals,1526505114.0
alakazan,Such great news to see that they are working on composite projects. Really nice.,1526514723.0
gradual_alzheimers,"if you put them in a json file you'll have to read that from disk, depending how often you read it from disk and at what scale you need to support this process it could be expensive to do so. I/O is typically one of the more expensive operations an application can have depending on a variety of factors.  ",1526446719.0
OneCoolSk8er,"I'd recommend the .json file. Once it's deployed, you can always change the json and restart the app. If you put it in as a const,  you'll have to recompile your .ts. 

If  it's an object and you know what the type will be,  you can require it in from the json and give it a type. 

Both ways will have the affect that the values are set once at the first time they are referenced.  

If you have a ton of static data, you can benefit from a sqlite or other in-memory databases. Doing an array find will go linearly through the data set whereas an indexed table can get there quickly with the right key info. 

",1526618768.0
AngularBeginner,"Just drop the `Arguments` type and you can do it simply with a conditional type:

    type AlterReturnType<T extends (...args: any[]) => any, R> =
        T extends () => any ? () => R :
        T extends (a: infer A) => any ? (a: A) => R :
        T extends (a: infer A, b: infer B) => any ? (a: A, b: B) => R :
        T extends (a: infer A, b: infer B, c: infer C) => any ? (a: A, b: B, c: C) => R :
        T extends (a: infer A, b: infer B, c: infer C, d: infer D) => any ? (a: A, b: B, c: C, d: D) => R :
        T extends (a: infer A, b: infer B, c: infer C, d: infer D, e: infer E) => any ? (a: A, b: B, c: C, d: D, e: E) => R :
        never;

And example usage:

    function noArgs(): string { return ''; }
    function oneArg(a: string): string { return ''; }
    function twoArgs(a: number, b: object): string { return ''; }
    
    type NoArgsAndReturnsNumber = AlterReturnType<typeof noArgs, number>;
    type OneArgAndReturnsNumber = AlterReturnType<typeof oneArg, number>;
    type TwoArgsAndReturnsNumber = AlterReturnType<typeof twoArgs, number>;",1526385116.0
SimplyBilly,"I would recommend using string enums if you use them.... E.g. enum MyEnum { BLAH = ""blah"" }. It generates just a straight up key / value map though, which means you can't convert from the string to the enum very easily \(but its possible if you need to\). But the benefits listed for using string literal types, also apply to string enums as well. It is also much nicer to use MyEnum.BLAH everywhere instead of ""blah"" everywhere in your code...",1526345715.0
cspotcode,"A transformer is the way to go, yes.  You want to transform the code while it's being compiled, so the results of your transformation will be visible in the emitted `.js` files, right?

TypeScript transformers must treat the input AST as immutable and return a *new* AST.  The language service needs to be super-fast, and ASTs are reused.  With incremental parsing, most of the AST is kept around; only modified parts are replaced.  Hence the immutability requirement.  (someone correct me if I'm wrong about this part)

Fortunately, the transformer API takes care of creating a new AST for you.  When your visitor function is called on the identifier node, return a new identifier node to replace it.  You can either use `ts.createIdentifier()` or `ts.getMutableClone(oldIdentifierNode)` to create a new identifier.

Here's a simple transformer which shows how to use the visitor API and return replacement nodes.

https://github.com/kimamula/ts-transformer-keys/blob/master/transformer.ts#L37-L40",1526341290.0
,[deleted],1526335163.0
CSMastermind,You're trying to do this at runtime? Or are you doing static analysis?,1526335883.0
diverightin63,I have been loving working in this framework. Pumped for v5!,1526225995.0
bheklilr,"This is a holdover from my python days, but I usually try to organize my imports into groups separated by a blank line, where the groups are

    Standard lib imports

    3rd party imports

    Organizational imports

    Current project's imports

The 3rd group would be for packages that have been implemented by your organization, but outside of the current project.

By organizing it this way you can keep each group sorted alphabetically without having them mixed up. The only thing I do differently for Javascript is add another group for resources like images and css. ",1526225844.0
scaleable,"It works great, you might need to duplicate a couple configs on webpack and tsconfig.

The only caveat, \_and it's quite a big one\_ , is that IF you are writing a lib which typings are to be consumed from another typescript project \(as a NPM module\), then your generated declarations will be broken. You'd either have to fall back to relative paths, or to find some webpack/rollup plugin to recompile your declarations.

If it's not a lib, no problem.",1526244891.0
peacebypiecebuypeas,"Here's my Typescript tutorial:

Write JavaScript and every time you declare a variable or a function, add ': <that thing's type>'. 

You're 90% there. ",1526210709.0
darkdigitaldream,"I see the appeal to this if you are developing in a heavy OOP style.

My preference, however, is to keep state out of my classes so I don't encounter the need for this in the first place.

The neat thing about the JS ecosystem and everything it brings is the flexibility to do things many different ways. Pretty neat.",1526164179.0
RealPatience,Great article. Useful stuff!,1526147581.0
BrunchWithBubbles,"Nice decorators. Seems useful in certain situations. In your lazy-loading example, you mention that load request might fire twice. Here is how you could implement it without that race conditions. The key is to push the promise type to the `users` property.

    class UserOverview {
        private users: Promise<User[]> | null;

        async getAllUsers(): Promise<User[]> {
            if(this.users == null)
                this.users = await this.loadUsers();
            return this.users;
        }

        async getUserById(id: number) {
            const allUsers = await this.getAllUsers();
            return allUsers.find(user => user.id === id);
        }

        private loadUsers(): Promise<User[]> {
            return myUserStore.getUsers();
        }
    }
",1526148842.0
mendrique2,"const method = descriptor.value!; 
what's that exclamation mark? is that a typo?",1526138160.0
ClutchHunter,"Near the end of the [opening remarks](https://www.youtube.com/watch?v=wpgKd-rwnMw) (all worth a watch IMO!) at TSConf the chap demoed something that might be of use to you, though I don't think it's landed anywhere usable yet. It's called composite projects and it's at the top of their [roadmap](https://github.com/Microsoft/TypeScript/wiki/Roadmap)!",1526127853.0
thinkmatt,"We have one shared common module at my work. I build that with ""declaration"" [1] set to true, which will print out a bunch of .d.t.s files along with the compiled js and source maps. Then when you import the module, typescript will see all your types in vs code. Havent used atom but I have been telling my team to just switch to vs code.

[1] https://www.typescriptlang.org/docs/handbook/compiler-options.html",1526132123.0
thepiggz,"I got this working a few months ago using a combination of VSCode, Yarn, Webpack, and Lerna. It’s very possible, though (at least a few months ago) pretty finicky to keep the build going with all the updates coming in to everything - specifically yarn. Works well though in the end, though my build is a tad slow. Right now, all of my modules are yarn workspaces in the same GutHub repo, though, using git submodules you could actual maintain them in separate repositories and get an integrated build going. Or, if you don’t want an integrated build, then you pretty much just upload your modules to npm with types and depend on them in your other modules - that’s what npm is for after all. Hope any of this helps.",1526140530.0
hmongoose,"You might want to read [this tutorial](https://www.reddit.com/r/typescript/comments/8k4guj/a_twopart_tutorial_to_learn_the_tricks_that_allow/) I just finished writing. It looks like it would apply well to your case.  
Anyway, if you end up using the ""file:""-style dependency you describe in another comment, I am curious to learn how this works out when you attempt to publish or deploy your package.",1526568611.0
geon,"I just parse t to json with any of the available libraries and cast to the known interface. 

",1526073455.0
tof,"I'm using DOMParser (https://github.com/jindw/xmldom), no problem with it.",1526134871.0
scaleable,"If you can't find anything XSD \-\> TS you can look into intermediate formats, like: XSD \-\> JSON schema \(then swagger, which is a subset\) \-\> TS.",1526087572.0
Angulant,"How is the XML generated?

If its from java entities you could use a tool like this:
https://github.com/dzuvic/jtsgen


",1526125361.0
AngularBeginner,They're doing it themselves. The code is available online to check. The TypeScript compiler has a staggering amount of zero dependencies. In the world of NPM that's a miracle.,1526050040.0
turkish_gold,"They really do it themselves. Typescript is designed and implemented by Microsoft\-\-\-you know that multi\-billion dollar company who also has compilers for C#, C\+\+, C, F#, Basic, etc.

They're more than capable of writing a compiler without relying on 3rd party efforts. ",1526063446.0
kaz3work,"It does not use Babel as Babel can only transpile JS. You can look at their dependencies to see they are not using it: https://github.com/Microsoft/TypeScript/blob/master/package.json  

You can see how they are transforming the TS in this folder: https://github.com/Microsoft/TypeScript/tree/master/src/compiler/transformers
  
A simple case is here: https://github.com/Microsoft/TypeScript/blob/master/src/compiler/transformers/es2016.ts
  
You can see on line 45 they are transforming x**y into Math.pow(x, y).",1526050249.0
cyanisis,Compiler does it,1526087204.0
BrunchWithBubbles,"This is a shortcoming of TypeScript's type inference algorithm. `Map.has` returns a boolean, but the type inference algorithm does not understand the actual meaning of that boolean (that Map.get(someVar) returns a defined value). A workaround would be to get the key before the if sentence:

    const x = this.mySet.get(someVar);
    if(x != null) {
        const y = x.blah;
    }

Edit: Fixed code formatting",1526043077.0
alex9158,"Another option is to use the non-null assertion operator (!) for cases where you know the value cannot be null/undefined.

     mySet: Map<string, IObjWithBlah> = new Map();
        
        if (this.mySet.has(someVar)) {
            const x = this.mySet.get(someVar)!;
            const y = x.blah; // undefined/null union case is stripped out
        }
",1526043337.0
ltray,"It would be nice if tsc had this knowledge somehow already, though it does feel like a kind of specific thing for the compiler to know about (vs, say, type guards, which is much more general of a concept).

Something like this _may_ be possible by overriding some `Map` definitions. The following example doesn't quite work (`typeof k` is `string`, so once in the guard any `get`'d item will be defined -- also the type guard casts `this` to `never` in the else case for some reason). However you can see how the construction works in a simple case (be sure to check ""strictNullChecks"" in options):

https://www.typescriptlang.org/play/#src=interface%20DefinedMap%3CK%2C%20V%2C%20T%20extends%20K%20%3D%20never%3E%20extends%20Map%3CK%2C%20V%3E%20%7B%0D%0A%20%20get(k%3A%20T)%3A%20V%3B%0D%0A%20%20get(k%3A%20K)%3A%20V%20%7C%20undefined%3B%0D%0A%20%20has(k%3A%20K)%3A%20this%20is%20DefinedMap%3CK%2C%20V%2C%20typeof%20k%20%7C%20T%3E%3B%0D%0A%7D%0D%0A%0D%0Adeclare%20const%20foo%3A%20DefinedMap%3Cstring%2C%20%7B%20x%3A%20string%20%7D%3E%3B%0D%0A%0D%0Aconst%20a%20%3D%20foo.get(%22bar%22)%3B%0D%0Aconsole.log(a.x)%3B%0D%0A%0D%0Aif%20(foo.has(%22bar%22))%20%7B%0D%0A%20%20const%20b%20%3D%20foo.get(%22bar%22)%3B%0D%0A%20%20console.log(b.x)%3B%0D%0A%7D%0D%0A%0D%0A",1526055415.0
hotrodx,"mySet.get() has return type IObjWithBlah | undefined. It cannot retroactively check the condition above.

Maybe use something like: 

    mySet: Map<string, IObjWithBlah> = new Map();
    const x = this.mySet.get(someVar);
    if (x !== undefined) {
        const y = x.blah;
        // do something here
    }

Or:

    mySet: Map<string, IObjWithBlah> = new Map();
    if (this.mySet.has(someVar)) {
        const x = this.mySet.get(someVar) as IObjWithBlah;
        const y = x.blah;
    }

EDIT: seems others have answered while I was composing mine",1526043491.0
RustyX,"If you're using Typescript 2.8, you can just do something like this:

```
type ConnectedState = ReturnType<typeof mapStateToProps>;
```

This will let you use the inferred return type of `mapStateToProps` as a named type.",1526046479.0
danvk,This is the sort of thing [dtslint](https://github.com/Microsoft/dtslint) helps you with. It's in increasingly widespread use in DefinitelyTyped.,1526042280.0
httptoolkit,"I've hacked together solutions to the same problem before using the typescript compiler programatically \(compile this file, assert on the error\). It's easier than it sounds, and it works but it's messy and non\-trivial. There might be one or two niche cases where that's still relevant, but this covers 95&#37; of what I was looking for, and is \_drastically\_ nicer.

Thanks for the tip, definitely going to use this!",1526037519.0
fk2106,React Virtualized although it may not be very easy to use. ,1525962120.0
ehdv,Recently heard about agGrid; looked pretty good.,1526009085.0
cr125rider,Nice to see an advanced guide here. Thanks. ,1525914900.0
-pertinax-,Thanks for the interesting read. The first idea is very much like Flow's opaque types. Hopefully we'll get that in TypeScript too at some point.,1525959163.0
iloveboxcutters,"I couldn't get the code in the first part to work. Had to change it to this
    
    export interface MyYear extends String {
      __my_year__: never;
    }

I was getting 
> 'string' only refers to a type, but is being used as a value here.
and interfaces dont use = ",1525968890.0
grinde,"The `async` keyword doesn't do what you think it does. The actual function body will be synchronous up until the first `await`, and the result will be wrapped in a promise. For example:

    async function foo() {
        console.log(1);
        return 3;
    }

    foo().then(console.log);
    console.log(2);

    // 1
    // 2
    // 3

Unless you use an `await` the behavior is equivalent to just returning a promise yourself.

    // This is equivalent to foo
    function bar() {
        console.log(1);
        return Promise.resolve(3);
    }

    bar().then(console.log);
    console.log(2);

    // 1
    // 2
    // 3",1525817892.0
MuppetMaster42,"Async is pretty well useless without await, which is why the feature is always referred to in the pair ""async await"".

Theres an eslint rule that you should turn on so you don't accidentally do this: https://eslint.org/docs/rules/require-await

But none the less, as an example...

    async function foo() {
      await Promise.resolve()
    
      return true
    }

And

    function foo() {
        return Promise.resolve()
            .then(() => true)
    } 

Are exactly the same thing - though IMO the first is more readable than the second.

*edit* formatting. stupid mobile.",1525858800.0
son_of_meat,"Both functions are pretty much the same in terms of how they'll behave in the end. One difference is that the transpiled version of the async function foo will come with a couple dozen lines of ""helper"" functions __awaiter and __generator.",1525836985.0
AngularBeginner,"`foo` does not run asynchronously. It runs synchronously, because you don't have an `await` statement.",1525815005.0
,[deleted],1525885966.0
PhysicalRedHead,"This is a complex question and all the answers I can think of have caveats. Typically you can get types definition files with `npm i @types/<package-name>`. You would do good googling around more, though.",1525738331.0
MostKaleidoscoped,"I think you're remembering [typings / TSD](https://github.com/typings/typings). There was a push to move from DT to Typings, which was an improvement in a few ways.

That was short-lived though, and scrapped a while back. Typings is deprecated, and instead types now get distributed through npm, like everything else. You either want a `@types/package-name` packages, or preferably types stored in the package itself (using a `types` or `typings` field in package.json), where possible. Those `@types/*` packages are autopublished from the DT github repository.",1525780921.0
realm_01,Why is this question getting downvoted? To me it seems to be a very legt question.,1525792166.0
cspotcode,"If the library doesn't bundle it's own typings, install them from @types/ on npm.  The @types/ scope is auto-published from DefinitelyTyped, the official community repo for declarations.",1525749904.0
cheekysauce,"This is actually super practical and a pattern I've been using to incrementally strengthen types as I use them.

Still can't find a clean way to deeply type Immutable.js objects.",1525740565.0
pe8ter,Link to VOD?,1526573980.0
Aior,"Yes, it does! You can just import from ""typescript"" package and compile stuff! Check this out: https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API",1525632578.0
voidvector,"No, what you are asking is ""computer algebra system"". General programming languages like TypeScript are normally not equipped with those. 

You can only evaluate `(x+(x+a)*a)*x` to `a^2 x + a x^2 + x^2` in an algebraic context, if your `x` and `a` are non-numbers (e.g. strings, booleans) or numbers non-algebraic properties (e.g. Infinity, NaN, large/tiny floating point values), the simplified version would not evaluate to the same result.

There are JavaScript computer algebra system you can use, e.g. https://github.com/davidedc/Algebrite",1525666649.0
,"Perhaps a custom transform plugin. Perhaps this tutorial might help? 
https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943 (Note, this is *not* my work or blog).",1525635545.0
fecal_brunch,"Cool, looking for something like this atm. Are there other similar libraries for typed reducers, and if so what does this do better?",1525775347.0
esamatti,"This seems really cool. Thanks for sharing.

I wonder if it works with redux-thunk?
",1525693613.0
HawkEgg,Why use strings with typescript? The language could be used so much more effectively.,1525581506.0
bertilxi,I accept suggestions,1525514790.0
,[deleted],1525477478.0
scaleable,"Rewriting the OP's question.

Can `lodash#mapValues` be strictly typed/inferred with current language features? Last time I checked the typedefs for that still didn't do the work...

https://lodash.com/docs/4.17.10#mapValues",1525565609.0
guncha,"This is not going to be possible until Typescript adds either:

1. Function signature resolution support in conditional types
2. Arbitrary expression support in the `typeof` operator

My money's on the first one, if anything.",1525570393.0
demoran,{ bar: 'abcdef' as 'abcdef' } will allow you to get typing on the values rather than just `string`.,1525439944.0
HeinousTugboat,[Let me know how close this is to your goal](https://www.typescriptlang.org/play/#src=type%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20number%2C%0D%0A%20%20%20%20bar%3A%20string%2C%0D%0A%20%20%20%20baz%3A%20boolean%0D%0A%7D%3B%0D%0A%0D%0Aconst%20test%3A%20Test%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20123%2C%0D%0A%20%20%20%20bar%3A%20%27abcdef%27%2C%0D%0A%20%20%20%20baz%3A%20true%0D%0A%7D%3B%0D%0A%0D%0Atype%20Wrap%3CT%3E%20%3D%20%7B%0D%0A%20%20%20%20data%3A%20T%0D%0A%7D%0D%0A%0D%0Atype%20Wrapped%3CT%3E%20%3D%20%7B%0D%0A%20%20%20%20%5BP%20in%20keyof%20T%5D%3A%20Wrap%3CT%5BP%5D%3E%3B%0D%0A%7D%0D%0A%0D%0Aconst%20mapTest%3A%20Wrapped%3CTest%3E%20%3D%20%7B%0D%0A%20%20%20%20foo%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20data%3A%20123%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20bar%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20data%3A%20%27abcdef%27%0D%0A%20%20%20%20%7D%2C%0D%0A%20%20%20%20baz%3A%20%7B%0D%0A%20%20%20%20%20%20%20%20data%3A%20false%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20mapObject%3CT%3E\(obj%3A%20T\)%3A%20Wrapped%3CT%3E%20%7B%0D%0A%20%20%20%20const%20newObj%20%3D%20%7B%7D%20as%20Wrapped%3CT%3E%3B%0D%0A%20%20%20%20for%20\(let%20k%20in%20obj\)%20%7B%0D%0A%20%20%20%20%20%20%20%20if%20\(obj.hasOwnProperty\(k\)\)%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20newObj%5Bk%5D%20%3D%20%7B%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20data%3A%20obj%5Bk%5D%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%20%20%20%20%7D%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20return%20newObj%3B%0D%0A%7D%0D%0A%0D%0Aconst%20finalTest%20%3D%20mapObject\(test\)%3B%0D%0Aconsole.log\(finalTest\)%3B).,1525440470.0
kallexander,Why doesn't Medium have syntax highlighting?,1525456970.0
tanguy_k,Please stop with MongoDb when 99% of the time what you need is SQL,1525465625.0
,[deleted],1525503946.0
jinhduong,"I just published my library like linq to npmjs.
Thanks for reading.",1525407061.0
BehindTheMath,"FWIU, the object returned by import does not have any information about where it came from. ",1525400873.0
Vbitz,If this is targeting nodejs then https://nodejs.org/api/modules.html#modules_require_resolve_request_options will return the path.,1525403873.0
spacejack2114,"You might be able to determine the full path from the value of `__dirname`, assuming you know where your current source file is relative to the files you're importing.",1525411054.0
zzing,I have started to much prefer the HttpClient service inside of angular that returns an observable.,1525380057.0
scaleable,"\`\`

    export * as File1 from './file1'
    export * as File2 from './file2'

\`\`[http://2ality.com/2014/09/es6\-modules\-final.html](http://2ality.com/2014/09/es6-modules-final.html)

EDIT: this one seems better

[http://exploringjs.com/es6/ch\_modules.html#sec\_importing\-exporting\-details](http://exploringjs.com/es6/ch_modules.html#sec_importing-exporting-details)

EDIT2: My snippet is not valid, i was wrong. The following works though

    export * from './file1'
    import * as _File1 from './file1'
    export _File1 //error
    export const File1 = _File1 //ugly... can i fix this?",1525283906.0
unshipped-outfit,"The complaint about nullablilty in TS is no longer true. 

http://www.typescriptlang.org/play/#src=function%20foo(num%3A%20number)%20%7B%0D%0A%20%20%20%20if%20(num%20%3E%2010)%20%7B%0D%0A%20%20%20%20%20%20return%20'cool'%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Aconsole.log(foo(1).toString())%3B",1525278938.0
scaleable,"This is quite old,  npm @types were not even a thing.

My opinion:

* Flow has \(or is expected to\) more consistent typing at a cost of a slower analyzer and less work on editor support/language service/etc;
* Flow doesn't erase types if a function argument is ""any"" \(is is analysed at call site for each call\);
* Flow is usually ahead on advanced typing things \(ex: controlling inference, variadic types\) but TS is always catching up; TS team is very cautious on adding features that will increase the complexity of the analysis. Flow is more focused on correctness.
* Flow has nominal typing on classes;
* \(From personal experiences\) Flow server keeps hanging up while TS server is usually very fast and stable.
* If you're migrating existing codebases, flow was supposed to be better \(better tools\), but the server keeps hanging.
* I've seen people complaining about weird bugs and/or lack of support for flow \(in a couple of talks\);
* TS has better editor tooling;
* TS is becoming sort of a community standard, a lot of new libs are already coming with TS typings;
* Even if a bit behind in the type checking department, TS keeps progressing with strong community and maintenance",1525286291.0
oliverguenther,"As one of the maintainers in a large monolith Rails app (OpenProject) that mostly worked on backend, but transitioned into an AngularJS frontend and ending up including Typescript 1.5 years ago, my recommendation is to just try it out. It is easy and straightforward to add to your existing project , however large it is.

It allows a smooth transition to it, letting the app become more and more typed as you go on. It has improved my frontend development experience manifold and for the foreseeable future all of my projects will run on Typescript.

Thanks to the earlier transition to TS, we have started migration to angular that finally fully embraces it and is just a breeze (for a large full stack app, that is.) We will likely complete the migration within a few months.",1525290035.0
vinz243,target: es5 in tsconfig.json?,1525265493.0
DrYakub,"In your tsconfig set “lib”: [“es2018”] or you could do es2017, esnext, or es7. All of that stuff is already supported by the ts compiler.

https://www.typescriptlang.org/docs/handbook/compiler-options.html",1525266003.0
sockaddr,"TS and Babel make syntactic changes, but they don't polyfill built-in methods like Array.prototype.includes and Object.assign on their own.  If you want to polyfill missing built-in methods, then you'll need to bring in something like core-js, which is what babel-polyfill does for you.

So to answer your question, set ""lib"" appropriately in your tsconfig, then pull in the polyfills that you want from core-js, and you should be good to go.  You can import core-js's ""shim"" if you want a blanket set of polyfills.  Another answer mentions the ""lib"" setting in tsconfig, but that just tells TypeScript which type definitions to use.  It doesn't affect the compiled output or bring in polyfills.  You'll still want to use it to something like ""es7"" so that it won't complain when you use Array.prototype.includes.",1525266725.0
hunyeti,"The TS compiler can emit ES5 JS code, there is no need for anything else for this.",1525265559.0
rajington,"I can't tell you the best solution still relying on the ts compiler because I don't feel there is one. The reason people don't have this CATEGORY of issues with Flow is because Flow JUST does type checking. Using TypeScript ONLY for type-checking is endorsed in [CRA@next](https://github.com/facebook/create-react-app/blob/next/packages/babel-preset-react-app/README.md), and even Microsoft [has a repo that follows this strategy](https://github.com/Microsoft/TypeScript-Babel-Starter).",1525265797.0
AngularBeginner,"Strict mode is a pretty huge improvement. Good job on that! Tho I'm surprised that such a change is released as a patch-release, but it seems you're simply not following SemVer.",1525182175.0
peacebypiecebuypeas,"What is the nature of these ""huge TypeScript improvements""? What kind of impact can one expect to see by upgrading?",1525189445.0
patwritescode,We use TypeScript with React on the frontend and have a few services written in TypeScript with Node + Express. ,1524943578.0
paulosuzart,This is very good question. I've been using ts for back end only for more than one and a half years now and it's jus brilliant. But I also question myself why almost all ts jobs are front end only. Let's see the opinions.,1524942393.0
jbenner,Anecdotally I do TypeScript + Vue at my job. ,1524952965.0
m12s,"I've used TypeScript for two years now, worked on large enterprise Office 365-projects. Never made an Angular-solution in TS, but plenty of React and standard JS solutions. 
More and more people adopt TS every day, and it's really growing in to somewhat of a standard in web programming. I would never dream of writing front-end code without TS.  

So I'd say; if they aren't common yet, they are going to be.",1524959596.0
LastOfTheMohawkians,I'd say 65% are non angular based on nothing other then old man intuition,1524949539.0
kylecordes,"I don't have a numerical answer to your question, but there certainly are quite a lot of projects and therefore jobs that meet this description.

We use TypeScript on nearly all of our Node work, and some non-Angular client-side work, in addition to our Angular work. TypeScript had a substantial community before Angular existed, although I suspect that Angular (which has a very large user base at this point) has substantially increased total TypeScript usage.


",1524969496.0
BrianBoyko,"If you know Typescript, though, you're pretty much good for any Javascript job. ",1524971661.0
goldcaddy77,"At Indigo, we use TypeScript + React for all of our front end apps and Typescript + GraphQL for all of our APIs (except data science). Being able to generate types from the GraphQL schema and share them in both the front and back ends is a game changer.",1525057514.0
Trab3n,I use TS with Node for server side ,1525012849.0
LowB0b,"the problem is that it's kind of unreadable. Sure it works for a factorial because everyone knows what a `factorial`function is supposed to return, but in a business setting you're going to have all sorts of different business rules intertwined (is that a word?) and using a ternary operator becomes a mess, like, really fast. I'd rather have this in my codebase

    const factorial = x => {
      if (x <= 1) return 1;
      return x * factorial(x - 1);
    }

IMHO that's more readable",1524926478.0
AceBacker,When you come back to this code in a year your future self will hate you.,1524924452.0
burtgummer45,"No, ternaries exist so you can put compact conditional logic on a single line. Why else would they exist?  This might be useful in a obfuscated code contest.  In production code this might get you murdered.

",1524927997.0
Yorek,I'm not a fan of nested ternary's myself.,1524922070.0
__trixie__,"Programmers have this mindset that ‘less code is better’ or ‘clever code is better’ You could easily write this in a more explicit and readable way with the exact same performance.  I’m sure everyone here looked at your code at first and was wtf is this cryptic nonsense.

If you want to write little clever solutions to CS 101 functions, that’s cool and entertaining , but please don’t write production code like this. Bug city.",1524927757.0
mrMaxBryson,No!,1524934971.0
RealPatience,I hope this is a joke... 😕 ,1524921718.0
Worworen,"The problem is not the nested ternary operators per se. It's that there is no convention on how to format them. Compare that code with nested if elses with the same formatting:

    let factorial: (x: number) => number =                                                         
         (x) =>                                                                                     
             if (x <= 0) {                                                                          
                 return  0                                                                          
                 } else if (x === 1) {                                                              
                     return 1                                                                       
                     } else { return x * factorial(x - 1) }",1524946307.0
dhruvrajvanshi,I wish JS had if expressions so we wouldn't need ternerary operator.,1524982463.0
danvk,"factorial(0)=1, not 0",1524924810.0
brockisawesome,Use a regular conditional if you want separate lines like that. ,1524934450.0
cspotcode,"Aside from the readability concerns expressed by everyone else, you should declare type information on the function expression and let inference apply it to the declared variable.  In other words, the style of type declaration introduces unnecessary duplication and verbosity, which it appears you're trying to avoid.",1525357502.0
BrunchWithBubbles,"I'm completely ok with this style. Very functional. Nested ternary operators are a bit iffy, but I get why you would use them here - Typescript doesn't have pattern matching or case-expressions like other functional programming languages.",1524930890.0
BrianBoyko,"Three problems: 

* You're defining the function type at the point of declaration so it LOOKS like the type declaration is the instantiation. 

* You're using nested ternaries.  

* You're declaring a function reference with ""let"" instead of ""const"".  Unless the variable ""factorial"" will be reassigned away from that function, at some point, use const or use a named function. 

so: 

    const factorial = (x: number):number => 
      [0, 1].includes(Math.max(0, x)) 
        ? Math.max(0, x) 
        : x * factorial(x-1);
       
",1524926305.0
blakflag,"I don't mind the ternaries, I like em better than bulky ifs for constants or for short epressions. But for me the double lambda expression took me a lot longer to read than if it was written as a more traditional typescript function definition.",1524925111.0
mourad1081,"It looks very programming 101.

Why a lot of new programmers think that fewer lines of code is ""cool"" ? 

R.E.A.D.A.B.I.L.I.T.Y. 

Our CPU run in 4 GHz and GPU's are even more powerful thanks to their parallelization. If an algorithm has the same complexity as another one, I will always take the more readable. 

And if it's less performant I will take the more readable anyway and try to make it better.",1524937268.0
besthelloworld,But it's just one line!,1524939132.0
tudor07,If you had to ask then no.,1525454311.0
mrbobjingles,"It's stage 0 right now, so you won't be able to use it for a while, but there is an open proposal to add pattern matching to JavaScript (and thus TS too), which seems like it'd be right up your street: https://github.com/tc39/proposal-pattern-matching

Example:

    const res = await fetch(jsonService)
    const val = match (res) {
      {status: 200, headers: {'Content-Length': s}} => `size is ${s}`,
      {status: 404} => 'JSON not found',
      {status} if (status >= 400) => throw new RequestError(res)
    }
",1525631630.0
lost_file,Yes but don't indent them,1524926262.0
HeinousTugboat,[No](https://stackoverflow.com/questions/36110070/does-typescript-have-operator-overloading?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa). It isn't supported at all by the underlying spec.,1524882960.0
scaleable,"Maybe theres a babel plugin for it?

People do terrible things with babel plugins.",1524930532.0
Anon_Logic,"Man, I get the contest being on Twitter... But fuck social media.",1524840053.0
ghostbyte,I already pre ordered the book some time ago. Just waiting for it to come out :),1524841868.0
TweetTranscriber,"📅 2018-04-27 ⏰ 12:17:56 [(UTC)](https://www.timeanddate.com/worldclock/converter.html?iso=20180427T121756&p1=1440)

>To celebrate the launch of my new book http://www.learningtypescript.com I'm going to give away 1 book 📕 per week for 10 weeks 🚀 Retweet this for a chance to WIN A FREE BOOK on the 4th of May 🤞There are 9 more books to go \#typescript \#nodejs \#angular \#reactjs 

>— Remo H. Jansen 🇮🇪 ([@RemoHJansen](https://twitter.com/RemoHJansen))

>🔁️ 16 💟 8



📷 [image](https://i.imgur.com/oVdz2gK.jpg)



 &nbsp; 

^(I'm a bot and this action was done automatically)",1524835587.0
AngularBeginner,Why is there a cast `as ICanaryConfig` in the sample? There's no reason a cast should be used or needed here. Doesn't really give much trust in this library.,1524808575.0
BrunchWithBubbles,"You Night wanna try ""object rest spread"":
    
    { productlist: [1,2,3,4,5], ...order }",1524760230.0
CrayonConstantinople,"So lets say `order` is the actual order.

JSON.stringyify will stringify it:

    let stringifiedOrder = JSON.stringify(order);
    >>> ""{""price"":31.5,""trackerId"":""sadfadsfasd""}""

We can parse it to get back the original order 
    
    let parsedOrder = JSON.parse(stringifiedOrder);

Now that its not a string anymore, we can add the new key value pair as normal.
    
    parsedOrder.products = [1,2,3,4,5];
    >>> (5) [1, 2, 3, 4, 5]

Then we can stringify it again:

    JSON.stringify(parsedOrder);
    >>> ""{""price"":31.5,""trackerId"":""sadfadsfasd"",""products"":[1,2,3,4,5]}""",1524759163.0
djnoxious,"The best way is to create an index.ts file for each directory and export all files/folders beneath it.

export * from './myFile'

Take a look at ts mappings/alias to reduce it even further ",1524762045.0
tme321,"Look at [path mapping](http://www.typescriptlang.org/docs/handbook/module-resolution.html) where you can define symbols directly to directories you specify.

Their example isn't the greatest because it points at node modules which clearly isn't necessary or helpful.  But with my projects I usually end up creating ones like

    paths: {
        ""@common"": [""./src/app/common/**/*""],
        ""@foo"":[""./src/app/features/foo/**/*""]
    }

Then my imports look like

    import { FooComponent } from ""@foo/foo.component"";

    import { SomethingCommon } from ""@common/something-common"";

Combine that with a vscode plugin that will find imports for me and it makes the import statements uniform and easy to create.
        ",1524766786.0
kurashu89,"[It's Python, but here's a project I've been working on in my free time](https://github.com/justanr/gamenight). I'm trying to keep the code simple, decoupled and cohesive so I don't need to keep all of it in my head at the same time.

Domain modeling is the process of taking a real world process and putting it into code. In gamenight's case that real world process is arranging a game night: scheduling a time, inviting people, and getting commitments on games and attendance (the actual code is a little light right now as work has been balls to the walls lately).

To address you questions:

- Presentation layer: This is what the user interacts with, it can be an actual UI, JSON API, a CLI, GUI or something else similar. 

- Business layer: This would be the heart of your application, this is where things like interfaces, entities and domain services live (I'll expand on this in a bit).

- Application layer: This the home for application specific things. In many applications this and the business layer are one and the same. But if you do things like multitenancy then they're probably separate if Client A and Client B have slightly different rules around something. You'd likely be very short on new interfaces and entities here, but very heavy on implementations.

- Data access: This is connecting to a data source, typically this will be a database, but in gamenight (my example app above) I use both a database AND the Board Game Geeks' API for data. Typically this layer is expanded to be an ""infrastructure"" layer -- not just database, but also your HTTP framework (or CLI or GUI, etc).

So about Services, value types and entities...

**Services** don't represent a thing so much as a process. In gamenight, this would be GameImporter, it represents the process of retrieving a game from the BGG service and bringing it into my application. If you have login, that's a service. I'm hesitant to say things like GameRepo are services because while they serve some purpose (moving data from my database into my application's memory space) they don't represent a crucial piece of the puzzle for my application, they're just a necessary evil in domain modeling.

Domain services are services that essential to the domain, they hold core logic. The [DefaultGameImporter](https://github.com/justanr/gamenight/blob/b3faf49e0230930e8e31d76ad7073a316c1f704a/src/gamenight/core/services/importer.py#L11) would be an example -- it encodes as part of it's code that if an imported game already exists in the system, then don't move forward with the import and just return the existing entity.

An application service on the other hand would be the [BoardGameGeekSearch](https://github.com/justanr/gamenight/blob/b3faf49e0230930e8e31d76ad7073a316c1f704a/src/gamenight/app/services/game_importer.py#L12). My domain doesn't care about the *how* or *where* it only cares about the interface. There's no domain logic to be found here, it's just boring glue code to tie the BGG Client and my application together.


**Value types** -- not to be confused with literal value types like structs or ints -- are objects that represent some concept in your application but don't have any special identity -- it doesn't matter if they came from the database or someone typing `new ValueType()`. Money is often my go to example. If I have $20 and you have $20 and we trade those bills, does it matter? No. 

If I have a Dell XPS 15 and you have a Dell XPS 15 and we trade does that matter? Absolutely. And the reason it matters is because both computers have identity, it matters *which* computer is which. They'd be **entities**. Your computer, over its lifetime, might change operating systems, hard drives, memory, get dropped and now has a dent or scratch on it but it's still *your* computer. There's a ""thread of identity"" that it keeps with it -- this thread of identity is often something like surrogate primary key (autoinc seq or the like in the database), which is often a useful concession to make in your domain.

Here's the kicker: In one domain, something might be all important and be an entity; in another domain, it's just a value type and it's not as important. This'll probably happen in gamenight. Games are important in one area, but when it comes to users games are just something users own and they're regulated to the back seat.

",1524703188.0
zzing,"Just to get you started, a domain is an area of knowledge. It is quite similar or the same as the concept in math.

A house might be an entity that has properties, for example, in the United States a house should have an address - well an address can be encoded into another entity. 

In a model-view-controller application such as asp.net mvc - the controller calls the business layer which does everything that doesn't need to know about the asp.net framework. The business layer generally calls the data layer which directly accesses the database. SQL stored procs could be considered a lower layer on that.

Look up the term 'business logic' - that is the code that usually is inside the business layer.

The controller passes data off to the view - that is the presentation layer. Now if you are using angular, there is another set of layers that can correspond to those above.

Not all of these layers are in all applications and they likely have a few different names. The more to confuse you with.",1524687348.0
AndreDaGiant,Just wait 'til everyone says that middleware shuffling around mysterious stateful untyped objects is a great idea to build large scale web service projects.,1524742328.0
Arjes,"Fairly low effort blog post, could at least talk about why you would choose one over the other. This also doesn't discus TS at all, here is how to do the faster loop in TS:

    const x = [1, 2, 3];
    for (let y of x) {
        alert(y)
    }

If you need your JS to be so performant that this change is meaningful, then by all means do it!

However readability of `forEach` vs the `for` loop and the ability to use closures makes this a wash in my book. The 95% slower is okay for 95% of the arrays I'm working with. ",1524654589.0
tfptfp,"This is a post from over a year ago.
Did you even read the comments?
And how they explain that this is a very bad genaral advice?
It's tested wrong, it matters almost never and it can be even faster in certain other testcases?
",1524675186.0
__gc,Hope no one's taking this seriously ,1525045096.0
mcboman,"Just a little extra: placering the .length in a variable, so you dont do multiple counts? Or is that only on c++ thats the case? ",1524675806.0
n0rs,"You can use a pattern like

				type Param = (
				  { group: ""red"" } & 
				  RedGroup & 
				  Not<BlueGroup>
				) | (
				  { group: ""blue"" } &
				  BlueGroup &
				  Not<RedGroup>
				)

Both or-groups need to list all params but you if you don't want some params in one group, set them to be undefined.

Let me know if that doesn't make sense, I'm on mobile so typing code is particularly annoying.",1524614540.0
,[deleted],1524612806.0
Auronon,"It sounds like you are looking for exact types. https://github.com/Microsoft/TypeScript/issues/12936

I mocked up a currently working version that I think is what you want:

https://www.typescriptlang.org/play/#src=interface%20BrowserRouter%20%7B%0D%0A%20%20%20%20uniq%3A%20'hi'%3B%0D%0A%7D%0D%0A%0D%0Ainterface%20StaticRouter%20%7B%0D%0A%20%20%20%20alsoUnique%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Atype%20BrowserRouterProps%20%3D%20%7B%0D%0A%20%20%20%20prop1%3A%20string%3B%0D%0A%20%20%20%20prop2%3A%20number%3B%0D%0A%20%20%20%20propShared%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Atype%20StaticRouterProps%20%3D%20%7B%0D%0A%20%20%20%20prop3%3A%20number%3B%0D%0A%20%20%20%20prop4%3A%20string%3B%0D%0A%20%20%20%20propShared%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Atype%20Not%3CT%3E%20%3D%20%7B%20%5Bkey%20in%20keyof%20T%5D%3F%3A%20undefined%20%7D%3B%0D%0A%0D%0Atype%20Omit%3CT%2C%20K%3E%20%3D%20Pick%3CT%2C%20Exclude%3Ckeyof%20T%2C%20K%3E%3E%3B%0D%0A%0D%0Atype%20JointedNot%3CONE%2C%20TWO%2C%20DISCONE%2C%20DISCTWO%3E%20%3D%20(DISCONE%20%26%20Not%3COmit%3CTWO%2C%20keyof%20ONE%3E%3E%20%26%20ONE)%20%7C%20(DISCTWO%20%26%20Not%3COmit%3CONE%2C%20keyof%20TWO%3E%3E%20%26%20TWO)%3B%0D%0A%0D%0Afunction%20tester%3CTEST%20extends%20JointedNot%3CBrowserRouterProps%2C%20StaticRouterProps%2C%20BrowserRouter%2C%20StaticRouter%3E%3E(val%3A%20TEST)%20%7B%0D%0A%20%20%20%20%0D%0A%7D%0D%0A%0D%0Atester(%7B%20uniq%3A%20'hi'%2C%20prop1%3A%20'hi'%20%2C%20prop2%3A%203%2C%20propShared%3A%20'shared'%20%7D)%3B%20%2F%2F%20valid%0D%0Atester(%7B%20uniq%3A%20'hi'%2C%20prop1%3A%20'yup'%2C%20prop2%3A%204%2C%20propShared%3A%20'shared'%2C%20prop3%3A%204%20%7D)%20%2F%2Finvalid%2C%20prop3%20is%20extra%0D%0Atester(%7B%20uniq%3A%20'hi'%2C%20prop1%3A%20'stillhere'%2C%20propShared%3A%20'shared'%20%7D)%3B%20%2F%2F%20invalid%2C%20prop2%20is%20missing
",1524676324.0
rco8786,"Rule of thumb: start with `const`, if you need to change the value later, change to `let`, and forget about `var`.",1524586999.0
recursive," * `let` - use this when you are declaring a variable to be used in a scope and possibly re-assigned later.
 * `const` - use this when you know you never need to re-assign to the variable.  assign when you declare and never again.
 * `var` - don't use this.  it's old and pointless.

That's it!",1524586318.0
,"You should never use `var`. it's like `let` but has scoping issues.

`let` is used to declare a variable like in any other language. You can use it to declare a variable who's value can be changed.

    let c = 1;
    c = 2; // changing the value of a let variable is fine

`const` is like `let` but its a constant who's value can't be changed changed.

    const b = 1;
    b = 2; // causes an error

You should always use `const` as your default choice and *only* use `let` when you need to be able to change the value of a variable \(which should be almost never\). Using constants over variables makes your code easier to reason about because there's less possible changes to keep track of in your head.

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

Example of whats wrong with var:

    if (true) {
      var a = 1;
    }
    a; // will be equal to 1. wtf?! it was declared in the if block
    
    if (true) {
      let b = 1;
    }
    b; // cant be accessed outside the block scope it was declared in",1524586419.0
konaraddio,"FYI var, let, const are from JavaScript. They are not exclusive to TypeScript. TypeScript has them because TypeScript is a super set of JavaScript.",1524602259.0
redkopite,I find the answer to this Stack Overflow [question](https://softwareengineering.stackexchange.com/questions/278652/how-much-should-i-be-using-let-vs-const-in-es6?newreg=0d0513a674ba46ba90d13b2d08c0cd7a) a very nice insight on subtle differences that `let` and `const` have.,1524591985.0
TjomasDe,Does it work with tree shaking?,1524546476.0
jineshshah36,What is the advantage of using this over core-js directly?,1524576400.0
Bamboo_the_plant,GitHub repo here: https://github.com/shirakaba/react-native-typescript-2d-game,1524496053.0
BurritoBashr,If your tsc takes 40 seconds to compile them so be it. AFAIK there’s no way to query the service.,1524480185.0
tehdog,"You should be able to query the service by creating a [language service plugin](https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin) that opens a socket / http server to query information. I was thinking about writing something like that for a different purpose, but I think it should work for this.


Note that with the current state this will only work for the language service within VSCode (plugins are not executed when using tsc) and only when using the VSCode integrated version of TS, not when using the workspace version.

Edit: Maybe you can use it with workspace TS versions, see [here](https://github.com/Microsoft/typescript-styled-plugin#usage)",1524491602.0
mikesalmonuk,"In my package.json file, I have this:
        ""precommit"": ""./scripts/git-pre-commit-hooks.sh"",

And then in my scripts folder I have the git-pre-commit-hooks.sh script which does a tslint check on all files I'm about to commit. I know it's slightly different to what you've asked, but it always catches any ts errors before I commit them.

    #!/bin/bash


    # exit immediately if any command fails
    set -e


    # set indent function
    indent() { sed '/^\s*$/d; s/^/   /'; }

    # navigate to top level
    cd ""$(git rev-parse --show-toplevel)""

    # lint check
    echo ""TypeScript lint check...""
    TSLINT=""$(git rev-parse --show-toplevel)/node_modules/tslint/bin/tslint -s tslint/formatters --config tslint.json""
    FILES=""""
    for file in $(git diff --cached --name-only | grep -E '\.ts$')
    do
        FILES=""$FILES $file ""
    done

    # lint check any typescript files
    if [ ""$FILES"" = """" ]; then
        echo ""No files to check"" | indent
        echo
    else
        eval $(echo $TSLINT $FILES) | indent
        if [ ""$PIPESTATUS"" = ""0"" ]; then
            PASS=true
        else
            PASS=false
        fi

        # exit if lint checks fail
        if [ ""$PASS"" = ""false"" ]; then
            echo ""Lint tests failed"" | indent
            echo
            exit 1
        else
            echo ""Lint tests passed"" | indent
            echo
        fi
    fi

    # all done
    echo ""Done 👍""
",1524576847.0
unshipped-outfit,"I know VSCode has something like this in their repo, it’s a pretty big project but the hook doesn’t add any significant time. Might be worth looking at how they do it. ",1524502358.0
welkie,"The readme makes it sound like exactly what I would end up using for a new project I was starting. I like a lot of the concepts, like the docker-compose stacks for both dev and prod, and running compiled JS instead of using ts-node.

Did you make sure there are source maps in the compiled JS in both dev and prod so that you get good debug support in dev and the prod logs will have meaningful stacktraces for errors?

Also I would avoid using the term ""best"". If it's the best, the stars count and contributions will reflect that. The open-source community generally feels respect should be earned, not assumed.",1524454114.0
perduraadastra,"I don't know if I'll use this, but I like the idea. Kudos.",1524446171.0
ResponsibleLife,"[Getting Started With TypeScript](https://basarat.gitbooks.io/typescript/content/docs/getting-started.html)

[TypeScript Courses](https://typescriptcourses.com/)",1524449447.0
insulind,I'm a C# dev and I found this book useful Pro TypeScript: Application-Scale JavaScript Development https://www.amazon.co.uk/dp/1484232488/ref=cm_sw_r_cp_apa_aCn3AbXHX24T6,1524422456.0
mrpmorris,Learning the language is the way part. Which framework are you considering for the front end?,1524435925.0
usedforprinting1234,"Some practical examples:

* Avoiding too many network connections: If you're writing your code for the browser, you don't want to serve each of your compiled files separately over the network. You would use webpack to bundle all of your compiled files into a single file. 
* Polyfill: You might compile from Typescript to ES6 and have webpack polyfill that code for use on older browsers.
* Code-splitting: You might want to ""code-split"" or separately bundle a web page's code or a certain feature of your application's code together to dynamically load only when needed. webpack would help you create those bundles. This applies to both the browser and server-side rendering.
* Minimizing overall application size: webpack ""walks"" through your code from an entry point and packages together only its dependencies. It would avoid bundling code from large packages that most likely have files you don't use in your application. This is obviously beneficial in the browser, but also useful if you're using something like AWS Lambda where start times matter.

If you're writing code for the browser or any other environment where size and/or start times are matter, you'll most likely need webpack. Some tools, e.g. [create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript), automatically handle this for you.",1524343309.0
symgeosis,"Webpack is a way to transform and bundle resources. If you're creating something simple, you probably don't need it. If you want to create a something with minified sources, with external libraries, or with other resources such as css, sass, images, etc, then you might want to consider Webpack. The simpler your code, the less likely you are to need Webpack.",1524338000.0
spacejack2114,"Browserify and Rollup are also alternatives, maybe easier. The main advantage is being able to use npm libraries.",1524343642.0
scaleable,"The key feature for webpack is allowing the use of a module system. A.K.A. write like you would do in node.js, using `requires` and `exports`, instead of global variables and `<script>` tags, without worrying about the overhead of having many small files** .  So, yeah, it's something more targeted at front-end.

**(which can be troublesome without a bundler because you'd have to manually fix script tags, and thats also slow because of the many http requests)

On top of that, webpack comes with a couple of extension hooks, which actually allows you to put more of the ""build pipeline"" into it. Thanks to this, webpack replaces most of the build scripts you'd previously have (node/gulp/grunt and sort). Common ""hooks"" examples are: transformation (ex: babel and typescript), minification, serving the files for development, etc...",1524349802.0
welkie,I've also found that Webpack has good support for including source maps. I've used Webpack with the TypeScript loader and other loaders to compile bundled JavaScript where in the browser dev tools you get to debug the actual separate files TypeScript. It works brilliantly.,1524356041.0
UnCrevard,"If you are using some packages from npm for example and want to use them in the browser, webpack ""emulate"" node API (process/fs/path etc...)

Bundlers like parcel, rollup, browserify are doing the same way",1524404709.0
ndubien,"The aim of this post is mainly to gather comments concerning the usage of fast-check.

- Is the README enough to start playing with the tool?
- Are there enough examples?
- Are there missing features? Missing arbitraries that other frameworks might have?
- Can you easily use it? Or is it too difficult to use? - if so, please put a comment in this thread so that I can work on it

Thanks in advance for the feedbacks
",1524330357.0
bitjson,"I don’t have any feedback for you yet, just wanted to say great work, and thanks for sharing!

Also very glad to see you’ve cut a major version. I’ll feel a bit more confident getting a project set up using fast-check now.",1524447134.0
Hath995,"The other libraries I'm aware of are:
http://leebyron.com/testcheck-js/
https://github.com/jsverify/jsverify

I originally tried jsverify and could get it to work, but I found working with it or extending it a bit clunky. Testcheck is easier to work with and had typescript bindings. It's compiled clojurescript though so extending it is not so encouraging.

Ultimately, the version to compare against isn't even in js, but Hypothesis by David MacIver in Python.",1524524049.0
ndubien,"Version 1.1.0 has been released, it includes:

- straight to corner cases runs (prefer small values for first runs) 
- verbose option in case of failure 
- better typings of fc.record",1526283725.0
fecal_brunch,"Can't it just be a single function that you call, rather than an object you instantiate?",1524267683.0
itghisi,"I think it all depends on your abstraction. I don't know your problem domain, but seems a little strange that Node class has a simulate() method. 

And as sad, Algo may be a single function if you don't need to hold state",1524279212.0
rco8786,"> Should I instead be compiling my TypeScript to JavaScript and then running the JS via Node?

That's quite literally the only way to do it. (ts-node just hides some of it from you, but ultimately that's what it's doing)",1524240263.0
locnload,"I compile it down to JS for releases. For development I use nodemon and ts-node. See here:

https://github.com/locnguyen/typescript-node-starter",1524246442.0
thadudeabides1,I usually create `src` and `dist` directories where the `dist` is just a replica of my `src` directory structure except the files are transpiled to javascript. Any node scripts will reference the dist directory (e.g. `node src/index.js`). I don't know if there is a better way to do it though.,1524242153.0
Auxx,"Compile it to plain JS and run it that way. ts-node has some weird issues with resolving files which lead to your code breaking when you are using dependency injectors and advanced decorators. Compiled code is fine though.

Also don't use @datorama approach, it doesn't work.",1524243513.0
cyanisis,"I don’t get what you mean?? Typescript doesn’t touch runtimes.   Typescript is a developer tool for writing JavaScript. You have to transpile (I notice people say compile a lot, are these interchangeable?) it to js and run the js with the node runtime. ",1524286003.0
symoc,I compile with webpack+babel because Typescript can only specify the target version (es20xx) but 'babel-preset-env' can generate code optimized for my exact node version,1524292952.0
s1cklik3,Nest.js!,1524267910.0
TjomasDe,easy: https://github.com/redplant3d/best_typescript_nodejs_docker_container,1524435114.0
AndreDaGiant,"Accessors are a huge bitch in large codebases because when you're step debugging, no IDE will show you that ""WARNING: THIS WILL RUN A FUNCTION WITH SIDE EFFECTS, IT IS NOT JUST GETTING/SETTING DATA""

and so tons of devs step over lines that they should really step into, and spend many extra hours finding bugs that would otherwise be trivial to find.

The upside of accessors is you don't have to write 5 extra characters (which the IDE will happily complete for you anyway).

Until IDE tooling is consistently able to mark getters/setters as such, I'm not using it in any codebase.",1524231027.0
demonizah,"Each time I ask myself this question, I realize how I've never come to a decisive conclusion.

I figure I'd prefer `getBestChild()` as it's more indicative to the reader that there is some processing/derivation going on, rather than accessing a 'cached' value.

But then `getBestChild()` could also be just returning a cached value. Well, I guess that's ok, since what goes on is an internal concern. The function name tells me 'Processing may have happened'.

I sometimes feel like I like the usage of simple accessors. No bajillion `getXXX` on the object. Or I feel like it's nice to use for readonly properties, which may have derivation logic in them.

There we go again. No conclusion.",1524206357.0
qalmakka,"I would personally recommend you to prefer the method to the accessor if there's no memoisation of the value whatsoever. I think that a bit of processing can be acceptable as part of a property only in a context of lazy initialisation of an underlying backing field; a method is much better in conveying the meaning of ""possibly expensive operation"".",1524220192.0
blood__drunk,"Hmm asked this one myself a few times, so looking forward to seeing other answers.

My thought at the moment - if you may need to pass arguments then a method should be used, but if you're certain arguments are not now, and never will be required, then use a getter...",1524204059.0
n0rs,"Another way to view this is that getBestChild should be findBestChild as it's not really an accessor since you're doing an action, not retrieving a stored value.",1524275709.0
RomanCow,"Personally, I decide which approach to use based on how I would want someone to use the result of the accessor/method. To me, a method tells the user ""you should store this value if you're gonna be referencing it more than once"" whereas an accessor tells the user ""it's fine to reference this value as an accessor each time if that's what you want"".

So for example, if they were using it in a function, implementing it as an accessor is saying this is ok:

    function someMethod(myNode: Node) {
        doSomething(myNode.bestChild)
        doSomethingElse(myNode.bestChild)
        doOneMoreThing(myNode.bestChild)
    }

Whereas implementing it as a method is telling someone that they should do something like this instead:

    function someMethod(myNode: Node) {
        const bestChild = myNode.getBestChild()
        doSomething(bestChild)
        doSomethingElse(bestChild)
        doOneMoreThing(bestChild)
    }


I'd say in your example, I'd probably want the method approach because I would want someone to store the value so they're not re-running the evalFunction every time.",1524234952.0
romeozor,"“Best child” doesn’t sound like a reasonable property of something, so initially the method signature looks more appropriate. 

But then I assume the result would not change once the object is constructed, no matter how many times you call getBestChild(), so you could calculate the best child in the constructor and assign it to a bestChild property. ",1524252443.0
pobbly,Does it even have to be in a class? A standalone function on []Node would be more flexible.,1524278477.0
yesman_85,I tend to do more methods instead because: it's clearer for the reader of the code that a function is called and it's easier to debug. Especially the memory mapper and GC have more troubles with getters and setters.,1524236389.0
crackdroid,"Huh, thanks. I'd not seen this pattern with 'get' before",1524210886.0
Neoflash_1979,"Ok, here is a synthesis of the various ideas so far.  
  
    // Decision process for choosing whether  
    // to use an accessor or a method
    if (you don't give a damn about debugging AND
        function is O(1) AND function is pure* ) { 
        use accessor
    } else {
        use method
    }
    
    * A function is pure when, given the same input, it will always 
       return the same output and when it produces no side effects.

Would you agree that this is a good heuristic? Thinking about this, you would pretty much never use accessors. Unless you don't give a damn about debugging. Then the only use case for a getter that I can now think about is for something like this:  
  
    class WeatherData {
        constructor(private fahrenheit_: number) { }

        get celsius(): number {
            return convertFToC(this.fahrenheit_);
        }
    }  
  
In this case, the convertFToC function is O(1), has no side effects and given F Fahrenheit will always return the same C Celsius value. Therefore it makes sense to use a getter.",1524240298.0
recursive,"I disagree with the idea of doing unit conversion *and* formatting in the same function, but if one must, I'd write the whole thing like this.

    function convertFtoC(temp: string | number): string {
        let value: number;
        if (typeof temp === 'string') temp = parseFloat(temp);
        return ((temp - 32) / 1.8).toFixed(1);
    }

Yes, I know the behavior is different.  I took out some of the insanity.  Temperature is zero when a non-value is passed?  What sense could that possibly make?",1524202834.0
unsung_unshift,"OK so what I think is going on here is, rather than *executing* those methods, the code is testing for their *existence*, as a means of determining what type `temp` is, since it could be `any`.",1524177383.0
unsung_unshift,"Did some more research as I'm a beginner with TypeScript myself. Probably what the author should have used was a [""union type""](http://www.typescriptlang.org/docs/handbook/advanced-types.html) and then just test for whether typeof is string, convert it to number with `Number()` (or `parseFloat` as he did seems OK too) and go from there.  There would then be no need for an else if the type was not String or Number.  Possibly the book you are reading came out before Typescript 1.4?  Because if not, and the author does not know the necessary features, shame on him/her -- you see it hardly took me any time to figure this out on my own; my first comment was 6 hours before this one, and I was asleep for 4 of those ;)",1524201664.0
thebosz,I'm just here to eat.,1524162289.0
blaster151,There ain't no such thing as a free TypeScript book.,1524192028.0
magnusdeus123,"Great stuff, OP. I actually bought your first ed.  book with office funds and read through the whole thing.

Don't know what the process is for perhaps getting a copy of this ed., but I'm a fan and would love to have one. :)",1524193847.0
pizzintea,Your book is eating?,1524207357.0
mfraser27,"Looks like a great book, wish it had a VueJS chapter.  ",1524214693.0
magnusdeus123,"Great stuff, OP. I actually bought your first ed.  book with office funds and read through the whole thing.

Don't know what the process is for perhaps getting a copy of this ed., but I'm a fan and would love to have one. :)",1524193843.0
mfraser27,"Thanks, picking this up today :)",1524226357.0
thescientist13,"Git (i.e. GitHub, GitLab, Bitbucket, etc).  Also referred to as version control.

If you aren’t using version control for software projects, I would highly recommend adopting it.",1524144196.0
rco8786,Use git. It is the de facto standard in all of software development for doing exactly what you’re describing.  ,1524191546.0
mfraser27,"Checkout GitKraken and read about GitFlow.  GitKraken has a great UI for using GitFlow methodology.  It's a good, simple way to start using git, I know alot of people struggle with the command line and git in the beginning.",1524215072.0
soulsizzle,"This project keeps looking more and more like Doctrine, and I'm 100% okay with that. Pretty much every feature Doctrine (or its extensions) has, and I want, is getting implemented. Great work.",1524160067.0
senoroink,"Awesome! I've been using typeorm a lot with my latest project and it's a huge improvement over my last favorite ORM, objection.js. Obviously that's biased since my new project is written in typescript, but I'm having less sporadic bugs with typeorm.

My only critique has been with the docs an expressing so many ways to do something -- query builder, active record pattern, entity manager, repository pattern, etc. It seems like the repository pattern is the defacto way of doing things (my co-worker who used to be in C# land says that's probably where it was influenced from). Given that, the guides could use a refactor to always show a repository example and then stuff the alternatives into an Advanced section.",1524158042.0
welkie,"I like TypeORM but what still keeps me in ASP.NET Core for serious work is the fact that while accessing properties in TypeORM is typed, joins/includes are not. In TypeORM, they're stringly-typed. It looks kind of like this:

  db.users.include(""posts"")

In Entity Framework Core, you use lambdas that specify the related entities as you do the include step, so it's all typed. It ends up looking like this:

  db.Users.Include(user => user.Posts)

If an association changes, the compiler will warn you that your queries with includes are now broken.

The TypeScript compiler won't be able to catch that with TypeORM. They've got an open issue for it, it's on their backlog til they decide on a good way to implement it. I hope they prioritize it!",1524177966.0
,[deleted],1524183516.0
GFandango,"Not really a typescript question but here's my attempt in ""functional style"".

    const totalSpentOnDiscountedItems = clients.map(
        // For each client
        client =>
            // For items of each client
            client.items
                // For each discounted item
                .filter(item => item.disc && item.disc > 0)
                // Calculate amount paid (price minus discount)
                .map(item => item.price - item.disc)
    )
    // Flatten total values for each client into one array
    .reduce((a, b) => a.concat(b), [])
    // Sum the values in the array
    .reduce((a, b) => a + b, 0);
    
    console.log(totalSpentOnDiscountedItems);

Answer: 380",1524141547.0
Jarrku,"Try this:

    const result = clients.reduce((total, customer) => {
        const totalOfUser = customer.items.reduce((totalUser, { price, disc }) => (disc === 0 ? 0 : price - disc), 0);
        return total + totalOfUser;
    }, 0);
        
",1524141127.0
RealPatience,"I'd prefer to be explicit, so I'd pick the last option.",1524069826.0
RoHMaX,"Not sure if it's a good practice or not, but you can also set baseUrl and paths in tsconfig.json to have non-relative resolution (like if you were using a lib in node_modules).

In your case, your path would be:
    
    ""baseUrl"": ""."",
    ""paths"": {
         ""modules"" : [""src/modules""]
    }
  
Which then allow you to write:

    import { ModuleB } from ""modules"";

[Documentation for baseUrl](http://www.typescriptlang.org/docs/handbook/module-resolution.html) ",1524072256.0
Fooooozla,Have you seen nestJS? It might be cool to work that into what you have ,1524031492.0
darkdigitaldream,"One technique I used that really helped my integration test coverage was using typeORM's ability to switch backend database drivers depending on the environment variables.

My tests run on a travis\-CI environment which does not include a postgres database. To get around this limitation, I have a switch that causes my application to load a SQLite driver when the NODE\_ENV variable is set to 'TEST'. Since SQLite runs in\-memory, I can not only run end\-to\-end tests from my controller all the way to my data store, I can reset the database in between tests if I like.

You are using knex.js which has a similar driver available for SQLite3. With a bit of config\-level switching, you could set it up. Then your integration tests could really give you complete coverage.",1524017745.0
TjomasDe,Maybe it works great with this docker template for ts in docker: https://github.com/redplant3d/best_typescript_nodejs_docker_container,1524460322.0
darkdigitaldream,"Hey, I did something similar with a slightly modified stack:

[https://github.com/KyleGalvin/backendBoilerplate](https://github.com/KyleGalvin/backendBoilerplate)

Full\-stack framework built on typescript. React/Redux on the frontend, express/typeORM on the backend.

Comparing notes, the first major difference I see is the file layout. This is typically a matter of preference, however I've worked in a lot of shops that more or less standardize to a flat layout. In the ./src folder I see you have entities, managers, and repositories which is very typical.

The part that diverges is your 'server' folder. Inside there, you have divided the code by feature, not function.

Instead, what I've seen is more common is having a ./src/controllers folder, and a ./src/models folder \(etc\)

Anyway, this is my first impression. I might leave another comment when I have a minute to look closer",1524016969.0
,"You can add a cast to assert that the string array you reduce over only contains keys of `IQueryParams`.

    export function convertParamsToQueryString(params: IQueryParams = {}) {
      const keys = Object.keys(params) as (keyof IQueryParams)[];
      return keys.reduce((accumulator, key) => `${accumulator}${key}=${params[key]}&`, """");
    }",1523980146.0
sufianrhazi,"*edited to correct an error, this is what I get for typing on my phone*

The type returned by `Object.keys` will *always* be `string[]`, even if the value passed in is a defined interface. This is because interface types in typescript are structural subtypes:

    interface Foo {
        foo: string;
    }
    
    function check(x: Foo): string {
        return x.foo;
    }
    
    let val = {foo: 'a', bar: 'b'};
    check(val); // Perfectly valid, despite ""bar"" being in val

Your error indicates (rightly) that if someone passes `{ foo: ""val"" }` into your function, the key ""foo"" is not guaranteed to exist in an `IQueryParams` object. This may even be a bug in your code (if you expect the function to return query parameters that adhere to a specific subset of values).

Perhaps you should instead use a whitelist of known potential keys, and iterate through them to build the result string.

Also, unrelated, but you should probably use `encodeURIComponent`.",1523988188.0
cramt,You could change the argument to params:  IQueryParam | any = {},1523979644.0
Gustorn,"We had this exact same problem but with `yarn link` and type definitions. The solution was to add this to the top-level `tsconfig.json`:

    ""paths"": { ""*"": [""node_modules/@types/*"", ""*""] }

Which basically forces TS to prefer the types in the top-level `node_modules` folder instead of the one nested in the linked dependency.",1523971600.0
TotesMessenger,"I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:

- [/r/webdev] [npm link and @types and duplicate deps mess](https://www.reddit.com/r/webdev/comments/8cqior/npm_link_and_types_and_duplicate_deps_mess/)

&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",1523908959.0
android2222,"Are you on windows? I ask because the symbolic links, or lack there of, can be troublesome in windows. I would recommend using Yalc. It has its own ‘link’ functionality, in addition to some other simple functions that I think might get you around that issue. It worked for me when npm and yarn link both failed with similar issues. It works by publishing your packages to a local repo, and you consume from there. 
https://github.com/whitecolor/yalc",1523914348.0
thadudeabides1,"You might be interested in this issue that's been open since 2015: https://github.com/npm/npm/issues/10343

The gist is that `npm i` breaks the symbolic links created by running `npm link <package>`.",1523915959.0
senoroink,My experience with this was to not bother. The extensions aren’t fully fleshed out and it’s less work to just maintain two files.,1523745330.0
josh64,"Have you tried using https://www.npmjs.com/package/tslint-eslint-rules ? I’ve been meaning to do this when I get some time and just use tslint only but with the eslint rules.
",1523757593.0
akitov,"You can use eslint with typescript, https://github.com/eslint/typescript-eslint-parser
Couple of rules doesn't works, but this way you can use same configuration for both ts and js files",1523822259.0
scaleable,"A bit out of topic, but enforcing the use of prettier (format on save) also solves your issues, and you don't even need to bother about linters anymore.",1523831703.0
twomousepads,Have you tried [tslint-config-airbnb](https://www.npmjs.com/package/tslint-config-airbnb)?,1523710457.0
madcaesar,What does **never** mean in ts?,1523469080.0
gigobyte,"I wonder why we can't just use it in the type parameter without using conditionals, something like

`type Foo<T extends {a: infer U, b: infer U}> = U`",1523602588.0
night_of_knee,I'm familiar with conditional types but not with the `infer` keyword. Do you have any reference on what it does? All I could find was [this](https://github.com/Microsoft/TypeScript/issues/21705) but it wasn't very enlightening. ,1523531014.0
colelawr,"I'm using `infer` to create types which translate synchronous functions to returning promises without losing argument types or return type

So `AsyncFn<(a: number) => string> // (arg0: number) => Promise<string>`",1523744463.0
scaleable,"Seems fine.
I'd point you can replace many of the strict options from tsconfig with just ""strict: true"".
In some places you added unnecessary annotations which would have already been inferred (when a type needs an anotation, noImplicitAny will yell at you). Ex:

    ast.traverseByType('number', (node: TreeNode) => {

`TreeNode` is not needed there.",1523418374.0
devrelm,"A few questions:

> I have a native JavaScript library with a .d.ts file

Did you create the JavaScript library, or is it 3rd party? If 3rd party, is it installed through npm/yarn? Did you create the d.ts file?

If the JS library is 3rd party and installed through npm, make sure to check [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/) to see if they have a d.ts file available for it. You can also easily check by just trying to install the types through npm. For an npm library called `some-lib`, you could try to install the types like this:

    > npm install --save-dev @types/some-lib

> I'd like to have my definitions file in one place and my .js file in another place.

Depending on how the d.ts file is formatted, one of these should work:

* Use a `/// <reference path=""./path/to/types.d.ts"" />` [directive](https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html#consuming-dependencies)
* Add the d.ts file's directory path to the [tsc config](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types)'s `typeRoots` option. This requires you to the d.ts file the same as the import (`my-lib.d.ts` for `import CoolThing from 'my-lib'`), and put the d.ts file in a directory with other types.

The TS import statement should always import the `.js` file. The `.d.ts` file is just a helper and can't be resolved to actual runnable code. So, if you have the following code layout:

    - index.ts
    - lib/
    -- my-lib.js
    - types/
    -- my-lib.d.ts

Then in `index.ts` you have to have this:

    import CoolThing from './lib/my-lib'

rather than

    import CoolThing from './types/my-lib'

And if the thing you're importing is an npm module, then just use an absolute import:

    import CoolThing from 'my-lib'",1523381512.0
ghostbyte,Thank for sharing. I already wanted the authors new book and didn't realize it was him till the end.,1523384611.0
verticalellipsis,Would the type `keyof typeof classes` work for you?,1523343734.0
demoran,"I was playing around with this tonight and it looks like I got something working.

    const classes = {
      Add: 'pr-add' as 'pr-add',
      Edit: 'pr-edit' as 'pr-edit',
      Delete: 'pr-delete' as 'pr-delete',
    };
    type actual = typeof classes[keyof typeof classes]
    const x: actual = 'abc';

So the key here is to explicitly cast your values as their own string literals, rather than as general strings.  This constrains them and allows them to be used in type checks.",1523850702.0
spacejack2114,"This is great! I also came across [StackBlitz](https://stackblitz.com/) which is awesome for larger projects and the ability to import modules, but I like yours a lot for quick code snippets. Much better than the TS Playground. I'm also not sure that StackBlitz gives you all the compiler flags.

One suggestion: might be nice to include the compiler settings in the URL?
",1523325799.0
Jazcash,"Thank god, the old one launching a separate tab every time was annoying",1523360388.0
lukeautry,Just thought the amount of generated code here was comical: https://imgur.com/a/H67bx,1523497134.0
synalx,"I love it. Can I make a feature request?

One thing I really wish the playground did was allow me to see the .d.ts produced for a given code example.",1523979724.0
Glinkis2,"Nice, this is something I've wanted for some time.",1524486843.0
cancerberosgx,"If you want to play against TypeScript Compiler API (normal users won't do this), StackBlitz and cia won't work. I'm building a playground just for that and filling it with examples: [https://typescript-api-playground.glitch.me/](https://typescript-api-playground.glitch.me/)

And the same as previous, but runs 100&#37; in the browser: [https://cancerberosgx.github.io/typescript-in-the-browser/typescript-compiler/](https://cancerberosgx.github.io/typescript-in-the-browser/typescript-compiler/) 

And , just in case, trying to build a TS project editor (based on monaco-editor) : [https://cancerberosgx.github.io/typescript-in-the-browser/candombed/](https://cancerberosgx.github.io/typescript-in-the-browser/candombed/)  \- but in this last one you won't be able to write TypeScript Compiler API code - just a normal user experience 100&#37; client side 

This is WIP I'm planning to add more features - but in general is a research project to see how well TS behaves in other platforms than node.js. Tell me whet you think",1531591339.0
cutmore_a,Really like this. Especially how it defaults to strict mode.,1538080462.0
Auronon,I was liking it until OP got the descriptions of the strict flags dangerously wrong.  Couldn't finish it after that.,1523325454.0
android2222,Yeah IDK I think I actually hate this idea,1522981718.0
spacejack2114,I want to install this and prettier at the same time and watch them fight.,1522975343.0
kingdaro,"You're not alone. In regards to Redux and TS, I feel the boilerplate is a bit much as well, which is why I opt for [MobX](https://mobx.js.org/) in personal projects instead, which works excellently with TS.

However, I'll add that the extra boilerplate is probably not as bothersome (and even beneficial) when working on a large project in a team. That's where both TS and Redux shine best, after all. But yeah, definitely overkill for just one person hacking together an app slightly bigger than a todo list.",1522958364.0
shorns_username,"Redux is confusing you.
Get rid of it for the moment: focus on learning Typescript and React.
",1523003372.0
scaleable,"Why can't we just declare all the actions as big type union, instead of rewriting the action name 3 or more times in different variations (UPPER_CASE, camelCase and camelCaseCreator)? Sometimes it feels like these ""evangelists"" are constantly fighting to achieve new levels of verbosity.

    export type ActionTypes = 
      | { 
          type: 'ACTION_ONE'
          name: string
      }
      | {
          type: 'ACTION_TWO'
          count: number
      }",1523012380.0
alsiola,"There is no getting away from the fact that properly typed redux is super verbose. You can make some helpful generic types that reduce it a little, but it will still feel boilerplatey.  There are some nice benefits though - the biggest for me being properly typed actions within different switch branches in a reducer.

I outlined my approach to typing with redux here: https://stackoverflow.com/questions/47640189/how-to-maintain-action-creator-types-in-connected-components-with-redux-react-a/47643972#47643972",1522961608.0
paulkoer,"I think it's a very common problem. Redux is quite hard to use in a type safe way. I have my own take in how to tackle this with https://github.com/paulkoerbitz/typeful-redux . It gives you a fully typesafe and low boilerplate way of using redux. However it is also pretty opinionated and doesn't work with the various side effect managing tools (thinks, sagas, observables, ...), This is currently in the works.",1523101746.0
lapanti,"Check out redux-guards: https://www.npmjs.com/package/redux-guards

That should help alleviate the boilerplate a lot :) And also my boilerplate which already includes it: http://ts-react-boilerplate.js.org/",1522992669.0
GoliathMcDoogle,"I've been enjoying redoodle from palantir for redux everything, definitely cuts down on boilerplate. https://github.com/palantir/redoodle",1523162018.0
QW4K,I created similar tool some time ago: https://github.com/krzkaczor/tadd Kudos anyway! :) ,1522869255.0
blaster151,I will try this - looks cool.  Thank you!,1522877540.0
pobbly,"Use webpack with a typescript loader, rather than tsc directly.",1522863343.0
evmar,"Your index.d.ts does not define ErrorRequestHandler so it is assumed to be `any` by the TypeScript tooling.  It also sounds like you might have some type checks turned off, perhaps in d.ts files.",1522831092.0
scaleable,"my 2 cents. Inference quirk:

 - since `b` is a mutable field, the ""A"" assignment is inferred as `string`

 - the assignment would only be assigned as ""A"" type if the field was immutable (like a const variable)

 - if you add the ""readonly"" keyword the error vanishes since now ""A"" is inferred as ""A"" instead of as ""string""",1522774770.0
revlayle,"Also, a class must provide an implementation of an interface.  This is not the same thing as extending a class.  If 'Bar' was a class, then if 'Foo' *extended* it, I would expect you to not have to re-annotate 'b'.

When you implement an interface, you still have to construct your class members as normal.  All implementing the interface probably tells the compiler is that your class must satisfy the interface contract. However, the compiler will NOT assume just because you are to implement an interface that it will inherit those members (if you want inheritance, make a base class and extend it instead of using an interface).

example on WHY you need to, well, when implementing several interfaces in one class:

    interface x {
        b: string;
    }
    
    interface y {
        b: number;
    }
    
    class z implements x, y {
        b: string & number;
    }

Class z need to have specific declarations so the compiler knows if it is satisfying the interface contract of BOTH x and y.",1522867969.0
Madd0g,"Not really important or urgent, just curious...? If it's not determined by my computer setting, where could a difference like that be coming from?",1522741814.0
tehnologie,"The library is written by the same guys who wrote the manual on [Functional Reactive Programming](https://www.manning.com/books/functional-reactive-programming?a_aid=playscala).

The author has stated that, had he written the book today, he'd have done it with TypeScript examples (instead of Java).",1522682996.0
Auxx,How does it compare to RxJS?,1522778645.0
AngularBeginner,"All tested with C# code generation.

- Does not support conditional types at all.
- Does not support number literal types at all.
- Does not support tuple types at all.
- Does not properly support indexer types with known properties.
- Does not properly support types with methods (they should be stripped).
- Does not support `readonly` properties.
- Does not support generics.
- Does not support read-only target types.
- Does not support choosing the appropriate type for `number` (a dictionary key of `double` is a **really** bad idea).
- Produced code will fail when one of the keys is set to `undefined`.
- Using a `struct` to hold all possible types of a union type is pretty wasteful.
- The code contains mutable structs.
- The code contains structs that don't override `Equals` or `GetHashCode`.
- The code uses enums for string literal types.
- The code creates a dedicated enum for every literal types.
- As a result does not support discriminated unions.
- Does poorly support union types, all properties across the union types are marked as optional in a new type.",1522687703.0
markprobst,"quicktype can now convert your TypeScript types to any of its supported target languages.  Of course you can still use it to infer your JSON types as well, or give it JSON Schema as input.  Under the hood, in fact, it uses [typescript-json-schema](https://github.com/YousefED/typescript-json-schema) to convert the TypeScript types to JSON Schema, which it then converts to your chosen target language.

Let us know what you think!",1522681039.0
,[deleted],1522697884.0
AngularBeginner,"Turning `strictNullChecks` off should be an absolutely no-go in modern code bases. And dude, that profile picture...

Most of us are using TypeScript for the type-safety it brings. Turning type-safety features off is contra-productive to that goal. Especially for such great features such as `strictNullChecks` (which I consider one of the greatest improvements to TypeScript).",1522611169.0
scaleable,Now those are a lot of buzzwords in just one small title,1522737536.0
ResponsibleLife,"While not interactive I’ve had good experience while doing this one.
https://typescriptcourses.com/typescript-fundamentals",1522531553.0
pagalvin,"I wrote a book on this with a dozen or so associated videos that might be worth your time. It's not an interactive class though. 

https://pagalvin.gitbooks.io/yet-another-typescript-book/content/
",1522538223.0
Fullstack_Questions,"So you used a preset for your linter, and complain that one of the preset settings changed your code? :) How about adding rules and disabling that one, or writing your own rules?

Linters and Formatters are great. No reason not to use them. ",1522521781.0
darkdigitaldream,"Correct me if I'm wrong (you may have configured your linter differently) but linters don't change your code; you do.

The linter simply points you to your own code smell.

In this case, it seems the regression came from your failure to understand the map function call parameters as well as your own overloaded method name.

In this case, I would reconsider whether overloading a function called array in a way that isnt synonymous with the language itself (map being a well-defined feature) is really smart or necessary.

After weighing the pros and cons of changing array, I would then either change it, or remove the linter rule from my project.

The linter is just a code secretary. You make the final call. Be the boss of your own code!

edit: a word",1522522705.0
dhruvrajvanshi,"Here's a simple example where autofix makes things worse

    const a1 = 1;
    const a2 = 2;
    ...
    callWithA1(a2);

Now, your linter will complain about unused a1. Which actually indicates that you probably meant to use it somewhere. If you autofix, it will simply remove it.

Don't use linter autofix. Every lint error might be a sympomatic of a a bigger problem and autofix won't be the right solution for many of those problems.

Edit:
I read your post and I've had the exact same issue. Fortunately, in my case, the type checker detected the error.",1522572251.0
demoran,"When I saw your description of this issue I thought Typescript was selecting the incorrect function signature.

However, the signature of map takes a function with a third parameter, and I believe that is what is causing your two parameter method to not be selected.

> map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];

I could be wrong though.  Maybe you've just fallen into the ""[first matching overload](http://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)"" trap:

> Don’t put more general overloads before more specific overloads:
    
    /* WRONG */
    declare function fn(x: any): any;
    declare function fn(x: HTMLElement): number;
    declare function fn(x: HTMLDivElement): string;
    
    var myElem: HTMLDivElement;
    var x = fn(myElem); // x: any, wat?
> Do sort overloads by putting the more general signatures after more specific signatures:
    
    /* OK */
    declare function fn(x: HTMLDivElement): string;
    declare function fn(x: HTMLElement): number;
    declare function fn(x: any): any;
    
    var myElem: HTMLDivElement;
    var x = fn(myElem); // x: string, :)
> Why: TypeScript chooses the first matching overload when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.
",1522585932.0
nocoolnametom,"Seems to me the linters uncovered a case where you were using a non-mapping function as a mapper because they have a similar enough signature for JavaScript that it wouldn't have usually mattered. Instead of instantiating an anonymous function every time the `map` call is executed, why not  create a mapping wrapper for the non-mapping function and use it as the linter suggests? Or just turn off the linting rule in question, a process easily done by line, by file, or even for the whole project?",1522522748.0
voidvector,"Optional argument is not a good practice in JavaScript/TypeScript. Since there's no language level support for it, it means every time it's used, 

* it forces you to have a code in your function accommodate it (extra `if` statement, ternary, or null check)
* harder to extend (add arguments, remove arguments)
* forces compiler to do more work in generating virtual functions with different signatures
* potentially hiding assumption from the user

Just split it up with different names: 

    array<T>(generator: Arbitrary<T>)
    arrayWithMax<T>(generator: Arbitrary<T>, max: number)
",1522533564.0
ndubien,"Following the useful comments provided by some of you, I updated the content of the article in order to be clearer about the ""problem"" and the possible ways to mitigate or fix it",1522540689.0
Gustorn,"`someClass` should be `SomeClass`. Other than that this works fine:

    interface ISomething { }
    interface IAnything {
        value: number;
    }

    interface IConstructor {
        new(someArg: ISomething): IAnything;
    }

    class SomeClass {
        value: number;
        constructor(public readonly someArg: ISomething) { }
    }

    const foo = <T extends IConstructor>(constructor: T) => {
    }

    foo(SomeClass);",1522509429.0
geon,"You are not supposed to have a return type on your constructor, are you? And I don't think you should call it without `new`.

Just because it's possible in js, with the prototype system, it's not necessarily a good idea if you use the `class` keyword.",1522453735.0
AngularBeginner,What I miss in every Angular tutorial is how to use Angular with `strictNullChecks` enabled.,1522667159.0
AngularBeginner,Found absolutely no documentation.,1522420110.0
demoran,"When I first came to javascript land from .net land, I was looking for something to replace linq.  Lodash is the defacto standard for that.

What does this project bring to the table that lodash doesn't?",1522429770.0
JustDoItArt,You are probably seeing some async behavior of console.log. Try getting string first then call log. ,1522383243.0
ritajalilip,"""Value below was evaluated just now."" means just that, that the object you're logging is updated in real time.

If you want to log the object in a point in time, you can `JSON.parse(JSON.stringify(theObject))`.

The same method can be used to copy an object.
",1522391882.0
Drake250,"You can simply do:

```
art.unshift(art.pop()!);
```

Which means you are telling TS that you are **certain** that the return value will not be undefined, thus it is always a string.

However throwing around `!` can be dangerous, so only do it if you are sure there is no way to re-write your code where TS can naturally type-check without you having to override it.

Also, `count` is never re-assigned so make it `const`.",1522363988.0
,[deleted],1522428927.0
jhand93,Nice! Might use this for a library!,1522342203.0
anotherdonald,"Funny, but I get an empty page and the browser runs like crazy.

Also: ""added 144 packages"". Heavy.",1522838549.0
Rollingdownhills,What are the public properties and methods of Something and Bar? If they are the same or if Something is a subset of Bar this is the intended behaviour.,1522335360.0
HeinousTugboat,"TypeScript is duck-typed, which means if it looks like a duck, it sounds like a duck, TypeScript will treat it like it's a duck, even if it's a goose. [Discriminated types](http://www.typescriptlang.org/docs/handbook/advanced-types.html) are good for exactly this, though. You can add a string as a static member of the *type* that won't show up in the compiled code, but will allow you to discriminate between ducks and geese more reliably.",1522339278.0
HeinousTugboat,"Huh. [Fun fact, the latest version of TypeScript solves your problem](https://blogs.msdn.microsoft.com/typescript/2018/03/27/announcing-typescript-2-8/#conditional-types). They've added an `Exclude` built-in type using the new conditional type mechanics.",1522471165.0
,[deleted],1522278450.0
PhysicalRedHead,"Your interface syntax is wrong.

    interface Identity {
        value?: any,
        map: (f: Function) => Identity,
        chain?: (f: Function) => any
    }",1522282156.0
icholy,"Like this 

    const Identity = <T>(value: T) => ({
      value: value,
      map: <U>(f: (value: T) => U) => Identity(f(value)),
      chain: <U>(f: (value: T) => U) => f(value)
    })
",1522949279.0
aleix_mp,"could you do a pastebin instead, please? :) ",1522282452.0
schwede,So what would you use this type for?,1522300348.0
sam_b_ran,"Here's a more robust implementation: 
https://github.com/tycho01/typical/blob/master/src/object.ts#L242",1522352154.0
ForAllThat,Do people still use yeoman nowadays? I feel like most people are simply cloning their favorite bootstrap project or are using create-react-app or similar.. just wondering,1522255064.0
johnfn,"My personal feeling about getters and setters is that they make code harder to read because they look exactly like normal properly access but do something more complicated. Code is hard to read when you expect it to do one thing but it does another. 

I would just use a method instead. ",1522257333.0
,[deleted],1522254739.0
SeanMiddleditch,"Just to start with the biggest items: using a getter/setter function breaks core JavaScript/TypeScript language features, like object property enumeration or destructuring, as well as various higher-order functional programming patterns. Using properties where possible makes your code work with the rest of the language better.

More abstractly around the topic of getters and setters, note that it's common for developers to have a strong expectation when seeing `setFoo(x)` or `getFoo()` that these are _cheap_ and _efficient_ functions. If they're doing anything else, a good style guide would recommend that they be named appropriate to strongly indicate what they're going to do. Treat functions as verbs: if the function doesn't just get a value, it shouldn't be called `get`.

In a language without properties, one could argue that a getter function signifies that there _might_ be bad code involved. It's a hint of potential dragons. That's just not true in JS/TS though because property getters are a thing; there simply is no strong guarantee that any `x.foo` isn't evil, so we have to check (or trust our libraries) rather than relying on syntactic warning signs.

Getter functions are sometimes just used for consistency in some languages. There's no easy standard way to have a read-only public field on a non-const object in C++ for example, so maintaining proper encapsulation around a field that has value constraints requires using a getter function around a private variable (with no corresponding ""dumb"" setter). And once you have getter functions for some fields it just looks weird to have other fields be public. This again isn't a problem for TypeScript, because it _does_ have read-only public fields.

The final argument for getters/setters in a language like C++ is that there _might_ someday be a change required to a setter to enforce a constraint, but it would be a source-breaking change to make a public field become private, so the code might as well just use getters/setters from the start for ""forward compatibility."" This again isn't a problem for JS/TS because property setters exist, so you can evolve code and strengthen constraint checking without source breaking changes even without setter functions.",1522305725.0
cspotcode,"They can't do method overriding with `super` calls in subclasses.  However, you can achieve the same by writing a getter / setter property that internally delegates to protected _getFoo / _setFoo methods, and then you can override those methods in subclasses.",1522257099.0
LowB0b,"Getters and setters come from OOP (Java, C#) where one of the basic rules is that you never ever make a property public. Hence public get and set methods. If you want to go hardcore OOP then you should enforce getters and setters, otherwise, do as you wish.

I personally have probably never put any logic in get / set methods, so to me it's idiomatic more than anything else",1522270795.0
e_man604,"Do you think getters and setters in, for instance, c# is an antipattern?",1522256030.0
hello_from_denmark,Personally I think getters and setters can be useful. But they should be used for stuff like library developers. Like having a game library where there is a object pool in the background when you allocate stuff. Etc. Otherwise its not so smart to hide stuff imo.,1522308302.0
Bamboo_the_plant,"Until TypeScript supports private set, public get on class fields (which the core team have been resistant about, because it doesn't mirror any JS phenomenon), there's no alternative for restricting read/write access to fields, unfortunately.

However, using them impedes refactoring (this is a real headache when using builder pattern), increases code size and – more than anything – increases the developer's keystrokes.

At best, they're necessary for builder pattern.",1522328008.0
autoferrit,"I sort of agree with the anipattern crowd. But one place I've seen them be helpful is when you need to validate the assignment. Make sure it's the right kind of value etc. Granted this is probably done like that more so in non strongly typed languages. But one of the things I like a bout properties in python is that you can make the access of the property through getters and setters totally transparent. They use it exactly like a property but it still gets validated by the getters/setters. 

That being said in recent times, especially after learning more about functional languages, no side effects, and even reading the clean code series, I think they make code not as clean some times. My only requirement for getters and setters would to have little to no side effects.",1522336874.0
phoenixmatrix,"Getters and setters have never really caught on as an idiomatic part of JS. For the longest time, we couldn't use them because of browser support (until we could drop IE8!).  That was just a few years ago.

Now we can, but they break the principle of least surprise. You look at a property and set it, and all of a sudden it could be making an http request (?!). The various development tools also generally consider it safe to read a property, so if it does anything non-trivial, the very act of debugging your code could change its behavior.

Because of this, languages where getters/setters are idiomatic (like C#) generally suggest you only use them to control access to backing stores, potentially with simple, fast and side-effect-free transformations. Basically an abstraction in front of backing data.

Now, that makes a lot more sense in a world where private fields are a common thing. In JS everything would be public and attached to the object unless you use a closure to wrap it or use symbols or something (until private fields become a thing. TS has compile type privates, but that has limitations). 

Finally, there's the issue of tooling. I mentioned how some debugger behave, but there's a bit more to it. In some languages (I think its true of C# + Visual Studio, or at least Resharper), its possible to make getters/setters a different color so it's obvious what they are. You can ctrl+click to go to their implementation. You can do static analysis to make sure private fields are NEVER exposed (a common practice). So you can assume ANY field access is going through a getter/setter.

In JS, we have none of that. That makes things very confusing.

For all those reasons and more, I personally only use getters/setters for framework-y things. Think how Chai's fluent assertions work (but even that is kind of a bad example, and many people prefer using function calls instead)",1522342855.0
HeinousTugboat,"I'm still pretty new to all this, so take this with a grain of salt, but I *believe* the issue is that TS is actually structurally typed, not nominally typed. So in your example, both are technically type A because they both have members `a` and `b`. 

Unfortunately, I can't find any good way of forcing a type to *not* have a property. [Here's](https://stackoverflow.com/questions/48215950/exclude-property-from-type?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa) one example, but I couldn't get it to work quite how you want it to.",1522243510.0
GFandango,"In both cases you are returning something that satisfies ""A"".

or ""the type is assignable to A"".

The fact that it has an extra""c: number"" doesn't make it incompatible.",1522248667.0
,"The issue is that excess properties are allowed in assignability. TypeScript will do excess property checking at initialisation:

    interface A { a: string; b: string }
    interface B { c: number; d: number }
    
    function f(a: number): A & B | A  {
        if (a) {
            const res: A & B = { a: 'asd', b: 'zxc', c: 2, d: 4 };
            return res;
        }
        else {
            const res: A = { a: 'qwe', b: 'zxc', c: 3 }; // error
            return res;
        }
    }",1522330189.0
hicksyfern,"In both cases your return value implements interface A, it looks like.",1522244032.0
johnfn,"Probably not what you want, but you can use a tagged union. You'd have to add an additional discriminator property, but you get the desired behavior. ",1522257606.0
daekano,"From the readme:


    let r1 = run(computation1());
    let r2 = run(computation2(r1));
    let r3 = run(computation3(r1, r2))
    
    Any failure in an intermediate step should short circuit the whole thing.

I'm really looking forward to the day that a type-safe [pipe operator](https://github.com/tc39/proposal-pipeline-operator) and [pattern matching](https://github.com/tc39/proposal-pattern-matching) become available in JavaScript.

I quite enjoy [handling errors in Elixir](https://medium.com/elixirlabs/railway-oriented-programming-in-elixir-with-pattern-matching-on-function-level-and-pipelining-e53972cede98), and think augmenting it with all the goodness TypeScript offers would be a boon to the developer experience.",1522249295.0
AngularBeginner,This is exactly what I wanted to write tonight.,1522255757.0
,"Is it possible to use a cache of proxy objects so that if `t === t1`, then `Optional.of(t) === Optional.of(t1)`?",1522313315.0
,[deleted],1522193874.0
rco8786,"The linked code contains no static or private methods. That said, the answer here is “you can’t”. Static methods exist at the class level, your private methods are on the instantiated objects of a class (unless it’s a private static, which I can’t remember offhand if TS supports) 

The transpiled js works because it’s js and there is no types to offer that sort of protection.",1522208779.0
Bamboo_the_plant,"/u/DanielRosenwasser How's the [""Investigate error messages in haiku or iambic pentameter""](https://www.reddit.com/r/typescript/comments/87hg3f/investigate_error_messages_in_haiku_or_iambic/) feature coming along?",1522172535.0
,"I think the explanation of Conditional Types should also mention that they are strict, or short-circuting on `never`. You can use the same non-distribution trick to get `never` to behave like any other type.

    type Foo<T> = T extends true ? 1 : 0;
    type A = Foo<never>; // A = never;

    type Bar<T> = [T] extends [true] ? 1 : 0;
    type B = Bar<never>; // A = 1;

This does follow from the description of distribution and viewing `never` as the empty union, but I'm not sure if that is immediately obvious.",1522183458.0
reiv,"Conditional types look to be really powerful feature, making it possible to write complex recursive types such as [`DeepReadonly<T>`](https://github.com/Microsoft/TypeScript/issues/13923) and the like. Really excited to see what else might come of it.

Why the need for an explicit `infer` keyword though -- is there ever a situation where inferring a type var by default would be undesirable?

Edit: I think I get it now. In the context of

`type Flatten<T> = T extends Array<infer U> ? U : T;`

`U` acts a ""free"" variable in the sense that it's not bound by the definition of `Flatten<T, ...>`, but adding the `infer` allows the typechecker to make sense of it anyway.",1522172648.0
,[deleted],1522306008.0
shuffle_kerfuffle,"How can I make use of the organize imports functionality? In VSCode I've set it to use the workspace version of TS at 2.8.1, but I don't get the ""Typescript: Organize Imports"" option like is shown in the gif.",1522733357.0
Rollingdownhills,If you don't export Configuration it is impossible for other code to import it and use it in their type hinting.,1522159120.0
Auxx,"A couple of notes about your code:

1. Convert Configuration from type to interface.
2. Default exports are a bad practice in TS.",1522181826.0
immutablehash,"Something like this?

    enum Foo { A = ""AAA"", B = ""BBB"" }
    
    function reverseLookup<T>(enumType: T, value: string): T[keyof T] | undefined {
        for (const key in enumType) {
            if (Object.hasOwnProperty.call(enumType, key) && enumType[key] as any === value) {
                return enumType[key];
            }
        }
        return undefined;
    }
    
    console.log(reverseLookup(Foo, ""AAA"")); // === Foo.A
    console.log(reverseLookup(Foo, ""NOPE"")); // === undefined
",1522160304.0
Bamboo_the_plant,"[Context on Twitter](https://twitter.com/kitsonk/status/973651805950242816). Added by Daniel Rosenwasser.

Screenshot for posterity: https://i.imgur.com/AN06Gqv.png",1522148021.0
madcaesar,I don't understand :(,1522143261.0
delphi_edict,Always. They always help. YW,1522075555.0
cr125rider,Try debugging a loosely typed language and you will love types. That or jumping into an unfamiliar codebase. ,1522101272.0
,How long did this take you?,1522054651.0
jineshshah36,It doesn’t.,1522016135.0
madcaesar,This post is doing your username proud.,1522021881.0
dcbroad3,Amazing. Every word you just said was wrong.,1522022726.0
Furryamigo,"You don’t need a semi-colon at the end of every line. In the end, typescript compiles down to javascript, so you only need semi-colons in the same cases that javascript requires them. I think most people just choose use semi-colons because many other type-safe languages like java use them, and is better than forgetting a semi-colon in one of the cases where it is needed.",1522016307.0
unshipped-outfit,Plenty of moden languages still use semicolons. So not a single statement you made is correct. ,1522018062.0
synalx,"As others have mentioned, they're actually not required in either JS or TS.

You should use explicit semicolons in Javascript, because the language is actually ambiguous without them. Javascript expects most statements to end in semicolons, and implements a rule called Automatic Semicolon Insertion to effectively guess where you meant to put semicolons when they're not present. Typescript by necessity applies the same rules, since it must accept mostly arbitrary JS code. This means that the semantics of statements can change depending on whether a line ends in a semicolon or not.

Personally, I prefer to avoid the uncertainty and just be explicit. A quick lint check ensures I don't miss any semicolons.
",1522022533.0
Philippus,This guy must have barely learned python and now thinks every language is like it.,1522035015.0
android2222,C# is an example of a very powerful modern programming language that uses a semicolon to denote line end. This is a silly statement to make. ,1522031702.0
User31441,"Every JS code is also valid Typescript. It doesn't require a semicolon.

It is possible, though, that you use a linter without knowing about it. A linter helps with enforcing a uniform coding style throughout a project. Because most people prefer to end their lines with a semicolon this behaviour is the default one for most Typescript linters.",1522024929.0
phoenixmatrix,"As mentioned, semi-colons are (mostly) optional.

However, if you're wondering why some people favor semi-colons over not, you can [read and learn](https://github.com/tc39/ecma262/pull/1062)

(also, when using Prettier to format your code, as you should, you'll never have to type them anyway, so it's no big deal)",1522092399.0
Dandamis,Haha thanks for the laugh,1522273819.0
bikasv,"Clearly a question from a person who never written a code in his life.


; is eol and used by almost all credible language.

But no, he want to leave dangling line ending so that each to compiler imterpret on their own and expected output is atthe mercy of compiler.",1522027638.0
know_not_much,"I found the answer. Surprisingly most of the answers given below are wrong.  The real reason is mentioned in the wikipedia page

https://en.wikipedia.org/wiki/TypeScript

"" It is a strict syntactical superset of JavaScript""

So in order to ensure the superset they copied the same "";"" rules from javascript.

Now to those who are saying ""you don't have to use ;s in JS or in TS mandatorily"" look how you teach TS to new comers like me


https://courses.edx.org/courses/course-v1:Microsoft+DEV273x+1T2018/courseware/dbe869f1929d4e46b3b03e60361b9a24/7bd970182db141d696a7d372da31732d/?child=first

    elementSets.map( (elem, index) => {
        let colorChangeClass = new colorChange(elem.div);
        (elem.div as HTMLElement).style.width = squareSize;
        (elem.div as HTMLElement).style.height = squareSize;
        elem.button.textContent = ""Change Color"";
    })

The tutorial uses ; at every line. So what I learn is to write code like above. This is same problem with JavaScript as well. Every tutorial/book or blog I read has semi colon on every line and yet the theoretical guys will keep saying that ""you don't have to use"" ; at every line.
",1522023985.0
cr125rider,Updated to v0.0.1-beta.1? Where did you start!?,1521752625.0
AngularBeginner,"Unfortunately the TypeScript support is not very good. The `args` you get when implementing the functionality of your command is of type `any`. Same with `flags`, where every property is of type `any`.",1521812595.0
,[deleted],1521628191.0
lukeautry,"I disagree that TypeScript *necessarily* slows development time, but I will say that it *can* slow development, and I've seen the scenarios where it does and I think I understand where things go wrong.

Without going into greater detail, I think to get the maximum productivity boost that TypeScript brings, you need to think about types first. I often write out interfaces that define inputs/outputs before ever writing any runtime code. By the time I get these data structure definitions in place, it's a lot faster and easier to write code that works the first time it runs.

Where TypeScript doesn't excel is when developers view it as Babel + Static Typing, i.e. an arbitrarily complex JS processor.  ",1521507088.0
,[deleted],1521524494.0
baseonmars,"Thanks for the tips. Nice article.

We’re just starting to use it on a project and I’ve been bitten by out of date types from Definitely Typed once or twice or libraries that just have faulty types internally. 

It’s easy to fall into assuming the type checker is always right and you’re wrong.

",1521833665.0
kurashu89,I'm still very deeply confused about this whole conditional type thing. ,1521475099.0
EvilFe,"You can use [generic classes](http://www.typescriptlang.org/docs/handbook/generics.html#generic-classes) and do something like:  
`class QueryBuilder<T> { insert(data: T): string { ... } }`
`class User extends QueryBuilder<IUser> { }`",1521382197.0
realm_01,Why do people downvote this post? Is the information not correct/good enough?,1521399653.0
cspotcode,"Generics are used for Arrays, Maps, and Sets.  An array is not merely an array; it's an array of `T` where `T` is the type of the items in the array.  The array has a pop method that returns a `T | undefined`.  It has a push method whose arguments are all of type`T`.  Other things like the map and forEach methods all have the type T somewhere in their interfaces.

Without generics, all arrays would be arrays of `any` which is not very helpful.",1521382286.0
erickwendel,"An example here, to code reusability

https://hackernoon.com/generic-repository-with-typescript-and-node-js-731c10a1b98e",1521574726.0
,"Here's a real world example. I just wrote this piece of a code a little while ago. It's for Java (more specifically JavaFX) but the idea transfers over to TypeScript. 

In JavaFX you have these fxml files. They're xml files that contain a layout for a given view. You can think of them like HTML. Each view has a controller class related to it. The controller handles the logic of the view.

What my method does is update the view, then resize and update the title of the window containing the view, then finally returns the controller for the view. The problem however is that the controller can be any type and I want this method to be generic so that it will work any of my views (so it has to be able to return any type of controller). How can I do this? I can do it by making the return type generic. 

    private <T> T updateStage(String fxml, String title, int width, int height) throws IOException {
        FXMLLoader loader = new FXMLLoader(getClass().getResource(fxml));
        Parent root = loader.load();
        primaryStage.setScene(new Scene(root, width, height));
        setStageTitle(title);
        return loader.getController();
    }",1521382974.0
mcb2001,"Anywhere you want a method or data structure to handle a broader than single different amount of types. But still be able to give garanties on run time, you should use a generic.
Examples include:

 * Array, Set, Dictionary and other collections.

 * Methods handling external events, like getting data from an API.
 
If you go into other languages, you can also add clauses to generics, like c# where you can force generics that implements an interfaces, that are common for all types the method could expect to receive.
This could allow you to write a full CRUD enabled REST API for all your classes, if you just ensure your classes all have the same interface defining a key called Id.",1521401279.0
empty_other,"All of this code is used in a real world application. I promise.

ELI5 for kids who understand basic typescript: You should avoid the `any` type in typescript. It is only to be used when converting old code. Generics can save you from having to use the `any` type.

One of the most common things in javascript is doing **web requests**. Lets say you do a http request to a server. The server might always return a response that wrap the results in extra response data, how many hits there was, and such... It might fit this interface:

    interface ResponseObject {
        success: boolean;
        count: number;
        errors: string[];
        data: any;  // Not type-safe.
    }

To stay type-safe I could write one interface per return type that might be returned:

    /** What my ""/api/GetLastLogin/"" endpoint returns */
    interface ResponseLastLogin {
        [...]
        data: Date;
    }
    // And one for number, string, and one for array number and string, one for a single user, one for an array of users, ...etc.

Or i could make a single generic:

    interface Response<T> {
        [...]
        data: T;
    }
    doWebRequest(url, (result: Response<number>) => {
        // I've just told typescript that data should be of type number. 
        // It is safe to use it when adding numbers.
        console.log(result.data + 5); 
    });
 
Or if your webrequest method is async, you could make the entire method generic:

    let result = await doWebRequestAsync<string>(url);
    // The result.data object is now a string. The result object is a Response<string>.
    console.log('My data was ' + result.data);

**Collection of data** (like arrays) _should be generics_ because you don't want to write one StringArray, one NumberArray, etc. Lets say you need to write your own implementation of a collection of items (maybe you miss C#'s List's):

    class MyCustomListImplementation<T> {
        private collection: T[];
        public add(value: T): void {
            this.collection.push(value);
        }
        // ... The constructor and other methods
    }

So if i try to add a string to a `MyCustomListImplementation<number>`, typescript will throw an error. And if i retrieve a value, typescript will know it is a number without me having to tell typescript that it is a number, more than once.",1521403292.0
,"Functions let you write reusable code by having program variables represent some unknown value.

Generics let you write reusable types by having type variables represent some unknown type.

To save yourself writing functions for each specific type of collection: `number[]`, `string[]`, `boolean[]`, you introduce a type variable that let's you abstract over the collection type: `T[]`.",1521409587.0
nicknisi,The type definition for Promise is generic so you can provide typing for what it resolves to. ,1521390946.0
ltray,"I’m not sure this is possible pre-2.8 (which just rc’d!), but with conditional types I imagine you could do something like

    type MappedNonFunctions<T> = { [P in keyof T]: T[P] extends Function ? P : ...whatever mapping involving P... }

On phone so cant know for sure if this is correct, but it’s the basic principal behind the function property name type alias in this PR: https://github.com/Microsoft/TypeScript/pull/21316",1521322987.0
verticalellipsis,"Here's as close as I could get, it uses `infer` from 2.8 to get just the callable interface from the base type. Unfortunately you lose the parameter names in the mapped type, and you need to guess the maximum number of parameters you may ever need (I've guessed 3):

    interface Foo {
      (a1: string): string;
      foo: 'bar';
      biff: number;
    }
    
    // Just the callable interface of the type
    type Callable<F extends Function> =
      F extends (arg0: infer A0) => infer R ? (arg0: A0) => R
      : F extends (arg0: infer A0, arg1: infer A1) => infer R ? (arg0: A0, arg1: A1) => R
      : F extends (arg0: infer A0, arg1: infer A1, arg2: infer A2) => infer R ? (arg0: A0, arg1: A1, arg2: A2) => R
      : never;
    
    type Mapped<T extends Function & {}, U> = Callable<T> & { [P in keyof T]: U };
    
    function test(a: Mapped<Foo, Date>) {
      const t1 = a(""a""); // t1 is string
      const t2 = a.foo; // t2 is Date
      const t3 = a.biff; // t3 is Date
    }
",1521384965.0
cspotcode,This question is unrelated to TypeScript; it's about nodejs.  You should ask GoDaddy if they can host a nodejs server; that will give you an answer.,1521232888.0
recursive,"An `IClient` already *is* an `IClientFoo`. The idiomatic typescript way to do this is to not convert it at all.

    interface IFoo {
    id: number
    value: string
    secretSauce: string
    }

    interface IClientFoo{
    id: number
    value: string
    }

    let foo: IFoo = {
        id: 1,
        value: ""asd"",
        secretSauce: ""zxcv"",
    };

    let clientFoo: IClientFoo = foo;",1521233593.0
spacejack2114,"Not sure if you want to cut down on type def boilerplate or code boilerplate. Anyway, what about:

	interface ClientFoo {
		id: number
		value: string
	}

	interface Foo extends ClientFoo {
		secretSauce: string
	}

	const createClientFoo = (foo: ClientFoo) => ({
		id: foo.id,
		value: foo.value
	})

`createClientFoo` will accept a `ClientFoo` or `Foo` object.",1521242613.0
Arffman,"You don't need to create classes at all. Just create using an object literal.

```
const cf: IClientFoo = { id: 1, value: 'abc' };
```

The `: IClientFoo` part is optional but makes it explicit that you want the variable to conform to that type. Interfaces in TypeScript only enforce the 'shape' of an object, they don't need to be explicitly defined as that type.",1521281893.0
cspotcode,"How about this?  It gets rid of all the repetition.  Public options are exposed in `IClientFoo`, private options are exposed in `IFoo`, and implementation happens in `ClientFoo`.  The constructor's private signature is technically ""public"" but it's been marked `@internal`.  If you use TypeScript's ""declaration"" and ""stripInternal"" options, the internal signature will be omitted from your compiled type declarations, so as far as external code is concerned, the constructor only accepts an `IClientFoo`.

    interface IFoo extends IClientFoo {
      secretSauce: string
    }

    interface IClientFoo {
      id: number;
      value: string;
    }

    interface ClientFoo extends IFoo {}
    class ClientFoo {
      constructor(foo: IFoo) {
        Object.assign(this, foo);
      }
    }
",1521229052.0
thedomham,"Maybe take a look at [this](https://www.typescriptlang.org/docs/handbook/advanced-types.html). You described your problem rather vaguely, so I'm not sure which solution is best for you, but you will find multiple in there. You could use something like the 'pluck' method, where you copy the properties based on the keyof operator.

On the other hand: are you sure you want to copy the data and create a new object? To me this kind of looks like using the client interface to hide the information of the more complex interface may already be the solution that you are looking for. ",1521273198.0
jineshshah36,"TS has a \`Pick\` type for this \(Also, don't use I in front of an interface! It's an anti\-pattern\):

    interface Foo {
      id: number
      value: string
      secretSauce: string
    }
    
    type ClientFoo = Pick<Foo, ""id"" | ""value"">
    
    const foo: Foo = {
      id: 1,
      value: ""hi"",
      secretSauce: ""saucy""
    }
    
    const { secretSauce: _secretSauce, ...restOfFoo } = foo
    
    const clientFoo: ClientFoo = restOfFoo",1522016523.0
jasan-s,">  Because I'm including the generated JavaScript files into my HTML files in an old-fashioned way (simple script tags)

This is not old fashioned, it's how you include JavaScript files even generated ones.

I think we need more details on what you are doing? Why would it have already indexed the TypeScript files? These are not used at runtime.

TypeScript sounds like a good choice for this purpose, I just think your setup is wrong - does sound like you've overcomplicated things.",1521191682.0
Follpvosten,"I would also like to add that the specific error messages i get are things like ""variable type should be the same - should be any, but is string"", and a gigantic amount of ""duplicate function definition"", which is what leads me to think that it checks the JavaScript files like they are separate from the TypeScript ones.",1521195046.0
Follpvosten,"Okay, i have now confirmed that there are no more errors as soon as i close all HTML files - that makes it perfectly usable. Thanks!",1521205734.0
welkie,"I was getting sick of finding a lack of Intellisense in the view layer, unless I was using a beefy IDE like Visual Studio or JetBrains Rider, which give you a good experience with Razor view templates.

I prefer using free, open-source tools, and I knew how to use React, TypeScript, and Node, so I put them together for work flow where you've got Intellisense from Visual Studio Code for your view layer.",1521168310.0
,[deleted],1521183269.0
mendrique2,great soon we can code in types only :),1521224302.0
grauenwolf,"I swear, TypeScript has got to be the most complicated type system in widespread use. ",1521163591.0
,"This is really cool:

    type IdOrName<T extends number | string> = T extends number ? Id : Name;
    declare function createLabel<T extends number | string>(idOrName: T): IdOrName<T>;

but it's abit of a pain to write the function in TypeScript and have it type-check.

It would be great if, when there is a 1-to-1 correspondence between parameter and type-parameter, narrowing would extend from the reference to the type constraint itself. ",1521165100.0
tudor07,Who needs these features ?,1521187082.0
y2bd,"Is `infer` existential types?

Edit: No, not really.",1521168716.0
Sipike,"I like that I will be able to express how an object is created/manipulated like:

interface Asd {
  foo: string;
  bar: string;
}

then I can say:

type AsdWithoutFoo = Extract<Asd, Pick<Asd, 'foo'>>

So its an Asd type but it doesn't contain the 'foo' property.  I think these kind of things help exressing what is happening to an object, or how it is created.",1521224498.0
null-_,"OLD

    declare function createLabel(id: number): Id;
    declare function createLabel(name: string): Name;
NEW

    type IdOrName<T extends number | string> =  T extends number ? Id : Name;
    declare function createLabel<T extends number | string>(idOrName: T): IdOrName<T>;

dude, I'll take the old way any time over this complicated nonsense!",1521285641.0
AlexMattoni,"Does anyone have any example on how to use the new 'Exclude' type? I'm trying to extend `React.InputHTMLAttributes` with my own `onChange` handler and I'm wondering if it will allow me to remove the `onChange` definition from the InputHTMLAttributes. I've tried but I'm not sure the correct usage.

Thanks!",1521327873.0
thepointer,"I'm a huge fan of this release. I've already started using conditional types to remove some hacks that I had previously coded that extracted types from deep in a code-generated interface for a GraphQL response (apollo-codegen). Being able to pluck out a non-nullable flavour of a node is very handy when defining methods that operate on the non-null variant. Conditional types are a very powerful solution to the problem!

I'm also really happy to see the JSX changes. As someone who's tried to write types for non-react JSX libraries, I immediately ran into the problems that are fixed in 2.8.

Amazing work TypeScript team!",1521513377.0
AlexMattoni,"Thanks, that’s what I ended up doing. Originally I threw the omit type into my typings folder, but since I’m making a lib and need the definitions, it was not included in the output giving me errors. I solved it by exporting the type from a .ts file and importing it later, but I wonder if you know a better way? 

Thanks!",1521558077.0
blakflag,"I like to use an electricity analogy. Javascript being exclusively dynamically typed is like a complex machine where wires of all different voltages are unlabeled and every wire can be plugged into every socket.  Typescript adds color coding to the wires (data) and different plug shapes (variables/formal parameters) to all the inputs, so that it is difficult to impossible to plug a high voltage wire into a low voltage input and causing damage to the machine.

In the future, if you want to switch the configuration of the machine (refactor) it is much easier to know what configurations will work and which will cause malfunction, without every turning the machine on and causing a fire.",1521156567.0
kaz3work,"> ts appear to be dynamically typed

While TS *can* be dynamically typed, the intended use is for everything to be statically typed; meaning each variable has a type at compile time and is not inferred at runtime.


Best source for me when learning was the official docs: http://www.typescriptlang.org/docs/home.html",1521148703.0
Dw0,"Js:
const foo = undefined;
foo.bar; // runtime error 'no bar on undefined', your code stops, your site visitor goes annoyed away

Ts:
const foo = undefined;
foo.bar; // compiler warns you that foo has no bar, you fix this your visitor never gets the error. After using your site for some time, they come to a surprising conclusion that this might be the first web site that actually works but then it breaks because compilers get smarter but humans are infinitely creative and the balance is restored. ",1521149945.0
hotrodx,"Let me preface by saying I love TypeScript. As someone with a background on C++ and C#, TypeScript brings a familiar feel to plain Javascript. However, if you're only in Javascript, do you really need TypeScript? I say no.

I've seem some complaints from pure Javascript users from another subreddit about the perceived ""smugness"" of TypeScript users, as if they're pushing TS down their throats. I guess some TS users (like me) just love TS because of previous experience with plain JS. I'm hoping you can appreciate it, too.

However, if you have good memory that you know what parameters you pass to your functions, or if you're the only one modifying your code, or you don't want the compile-step added by TypeScript, then Javascript will be fine.

The value of TypeScript is for us losers who can't remember the parameters needed on each of the function. Is it a number, a string? I already don't know one month later. It's also for losers who band together to code something. Loser B might be changing a function's parameter or an option, and it's required, and I would've never known unless TypeScript complained about the parameter required.  Finally, it's for losers who want to code in C++/Java style ES6 or above classes, and have TypeScript's transpile it down to (pre-)ES5 Javascript code for compatibility with IE that your manager keeps reminding you of. Sure, you can use Babel for that, but that's adding a transpile/compile step to your Javascript to convert to Javascript, so TypeScript's inherent compile step isn't a hassle anymore.",1521167853.0
BrianBoyko,"I've found Maxamillian's coursework on Udemy to be very helpful so far (I'm 1/3rd of a way through it) on understanding the value of Typescript.  

Now there are two things to ask: What is the value of static types in Javascript? and What is the value of Typescript?  These are two different things - FlowType, for example, provides type checking but little else.  

So, what is the value of static types? It allows you to more clearly see when you could pass in a value that *would have* caused an error at runtime.  If it's possible for a value to be undefined, but you try to access a property on it - you will get notified that that is a possibility *while you write the code* rather than having to discover this scenario yourself.  If you need to do math on a variable but you actually use the string version of it (""2"" + ""2"" => ""22"") Typescript will tell you. 

This is especially helpful when working with a team to develop software because *even if you didn't read the source code someone else wrote*, you can get warned if you're passing in an incorrectly formatted input or getting back and incorrectly formatted output.  

Now, Typescript (unlike Flow) takes this further by adding in protections that are standard in Java and C# that are not standard in Javascript.  It doesn't require, but *strongly encourages* the use of an object-oriented structure for your program - where each part of your program stands alone and simply interfaces with the others.  It provides ways to ensure properties on an object are read-only, for example.  The result is that if your team works in Typescript, it is a lot easier to manage the code and prevent each other from ""stepping on each other's toes.""  ",1522422572.0
Dandamis,"Lissen dude. Here is the deal. 

TypeScript is like a framework for javascript. It helps you in many many ways. The last thing being 'type safety'. It helps your IDE so your code makes sense the moment you write it. There is no other real reason to use typescript. Sure it prevents you from feeling stupid.

But yea your IDE needs a lil help, flow or typescript. I like typescript because im from a c# background so its comfortable.

With that being said, if you are going the front-end framework route such as Vue... TypeScript will be more of a hinderance than a benefit.

Either way.. if you would be a good programmer  you'd have no need for typesafety. With a full set of well defined unit-tests you get the same result. So you can also look at it like that: type safety are mini unit tests.

Have fun!",1521156309.0
recursive,"If you have a tsconfig file, all the ts files will be compiled by default.",1521137506.0
jaapz,Maybe move the definition of x to below tha example class,1521137810.0
recursive,"If you're using typescript modules, this normally happens automatically.  But you're not.

Maybe you can surround main.ts in a set of curly braces to establish a scope.  (You said main.js, but it's .ts, right?)",1521150760.0
Fullstack_Questions,"Are you a frontend developer? Then typescript.  Plenty Typescript courses, and it's easy to just keep developing your Javascript apps WITH Typescript after you learn it. (Check Maximilian Schwarzmuller's Typescript course on udemy) It's basically a superset of Javascript. You can still code javascript in it. It just wont be type-checked (will be of ""any"" type) 

Kotlin is used on backend, and android (and more?) 

You can use typescript for React Native (both android and ios), React, Node.. and many other venues. 
",1521115944.0
kccoder12,...that thumbnail =/,1521037749.0
rubenduiveman,Very impressive!,1520962708.0
,"> Trying to figure out types of parameters for callbacks

If you don't rely on object identity too much you can use Proxies to do this. (Same for object types too)",1520984861.0
bitjson,"Hi all, I just published the latest version of `typescript-starter`. It's a minimal boilerplate generator with many of the most popular development tools pre-configured and ready to start hacking. (testing, coverage, typedoc, tslint, prettier, standard-version, etc.)

**The CLI lets you get started quickly, just type `npx typescript-starter` to install the latest version and run the interactive generator.**

(For those who haven’t seen it yet, `npx` is a quick-run command which now comes with `npm`. You probably have it installed already.)

The interactive mode lets you quickly select from a number of configuration options, and I plan to keep adding new options which work well together. Are there other packages or tooling options you would like to see added?",1520899139.0
nemesis78,Awesome!,1520958082.0
cspotcode,"Dang, there's a lot of stuff here.  I need a good changelog solution; I'm gonna check it out.  Does it all work on Windows?",1520938336.0
paulkoer,Shameless plug: https://github.com/paulkoerbitz/typeful-redux,1520886340.0
ibezkrovnyi,"Enums are good here, for both semantic and DRY reasons. Instead of writing export const A = ""xx""; export type A = typeof A;  you may write it only once export enum ToDoActionTypes { A =""xx"" }. Now, ToDoActionTypes.A is a type and value at the same time. Additional benefit - no need for typeof.",1520929491.0
zintjr,"Do a search on John papa and redux, he has a library meant to reduce all of the boiler plate 


EDIT: was on phone earlier, [ngrx-data is the library I was referring to](https://github.com/johnpapa/angular-ngrx-data)",1520876171.0
fecal_brunch,"Object spread has incomplete generic support, but in this case you are doing something weird. I think your props should just extend the props type of Route, which you should be able to import from its type definition.",1520892904.0
gigobyte,"Very useful, didn't know some specifics mentioned in the article :)",1520852492.0
,Great article!,1520857474.0
pe8ter,"Great info, but I cannot follow the GIFs. The info disappears before I can read it, let alone comprehend it.",1520873721.0
cspotcode,"Hope this makes sense.  Inspired by a recent async utility post on this sub, I wanted to create something like async.auto but:

* without manually stating dependencies
* using async functions (Promises, not callbacks)
* with automatic tab-completion and typing

This is what I came up with.  Give it a dictionary of async functions, and it'll run them all in parallel.  If one function needs to access the result of another, it can `await this.nameOfOtherFunction`.  The names will tab-complete, rename refactoring works, and the return type is carried through as well.  So if one task returns a complex database query result, you'll still get tab completion everywhere you use that result.

Some of this magic requires TS 2.8's new conditional types with inference.  If you haven't checked them out, they are truly magical and enable a lot of awesome new possibilities!",1520840994.0
Auxx,Things people do just to avoid RxJS...,1520848439.0
,"What's the purpose behind passing in the `success`, `failure` and `run` functions as arguments, rather than having them as top-level functions?",1520682502.0
rubenduiveman,"I like the idea of explicitly defining type safe responses, both for success and failure. Nice!",1520709729.0
gigobyte,How is this better than an `Either` implementation?,1520852931.0
AngularBeginner,"> uBlock Origin has prevented the following page from loading:

Oh well, then not gonna visit it.",1520620450.0
Chris9513,"Question, what is the point of using typescript for your application when you're using 'any' several places? Might as well use Javascript at that point, or am I wrong?",1520622791.0
cjg_000,You probably need to look at the type definition for subscribe. It is inferring the type of data based on that.,1520559367.0
cspotcode,"Assuming your using an editor with language service integration, you can hover over all those values to see their types.  You can also use the ""go to declaration"" shortcut to jump to where they're declared so you can see all the relevant type information.  For example, in VSCode, put your text cursor over `subscribe` and hit F12.",1520560192.0
PassItOnBro,Agreed. Try subscribe<string>((data) => ...),1520563384.0
recursive,What line and column is the compilation error?,1520569909.0
Aior,Why would it? I actually think the other way is more likely.,1520530136.0
cspotcode,No it won't.  It doesn't do a lot of what tsc does.,1520534609.0
ibezkrovnyi,Just replacing babel with typescript decreased build time by ~50% on js projects. Replacement in the opposite way is impossible - typechecking is done by tsc itself.,1520538232.0
paulkoer,"I'm not sure it counts but here is a simple, but complete example of a todomvc app with typeful-redux: https://github.com/paulkoerbitz/typeful-redux/tree/master/examples/todomvc
the upside is that it is a relatively simple yet complete example, so shouldn't take too long to complete. We use this approach (on a much larger scale, but conceptually identical) in our pretty complex redux app.",1520510002.0
vinnl,"Yes! And I fully share your frustration: it was really hard to find documentation on typings, so a lot of it is guessing with the help of type definitions.

Luckily, I have been through this, and am working on a production open source project that uses Redux and TypeScript in strict mode: https://gitlab.com/Flockademic/Flockademic/tree/dev/stacks/frontend

The most comprehensive one to look at is probably [this component](https://gitlab.com/Flockademic/Flockademic/blob/dev/stacks/frontend/src/components/orcidButton/component.tsx) (`OrcidButton`), which both receives props from the state, callback props to dispatch, and is wrapped in React Router.

If you have any questions, I might be able to answer them as well.

**Edit:** I've now done some closer reading, and see you're asking specifically about reducers. You can find those [in here](https://gitlab.com/Flockademic/Flockademic/tree/dev/stacks/frontend/src/ducks). Though it seems your issue is more about understanding Redux than it is about TypeScript, so about your specific question: yes, by default, reducers receive the entire state and all possible actions. However, you usually use a main reducer that takes a subset of the global state, and passes that with all possible actions to every reducer, and then combines the results of those reducers back into the global state - this is what [`combineReducers`](https://redux.js.org/api-reference/combinereducers) does (see also the [basic docs on that](https://redux.js.org/basics/reducers#splitting-reducers).",1520522590.0
lapanti,"https://github.com/lapanti/ts-react-boilerplate <- my personal boilerplate has full typings, it isn't too large, but I'm working towards enlarging it",1520510636.0
paulkoer,"Hi there! I'm the author of typeful-redux. I wrote the library because I felt that using redux in a type safe manner is really difficult. In particular, I think that none of the existing wrappers achieve full type safety. I'll be happy to answer questions.",1520431557.0
RustyX,Does this allow for a single dispatched action to be handled in multiple reducers? It seems like from the example that isn't the case. ,1520441929.0
scrollin_thru,"I'm not 100% sure, but it looks like React is [exported as a namespace in the Typescript typings](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts), so `{ Component }` doesn't exist in Typescript's eyes.",1520376342.0
Aior,"Maybe part of the error is that you're not supplying any type parameters. Change it to ...extends Component<{}, {}>... and see what happens.",1520447317.0
cspotcode,"The error you're getting, it's happening at runtime, correct?  That indicates that it's a webpack or transpilation error.  What does your tsconfig.json look like?  What are the exact versions of react, @types/react, and typescript you're using?",1520712983.0
HeinousTugboat,"I'm not sure you can call the Mersenne Twister 'pure random' in good faith. It's a PRNG just like every other software-based RNG.. I'm not familiar with the other one, but I'm assuming it's similarly not 'pure'.",1520371408.0
ndubien,"Just to add a bit of context and describe a subject where such generator can be useful.

Let's say we are building a turn by turn game in TypeScript (2048 for instance). Each time the player plays a round the IA uses an internal random generator to guess its next move (adding a 2 or 4 in the grid). If we want to add some kind of cancel operation, then replaying the user input might lead to a completely different situations given we use unpure random generator. Using a pure one we just have to ask the generator again for its value.

Such problem can easily be encountered in implementations of 2048 allowing the back operation. ",1520367467.0
bitjson,"You might find this project helpful for getting started with a new typescript project: https://github.com/bitjson/typescript-starter (or for copying working configurations into an existing repo)

You can just run `npx typescript-starter`, and it will walk you through generating a pre-configured project. There are also examples of module exports and import for both Node.js and the browser.

Hope that helps!",1520900594.0
welkie,"When I switched from JS to TS, I don't remember having to do anything special to use modules. I simply used imports and exports the same way I did before, except instead of using the ```require()``` syntax for importing and the ```module.exports = ``` syntax for exporting, I started using ES6 style imports (```import x from 'y';``` for importing and ```export default x;``` for exporting).

Would you say your issues are related to the concepts behind importing from other modules, or you're familiar with importing and exporting and you're just trying to get it working for TS? Are you working on Node or browser code? You should be able to import from another module like this:

a.ts

    const SOMETHING = 42;

    export default SOMETHING;

b.ts

    import SOMETHING from './a';

    console.log(`The constant is ${SOMETHING}.`);

It should be noted that I only use TS on the server, so I use the Node module system. I grab the ```tsconfig.json``` file from [Microsoft's Node Starter Repo](https://github.com/Microsoft/TypeScript-Node-Starter) when I begin a project.",1520290916.0
kaz3work,"You need to use a bundling step that understands modules and to set that in tsconfig's ""module"" setting. That could be UMD, AMD, SystemJS, CommonJS. For example Node.js uses CommonJS which utilizes the require() method to handle the linkage.

Which are you using? And do you currently have a build tool set up to handle this, such as Webpack?",1520291051.0
fecal_brunch,"> Static type checking won’t ever protect you against runtime errors.

Uh. Yes it does. Any incorrect use of an API or use of an undeclared variable.",1520291311.0
rdfuhr,Static type checking has  protected me from many run-time errors. It is certainly preferable to catch as many errors as possible at development time rather than wait until run time. There are certainly many other types of errors that can slip through and would not be caught by static type checking. ,1520789297.0
cspotcode,"Small nitpick: you should use `PromiseLike` for your input types instead of `Promise`.  `PromiseLike` is the minimum interface for a value to be considered a `Promise`, whereas `Promise` is the full native interface including helper methods that are not technically required.

Also, I noticed that type inference of the returned object assumes all properties are `any`.  I think this can be fixed with conditional types once TS2.8 is released.",1520561516.0
rubenduiveman,"But why won’t you just promise the whole object?
Is there also an option to await or Promise.all all properties?

Edit: I see the readme provides an example of my second question. ",1520275916.0
paneq,I see you like promises :),1520265721.0
fecal_brunch,I think you should either throw or reject with a `TypeError` when a non-object is passed.,1520289318.0
turkish_gold,"You should report what is in `response` when all the promises are complete.

Also you should probably list *why* you aren't rejecting the promise when any asset fails to load, but instead passing along a {loaded: false, src: """" } down the line.

Basically, cover exceptional usage. Also maybe condense it into a single file since its < 100 lines long, so I don't see what we're gaining by all this indirection.",1520278321.0
cslfrc,"By default Typescript will interpret a string literal to have type string. So the inferred type of `state` is `{ light: string }`. Add the type annotation in the definition of `state` and it should work

    state: State = {
        light: ""off""
    };
",1520155729.0
hicksyfern,"You can also do `”off” as “off”` I believe. This is a more general workaround if you don’t have public access to the interface, but you want to supply a string enum.

What this does is to tell TS to understand the string “off” as the type “off” rather than ‘a string that happens to have the word off in it’.",1520161907.0
Limecta,"Instead of defining state in the class itself (which isn't allowed). it is better to do that in the constructor (probably even the best way). The constructor is also the only place where you are allowed to set the state without calling `this.setState()` (by convention).  
  
So what you want to do is define the constructor of your class with your props as its parameter, then give props as parameter to the `super()` function and then set the state. Which will result in this:

    class App extends React.Component<Props, State> {
        constructor(props: Props) { //defining the constructor
            super(props) // giving the props to super so it becomes available as 'this.props'
            this.state = { // Here we set the state 
                light: ""off"" // with light containing the value ""off""
            }
        }
        // the rest of your class
    }
",1520191103.0
cspotcode,"I think you can simplify this by removing P1, P2, and P3.  You don't need them.  For example:

```
await failable(() => callTheFunction(arg1, arg2, arg3));
```

The `failable` API doesn't need to worry about function arguments because it's easy to wrap the entire function call in a zero-argument arrow function.

Otherwise this makes sense to me.  You'll probably want to make a synchronous variant as well for performance, since `async` imposes a few extra cycles around the JS event loop, per the `Promise` spec.",1520106368.0
,"Depending on how you intend to use this, it might be handy to curry the function so you can wrap a function as a `failable` and use it multiple times.

    interface Failure {
        readonly isSuccess: false;
        readonly errorMessage: string;
    }
    
    interface Success<T> {
        readonly isSuccess: true;
        readonly data: T;
    }
    
    type Result<T> = Success<T> | Failure;
    
    function failable<R, A = any, B = any, C = any>(f: (a?: A, b?: B, c?: C) => R): (a?: A, b?: B, c?: C) => Result<R> {
        return (a?: A, b?: B, c?: C) => {
            try {
                return { isSuccess: true, data: f(a, b, c) };
            } catch (error) {
                return { isSuccess: false, errorMessage: String(error) };
            }
        }
    }
    
    function foo(x: string, y: number): boolean {
        return y === 3 && x === 'hello';
    }
    
    const f: (x: string, y: number) => Result<boolean> = failable(foo);
    const a = f('hello', 3);
    const b = f('world', 42);

Then if you want to add error handling you could to something like:

    function isSuccess<R>(res: Result<R>): res is Success<R> {
        return res.isSuccess;
    }
    
    function join<R, T>(res: Result<R>, onSuccess: (succ: R) => T, onFail: (err: string) => T): T {
        return isSuccess(res) ? onSuccess(res.data) : onFail(res.errorMessage);
    }
    
    function handleError<R>(res: Result<R>, onFail: (err: string) => R): R {
        return join(res, x => x, onFail);
    }
    
    const c = handleError(f('return false for failure', 4), () => false);",1520115628.0
AngularBeginner,"Just pointing out that your type for `errorMessage` is wrong. In JavaScript you can throw **anything**, so the correct type to use would be `any`.",1520122043.0
,"Does anyone use Vue? Seemed so hot. But now, not so much.  This is a three day old post. ",1520418491.0
trevorsg,See non-goal #6: https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals,1520097911.0
,[deleted],1520098238.0
Angulant,"TypeScript is doing the right thing with not implementing features like this. If you want them, you want them in EcmaScript not in TypeScript. :)

Coffeescript started to add features to JavaScript. That was its death sentence. Because the APIs diverged at some point. 

TypeScript should only add Types for JavaScript. Features should be provided by EcmaScript itself.  ",1520098921.0
diverightin63,"Yeah that's not not the purpose of TypeScript. Check out TypeScript.Net or Linq.js, maybe they will give you some of what you're looking for (if es6 and lodash aren't cutting it)",1520099029.0
Arffman,"This is going to sound condescending but you need to shake the notion that TypeScript should adapt to your expectations and experience. I'm assuming you're new to JavaScript and a lot of things can seem alien but you should endeavour to adapt to it rather than try and adapt it to you. 

I speak as someone who went through the same thing. I wanted my good old `List<T>` from .Net, I wanted uppercase properties and methods names. So I did it, and wrapped whatever 'weird' JavaScript concepts I could. It was a pain, and in the end I wasn't using the language as intended, I was hiding the quirks rather than learning them. It was a big waste of time.",1520112808.0
cspotcode,You can use a polyfill that augments native arrays.  No need to `import` anything.  Let me know if you're confused about any of the details.,1520102416.0
fecal_brunch,Just use lodash.,1520289509.0
esamatti,"There is actually a third alternative which is my preferred solution. Babel 7 has a Typescript plugin which can be used to strip the types. 

This is a really nice solution if you need/want babel plugins with Typescript. No need to run two compilers. There are plenty of optional libary specific babel plugins which enhance the developer experience (styled-components-displayname, glamorous-displayname), runtime speed (polished) or reduce the bundle size (lodash, recharts).

Babel 7 is still in beta although I haven't run into any problems once got it setup which can be quite challenge currently.

More information http://artsy.github.io/blog/2017/11/27/Babel-7-and-TypeScript/",1520014438.0
cspotcode,"I use ts-loader with typechecking turned off and paired with thread-loader.  I'm gonna add hard-source-plugin, too.  I can't offer an educated comparison to at-loader, though.",1519975417.0
User31441,I use at-loader and never had any problems with it. I have used ts-loader before and only ever run into a single minor issue (which might even be fixed now) at which point I switched. It really doesn't matter which one you choose.,1519987755.0
shawarma_burrito,"I switched from at- to ts- because the former was acting up with my SSR app’s hot reloading. In at-loader’s defense, I probably screwed something up, but the problem went away when I switched to ts.",1520020389.0
Arffman,"Because of some issues with the loaders in older versions I've always used tsc to build to ES6> JavaScript, then used that as the input to Webpack (and Babel et al). It works well enough, but the Babel 7 support is something I'll be looking to move to.",1520113564.0
Useless-Pickles,"If you use `undefined` instead of `null` (See [Null is bad](https://basarat.gitbooks.io/typescript/docs/tips/null.html)), then you can take advantage of the standard `Partial` type to convert a type to have all optional properties.

If you want to make all properties capable of being undefined without being optional (still must explicitly provide a value for the properties), then you could use a mapped type like this:

    type Undefinable<T> = {
        [P in keyof T]: P | undefined;
    }
",1519946903.0
Artraxes,"So instead of either disabling the strict check and gradually adopting nullability or just biting the bullet, marking fields as optional in the language's idiomatic definition that all existing TS developers understand (i.e. adding the question-mark to the end of the property name) - you went with the overly contrived solution of producing a bunch of new types that require an entire blog post to explain and aren't at all familiar to any newcomer to your project.

Yikes.",1519945513.0
LukaLightBringer,"This would probably have been a good time to use either Partial, Pick, or a mapped type that allows the fields to be undefined.",1520265032.0
steveokay,"Finally a good way to handle defaultProps!  This is awesome, thank you for sharing.",1520013464.0
ibezkrovnyi,"This study is often misread - it is only about bugs, which have survived testing (number of months spent on debugging/unit tests development is out of focus) and review, and not about bugs/issues in everyday development cycle. During experiment only 10 minutes was given to add type annotations for code, which has never seen before. Also the study is quite old - latest TypeScript dev-version is 2.8, there is fantastic number of improvements in TypeScript since 2.0.",1519870166.0
cspotcode,"Right off the bat, he's misrepresenting the first error.  He says it's because the function's arg is inferred to be number, but the error is actually due to noImplicitAny.",1519833220.0
defenestrant,"I made this to have something easier to use in my own projects than redux and thought I could share it. It's written in TypeScript, so it comes with typings. If you type your store, you will have type-safety and auto-completion where-ever you want to consume the state or when creating actions to update it. 

I know there've been many lately, but just thought to share. I was inspired by /u/drcmda 's [react-contextual](https://github.com/drcmda/react-contextual), but wanted something with type-safety. 

I'm open for any questions or suggestions :)",1519828097.0
AngularBeginner,"Have it as specific as possible, that will prevent you from gotchas and increases your code quality.

Did you know that these two functions are evaluated differently by the compiler, and that one is better than the other?

    function myFunction1(): ISomeObject {
        const result = {
            property1: ...;
            property2: ...;
        };
        return result;
    }

    function myFunction2(): ISomeObject {
        const result: ISomeObject = {
            property1: ...;
            property2: ...;
        };
        return result;
    }",1519715779.0
,"Are you having issues with TS or React + TS? React has some issues with TS (the typings are sometimes outdated / wrong)

I kind of really wish flow and TS did somekind of a merger. Theres really no point in having both.

Edit

Heres some examples for getting started
https://github.com/Mercateo/react-with-typescript/blob/master/README.md",1519704962.0
jovdberghe,It would be nice to have a vs-code plugin for that with quick fix suggestions.,1519763881.0
Auxx,"You don't need to add types everywhere, because type inference. And you don't need to use debugger to check variable type, because IDE.",1519949831.0
,"Does TypeWiz work for higher order arguments like objects and functions, or will it only give them the type `object` or `Funtion`? For example:

    function app1(f, x) {
        return f(x,1)
    }

    app1((x, y) => x + y + 3, 42);

What would be the type of `f`?",1519693616.0
gcanti,I guess it would be better `type AutoDiscovered = never` (which has no effect on unions) instead of `type AutoDiscovered = void`,1519714262.0
,"This looks great.

Did you consider using a typed tuple for the parameter names instead of variable arguments? I'm assuming it's possible (but I don't know). I'm curious as to whether the ability to index into a tuple at the type level would give a nice type-encoding of this. From a caller's point of view I think the vargs are nicer.",1519694475.0
FauxStonehenge,This is awesome. A co-worker was just explaining to me how he wanted to implement this exact thing. Gonna give it a try,1519712395.0
night_of_knee,This looks like a good argument for variadic generics in the language :),1519721575.0
brogrammer2018,"Hi TypeScript devs! I converted the best TypeScript snippets on Stack Overflow Documentation to create this free TypeScript PDF book, any suggestions for improvements are appreciated as it will help me improve this PDF book; which will then benefit everyone 😊",1519650498.0
notNullOrVoid,"Symbols don't provide true runtime privacy. It's pretty easy to get access to the symbols without them being exported. `Object.getOwnPropertySymbols(toggleable)`

Without private properties, the closest thing to true runtime privacy you can get is to use maps. Even then though not strictly private because Map could be modified to leak information.",1521036939.0
paulosuzart,"Any plans to integrate with Watson conversation?

Very nice work.",1519612140.0
mushishi78,"I'm sure a library for this already exists, but a quick google didn't turn up anything so I implemented something simple. Thought I'd share in case it of any use to anyone :)",1519418335.0
BenZed,"syntactically, you're doing the exact same thing as:

    element.addEventListener('click', () => Promise.resolve(doSomeStuff()) })

Babel transpiles this to something a little different using its *regeneratorRuntime* function, but you are correct. This function will execute as expected.

You are also correct that if you were using multiple await statements, the promises would execute sequentially, like a queue.

The one thing it seems you might be confused about: async functions don't *halt execution* of the main thread. Consider:

    event.addEventListener('click', async () => { 
        await oneSecondDelay()
        await twoSecondDelay()
        console.log('you clicked something 3 seconds ago')
    })

Yes, its true that the log message wont appear for three seconds, but the rest of your events will still be fired and the page wont freeze. Click that button three times, and then roughly three seconds later you'll get three log messages.",1519413966.0
GFandango,"there's nothing wrong with it

as you mentioned the only catch is it doesn't wait for the callback function but it's still useful for allowing you to use the ""await"" keyword to order the sequence of things that happen inside the callback.",1519415693.0
_eps1lon,"So in the readme is a quote:
> An int on its own is just a scalar with no meaning. With an object, even a small one, you are giving both the compiler and the programmer additional information about what the value is and why it is being used.

> ‐ Jeff Bay, Object Calisthenics

But this doesn't give the compiler additional information because Typescript uses structural typing. With this I can still write

    class SafeHtml extends TinyTypeOf<string>() {}
    class UnsafeHtml extends TinyTypeOf<string>() {}

    const unsafe = new UnsafeHtml('<image />');
    const safe: SafeHtml = unsafe;

and get no Error.

The only benefit I can see is improved intellisense in VSCode because VSCode resolves type aliases. Other than that it's just some runtime type checking. Adding domain context is already possible with type aliases.

I'm probably missing a major point here though?",1519414620.0
johncoates,"This is a problem that would be solved by named parameters, which I feel that TypeScript would really benefit from.  https://github.com/Microsoft/TypeScript/issues/467",1519396531.0
cspotcode,"I'd probably do this with branding and identity functions, to avoid the extra runtime overhead of constructing classes.  Something like this:

    function FirstName(v: string) {return v as string & {__firstName: any}}
    const Jerome = new Author(
        FirstName('Jerome'),
        ...
```",1519401818.0
gigobyte,[This](https://github.com/gcanti/newtype-ts) implementation doesn't have any runtime and I think it's a better alternative.,1519480715.0
,I'd be interested to see the performance hit on using 'tiny types'. Seems like they would play havoc with hidden classes.,1519416584.0
AngularBeginner,Advertisement for a paid course that is definitely not the 110 € worth.,1519373126.0
ower89,"Hi, Author of InversifyJS here. I like what you have done. One of the goals of InversifyJS is to allow others to create their own libraries. At the same time, we want to keep the library as light way as possible. Functionality like this in an additional module makes sense to me. Thanks for spreading the word about dependency injection I also believe it's a very useful tool for writing maintainable and easily testable code.",1520614018.0
realm_01,What woud be a good usecase for that?,1519342754.0
,[deleted],1519247869.0
BenZed,"A try-catch and an inline function anytime I need to access a property?

No thanks.",1519191860.0
fecal_brunch,"These are useful additions, but what I really want is a helper for building the unions:

    Import * as Actions from './actions'
    type ActionType = Values<Actions>",1519164178.0
RustyX,"Got super excited about conditional types, and then really confused that I missed the 2.8 release. Looks like I didn't... still only 28% complete. This will be a great release though once it's done!",1519183375.0
SuperImaginativeName,How does this compare to chroma.js + typings?,1519338237.0
_xiphiaz,"I’ve used it in some very large projects - it has the benefit that it forces you to really consider if any is truly appropriate, and if so you must put a tslint disabling comment. We had a code review rule that for every tslint disable there had to be a comment justifying it.

 Nearly every time you will find a more appropriate way to type the field, sometimes with a generic, sometimes with a new interface etc",1519090849.0
dvlsg,"I'd say if you can get away with it (and you can, if you put in the effort), then yes -- it's very helpful.

You should at _least_ be using the `noImpicitAny` typescript compiler option, though.",1519109748.0
MrEnigma,"We don’t have this rule on by default, but we do require everything to be typed, and generally in code review you need to justify using an any.

We also enforce most of the TS strictness as well, while initially a pain, it makes working with the code (and less issues at runtime with the strictness) much easier.",1519095404.0
StuffedDoughboy,"I found that rule has prompted me to become a better TS developer. I encountered it the same way as you did, using that starter and initially had many */tslint:disable-line no-any */ in my code. As I gained a better understanding of the available types I gradually removed 99% of them.",1519252741.0
night_of_knee,"This is a cool _little_ feature, I remember when something like this was [proposed for c++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3499.html). If I remember correctly it was rejected (or postponed) because it was too complex (I think they thought it necessitates parsing input with separators too). 

  
  
It's indicative of the difference between C++ and TypeScript, how easy it is to make a change to the language...",1519034461.0
kuatsu_janka,"> Is it bad that it depends on a few ES5/ES6 features at run-time 

No. That's what polyfills are for.

>Should I put effort into making it ES3 compatible at run-time and lose the Iterable functionality of my enum wrapper?

No. If you care enough you should make an ES3 specific version.

Overall your code looks pretty solid to me. Good work! Nicely documented too!",1519035310.0
Useless-Pickles,"I added some more thoughts for discussion/feedback to the original post:

* Is the implementation of the Map interface just adding too much confusion? There are 2 ways to do many things now (e.g., keys() returns iterator, while getKeys() returns an array; get() and getValueOrDefault() with the second param omitted are equivalent, etc.) Should I drop support for keys(), values(), entries(), and get() for a less confusing API, or are the additional options good? I would keep the @@iterator(), and forEach() is still inspired by Map.
* Is there confusion about getValue() vs getValueOrDefault()? Should I rename getValue() more explicitly as ""getValueOrThrow"" to avoid any uncertainty about whether the method will throw vs return a value when the key is invalid? (similar for getKey and getKeyOrDefault).
* The combination of the above 2 points is particularly concerning to me, because I have a nondescript ""get()"" method from the Map interface that adds even more uncertainty about which method you should call between get(), getValue() and getValueOrDefault(). Maybe I should at least drop support for get(), even if I keep keys(), values(), and entries() from the Map interface.

",1519054113.0
ltray,"I'm curious as to the intended use of this lib -- it seems like you're adding a lot of scaffolding around improving enums at runtime (runtime checks, mapping/iterating), but I've mostly used enums myself for more compile-time concerns. Since enums are defined at compile time, I always know all the keys and values, and feel like I would only benefit from runtime checks in relatively niche cases (e.g. interpreting some part of a response of an api call as an enum). For most of my enum usage, I want them to be as lightweight as possible, so multiple linear/superlinear operations in construction and large object sizes scare me.

Not trying to throw shade in any way, just wondering how you're using enums. A practical example or two would go a long way. Very well documented though :)",1519077895.0
fecal_brunch,I've been using https://www.npmjs.com/package/enum-values. You may wish to include this in your other projects list. I haven't spent time reading your readme yet but might switch dependencies if it offers better type support.,1519095216.0
Useless-Pickles,"I already had 100% unit test coverage of run-time behavior, but an important part of this library is correct compile-time types. So last night I added a suite of [dtslint](https://github.com/Microsoft/dtslint) tests to verify compile time types :)

Example tests for an enum with numeric values: https://github.com/UselessPickles/ts-enum-util/blob/master/type_tests/EnumWrapper-number.dtslint.ts",1520358496.0
nosmileface,Typescript types are sufficient.,1518979014.0
danvk,"Since PropTypes are checked at runtime, there are some things you can do with them that can't be expressed in a static type system, e.g. ""the URL prop must start with https.""

But those checks are somewhat rare and the wins of running checks earlier (with tsc or in your editor) are big.",1518987084.0
phoenixmatrix,"Inevitably someone in your team will complain about losing the runtime guarantees. But proptypes don't do anything in a production build anyway, and the significantly better type system and build time guarantees far outweigh those benefits.

And for the love of all that is holy, don't use proptypes AND TS types at the same time.",1519327540.0
yesman_85,If you think types are just bloat then maybe TS is not right for you. Types catch a lot of tiny mistakes and forces clean and organized code. We have a large enterprise app with over 100k LOC and I have NEVER come across a situation where TS was in my way.,1518837335.0
schwede,"You won't lose any JavaScript power because anything you can do in JavaScript you can also do in TypeScript, it just provides the ability to use types. 

    let x: number;
    let x: any;

If you declare variables as in the first line you will get type checking wherever it's used. The 'any' type is an escape hatch to JavaScript object where anything is fair game.",1518837123.0
cspotcode,I'm actually not sure why you'd think a large-scale app would ever be worse off with TypeScript; it'd always be better.,1518837763.0
mispy,TypeScript is ideal for large and enduring codebases because it frees you from having to keep all the type information in your head. I only really consider writing plain JS anymore when it's a small throwaway script.,1519357146.0
NewDark90,"The nice thing about typescript is you can make it as strict/""bloated"" as you need it to be. Most of which you can see in the compiler options here: https://www.typescriptlang.org/docs/handbook/compiler-options.html

Examples would be noImplicitReturns or allowUnreachableCode. Remember that even if your development environment complains about valid JS as typescript code, it will still emit as long as you have noEmitOnError turned off which it is by default anyway. 

Besides a little bit of effort to configure it, the benefits are so real and worthwhile. Like just knowing what all of my libraries functions are, in my IDE, with their expected input and output as long as you have the right .d.ts file is worlds easier than looking to a wiki/doc/SO every time I want to do something.",1518845486.0
rodrigoelp,"Hi, I came to nodejs and react native from the point of view of static types and I honestly can not understand why you wouldn’t change to typescript.

In the first few weeks of me using it I found a few bugs with the implementation of some libraries that the authors saw as little JavaScript oddities before noticing it was a problem with the type they had imagined and it was working by “chance” in some edge cases.

Said that, the one thing I have found annoying of typescript is the type definition as there are plenty libraries without the typescript definition file. Sure, you can declare everything as any and use it in the JavaScript way, but if you are going to do that, the safety ts gives you is gone for a section of your code.",1518854373.0
mwcz,"Having dabbled with TypeScript but not adopted it, I can say the only reason I didn't fully embrace it was the pain of including dependencies' type definitions.  

There were four different recommendations at the time: give up and use any type, commented d.ts include, definitely typed, and @types.  Any type has no benefits and is annoying cruft, commented include works but is extremely tedious, and the later two were simply missing many of the modules I use regularly.  I spent so much more time trying to include dependencies than I did building apps, so I gave up on TS.  I would like to try again and see if the situation has stabilized.",1518878009.0
cspotcode,What exactly is this?  Is it a reimplementation of dotnet APIs in TypeScript?  Is it targeted at people who are familiar with the dotnet collections and API and want the same thing running on a JS VM?  I'm intrigued but confused.,1518838649.0
abuassar,any examples and uses cases would be super helpfull!,1518876533.0
icc-coder,This is amazing.  ,1519480281.0
CarProfessor,--target ES5 resolves the TS1056 error,1518804151.0
fecal_brunch,You can whitelist keys using `Pick`. If you want to do it generically based on the type of  each property you may be able to achieve this with conditional mapped types https://github.com/Microsoft/TypeScript/pull/21316.,1518805820.0
Uknight,"    Object.keys(obj).filter(k => typeof obj[k] === ""number"")
    .reduce((newObj, k)=> ({[k]: obj[k], ...newObj}), {})",1518808670.0
dimkinv,"Is your object is an instance of a class? If so you can only iterate on it (assuming you write typescript without ""cheating""😊) if you describe an indexer on your object. Something like [id:string]:string|number. You can iterate on the object by calling Object.keys function. It will give you an array of all the keys in the object. Then evaluate each property by (typeof obj[key])

I'm on phone so cannot validate or write you a code snippet.
Also, i don't know the scenario you are facing, but, I would consider using map instead of Javascript object",1518800225.0
watercoolerthrowaway,"    const obj = {
      a: 1,
      b: 2,
      c: 'string'
    };
    const newObject = {};

    for ( const key in obj ) {
      if ( typeof obj[key] === 'number' ) {
        newObject[key] = obj[key];
      }
    }

something like this would do the trick? Here you're iterating the object using a for...in loop, which cycles through the keys of the object.",1518808278.0
eguanlao,"If you're a ""daily C# developer"", then you should know how to learn any programming language because they all have many of the same constructs, but the syntax may be a little (or a lot) different.

When you're learning TypeScript, you're learning JavaScript... but with types.

Like any good developer, read the [documentation on the language's home site](https://www.typescriptlang.org/docs/home.html).

Have a look at the links in [Awesome TypeScript](https://github.com/dzharii/awesome-typescript).",1518760117.0
,[deleted],1518739039.0
PM__YOUR__GOOD_NEWS,"For me refactoring is another major benefit. The ability to basically break your API on purpose and then wander around fixing all the places where the change broke code is fantastic.

I've tackled some pretty large TS project refactors I would scarcely have even attempted with vanilla JS.",1518731200.0
ForAllThat,The v2 types are under @types/jquery/v2. But I'm not sure how you can tell Typescript to use those (they are in the `@types/jquery` package),1518629897.0
cspotcode,"`npm install @types/jquery@2`

Omit the minor and patch numbers.",1518651160.0
Bodmen,Right on! Need to give it a try ,1518626332.0
Qwakeworld,"Nice article. What does

    __TYPE__

refer to in your type definition?",1518494624.0
insane_yet_awesome,"This article has just taken the static vs dynamic language discussion and given it a spin by calling it ""type driven development"", which is essentially nonsense. It's not a method. It's just a property of the chosen language.",1518467134.0
Devcon4,"I mean types are awesome and people should definitely design things functionally, but I wouldn't go around throwing custom types everywhere. Every project has a ""vocabulary"" of custom things, you want to keep that as small as possible (that's why we use libraries/frameworks). You don't want to be in a place where you have 5 different types of stings and instead of creating another helper to transfer from one to the other you just cast it.",1518481889.0
madcaesar,"Neat, but am I wrong or can't you return arrays from components as well? Which is effectively the same thing and doesn't need a wrapper or fragment?",1518518732.0
thepointer,I believe https://github.com/Microsoft/TypeScript/issues/13347 is the issue you're looking for.,1518438121.0
AngularBeginner,"What you want is not possible and not supported by TypeScript, because it's not covered by what TypeScript aims to solve. It just adds the type safety that the property of that interface can't be written to, and that is the case. When you have the interface, you can't write to that property. It does not prevent the modification of the underlying object in general. For that to work the `readonly` would have to be enforced in the object itself during runtime, and that is something that JavaScript does not offer yet.

If you want that functionality, wrap your object creation in a call to the `deepFreeze` library. It replaces your object with a new one that will crash when it's modified.",1518434786.0
Bjeaurn,Does the compiler not whine about this? What version are you using?,1518431742.0
coopaliscious,I generally use classes with only getters if a property is read only. ,1518436091.0
,[deleted],1518432282.0
mugwumpj,"There is a functional data type called ""Either"".  The ""Failable"" idea in this blog is the more-or-less the same as an Either.  Eithers have a ""left"" and a ""right"" type.  The convention is to use the left type as the error type and the right type as the success type.  (Easy to remember because right is right.)   Eithers typically have all of the functional methods you'd expect on collections/monads (map, flatMap, etc).  Some implementations are right-biased, which means ""map"" would operate on the right type.  Other implementations have separate ""mapLeft"" and ""mapRight"".  My preferred implementation will allow to convert the Either<L, R> to an Option<R> and vice versa.

TL;DR: use Either.",1518384773.0
,"~~How do these things compose? Does `run` not need to take some input if I want to combine two failable computations?~~

EDIT: Ignore the above: there is an example showing composition.

Question: What is the reasoning for making run take a function, rather than just a `Failable`?",1518393871.0
bstriker,"I usually just use ""instanceof""

    try {
        // ...
    } catch(err) {
        if (err instanceof MyError) {
            // ...
        }
    }",1518402916.0
kylorhall,I guess this is what you do when you want a blog post to stand out?,1518315359.0
paulosuzart,"https://nestjs.com/ is for sure a good option. And for persistence, http://typeorm.io/",1518233254.0
dangerzone2,I'm using express with a project right now.  Seems to work well.  I haven't found a reason to switch off of express yet. ,1518283751.0
jineshshah36,Koa + Typeorm + Routing-Controllers + Class-Validator is very flexible and does the job well.,1518369123.0
misterlively,"Express, dotenv, and knex works well and is very flexible.",1518233779.0
Bamboo_the_plant,Presumably you're already using ts-node?,1518259443.0
Tayk5,Nest.js is a typescript framework for node.,1518270176.0
thajunk,"Hapi.js works well with it, might need to use v16 instead of the newest v17 though",1518298094.0
i_spot_ads,NestJS,1518377087.0
BenZed,"Why is this ""what npm should be doing for us""?",1518258511.0
cspotcode,"My advice, at least to start, don't write typings for third-party code if they don't already exist.  It's unnecessary.  Either turn off noImplicitAny or declare them in an empty .d.ts file:

    declare module ""lib-without-typings"";

That will tell TS that ""this module exists and doesn't have typings."". It will be of type `any`.

But first, have you checked the @types declarations from DefinitelyTyped?  Do they have any of the libraries you're using?

Make sure you're using ""moduleResolution"": ""node""",1518196903.0
kaz3work,If the types don't exist in the package have you looked in NPM's [@types](https://www.npmjs.com/search?q=%40types)?,1518197098.0
frenchPressedFolgers,"If you're going to use an NPM package that wasn't developed with TS, you'll want to add the package's typings, if they exist. A great tool to find typing files is [TypeSearch from Microsoft](https://microsoft.github.io/TypeSearch/). Then you install the typings by doing `yarn add @types/INSERT_PACKAGE_NAME_HERE`.

As an example, if I want to include lodash, run

```
yarn add lodash @types/lodash
```",1518199653.0
insulind,Definitely typed and also nuget and node have typed definition packages for all the libraries you mentioned and 100's more ,1518210655.0
,[deleted],1518134150.0
BenZed,"I don't have twitter, but: Style-A, all the way.

Rust did many things right. This is one of them.",1518161049.0
ruszki,"Sizes of byte, short, int, and long are not defined exactly in C/C++. This causes confusion. Some languages define these precisely, so they aren't so consistent across communities. On the otherhand, int8, int16, and int32 mean the same everywhere (as far as I know).",1518193355.0
Aior,Consider this: https://github.com/dslomov/typed-objects-es7,1519560078.0
indiescripter,"Update: on 54 votes the tally so far is

Style-A: int8, int16, etc: 81%

Style-B: byte, short, etc: 19%",1518201089.0
Aior,"Style A, but shorter - you should try to match WAsm naming. WASM has types i32, i64, f32 and so on.",1518164295.0
danvk,Also looking for speakers and hosts for this (and future) meetups!,1518116981.0
MosquitoD4K,"Do you think, that it would be possible to do the same for a nameof(...) operator?",1518077835.0
MosquitoD4K,"I would do it similiar to .net nameof. So when referencing a Type it will Display the Type. If you reference something like 
nameof(this.test) it will use ‚test‘, 
nameof(this.test.func) -> ‚func‘
nameof(Person) -> ‚Person‘

If you don’t use a reference like nameof(()=>...) it should either use undefined or ‚function‘ if that is possible.

",1518108252.0
dangertrager,I use [prettier](https://github.com/prettier/prettier).,1518045161.0
kjolesquid,tslint?,1518031063.0
cspotcode,"The closest analogs in the JavaScript community would be a linter (ts-lint), a pretty-printer (prettier apparently works well), or a codemods tools.  There is not yet a codemod tool for TypeScript, but there's work in progress to add support to the ""recast"" library.",1518035470.0
HeinousTugboat,[CodeMaid](http://www.codemaid.net/) says it supports TypeScript.. so.. why not that?,1518035651.0
AEternal,Are you using VSCode? Can offer a number of suggestions if so.,1518046501.0
comradecow,"Is that TypeScript's problem to solve? The TS language has tried to only add typing on top of whatever is the most recent version of ES (or looks to become the latest). Specifically sized integers aren't on the standards track as far as I know. So adding BigInt into the language would be counter to a main design goal.

Are there any good JS libraries that provide sized ints? I know the asm.js/wasm stuff has support for integers (to make more performant codegen), but I don't know if it supports specific sized stuff.",1518017711.0
cspotcode,"This needs to be added to the JS language; then TS can support it.  There are good reasons TS doesn't add non-JS features like this.  They've been discussed many times before; you should be able to find them with Google.  A big one is that, if TS introduces non-standard language features, then JS introduces features that conflict (possibly using overlapping syntax), TS will have no way of supporting the new JS without breaking changes.  The type system's syntax is carefully designed to hopefully never conflict with future JS syntax.

Have you heard about the BigInt proposal?
https://tc39.github.io/proposal-bigint/
What do you think?",1518019203.0
blakflag,"Could track this proposal:
https://tc39.github.io/proposal-bigint/",1518018858.0
elprophet,You might be interested in TypedArrays - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray - which TS supports - https://github.com/Microsoft/TypeScript/blob/master/lib/lib.es2017.typedarrays.d.ts,1518022041.0
indiescripter,"Thanks everyone for your input so far.

Being a stickler for strong typing, I've been working on and off various approaches for typed numbers in TypeScript for well over a year, probably longer.

The approach which I'm most happy with now lets you write TypeScript code like the example below. This is a genuine working, type-checked example that requires a fairly thin library to compile against and to include as a run-time dependency.

I'm rather pleased with and proud of the achievement though I do understand that strongly typed numerics is not something that everyone cares about.

The names of the numeric types supported in my library are based upon the names of the ES2015 Types Array variants except in all lowercase. So there is float64, float32, int8, int16m int32, uint8, uint16, uint32. The float64 type is just an alias for the TypeScript/JS number type.

    function add(x: int32, y: int32): int32 {
      return int32(x + y);
    }

    function price(unitPrice: float32, numUnits: int32): float32 {
      return float32(unitPrice * numUnits);
    }

    function tally(): float32 {
      return price(float32(4.5), add(int32(3), int32(2)));
    }

    console.log('tally=', tally());

Compiles nicely and when run outputs:

  tally= 22.5
",1518088607.0
cspotcode,"`typeof v` extracts the type of a value `v`.  Since `ActionCreators` is a value whose type was determined by inference, its type has no name by which you can refer to it.  So you must use `typeof`.

If you wanted to make the code more clear, you could do `type ActionCreators = typeof ActionCreators;`

`keyof T` generates a string literal union type with every property name from type `T`.  For example:

    interface Foo {
        bar: boolean;
        baz: RegExp;
    }
    type FooKeys = keyof Foo;
    // FooKeys is 'bar' | 'baz'

Finally, when you index a type with a string literal union type, you get a union of the possible values of all those properties.  Building on my example above:

    type FooValues = Foo[FooKeys];
    // FooValues is boolean | RegExp

---

For the most direct solution to your second question, check out the `Omit` helper here: https://github.com/cspotcode/typescript-toolbelt
It lets you remove 'create' from a string union, allowing you to derive a type including everything from an ActionCreator except the `create` method.",1518018708.0
AngularBeginner,https://github.com/prettier/prettier/issues/3561,1517916319.0
cspotcode,"If the JSDoc appears immediately above the `const Avatar` then yeah, it applies to the `const` node.  This makes sense because the documentation applies to `Avatar`.

Your code should traverse the AST checking for `const` declarations, then check the type of the assigned value's AST node.  If the value's AST node is an arrow function, you know you should look at that node.",1517868144.0
calebegg,https://astexplorer.net/ is extremely useful for stuff like this (be sure to set the parser to typescript),1517894328.0
RickyMarou,"I don't think many JS librairies bother with typechecking what you pass to their API (e.g. by using `typeof` or duck typing) so i don't get why it is a problem for TS librairies.

If your consumer uses TS, then awesome they get all the typechecking and goodness of the TS Language Service, if not then they were not even expecting having these in the first place.

If you still want to help them, it really depends on what tooling you want to support.  I guess you could use JSDoc that is partially supported in TS: https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript

You could also manually typecheck and throw explicit errors when types are wrong but it's going to look pretty weird in TS...
",1517829094.0
blakflag,"Would you cut the seatbelts out of your car because some others on the road might not be wearing theirs?  Every arrgument supplied to a JS method has a type at runtime whether or not you're flagging errors.   I assume if it was written in pure JS then you'd have to do all manner of ugly checks at runtime anyway. 

If you're concerned, then code up a nice utility that encapsulates error checking for expected types, and stick it at the head of each public method in your API as a gatekeeper. Easy peasy.",1517833394.0
cspotcode,"JavaScript libraries don't check types at runtime any more than TS.  It's an unnecessary performance hit to do so.  Write proper docs and expect developers to read them.

As a responsible developer, I will read your documentation and use your library correctly.  Do not waste my CPU cycles with runtime type checks!

*Even when* libraries check args at runtime, they're certainly not checking for all possible pitfalls.  JS has too many.  (E.g. prototype quirks, function binding)

Supposing I wanted to write a TS library that performs runtime type checks, the type system would make it easier to do so correctly, providing guarantees that the runtime checks being invoked match the declared types.  TypeScript's decorators and type metadata can even facilitate this in a way that can be compiled-out for production builds.",1517838091.0
vinnl,"Yes, I think this problem is not widely recognised - although as /u/RickyMarou suggests, I think it's a problem for regular Javascript libraries as well. In other words: _most_ libraries assume you not to use their API's correctly.

And it makes sense somewhat. For example, I wouldn't usually expect you to pass `{ valueOf: Math.random }`, even though TypeScript wouldn't prevent you from doing that. That's usually a valid assumption.

That said, you can of course still implement checks for invalid values in your TypeScript code even if the type definitions say they should be impossible.

An interesting related problem is this: when a library written in TypeScript does not use `strictNullChecks`, then its type signature might e.g. say `someFunction(val: string)` when it actually expects `someFunction(val?: string | null)`. Now, if you call that from your TypeScript code that _does_ use `strictNullChecks`, you wouldn't be able to pass it `null` even though that's supposed to be possible.

**Edit:** See [this bug](https://github.com/Microsoft/TypeScript/issues/12615) for the latter issue, although they apparently do not consider it an issue.",1517833755.0
,[deleted],1517854425.0
phoenixmatrix,"This is literally a non-issue. As I can pass any invalid input to a TypeScript function by casting it to any, anybody can pass anything to a javascript function. No one really checks all their arguments: that would defeat the purpose of using a low friction dynamic language if 3/4th of your code was type checks and shape assertions anyway. So there's no difference really.

The only (minor) issue with using a TypeScript api from JS (or vice versa) is that some design patterns are needless, or necessary. Eg: Redux' connect is annoying to use from TS because it does not infer types from the Store without you specifying it (the connect factory would have to be created from the store for that). Vice versa, some TS stuff might have a bit more ceremony from JS because it was meant to infer types (but obviously in JS it cannot)",1517931925.0
indiescripter,"""Crux of the problem. You write TypeScript code based around assumptions that will be erased along with the types in the output JS. We see this in BuckleScript output too."" -- Yawar λmin (@yawaramin on Twitter)
https://twitter.com/yawaramin/status/961386334408474624",1518400914.0
HerringtonDarkholme,"That said, injection via function is still not possible in TS :(",1518060291.0
dpash,"OP is a little confused about what dependency injection is. 

    class Foobar {

        constructor\(foo: Foo, bar: Bar\) {

        }

    }

This is in a DI style. Opposed to:

     class Foobar {

        constructor\(\) {

            this.foo = new Foo\(\);

            this.bar = new Bar\(\);

        }

    }

The following code is just manual DI, but is still DI. DI does not require automated injection.

    const foobar = new Foobar\(new Foo\(\), new Bar\(new Foo\(\)\)\);",1519551676.0
dvlsg,"Cool. Property based testing is pretty sweet (assuming you can actually come up with useful properties for what you are testing, anyways).

I'm not sure I'd say ""instead of examples"", though. It's often useful to do both.",1517678018.0
cspotcode,"The article doesn't mention that you'll need a runtime module loader configured with the same path mappings, be it webpack, require.js, etc.  TS will emit `import`, `require`, or `define` statements with paths that begin with e.g. `@components`.",1517599178.0
Arffman,One issue I've found with this is that the declaration file imports also have the same (original) paths and when these are used in another project TypeScript starts to get confused. A shame as I'd love to have a ~/ path for paths relative to the source root but I also need declarations.,1517600318.0
fredriknicol,I created this mainly for https://github.com/frenic/glitz/ a CSS-in-JS library I'm doing and realized that it could be quite useful for other as well. I'd love some feedback to make it even better.,1517529253.0
guncha,So... the same as React.CSSProperties ?,1517581568.0
brosterdamus,How does this compare to https://github.com/typestyle/typestyle ? ,1517598972.0
itl-lmfao,"Very cool. Just browsing/skimming the codebase. In the genesis Block instantiation, is the hash always hardcoded or will it eventually be generated by a microservce? ",1517534196.0
welkie,Mining cryptocurrency on Heroku is against their Terms of Service.,1517563514.0
cspotcode,"Hahaha, could this possibly look more suspicious?",1517436918.0
ToxicalToast,"reported

will be deleted soon i guess",1517486878.0
Tuhneeshk,bump,1517436822.0
a_simple_pie,Getting the return type of a function like that is going to be awesome for day to day programming and readability. I’d love something similar for positional arguments!,1517436633.0
Arffman,Crazy times when programming in C# makes me sorely missed the typing capabilities and safety of TypeScript.,1517429567.0
So_Brave,Appreciate the smarter object literal inference--definitely something I've ran into a few times.,1517424771.0
ltray,Nice! Looking forward to 2.8. Conditional and inferred types just around the corner.,1517469854.0
j0be,"I actually had to revert to 2.6.2 for this. 2.7.1 caused this nondescript dump

    /usr/local/lib/node_modules/typescript/lib/tsc.js:59841
    throw e;
    ^

    Error: Debug Failure.
    at checkUnusedClassMembers (/usr/local/lib/node_modules/typescript/lib/tsc.js:35757:38)
    at checkUnusedIdentifiers (/usr/local/lib/node_modules/typescript/lib/tsc.js:35643:29)
    at checkSourceFileWorker (/usr/local/lib/node_modules/typescript/lib/tsc.js:37913:21)
    at checkSourceFile (/usr/local/lib/node_modules/typescript/lib/tsc.js:37891:13)
    at getDiagnosticsWorker (/usr/local/lib/node_modules/typescript/lib/tsc.js:37945:17)
    at Object.getDiagnostics (/usr/local/lib/node_modules/typescript/lib/tsc.js:37934:24)
    at /usr/local/lib/node_modules/typescript/lib/tsc.js:59858:85
    at runWithCancellationToken (/usr/local/lib/node_modules/typescript/lib/tsc.js:59834:24)
    at getSemanticDiagnosticsForFileNoCache (/usr/local/lib/node_modules/typescript/lib/tsc.js:59848:20)
    at getAndCacheDiagnostics (/usr/local/lib/node_modules/typescript/lib/tsc.js:60059:26)

Something with the `checkUnusedClassMembers` is breaking my compilation, as turning that off lets it succeed. ",1517508553.0
spacejack2114,"Awesome stuff as always.

Kinda wish `strictPropertyInitialization` could understand this:

    class Foo {
        a: string
        constructor() {
            this.init()
        }
        init() {
            this.a = 'xyz'
        }
    }

",1517431063.0
,[deleted],1517405259.0
,[deleted],1517322081.0
anti-gif-bot,"[mp4 link](https://g.redditmedia.com/obaOkROje9Uxp5DQidM_vK_OuufRJS9dIChxi0BP66g.gif?fm=mp4&mp4-fragmented=false&s=3903ba7f9613ac99205540008e8fe947)

---
This mp4 version is 95.85% smaller than the gif (726.1 KB vs 17.09 MB).  


---
*Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2",1517319673.0
AngularBeginner,"> What's a clean way to ensure type safety without litering my code with a bunch of if else statements?

Generally the best approach is: Don't have `null` or `undefined`.

If that is not possible, you can either use the **conditional operator** like:

    return typeof word === 'string'
        ? word.slice()
        : fallbackValue;

Or if you want to treat empty string as a falsy value too you can use the common pattern (I don't know the name of it):

    return word && word.slice() || fallbackValue;

> Also, why can't TypeScript understand `if (!isEmpty(null))` is also a valid form of typechecking?

That would depend on how `isEmpty` is defined. I don't know where you got this function from. The function could basically do anything.. without ensuring type-safety, so how would TypeScript know?

You can write functions in TypeScript that inform the type-checker that **you** ensured the type of a value, for example:

    function hasValue(value: string | undefined | null): value is string {
        return typeof value === 'string';
    }

    const yourString: string | undefined | null = null;
    if (hasValue(yourString)) {
        // ...
    }

A function returning a *type* of `<parameterName> is <type>`, e.g. `value is string` as in my example, will tell the type-checker that this method ensures that `parameterName` is of the type `type`. The function must return a boolean, either `true` when it is of said type, or `false` if it's not. Then when you call the method in an `if` block, TypeScript will know: The method returns `true` if it's of a said type, so the type-checker can safely assume the type is now narrowed in the if-block.

This means for my example, that within the `if` block the type of `yourString` is not `string | undefined | null` anymore, but instead just `string`, so you can call the methods of `string`.

These functions are called *user-defined is-guards*.",1517298194.0
voidvector,"You normally don't want to pass ambiguous union types through your whole application. Unless the union types has a common base type, it basically means every time you use it, you would need to write an IF statement. 

The better practice is to sanitize and stop propagation of your input or API service calls as soon as you can. 

This problem exists without type safety, but people were just more oblivious about it.",1517316854.0
kasztelan,"If you have strictNullChecks enabled in tsconfig.json you'll get an error in your example

Simply do if(str != null) {} and inside the block ts will be sure it's a string ",1517313838.0
cspotcode,"TypeScript *can* understand `isEmpty` *if* the type declarations are set up correctly.  You didn't say what isEmpty does or where it comes from, so I can only assume you want it to be typed like so:

    function isEmpty(v: any): v is null | undefined | string {}

If you haven't already, look up the bang (`!`) postfix type assertion.",1517323367.0
alsiola,"Just to give another perspective, you could use `Maybe` wrappers around possibly undefined values.  There are plenty of Maybe providing libraries out there, I use [my own implementation](https://github.com/alsiola/alex-utils/blob/develop/src/maybe/maybe.ts).  The idea is that the Maybe encapsulates the concept that the value may or may not be defined, and allows you to safely transform the data.

You would then write a copy function such as the following.  If the encapsulated value is defined (known as a `Just`) then the function is applied, if it is not defined (known as a `Nothing`) then it is not.  Either way a new Maybe is returned, which will contain either the sliced string, or still Nothing.

    function copy(word: Maybe<string>): Maybe<string> {
        return word.map(a => a.slice());
    }

To put this into context, let's imagine we have the variable `person`, that may or may not have a `firstName` property:

    const person1 = { firstName: ""john"", lastName: ""smith"", age: 34 };
    const person2 = { lastName: ""jones"", age: 50 };

We want to get the user's firstname, then if present, capitalize it:

    interface Person {
        firstName?: string;
        lastName: string;
        age: number;
    }
    
    function getFirstName(user: Person): Maybe<string> {
        return user.firstName ? Maybe.Just.from(user.firstName) : Maybe.Nothing.from();
    }
    
    function capitalize(name: string) {
        return name.toUpperCase();
    }
    
    function getCapitalizedFirstName(user: Person): Maybe<string> {
        return getFirstName(user).map(capitalize);
    }

When we want to display it, we need to unwrap the actual value out of the `Maybe`, which we can do with `withDefault`, which allows us to either return the value, or if it is a `Nothing` type then use the default.

    const defaultFirstName = ""NO NAME SET"";
    
    const person1FirstName = getCapitalizedFirstName(person1).withDefault(defaultFirstName);
    // => JOHN
    
    const person2FirstName = getCapitalizedFirstName(person2).withDefault(defaultFirstName);
    // => NO NAME SET

The positives of this approach are that the possibility of a value being not defined is enshrined within your types, so you get great compiler help without having to write type guards and null checks.  The negatives are that you end up with `Maybe`s throughout your code base, which may or may not be a problem for you and your teammates.

",1517356787.0
Devcon4,I normally only write truthy it falsey checks not strick is not null and is not undefined checks. I also hardly use null and use undefined for everything. That is the nice thing about it just being js underneath is you don't have to do tedious things unless you want too. I'll also use double bangs to strictly say I'm checking for a truthy expression Eg if(!!user) { return user.name; },1517364584.0
fecal_brunch,Just don't assign the instance. Remove the private field.,1517283135.0
tme321,">which has side effects, even if I may never use its reference later?

That's your issue right there.  Why would you be creating an object *just* for side effects?  That makes no sense.",1517314143.0
dhruvrajvanshi,"You can make it public. That sounds bad but it's react and you don't usually have instances of components anyway.

But it looks kind of odd. Why are you assigning to the member if you're not reading it?",1517285056.0
,[deleted],1517294569.0
cspotcode,"Awesome!  I've wanted something like this when I'm refactoring, especially when splitting up a project that's grown too big for the one or two files it started in.

I'm on Windows and it's writing full import paths instead of relative paths.  I get `C:\Users\cspotcode\Documents\dev\myProject\src\foo` instead of `./foo`.  Is this a bug?

EDIT: is this the culprit?  https://github.com/stringham/copy-with-imports/blob/master/src/extension.ts#L222  Paths on windows start with something like `C:/`, not `/`.

EDIT2: Yup, that seems to be the problem!  I sent you a PR /u/1stringham",1517284419.0
1stringham,"I created this extension last month, and it has been way more useful than I thought it would be.

I figured it could be nice while refactoring code, but it turns out that everyday tasks like copying and pasting a parameter from one file to another happens a lot.

I used to paste, wait for the yellow light bulb to show up, click on it and select the correct import. Now when I paste it automatically adds the correct import based on the location I copied it from.",1517255408.0
toymachine11861,"I don't think there is a simple solution to your problem such that you can use those tools to turn your .js into .ts.

**Suggestion:**
What if you just move forward with exclusively typescript and keep your old repos .js?

Those projects will still benefit from intellisense of the newer projects. Vice versa, you can just write a library of `.d.ts` files as the intermediary.

The `.d.ts` files will include all the interfaces, return types, etc. of your old es6.  Thatway you can still use your old libraries w/ intellisense and types without refactoring.  Just include the `d.ts` typings module and then boom, your old .js is type-ified.

This solution is also nice because it's incremental– devs can just add the d.ts files as needed.",1517255064.0
cspotcode,"I have a TS-powered codemods tool in development, but it's not ready for production.  If anyone is interested in contributing to such a project, we might be able to work together.",1517286458.0
aocay,"[This article](https://dev.doctorevidence.com/how-to-write-a-typescript-transform-plugin-fc5308fdd943) may be of interest to you. I haven't done any experimenting with transform plugins yet, but it might lead you to some answers.",1517263819.0
blaster151,This is now supported.  Recent commits to recast and ast-types have enabled jscodeshift to work perfectly with TypeScript codebases (make sure to use the flag `--parser babylon`).,1522172228.0
,"I'm afraid I don't have an answer as to *why* it does this, but I believe it is to do with type parameters bounded by union types. Here is a similar problem that doesn't involve indexer signatures: [issue](https://github.com/Microsoft/TypeScript/issues/13995).

In the example you give you can probably just give `key` the type `DictKey`, I don't know if there is much to be gained by using a parameter (but you may need it for other reasons).",1517249193.0
Dw0,It's a circle of life! The synchronized in js!,1517085077.0
cspotcode,Awesome!,1517100627.0
Oeb25,"Got an alternate solution! You could have `ModelOptions` be a property on `Model`, like

    interface ModelOptions { ... }

    class Model {
      options: ModelOptions
      constructor(options: ModelOptions) {
        this.options = options
      }
    }

Then all access to the options would be rough `this.options.columns` and so forth. If the options needed to be copied, that could be done in the constructor.

I personally like this better, due to the fact that it involves composing the types, rather then inheritance. But all in all choose what you like, and what fits your needs!",1517040235.0
ltray,"I realize there are sometimes a need for classes, but can you not do with just using the interface? Can you describe what aspect of being a class it is you need? In the above example, a valid `ModelOptions` has nearly the same properties as the resulting class.",1517018521.0
dbc_,OFFTOPIC: what's your color scheme? ,1517017256.0
,[deleted],1517010871.0
cspotcode,"Yeah... this is a pain point for me, too.  If you want them to be private, I don't have a good solution.  But it looks like you're ok with public properties.

You can append the `class Foo {}` declaration with a `interface Foo extends FooOptions {}`.  That'll copy all options onto the class as public members, so you only need to declare them in the options interface, not on the class.  You can `Object.assign(this, options)` in the constructor.

Maybe Object.assign isn't good enough, for example if you want to whitelist the options.  Decorators to the rescue!

    // Put this in a helpers file somewhere
    const owm = new WeakMap();
    function Opt(target, propName) {
        const a = owm.get(target) || [];
        owm.set(target, a);
        a.push(propName);
    }
    function setOptions(instance, opts) {
        for (let propName of owm.get(Object.getPrototypeOf(instance))) {
            if (opts[propName] !== undefined) instance[propName] = opts[propName]; 
        }
    }

    // And write your class like this:
    import { Opt as O, setOptions } from './my-helpers';
    class BarOptions {
        @O bar: string;
        @O baz: string;
    }
    interface Bar extends BarOptions {}
    class Bar {
        constructor(opts: Readonly<BarOptions>) {
            setOptions(BarOptions, opts);
        } 
    }
",1517015909.0
wordlimit,Maybe a mix of `constructor(private foo)` syntax and object spreads could help?,1517043100.0
cspotcode,"Looks like the compiler exposes diagnostics via separate methods `getSyntacticDiagnostics` and `getSemanticDiagnostics`, so this should be possible.

The tools I've looked at so far -- ts-loader, awesome-typescript-loader, and fork-ts-checker-webpack-plugin -- lump all diagnostics together, but it looks straightforward to send them PRs for the option I'd need.",1516848661.0
mendrique2,In feather-ts (my framework) I do it so that for each instance decorator I Have a class that needs to be extended. In a weakmap I store the decorator data and in the super constructor I run the logic. you can also store the property name then there is no need to follow the prototype chain when applying the decorator logic.,1516828682.0
cspotcode,"Sounds like a string index.

    interface IntermediateStructure {
        /** Key is JSON.stringify-ed participants array; value is array of location strings */
        [stringifiedJson: string]: Array<string>;
    }

I know this is not your question, but if you want some pointers on implementing TypeScript piecemeal, I'm happy to help.  Since TypeScript errors never prevent or affect transpilation, you can actually rename your entire codebase from .js to .ts and everything will still compile the same.  Even with type errors, compilation will give you the same .js.  It seems to me that starting in TypeScript will save you effort in the long run and should be great for prototyping as well.",1516737035.0
rco8786,"Can’t you just a use a Map<string, Array>?",1516804953.0
,[deleted],1516660874.0
rwbcxrz,"A lot of these seem fairly obvious (to me, at least), but I think they're worth stating anyway.

One point I disagree with is on ""trivial"" selectors. If you end up changing your state shape, it can be a lot less tedious to refactor a few selectors than to refactor every reference to that part of the state. Having selectors also makes it a lot easier to introduce a library like reselect (or some other strategy for memoizing state access).",1516660273.0
Lakston,Do you have a starter or boilerplate to see how you set up typescript with webpack and react ?,1516693423.0
Mattonicide,"I'd love to see your thoughts on sagas/selectors, especially since my sagas tend to touch other things (like issuing notifications etc). And by the time all that logic is introduced, it's way too much for one file imho. 

What I end up doing is creating a feature folder, that is responsible for a slice of state. Issue I'm running into is that I end up having to pass that slice of state into the selectors instead of the root state since they shouldn't know how state is organized overall (not a huge issue, just bugs me sometimes), and sometimes i have overarching selectors that need access to more than just their slice of state to be useful, so where should those go?

Anyway, some great concepts here, and like I said I'd love to see it expanded upon. ",1518310321.0
AngularBeginner,This will finally allow `DeepReadonly<T>`! Can't wait for.. I guess TypeScript 2.8.,1516607276.0
R4p354uc3,"This is a game changer. It's awesome to finally see typescript implement some advanced functionality like this. Combining this with mapped types, the possibilities are innumerable.",1516605748.0
cspotcode,"Nice!  This looks like it gives us similar type resolution behavior to overloaded functions, since they do the same ""If argument types match this signature, then return type is this, otherwise try one or more other overloads.""",1516588503.0
mbrodersen,This is a step towards Dependent Types (as implemented in Agda/Idris etc.) I hope Anders realize this and plan accordingly so that we don't end up with random ad-hoc syntax for subsets of Dependent Types.,1516775368.0
night_of_knee,"I don't understand the following:

>     type BoxedValue<T> = { value: T };
>     type BoxedArray<T> = { array: T[] };
>     type Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;
>
>     type T20 = Boxed<string>;  // BoxedValue<string>;
>     type T21 = Boxed<number[]>;  // BoxedArray<number>;
>     type T22 = Boxed<string | number[]>;  // BoxedValue<string>  | BoxedArray<number>;
>
>Notice that `T` has the additional constraint `any[]` within the true branch of `Boxed<T>` and it is therefore possible to refer to the element type of the array as `T[number]`. Also, notice how the conditional type is distributed over the union type in the last example.

In the `Boxed` type definition, in the true path its defined as `BoxedArray<T[number]>`, what does the `number` part mean? 

I see that Mr. Hejlsberg is trying to explain it but I don't understand the explanation (perhaps I'm missing some prerequisite).
",1516616725.0
cspotcode,"Here's the solution.  Try it out and let me know if it works or if anything is confusing.

    // Implementation omitted because it's not relevant to explanation
    // Use generics.  This says ""T must be Dict or a subtype of Dict"" 
    function ObjectFromPropKeysFactory<T extends Dict>(obType: T): PropKeysBoolean<T> {
        // implementation omitted
    }

    // Do not annotate as Dict.  Doing so would strip all type information and replace it with Dict.
    let objectFromInterfaceWithIndexType = {
        a: 'a',
        b: 'b',
        c: 'c'
    }

    let objectWithKeysFromInterface = ObjectFromPropKeysFactory(objectFromInterfaceWithIndexType);
    // Type information preserved.  If argument does not conform to requirements, above line will show a type error

### Problems with your original code:

By declaring the type of `objectFromInterfaceWithIndexType` as `Dict`, you are stripping all inferred type information from that object.  Even though the compiler can infer it as an object with three properties a b and c, you've explicitly overridden that inference with `Dict`.

Also, `ObjectFromPropKeysFactory` is not enforcing the `Dict` type restriction for its argument.  Functions are usually declared with types for their arguments.  Since you're using generics, you must use `T extends Dict` to apply a type constraint to your argument via `T`.

If you still *really* want to enforce the right type at the variable's declaration site, there are ways to do that, but it's a weird choice since the function can and should do the same enforcement.

EDIT: formatting",1516587671.0
,"I'm abit confused on what you mean in point 2.

Do you mean that you want to be able to give T (the input type to the function) some constraint to stop users supplying something that isn't an object with fields? Do the fields have to be the same type?

Could you give an example of a program you want to reject because it is not 'correct' in some sense?

You can put a constraint on type T, but I'm not sure that's what you want:

    type PropKeysBoolean<T> = {[K in keyof T]:boolean};
    
    interface Dict {
        [key: string]: string
    }
    
    function ObjectFromPropKeysFactory<T extends Dict>(obType: T) {
        let objectWithPropKeys = 
    
        Object.getOwnPropertyNames(obType).reduce((acc,curr)=>{
            acc[curr] = true;
            return acc;
        }, {});
    
        return (objectWithPropKeys as PropKeysBoolean<T>);
    }
    
    let objectFromInterfaceWithIndexType = {
        a: 'a',
        b: 'b',
        c: 'c'
    }
    
    let objectWithKeysFromInterface = ObjectFromPropKeysFactory(objectFromInterfaceWithIndexType);
",1516578210.0
ryansworld10,"Look into the built-in Record<K, V> type. You would use it like this: Record<keyof TypeWithPropKeys, boolean>. For enums, you could drop the keyof bit and it will use the values of the enum instead of the property names.",1517511444.0
citycide,"I just put a beta on npm for the v2 release of trilogy, which is now written in TypeScript. trilogy is a simple & extensible library for dealing with a SQLite database. It's not an ORM and it won't become one since no relationship features are going to be added. A killer feature is equal support for native `sqlite3` and pure-JS `sql.js` as the backend.

This release is a pretty big code change so before the final release there are 2 things I'm hoping to get feedback on or contributions for: the use of TypeScript and the newly added plugin system. This is my first project in TS and it's been great so far.

The code for this release is currently on the [next branch](https://github.com/citycide/trilogy/tree/next) and there's an [issue](https://github.com/citycide/trilogy/issues/81) and a [PR](https://github.com/citycide/trilogy/pull/82) open for discussion & reviews.

If you want to try it you can do:

    npm i trilogy@next

Thanks!",1516560109.0
R4p354uc3,"As you probably came to realize, it was because of how you were exporting the value.

In the first example, you are setting the entire module's export value to the value of the config.

In the second example, you are exporting the value of the config under the *named* export `config`.

In order to be able to use `import * as config from './config'`, you can only do it the first way.

If you want to be able to export and declare the config on the same line, you can either do it using the second example, which would require `import { config } from './config'`; or you can export the value as default, as in `export default const config = ...`, and import it as in `import config from './config'`.",1516559335.0
schlenkster,"Isn’t that only marking one instance of Props as readonly? I wouldn’t call that a readonly interface, as it isn’t tied to the interface. You’d have to remember to do that each time you create a new instance of Props. ",1516473103.0
briangonzalez,"This is a contrived example with two properties.
In the real world, interfaces often grow to 10+ props and this is where this method really shines. ",1516507661.0
AngularBeginner,"Besides it not supporting nested objects, it also does not support arrays. You still have to remember to use `ReadonlyArray<>` instead of arrays. The `Readonly<T>` is a poor half-thought solution.",1516604200.0
briangonzalez,Ohhhh. Neat. How do you know this?,1516659874.0
,"IMO

    interface Props {
      readonly firstName: string
      readonly lastName: string 
    }

is more readable than

    interface Props extends Readonly<{ firstName: string; lastName: string }>


What do people think to

    interface MutableProps {
      firstName: string
      lastName: string 
    }
    type Props = Readonly<MutableProps>",1516486350.0
IZEDx,"The conclusion felt like an ad for Reason, more than the conclusion of a comparison.",1516448448.0
spacejack2114,"In the first example Typescript could behave a bit more like Flow, even with noImplicitAny:

    let x
    x = 1
    x = 'c'

Though rather than being type `number | string`, x is `any`.",1516478739.0
AngularBeginner,"Oh no, you found a bug in Deep Thought!",1516427694.0
sickcodebruh420,"I didn’t have a great experience when trying to use TypeScript with Sequelize in the past. I seem to remember a lack of generics when defining models. Is this new, was I doing something wrong, or am I just remembering it wrong? What about things like associations? Are the typings strong?",1516421089.0
AngularBeginner,"> db.sync().then(() => { ... });

This confuses me.",1516428252.0
corgrath,"If you care about code quality, you type check JavaScript.

TypeScript or Flow, I don't care, as long as a compiler/transpiler tells the developer exactly what broke in the entire project by changing a function return type.",1516389201.0
EricTboneJackson,"> Use inference where possible so you don’t have to maintain a lot of type-specific code.

If you use inference ""wherever possible"", you lose the advantages of having a type system in the first place. You should only use inference when it doesn't cost you type safety.

For instance, you can leave the return value off a function/method definition and let Typescript infer it, but now the compiler can't tell you if you fuck up and accidentally return an unintended type.

For example:

    function supposedToReturnAString(value: number) {

        // bunch of code
        return value.toString();
        // bunch of code

        // oops, left off parentheses here, so we're return a function,
        // which is perfectly legal since we didn't tell the compiler this
        // function should return string
        return value.toString
    }

Most code *is* type-specific and should be annotated accordingly.",1516498704.0
,"> Use inference where possible so you don’t have to maintain a lot of type-specific code. In my experience, this is an area that Flow shines in – you don’t need much type code for it to infer almost everything.

Would it be reasonable to say that when you rely on inference, you're still maintaining type-specific code, but instead of the specification being explicit it is now implicit in the inferred types. If the inference engine changes and gives you different types you still have to deal with the potential fallout from that.

I can't speak for Flow, but I also find error messages in TS come out much cleaner when the program has explicit type annotations.",1516404090.0
21October16,"`await` takes a `Promise`, but you pass a `Subscription` (result of `subscribe()`) which is transformed into a already resolved promise. This should work better:

    let returnVal: Feed = await this.http.get(url)
        .map(res => res.json())
        .toPromise();

together with `try` `catch` for the rejected case.",1516387836.0
Lakston,"Seems like the interviewer suffered a stroke during the interview :

> How to compile a Typescript file?

Easy, answers...

> What do you understand by classes in Typescript? List some features of classes.

Answers question

> Is Native Javascript supports modules?

That question doesn't make sense, I guess he wants to know if native has modules, I'll answer that

>How to compile a Typescript file?

I just told you
>Explain Classes in Typescript? List some features of Classes?

Sir, are you ok ?

Also, some answers are just plain wrong, save some time, don't read that article.",1516367566.0
bencoveney,"There are 20 questions but the answers seem to only go up to Q12?

Also I think some of the expected answers are a bit questionable:

> Q1. What is Typescript? How is it different from javascript?

> A: JavaScript is an scripting language whereas Typescript is an object oriented language.

You can do OOP in JavaScript, you can do scripting in TypeScript. They have almost the same capabilities (outside of syntactic sugars, type constraints) because they both run in the same way.

> JavaScript has no optional parameter  feature while Typescript has optional parameter feature.

    function parameters(optional) {
      console.log(`optional ${arguments.length > 0 ? ""was"" : ""wasn't"" } provided`);
    }

    parameters(); // optional wasn't provided
    parameters(""hello""); // optional was provided
",1516366167.0
trevorsg,"Well obviously these questions are no good, but what are your favorite TypeScript interview questions? If someone says they are familiar with TypeScript, I always like to ask, ""What is one thing you would change about TypeScript?"" (or a variant thereof: ""feature you would add"", ""criticism you have"", etc.)",1516370021.0
TechnoCat,"Some of this is okay, but there is a lot incorrect about it and is pretty misleading.",1516374016.0
PassItOnBro,A lot of these questions gauge the knowledge of a particular technology (in this case TypeScript); they do nothing to measure the knowledge of software development. ,1516372235.0
uvimateapp,Thanks for the great post! Your QAs have been added to the **https://www.fullstack.cafe** portal and back-linked!,1530105751.0
,[deleted],1516295226.0
synalx,"Actually, the mutability of `OPERATORS` isn't the issue here, it's the type. `OPERATORS` has type `{EQUALS: string, NOT_EQUALS: string}`. In order for narrowing to work, you want it to have type `{EQUALS: '=', NOT_EQUALS: '!='}`.

So declare it that way:

    const OPERATORS = {
      EQUALS: '=' as '=',
      NOT_EQUALS: '!=' as '!=',
    };

Now not only does comparing against `OPERATORS.EQUALS` narrow values properly, but you're protected from accidentally assigning anything other than `=` to `OPERATORS.EQUALS`.

[Playground example](https://www.typescriptlang.org/play/#src=const%20OPERATORS%20%3D%20%7B%0D%0A%20%20%20%20EQUALS%3A%20'%3D'%20as%20'%3D'%2C%0D%0A%20%20%20%20NOT_EQUALS%3A%20'!%3D'%20as%20'!%3D'%0D%0A%7D%3B%0D%0A%0D%0Ainterface%20Thing1%20%7B%0D%0A%20%20%20%20operator%3A%20'%3D'%2C%0D%0A%20%20%20%20value%3A%20number%0D%0A%7D%0D%0A%0D%0Ainterface%20Thing2%20%7B%0D%0A%20%20%20%20operator%3A%20'!%3D'%2C%0D%0A%20%20%20%20value%3A%20string%0D%0A%7D%0D%0A%0D%0Alet%20myObject%3A%20Thing1%20%7C%20Thing2%3B%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'%3D'%2C%20value%3A%202%20%7D%3B%20%2F%2F%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'%3D'%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20Not%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'!%3D'%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20'!%3D'%2C%20value%3A%202%20%7D%3B%20%2F%2F%20Not%20Okay%0D%0A%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.EQUALS%2C%20value%3A%202%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.EQUALS%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Not%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.NOT_EQUALS%2C%20value%3A%20'x'%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Okay%0D%0AmyObject%20%3D%20%7B%20operator%3A%20OPERATORS.NOT_EQUALS%2C%20value%3A%202%20%7D%3B%20%2F%2F%20EXPECTED%3A%20Not%20Okay%0D%0A%0D%0AOPERATORS.EQUALS%20%3D%20'!%3D'%3B%20%2F%2F%20Not%20Okay)",1516307988.0
cspotcode,"Do us a favor and post a more complete code example, preferably with a link to the TypeScript playground.  For example, you omitted your declaration of `myObject` and `CONSTANTS`, so please include them.  They affect the answer.

Our response will make a lot more sense based off of a complete example.  Thanks!",1516285650.0
buu700,Looking forward to `--strictPropertyInitialization`! I've got a lot of pre-strict-null-checks code that needs exactly this. The recent typing strictness improvements have been great.,1516234490.0
dvlsg,"> Fixed Length Tuples

Can we use the spread operator with tuples to use the values as function arguments with this change?",1516245014.0
pe8ter,What in the world is going on in the `instanceof` section? What do any of the comments mean?,1516250997.0
kevindqc,What's the difference between using 'undefined | boolean' vs 'boolean?' ? ,1516290386.0
Voidsheep,"I love the narrowing change, if I understand it correctly.

Recently worked on a project with API that sends a ton of conditional fields based on a type field (e.g. fields 1, 2, 3 for type A, fields 1 2, 4, 5 for type B and so on).

It was initially a mess with tons of checks for property existence everywhere, so I started refactoring it to concrete types without any conditionals like 

    interface Item {
      field1: string
      ...
    }

    interface ItemA extends Item {
      type: 'A'
      field2: number
      ...
    }

    type ItemAny = ItemA | ItemB | ...

I imagined I could then just check for the `type` field value on `ItemAny` and TS could figure out the specific type with appropriate fields, but no such luck and I end up just doing `as ItemB` manually after each check. With this change, it should just work, right?",1516304271.0
kingdaro,"- Since you're exporting a default, the correct syntax to import it would be `import template from '...'`, without `* as`. Look up more details on ES6 modules for why this is the case.
- Instead of specifying the template as a type you'll want to pass it as a value instead.
- The decorator is missing.

From the looks of it, since you're giving an `el` property here, it looks like this is supposed to be the root instance of the app. The `@Component` decorator is only available for Vue components, and can't be used to create instances. I might be wrong on that, but you should probably go with a normal instance anyway to save the trouble.

With that in mind, here's what the working code should look like:

    import Vue from 'vue'
    import template from '../Detail/detail.html!text'

    new Vue({
      el: '#app',
      template,
    })
",1516164452.0
cspotcode,"Cannot find name `Template` because you're using the identifier as a type, but you imported a value.  Did you mean to say `template = Template;` instead of `template: Template`?",1516174568.0
cspotcode,"Even with those errors, it is still transpiling and emitting .js files.  Does that work for you?",1516122622.0
ForAllThat,"You could enable the ""allow js"" option for now, so it will not complain about files that are not in Typescript yet.",1516120571.0
cr125rider,as any all the things. That sounds rough man good luck!,1516167704.0
kxerr,"Sounds hellish!

Refactoring a bohemith js codebase into multiple TS microservices takes some of this pain away.",1516583334.0
anomaly-,"Don't even bother. Keep your frontend code outside of VS, and use vscode for it instead. You'll have a much better time.",1516056665.0
zzing,Glad to see something like this!,1516046634.0
MosquitoD4K,"I would just use antlr, it works like a charm.",1517644330.0
bidi82,"That may be defeating the concepts of inheritance as 
Your interface C is **not** more specific (I.E Dog ""is an"" animal).

So if you provide an ""instanceOf"" C to a method that can accept type ""A"" the constraint of the expected type of the property will not be met.

",1516033805.0
,[deleted],1516046918.0
AskYous,This is cool!,1516051520.0
hthouzard,"This one is excellent:
https://typescriptcourses.com/",1516046149.0
cspotcode,"I don't quite have an answer for you, but here's what I can offer:

Generics are stripped when you assign to `const promisifiedTrack` because the return type of `promisify` is not declared to be generic.  When you invoke `promisify`, `Input` and `Output` are bound to `{}` for lack of a better type.  (because the only way to bind them is to pass a value to `track`, but track isn't being invoked)  So inference is finished even before you invoke the `promisifiedTrack` function.

The simplest way around this is to declare a generic function signature for `promisifiedTrack` when it's assigned.

    const promisifiedTrack: <T>(x: T) => Promise<T> = promisify(track);

This accomplishes the same thing as your `promisifiedTrackFixed`.

Here's one possible reason this situation is not supported.  Consider the following declaration of `track` using function overloading:

    function track(x: number): string;
    function track(x: Window): boolean;

How should `promisify` bind the `Input` and `Output` generic parameters?

If you know you're going to promisify functions that return the same type as their argument (a.la `track`) you can do this:

    function promisify<Fn extends <T>(i: T) => T>(
        fun: Fn
    ) {
        return <T>(i: T) => Promise.resolve(fun(i));
    }
    
    const promisifiedTrack = promisify(track);
    promisifiedTrack(new Foo()).then(x => x.bar());",1515972397.0
kingdaro,"It looks like it's an issue with the depth levels of generics. It seems to work fine if `track` is defined as `function track(x: Foo): Foo`.

There're always places to improve inference, so consider opening one up on the TS repo and they'll take a look at it.",1515969970.0
AngularBeginner,"Not an answer to your question, but related: Consider using `prettier` to just automatically format the source code according to your own configuration. No dev wants to deal with silly formatting rules, stuff like this should really be automated.",1515775510.0
demoran,https://palantir.github.io/tslint/develop/custom-rules/,1515793053.0
fecal_brunch,"I don't know what ng2-packager is, but the import paths you want are supported by exporting those classes from files in your npm module. Either `/models/index.js` or `/models.js` where `/` is the directory containing `package.json`.",1515770676.0
tme321,In the tsconfig for your library create a paths entry that points directly at your public api file.,1515870043.0
bidi82,"I would define a new d.ts file that re-imports and re-exports the relevant APIs.
This would have to correspond to how your ""common"" package exports
the combined namespaces at runtime.

For example:


    import {IMyModels} from ""..."";
    import {IMyServices} from ""..."";

    // assumes your common package exports properties named models/services.
    export const models:IMyModels;
    export const services:IMyServices;

    export as namespace MyCommonPackage

",1516028948.0
BeanzPatio,"As an aside, I would highly recommend people checkout [create-react-app-typescript](https://github.com/wmonk/create-react-app-typescript)",1515728036.0
cspotcode,"`export` statements must be static and top-level.  This is an ES6 rule, not specifically a TS restriction.  (when they're within a TS namespace, they have to be static and top-level within the namespace)

    export let now: () => number;
    if(someConditional) {
        now = /* function implementation here */;
    } else { // ...
",1515526792.0
cspotcode,"I'm pretty sure it's purely a style choice.  The ES6 import/export spec basically requires them both to behave the same way, performance-wise.

If TS is transpiling to CommonJS or AMD, the emitted code for `import *` and `import {}` will look identical.  Imports are always referred to via property access, even when using the `import {}` syntax.

For example:

    import {Foo} from 'foo-lib';
    import * as BarLib from 'bar-lib';
    alert(Foo);
    alert(BarLib.Bar);

...transpiles into:

    var foo_lib_1 = require(""foo-lib"");
    var BarLib = require(""bar-lib"");
    alert(foo_lib_1.Foo);
    alert(BarLib.Bar);
",1515462975.0
tehdog,`import {x} from 'lib'` might have advantages if you're doing [tree-shaking](https://webpack.js.org/guides/tree-shaking) but I'm not sure if that stops working with `import *`.,1515439992.0
AngularBeginner,"There's no mention of the official sources that globs are supported. The first article likely used a functionality of his shell, not of the TS compiler.

I'd suggest you to not do it this way anyway. The better approach is to have a `tsconfig.json` in your project folder. In this file you can define your files you want to compile (if the default does not match your needs). That configuration does support globs.",1515438703.0
cspotcode,"if you're using bash, the shell will be expanding those globs, since this is how Unix handles globs.  However, bash does not by default understand `**` globs.  So your `./src/**/*.ts` will be treated like a `./src/*/*.ts`.  Try `echo ./src/**/*.ts` and see what bash shows you.

To enable `**` globs, you must enable ""globstar"" globbing.

    echo ./src/**/*.ts # fails
    shopt -s globstar # enable globstar recursive globbing
    echo ./src/**/*.ts # see if there's a difference

http://www.linuxjournal.com/content/bash-extended-globbing
https://unix.stackexchange.com/questions/49913/recursive-glob",1515462383.0
akdor1154,"I would strongly recommend to not publish the library as pure typescript, it's not a common pattern and you'll likely run into frustration. Number one is that your compilation settings for library and project will be unable to be set independently, and you might run in to trouble trying to update to a new typescript version.

Instead, compile and publish the compiled library with `declaration: true` in tsconfig, and `main: compiled/file.js`, `types: compiled/file.d.ts` in package.json.

This is definitely what you should do if publishing to npm at large, and good practice to follow even for internal projects.",1515416376.0
Dean177,"Check out a couple of my repos, in particular the package.json and tsconfig.json files:

https://github.com/Dean177/with-url-state
Or
https://github.com/Dean177/create-reducer-extra

Should give you a decent guide
",1515453631.0
BeanzPatio,"I’m working on a package to help with this! It’s called [create-typescript-package](http://github.com/ncphillips/create-typescript-package). The goal is to be able to develop and publish Typescript packages with zero build configuration. This projects pretty new, so if you check it out feel free to open an Issue or submit a PR if you run into any problems!",1515469504.0
bidi82,"You will publish your library to npm **after** compilation.
That is your responsibility as you cannot assume consumers of your library know/want to compile your library.

So from a **runtime** perspective consumers will be using a plain JavaScript library and the fact it was written in TypeScript is irrelevant.

For consumers that also use TypeScript and want to take advantage of Type Definitions you will need to export a d.ts file with your library definitions and point to that file in your library's package.json ""types"" field.

See: 
* https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html

Once your npm package includes both the d.ts definitions and the reference from the package.json. the TypeScript compiler used by consumers will automatically resolve the types during imports. 

",1515766639.0
rodrigoelp,"Hi u/pentafloppy,

It depends on how your library is published and how you are importing it into your code.

If your library is going to be part of the compilation, then you do not need the type definition as the type information is already included in each module you import. It would be the same as you writing another ts/tsx file

If the library is imported as part of your node modules and the source code contains just the us files you need to d.ts file to give you the type definition for typescript to work. Alternatively, you could declare the module you are importing as ‘any’ and typescript will ignore the type information and try to work just like JavaScript would.",1515412893.0
k1r0s,"Just write your library using TS but you should only ship compiled JS and, of course, typings. That's the best. ",1515932263.0
turtlecopter,This could be used as a great learning tool!,1515379887.0
BeanzPatio,"I’ve had a hard time finding approachable examples. VSCode and RxJS may be he ones I’ve looked at the most.

As a bit of an aside, I’ve been working on [create-typescript-package](http://GitHub.com/ncphillips/create-typescript-package). The goal of this project is to let people write NPM packages in Typescript with zero build configuration. This will let you spend your time writing great Typescript, rather then fiddling with rollup or webpack.

The projects still pretty new, so if you check it out feel free to open some issues or PRs.",1515502431.0
martijndeh,This started as a proof of concept. I'm really enjoying the type safety features this project enables so we're going to work on a getting a production release out. I like the public API so far. What do you think?,1515229499.0
voidvector,You can add a schema importer to make the table names and columns strongly timed as well. That's what [jOOQ](https://en.wikipedia.org/wiki/Java_Object_Oriented_Querying) in Java does,1515238579.0
spacejack2114,How would this compare with knex (which has type definitions)?,1515364349.0
spacejack2114,I think your tsconfig needs the `strict` or `strictNullChecks` option.,1515197691.0
GoSubRoutine,"AFAIK, all JS variables are initialized w/ `undefined` by default.",1515195819.0
ower89,Great to see the first TS Conf! Also great date and location because it is very close to the Microsoft MVP Global summit :),1515368795.0
nudi85,Are the sessions being recorded?,1516832391.0
EvilFe,"In your db.ts, try replacing `exports.connect = function(cb) => { ... }` with `export function connect(cb) => { ... }`  
Look here for an [js to ts introduction](https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html) ",1515091077.0
tombpss,"I usually use mapped types to pull this off:

    type RGB = ""r"" | ""g"" | ""b"";
    type RGBMap = {[I in RGB]: string};
    var rgbLabel: RGBMap = {
        r: ""Red"",
        g: ""Green"",
        b: ""Blue""
    };

The compiler won't let you forget a string or add one that isn't part of the union. Works on enums too.
",1514935993.0
johnfn,"The best way to do this is to have a function that takes a variable of type never (the body can be empty), and then call that function, passing in the variable you want to check, after you've handled every case. If you later add a case, the variable won't be type never any more, it'll be the type of the new case, so it'll cause a type error until you handle it. 

Search this page for assertNever: https://www.typescriptlang.org/docs/handbook/advanced-types.html. One of the most useful things I've learned about Typescript recently.",1514952459.0
Useless-Pickles,"New feature: Unexpected values are now detected at runtime, and a helpful error is thrown with the unexpected value. This default behavior can be overridden with an optional ""handleUnexpected"" handler in the visitor or mapper implementation.

This is useful for processing values from external data sources (like data from an API) that isn't 100% guaranteed to match the definition of your string enum or strign literal union type.",1517552697.0
cloudify,"This is a great approach, I've implemented something similar [here](https://github.com/teamdigitale/digital-citizenship-functions/tree/master/api), it's much simpler, it generates TypeScript models from a Swagger API definition, it also uses [io-ts](https://github.com/gcanti/io-ts) for validation. So you basically get parsing + validation automatically from a Swagger API definition.",1514951919.0
markprobst,"Dear TypeScripters,

I recently gave a presentation at the San Francisco TypeScript meetup on [quicktype](https://quicktype.io/), a tool for generating static types from JSON, JSON Schema, and GraphQL.

We've also recently released a [Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype) that lets you paste types from JSON.  If you find it useful, or useless, please let us know - we love constructive feedback.

Cheers!
Mark",1514926591.0
mrmizx,"I replied to your stack overflow post the best I could using my phone. I won't have access to a computer for another couple days, but hopefully it's enough to keep you going!",1514919112.0
cloudify,"Author here, happy to hear your thoughts on this technique.",1514883774.0
rheadit,"should give you a TS2322 compilation error. you have ""strict"": true in your tsconfig?",1514852359.0
heinbau,"This seems to be opinion based... so I think it rocks! I haven't had any issues and there is great community support around typing.

On a more serious note: are there any use cases you are curious about? I can speak more specifically if you do :)",1514863655.0
FartingWithASmile,"Since TypeScript grew to encompass basically every feature of Flow, there is now the question of how finished and reliable they are as products, and TypeScript wins easily. Much bigger ecosystem and community too.",1516401759.0
qm3ster,Is this a typo and OP meant Flow instead of ReasonML?,1529586661.0
sanex3339,"JavaScript obfuscator is a powerful free obfuscator for JavaScript and Node.js with a wide number of features which provides protection for your source code. 

It gives many obfuscation features like dead code injection, control flow flattening, strings encryption.",1514813954.0
,[deleted],1514818269.0
pokemonDevGuy,Have you considered jss?,1514571169.0
kingdaro,"You might want to use a library like [emotion](https://emotion.sh/). Autocomplete is less cumbersome to set up with a CSS-in-JS library, since TS understands TS syntax better than CSS syntax.

For CSS autocomplete in emotion, you can use [this typescript plugin](https://github.com/Microsoft/typescript-styled-plugin). Also noting you can do pretty much everything in emotion's style syntax that you could do with SCSS, including variables (in JS), interpolations (in JS), color shifting functions (in JS), self-references, mixins (in JS), and so on.

If you want classes to be accessible globally, you'll either have to write them normally with CSS, or you can use the [injectGlobal](https://github.com/emotion-js/emotion/blob/master/docs/inject-global.md) helper.

If you still insist on using normal CSS/SCSS files... as you can tell, it's not easy (and probably not worth it) if you still want to reap the benefits of TS.",1514571852.0
thepointer,It's worth checking out https://github.com/typestyle/typestyle to have a look at that approach.,1514579406.0
cloudsourced285,Just a heads up. Make sure you are no longer using typings and using the @types packages from npm. I find most packages have types either included or can be found in npm,1514532499.0
insulind,"I'm new to typescript and I've just finished reading 'Pro Typescript'. The author had a section on typings saying what I thought were some.good points.

1. Make sure it's worth your time. Will it actually help your work flow?
2. Do it iteratively - just do the top level stuff you are calling into and then go round again and add even more type info, using either your own code to inform type info or the libraries documentation. Do this until it stops being useful or there's no more to do. 
3. If you think you've done something of use to others then put a PR into the Definitely Typed git repo",1515315392.0
tme321,"Personally I wouldn't write any definitions for packages that don't have them.  I'd either find a different package or just use a declare var Foo: any if I *had* to use an untyped package.
",1514525149.0
mugwumpj,"I add ""readonly"" to all of my interface properties.  Then, TypeScript treats those types are immutable.  This means I don't need ImmutableJs or classes.

Reselect is still a good option. Selectors are an abstraction layer that decouples the state implementation and the react components.  The memoization from Reselect can reduce the number of unnecessary react renders.



",1514396906.0
Arthelon_,Thought this was the name of a library. Had me scared for a few seconds.,1514429999.0
rco8786,"Nothing in your `constants` folder is a constant.  I don't really have any other feedback b/c I'm not entirely sure what you're asking, but I just noticed that.",1514394904.0
squiffs,"Looks like there are 8 instances of something being typed as `any` in `src/` - that's a bunch of nails sticking out that could be hammered down.

I also saw a lot of e.g. `typeof CounterListStore` which is something I haven't come across, is it a way to get around ImmutableJS annoyances?

I can see some things in the usage of reselect that can be improved e.g. [selectCounterFromRoot](https://github.com/cantux/typescript-react-redux-reselect-immutablejs/blob/fe02d2ac11c01cc99f9c25c2899c975e3de9da97/src/selectors/counterList.ts#L27). First, the output of `createSelector` is already a function of `state` and `props` so you don't need to have the outer function. This would probably remove other weirdness from e.g. [selectCounter](https://github.com/cantux/typescript-react-redux-reselect-immutablejs/blob/fe02d2ac11c01cc99f9c25c2899c975e3de9da97/src/selectors/counter.ts#L7).

Something like [selectCounterListFromRoot](https://github.com/cantux/typescript-react-redux-reselect-immutablejs/blob/fe02d2ac11c01cc99f9c25c2899c975e3de9da97/src/selectors/counterList.ts#L8) is the same as `getCounterListFromStore` so no need to wrap it up in a selector. Unless `state.get('counterList')` is somehow slow you don't need to memoize it.

I'll second the use of `readonly` to help avoid ImmutableJS although I didn't look too hard at what data structure you were using.",1514396478.0
Useless-Pickles,Crap. I should have linked directly to the README. I’ll delete and repost...,1514039113.0
pobbly,"I never use classes these days. Just unions, generic interfaces, and functions. It's very flexible and you don't end up with unwieldy hierarchies. You can also sort of emulate type classes. So yeah FP style I guess.",1514055482.0
diverightin63,Had a few apps where I just used interfaces for models returned from REST APIs. Switched to using classes and it's been amazing - love having getters and whatnot to nicely wrap up model-specific behaviors.,1513975617.0
tanguy_k,"Don't know about Vue, but for React everything (100%) is typed and well recognized including JSX.",1513949958.0
Bloompire,"While I like Vue framework more than React, when it comes to TS integration, Vue is far far behind React. In Vue you have some things strongly typed, but a lot of things typed as `any` - this is because Vue uses various ""hacks"" to work like calling vuex methods by string, using their own object literal structure instead of classes etc.

React uses standard ES6 things like classes or reducer functions which are easy to provide type for; also, React uses JSX files which are natively supported by TypeScript in form of TSX files, with stronly typed component properties, etc.

React is strongly typed completely, that is stores, component code and component ""templates"" (render functions) - everything is typechecked. In Vue, you are working with partial typechecking instead.",1514296239.0
Rhyek,I've used both react and vue with TS. Vue is finicky at best. React would be the way to go. ,1513951257.0
ezio93,"Typescript support was dramatically enhanced Vue 2.5 onwards. There are official types available for vue, vuex, vue-router etc.

Been using Vue with TS in production at a medium sized company and it has been phenomenal.

I highly recommend using [vue-class-component](https://github.com/vuejs/vue-class-component) ([vue-property-decorator](https://github.com/kaorun343/vue-property-decorator) if you wanna go the extra mile) with typescript. ",1513954266.0
jsNut,"But why would you ever write typescript in notepad when you get some much functionality like auto complete, refactoring, quick fixes etc from ide integrations. That's like insisting on crawling everywhere when you could walk.",1513802200.0
grinde,"You could use es6 modules. One caveat is that you have to include a '.js' file extension on all of your imports, since TS won't add it for you (see [here](https://github.com/Microsoft/TypeScript/issues/13422) and [here](https://github.com/Microsoft/TypeScript/issues/16577) for a bit more info).

So for example

> tsconfig.json

    {
      ""compilerOptions"": {
        ""target"": ""es2015"",
        ""module"": ""es2015"",
        ""outDir"": ""./dist""
      },
      ""include"": [
        ""./src/**/*.ts""
      ]
    }

> index.html

    <html>
    <head>
        <title>Module test</title>
    </head>

    <body>
        <script src=""dist/index.js"" type=""module""></script>
    </body>
    </html>

> src/index.ts

    import { hello } from './hello.js';
    hello();

> src/hello.ts

    export function hello() {
        alert('Hello, world!');
    }",1513797295.0
cspotcode,"Use nothing but namespaces and avoid all import and export statements.  Use your tsconfig's ""files"" array to control the order of concatenation and the ""outFile"" option to merge all files into  one.

The TypeScript compiler itself is written totally with namespaces and without ES6 imports or exports.",1513824818.0
Plorntus,"No, not that I can tell, if you want to be able to use modules you have to have some form of module loader. If you want tsc to perform the concatination and output into one file you will need require.js or system.js. 

It's not a big deal though to include either one of these though.
",1513795441.0
BBQCalculator,"Chrome, ~~Firefox,~~ Edge and Safari all have native support for modules. You can use `import/export` in your code and load your main module in your page with `<script type=module>`. [This blog post](https://jakearchibald.com/2017/es-modules-in-browsers/) has more details.",1513797549.0
i_spot_ads,Stupid question ,1513839157.0
schlenkster,Do you have the option of writing your code in typescript? Typescript will generate the .d.ts files for you and all the namespacing will work exactly as your code is written. ,1513774499.0
spacejack2114,"That's how I would approach it - put complex/reusable types in external d.ts files.

Can you use `/// <reference path=""...d.ts""/>` to just include types in the files that need them?",1513779900.0
yawaramin,"Trying a slightly different tack: I'm writing a library and trying to provide a typing using the 'module function' template: https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html

    // index.d.ts
    declare function add(a: number, b: number): number;
    export = add;

    // index.js
    module.exports = function add(a, b) { return a + b; }

But, VSCode is not picking up the typing for my module (I'm getting errors saying the parameters `a` and `b` are inferred to have type `any`). This is with full and strict checking turned on in the project:

    {
        ""compilerOptions"": {
            ""checkJs"": true,
            ""strict"": true,
            ""noImplicitReturns"": true,
            ""noUnusedLocals"": true,
            ""noUnusedParameters"": true
        },
        ""exclude"": [
            ""nodes_modules"",
            ""**/node_modules/*""
        ]
    }

Any ideas as to how to make VSCode pick up my typings?",1513823325.0
yawaramin,"OK, for now, settled on this strategy: define all types in an ambient `types.d.ts` file that should be available throughout the codebase, and use JSDoc annotations on JS module contents.",1513985829.0
nightfire1,This isn't really a Typescript specific question. It's just JavaScript. One thing to consider is that you will need different varience calculation functions for dates than for numbers unless you first convert the dates to timestamps. Also due to the size of timestamp numbers you must take care when calculating varience not to accidentally cause a wraparound error or lose precision when adding values for calculating the mean. ,1513689948.0
voidvector,"What you are trying to do is ""outlier removal"". 

Since your data is 3-dimensional as supposed to the normal 1-dimensional vector, you should read up on that topic first. There are special Machine Learning algorithms (clustering) for 3D data. 

Also this is normally done in Python/R. Both of those can do a basic version of outlier removal in one line of code. ",1513744144.0
rco8786,"As mentioned, not really Typescript specific. But this library should get you going: https://www.npmjs.com/package/descriptive-statistics",1513740549.0
bas1212,TL;DR: yes,1513705930.0
cspotcode,"You just need to specify the second generic parameter explicitly.

    const WithGet = Gettable<IUser, typeof Endpoint>(Endpoint);
    const WithGetCreate = Createable<IUser, typeof WithGet>(WithGet);

If you specify *any* generics, then the omitted ones will use their default values instead of using an inferred value.  This means, in your case, `U` was being set to `typeof Endpoint` instead of being inferred as `typeof WithGet`.

You can sidestep this limitation by splitting up the `T` and `U` generics onto separate functions.  That way you explicitly specify `T` and let inference figure out `U`.

    function Createable<T>() {
        return function<U extends Constructor<Endpoint> = typeof Endpoint>(Base: U) {
            return class extends Base {

...and then invoke it with an extra set of parentheses:

        const WithGetCreate = Createable<IUser>()(WithGet);",1513900398.0
tme321,"I'm wondering if instead for now the answer is to create a higher level mixin creator that will take in a number of different mixins and return the result from all of them.  This might fix the issue since each new mixin wouldn't be masking the total signature created.

Might be worth a shot trying anyway.",1513651508.0
criloz,"I can't believe this,  I am in tears, I lost 6 hours of my life trying to configure webpack, typescript, hrm, react and avoid full reload of the app and its state, parcel did all this for me in just a minute.  thank you op",1513613791.0
monnef,"I was reading about Parcel recently, but the missing (or rather not advertised) TypeScript support has discouraged me from even trying it. Thanks for the info :).",1513603972.0
drawm08,is it me or parcel swallows all transpiling error?,1513631916.0
AngularBeginner,Link is suspended.,1513860940.0
Damien0,https://github.com/gcanti/fp-ts is a nice little lib.,1513569900.0
spacejack2114,"Maybe not exactly what you're looking for, but some things I've come across:

https://github.com/funkia/hareactive

https://github.com/kube/monolite

https://github.com/garrettm/tsum
",1513562214.0
chantisnake,https://github.com/types/npm-ramda/,1513565167.0
thadudeabides1,CycleJS is written in Typescript. It's less of a functional utils framework and more of an application/state-management library.,1513546700.0
,"TypeScript is such a blessing for frontend code. The fact that microsoft (can you imagine?) dogfoods it via vscode is also a very good sign!

TypeScript has made me enjoy frontend dev in a totally new way!

Long live TS!",1513455288.0
xmsxms,"> 9,615 developers reported they had used Angular 1 and would not use it again

Not use Angular 1 again, or not use Angular again? 

Does this mean they wouldn't use it in a new project, or they would avoid working on projects that are currently using it?


I doubt anyone would start a project using angular 1 given it has been superseded.",1513453625.0
Kloranthy,"I've been trying to become less dependent on Angular, but the more progress I make on this goal the less benefit I see in it.

it took a bit, but I finally learned webpack enough to get it to also move the non-ts/js files from src to dist.
the Angular command line tool took care of that webpack configuration for me without any downsides.

I really like the Angular paradigm (presentation and container components, services, dependency injection) and have found myself re-inventing the Angular wheels in my (supposed to be) plain typescript project...",1513454911.0
lechatsportif,Never going back to angular.  Sad my company went down that route.,1513447724.0
beand1p,Can this be used with Angular 5?,1513383989.0
mkotechno,Reinventing Swagger/OpenAPI,1513830748.0
rawrmaan,"Hey TS folks! This is my first OSS project and I would absolutely love your feedback!

HN discussion: https://news.ycombinator.com/item?id=15934289",1513365912.0
isakdev,That's a long neck,1513341844.0
Artraxes,"Surely this is a feature of the IDE, not of TypeScript?",1513275443.0
6millionways2try,"Nice, I was actually looking for something like this.  Thoughts on TS/Vue so far?",1513223087.0
hatepoorpeople,Curious about why the store is so weakly typed or did I miss something? I ask because I had a big problem getting vuex to play nicely w/ TS and ended up giving up. I was hoping someone smarter than me has figured it out (without resorting to vue-class-component).,1513272100.0
antanas-a,It's full fledged oo language and it's also a sugar on top js. Did you think that js is not oo?,1513186932.0
voidvector,"The only major difference between what people refer to as OOP language and non-OOP language is syntactic sugar. 

In fact, any language that supports objects can do OOP. You can write [OOP code in C](https://www.cs.rit.edu/~ats/books/ooc.pdf)! It involves naming your functions consistently, and using ""self"" as first argument of those functions. In fact, this convention supports inheritance as well, and was the foundation of how it is implemented in C++ and Java. 

Since ES6, there is the OOP syntactic sugar, so yes. 

",1514353956.0
icholy,"What is ""pure oop""?",1513285700.0
TheBen1,It's can't be fully OOP since it still uses prototype-based inheritance (since it's a superset of javascript).,1513180526.0
drewwyatt,"Definitely webpack (although I have heard good things about rollup too). [the guide here should get you up and running. ](https://webpack.js.org/guides/typescript/) 

Edit: Also - this did not come off as mean. You are just dealing with the current state of web. There are a lot of moving parts. [This blog is over a year old now but I think it probably captures how you are feeling right now. ](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f) ",1513177918.0
Devvvvvv,"This webpack config should be enough to compile your typescript app into a single bundle.js

    const path = require(""path"")

    const SRC = path.resolve(""./src"")
    const DIST = path.resolve(""./dist"")

    module.exports = {
        entry: path.join(SRC,""index.tsx""),
        output: {
            filename: ""bundle.js"",
            path: DIST
        },

        // Enable sourcemaps for debugging webpack's output.
        devtool: ""source-map"",
    
        resolve: {
            // Add '.ts' and '.tsx' as resolvable extensions.
            extensions: ["".ts"", "".tsx"", "".js"", "".json""],
        },
    
        module: {
            rules: [
                // All files with a '.ts' or '.tsx' extension will be handled by 'awesome-typescript-loader'.
                {
                    test: /\.tsx?$/,
                    exclude : /(node_modules)/,
                    loader: ""awesome-typescript-loader""
                },
                // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.
                { enforce: ""pre"", test: /\.js$/, loader: ""source-map-loader"" }
            ]
        },
    };",1513180930.0
rheadit,"I was exactly the same a year ago. 
Although typescript looked good compared to classic javascript, the build process and integration into the page felt wrong. Using [webpack](https://webpack.js.org/guides/typescript/) now it still feels wrong somehow (especially when i look into the webpack config file) but it actually works pretty well.",1513179934.0
spacejack2114,"IMO Browserify is way easier to get started with. It does most things you need from webpack with a fraction of the configuration. Just point it at your app entry point. Eg:

    npm install browserify tsify

    browserify --debug main.ts -p [ tsify ] -o app.js

Want a minified bundle?

    npm install uglify-js

    browserify main.ts -p [ tsify ] | uglifyjs -cm -o app.js

If you want a minimalist starter project I have [this example here](https://github.com/spacejack/mithril-browserify-ts-budo).",1513216459.0
sanyatuning,"You should try Fusebox. I think it is much better then webpack. Easier to configure, faster, with built in typescript support.
http://fuse-box.org",1513201509.0
,[deleted],1513321451.0
steveokay,Try Parcel.  See https://hackernoon.com/zero-config-typescript-bundling-with-parcel-ef76fabcbfe3,1514594302.0
night_of_knee,tl;dw?,1513169107.0
TotesMessenger,"I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:

- [/r/titlegore] [Typescript prevents you from prototyping (spoiler: it's not)](https://www.reddit.com/r/titlegore/comments/7jvyni/typescript_prevents_you_from_prototyping_spoiler/)

&nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",1513297159.0
cspotcode,"Do you know about generics and union types?  If you ""go to declaration"" in your IDE it'll show you where those types are declared.",1513049085.0
QW4K,Are you aware of nestjs & zafirojs?,1513020674.0
ghillerd,"I'm sharing this because I'd like it to be critiqued before I package it. I wrote it this morning, so please, shred it.",1513005822.0
hthouzard,The readme is ... too short. ,1513017228.0
fanciullo,"On that same Github page, minestarks (MSFT) says:
> Our long term plan is in fact to base the language service version off of what's specified in the .csproj file to match the build.

Wow, so right now, by design, the build (Ctrl+Shift+B) and the Compile on save (Ctrl+S) use completely different TS versions and this is apparently completely OK.

:tableflip:",1512999209.0
KangarooImp,Then try to find out why it's a boolean[] instead of a string[].,1512894185.0
flaccidopinion,.,1512955110.0
macd2point0,"I had to go with   

    list.sort(function (a:any, b:any) {   

      return a.toLowerCase().localeCompare(b.toLowerCase());  

    });   

I don't know why the TS compiler demands a boolean for a and b but casting them to any worked  
edit: formatting",1512922393.0
monnef,"Damn, didn't know TS now supports plugins. Anyone know if there are (being worked on) plugins for that mentioned runtime typechecks (e.g. for every function/method call it would check types when running a debug build) or pipe (aka |> operator, reversed function application)?",1512846004.0
Bamboo_the_plant,Can a transform be made to generate typings for CSS files?,1513218314.0
voidvector,"you can do: 

    class MyScript extends pc.createScript('scriptName') {
        initialize() {
        }
    }

If return value of `pc.createScript` is not an idiomatic JS class, the behavior might not be exactly the same. ",1512718552.0
hotrodx,"Can you check if this works? Assumes pc is of global scope, and the created object does not have initialize and update by default.

    class MyScript {
      constructor() {
         Object.assign(this, pc.createScript('scriptName'));
      }
      
      initialize() {
        // Stuff that happens when script is initialized
      }
      
      update() {
        // Stuff that happens every tick
      }
    }
",1512718201.0
broken_e,"I don't see how it works in that partial code you pasted that seems to be just mostly comments, but it is valid syntax as [object destructuring](https://www.typescriptlang.org/docs/handbook/variable-declarations.html):

    module Mod {
        const obj = { a: 'foo', b: 12 };
        export const { a, b } = obj;
    }
    console.log(Mod.a); // prints ""foo""

edit: ok I think I see what your code's about; seems like a formatting issue where each comment ends with a colon and there is a missing line break after each.",1512714201.0
voidvector,You can prepend `export` to any `const`/`let`/`var`/`function`/`class`/`interface`/`type` declaration. It would simply export whatever variable/function associated with that declaration. ,1512718989.0
sylvanaar,Do you develop your IDE using your IDE now?,1512704929.0
lifenautjoe,"I'll never get the purpose of these ""Cloud"" IDEs. Just have it on your machine maybe ? Use source control to store your files maybe ? Have full control over your Dev environment maybe? Ugh.",1512690266.0
rheadit,yes,1512672435.0
brandonlee781,"I might be mistaken but inside a class method you could add

    const { value } = this;
    
and reference is by calling value instead of this.value.

Edit: corrected variable name",1512674575.0
cspotcode,"Yup, that's just a JavaScript thing.  If you only need to *read* values, you could copy them to local variables at the top of your method, using a destructuring statement:

    const {foo, bar} = this;

Or if you felt like `this` was too verbose, you could `const T = this;`

But really, this is just the way JavaScript works.  JavaScript is so dynamic that, unlike C# or C++, it's not possible to unambiguously determine whether or not you're referring to an object property or a lexically scoped variable without requiring the explicit `this.` property lookup.",1512753509.0
th3drean,"You could set this to a variable I suppose, so it’s myClass.value ",1512690109.0
th3drean,"You could set this to a variable I suppose, so it’s Basic.value ",1512690116.0
rheadit,"     class Foo {
        bar: string;
        otherProp:number;

        constructor(params:Partial<Foo>) {
            Object.assign(this, params);
        }

        method() {
            return 'result';
        }
    }


    const foo1 = new Foo({bar: 'value'});
    const foo2 = new Foo({otherProp: 3});
    const foo3 = new Foo({method: ()=>'override'});",1512655417.0
k1r0s,"BTW you can use Builder pattern in TypeScript (JavaScript as well)

Here is an example in Java (just googling ""builder pattern"")
http://javarevisited.blogspot.com.es/2012/06/builder-design-pattern-in-java-example.html",1512654763.0
trevorsg,"You mean like type alignment to figure out which of several ordered optional values you have passed? No, it doesn't.",1512654007.0
k1r0s,"U can use optional params

class Car {
  constructor(param1, param2, param3?) {

  }
}

new Car(""Seat"", ""Ibiza"") // this is correct",1512654639.0
sylvanaar,TypeScript can do what JavaScript can.,1512705049.0
seekheart2017,But any of them can be null,1512654676.0
Gaussprey,"You don't need to use var when declaring class properties. They'll exist as properties on an object and by default can be assigned and reassigned to.

By default properties are public, so the first one is public and the second one is private.",1512618717.0
Faucheuses,"> equivalent [...] in Java 

If you want to learn typescript, forget it looks like Java and try to understand what's happening JS side.

Typescript playground is an awesome tool for that.

Nothing in typescript is like Java, it looks like it and can work like it so it's easier for javaers, but if you code it only like you code Java, your code will be bad.

On that note about your issue, there is no real access modifier in javascript. When TS parses your code and sees you are calling a private var, it throws an error. But in JS (at runtime) you can access that var.",1513096869.0
spacejack2114,"Why not:

	type Color = 'red' | 'green' | 'blue'

I have not found a use for Enums yet.",1512694772.0
kidkkr,string is an object type. so it should be error.,1512614870.0
cspotcode,"Depending on how much duplication and boilerplate you can stomach, you could do something like this: (you can certainly make it shorter depending on your code style)

    enum Color {
        red = 1,
        blue = 2,
        green = 3,
    }
    namespace Color {
        export type Map = {
            red: 1,
            blue: 2,
            green: 3
        }
        export type Value = Map[keyof Map];
    }
    
    function logColor(c: Color.Value) {
        console.log(c);
    }
    
    logColor(0);    

http://www.typescriptlang.org/play/index.html#src=const%20enum%20Color%20%7B%0D%0A%20%20%20%20red%20%3D%201%2C%0D%0A%20%20%20%20blue%20%3D%202%2C%0D%0A%20%20%20%20green%20%3D%203%2C%0D%0A%7D%0D%0Anamespace%20Color%20%7B%0D%0A%20%20%20%20export%20type%20Map%20%3D%20%7B%0D%0A%20%20%20%20%20%20%20%20red%3A%201%2C%0D%0A%20%20%20%20%20%20%20%20blue%3A%202%2C%0D%0A%20%20%20%20%20%20%20%20green%3A%203%0D%0A%20%20%20%20%7D%0D%0A%20%20%20%20export%20type%20Value%20%3D%20Map%5Bkeyof%20Map%5D%3B%0D%0A%7D%0D%0A%0D%0Afunction%20logColor(c%3A%20Color.Value)%20%7B%0D%0A%20%20%20%20console.log(c)%3B%0D%0A%7D%0D%0A%0D%0AlogColor(0)%3B",1512660903.0
sylvanaar,This looks like a similar topic: https://github.com/Microsoft/TypeScript/issues/17690,1512708219.0
twomousepads,I was _just_ wondering if I should write validation decorators for my app.  Now I don't have to.  Thanks for sharing!,1512480830.0
chantisnake,"This validates the object in runtimes right?

This is great, it is always better to crash than continue with an error. 

However I really want typescript to see the needs of this and put the validation to compile time. Either implement refinement type or at least compile time code injection.",1512485969.0
ower89,This library is part of the [Zafiro](https://github.com/ZafiroJS/zafiro) ecosystem but it is standalone and can be used on its own.,1512471630.0
endjynn,"I'd also like to give a shout out to class-validator which does the same thing but is written by the same guy who created TypeORM (that Zafiro uses).  
https://github.com/typestack/class-validator",1512489381.0
geon,"In the example, you limit password length and chars. 😕",1512539862.0
e_man604,Wouldn't it make sense to pass in the current value and return the result? You could do it as an optional parameter that defaults to 0.,1512199175.0
cspotcode,"This is Google's configuration of tslint and clang-format.

If you want the same code formatting capabilities, but you want to configured it yourself, it looks like you should use clang-format.",1512157793.0
gypsyface,how does it compare to prettier ?,1512152104.0
help_computar,"it's your face... on my reddit...
",1512118661.0
RaptorXP,"> No proof-of-work or proof-of-stake: a block can be added to the blockchain without competition

Can't really call that a Blockchain then",1512988009.0
