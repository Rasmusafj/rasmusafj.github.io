{{distinguish|occam (programming language)}}
{{primary sources|date=May 2015}}
{{Infobox programming language
 | name                   = OCaml
 | logo                   = OCaml Logo.svg
 | logo caption           = 
 | screenshot             = 
 | screenshot caption     = 
 | paradigm               = [[Programming paradigm#Multi-paradigm|Multi-paradigm]]: [[imperative programming|imperative]], [[functional programming|functional]], [[object-oriented programming|object-oriented]]
 | scope                  =
 | released               = {{Start date and age|1996}}
 | designer               = [[Xavier Leroy]], Jérôme Vouillon, [[Damien Doligez]], Didier Rémy, Ascánder Suárez
 | developer              = [[French Institute for Research in Computer Science and Automation|INRIA]]
 | latest release version = 4.07.0
 | latest release date    = {{Start date and age|2018|7|10}}<ref>https://ocaml.org/releases/</ref>
 | latest preview version = 
 | latest preview date    = <!-- {{Start date and age|YYYY|MM|DD}} -->
 | typing                 = [[static typing|Static]], [[strong and weak typing|strong]], [[type inference|inferred]]
 | implementations        = 
 | dialects               = [[F Sharp (programming language)|F#]], [[JoCaml]], MetaOCaml, OcamlP3l, [[Reason ML]]
 | influenced by          = [[Caml]] Light, [[Cool (programming language)|Cool]],{{citation needed|date=November 2016}} [[Standard ML]]
 | influenced             = [[ATS (programming language)|ATS]], [[Elm (programming language)|Elm]], [[F Sharp (programming language)|F#]], [[F* (programming language)|F*]], [[Haxe]], [[Opa (programming language)|Opa]], [[Rust (programming language)|Rust]], [[Scala (programming language)|Scala]]
 | programming language   = OCaml, [[C (programming language)|C]]
 | platform               = [[IA-32]], [[x86-64]], [[Power Architecture|Power]], [[SPARC]], [[ARM architecture|ARM 32-64]]
 | operating system       = [[Cross-platform]]: [[Unix]], [[macOS]], [[Microsoft Windows|Windows]]
 | license                = [[GNU Lesser General Public License|LGPL]]
 | file ext               = .ml, .mli
 | website                = {{URL|https://ocaml.org/}}
 | wikibooks              = Objective Caml
}}
'''OCaml''' ({{IPAc-en|oʊ|ˈ|k|æ|m|əl}} {{respell|oh|KAM|əl}}), originally named '''Objective Caml''', is the main implementation of the programming language [[Caml]], created by [[Xavier Leroy]], Jérôme Vouillon, [[Damien Doligez]], Didier Rémy, Ascánder Suárez and others in 1996. A member of the [[ML (programming language)|ML]] language family, OCaml extends the core Caml language with [[object-oriented programming]] constructs.

The OCaml [[toolchain]] includes an interactive top-level [[Interpreter (computing)|interpreter]], a [[bytecode]] [[compiler]], an optimizing [[native code]] compiler, a reversible [[debugger]], and a package manager (OPAM). It has a large standard library, making it useful for many of the same applications as [[Python (programming language)|Python]] or [[Perl]], and has robust modular and object-oriented programming constructs that make it applicable for large-scale software engineering. OCaml is the successor to [[Caml]] Light. The acronym ''CAML'' originally stood for ''Categorical Abstract Machine Language'', although OCaml omits this [[abstract machine]].<ref>{{cite web|url= http://ocaml.org/learn/history.html|title= A History of OCaml|publisher= |access-date= 24 December 2016}}</ref>

OCaml is a [[free and open-source software]] project managed and principally maintained by the [[French Institute for Research in Computer Science and Automation]] (INRIA). In the early 2000s, many new languages adopted elements from OCaml, notably [[F Sharp (programming language)|F#]] and [[Scala (programming language)|Scala]].

==Philosophy==
[[ML (programming language)|ML]]-derived languages are best known for their static [[type system]]s and [[type inference|type-inferring]] compilers. OCaml unifies [[functional programming|functional]], [[imperative programming|imperative]], and [[object-oriented programming]] under an ML-like type system. Thus, programmers need not be highly familiar with the pure functional language paradigm to use OCaml.

OCaml's static type system can help eliminate problems at runtime. However, it also forces the programmer to conform to the constraints of the type system, which can require careful thought and close attention. A type-inferring compiler greatly reduces the need for manual type annotations. For example, the [[data type]] of variables and the signature of functions usually need not be declared explicitly, as they do in languages like [[Java (programming language)|Java]] or [[C Sharp (programming language)|C#]]. Nonetheless, effective use of OCaml's type system can require some sophistication on the part of a programmer.

OCaml is perhaps most distinguished from other languages with origins in academia by its emphasis on performance. Its static type system prevents runtime type mismatches and thus obviates runtime type and safety checks that burden the performance of dynamically typed languages, while still guaranteeing runtime safety, except when array bounds checking is turned off or when some type-unsafe features like serialization are used. These are rare enough that avoiding them is quite possible in practice.

Aside from type-checking overhead, [[functional programming]] languages are, in general, challenging to compile to efficient machine language code, due to issues such as the [[funarg problem]]. Along with standard loop, register, and instruction [[compiler optimization|optimizations]], OCaml's optimizing compiler employs [[static program analysis]] methods to optimize value [[Boxing (computer science)|boxing]] and [[Closure (computer science)|closure]] allocation, helping to maximize the performance of the resulting code even if it makes extensive use of functional programming constructs.

[[Xavier Leroy]] has stated that "OCaml delivers at least 50% of the performance of a decent C compiler",<ref name = "LWN">[https://lwn.net/Articles/19378/ Linux Weekly News].</ref> but a direct comparison is impossible. Some functions in the OCaml standard library are implemented with faster algorithms than equivalent functions in the standard libraries of other languages. For example, the implementation of set union in the OCaml standard library in theory is asymptotically faster than the equivalent function in the standard libraries of imperative languages (e.g., C++, Java) because the OCaml implementation exploits the immutability of sets to reuse parts of input sets in the output (see [[persistent data structure]]).

==Features==
OCaml features: a [[Semantic analysis (computer science)|static]] [[type system]], [[type inference]], [[parametric polymorphism]], [[tail recursion]], [[pattern matching]], first class lexical [[Closure (computer science)|closures]], [[Function object#Other meanings|functors (parametric modules)]], [[exception handling]], and incremental generational [[garbage collection (computer science)|automatic garbage collection]].

OCaml is notable for extending ML-style type inference to an object system in a general-purpose language. This permits [[structural subtyping]], where object types are compatible if their method signatures are compatible, regardless of their declared inheritance (an unusual feature in statically typed languages).

A [[foreign function interface]] for [[Linker (computing)|linking]] to [[C (programming language)|C]] primitives is provided, including language support for efficient numerical [[Array data structure|arrays]] in formats compatible with both C and [[Fortran]]. OCaml also supports creating libraries of OCaml functions that can be linked to a ''main'' program in C, so that an OCaml library can be distributed to C programmers who have no knowledge or installation of OCaml.

The OCaml distribution contains:
* An extensible [[Parsing#Computer languages|parser]] and [[Macro (computer science)|macro language]] named [[Camlp4]], which permits the syntax of OCaml to be extended or even replaced
* [[Lexical analysis|Lexer]] and parser tools called ocamllex and ocamlyacc
* [[Debugger]] that supports stepping backwards to investigate errors
* [[Documentation generator]]
* [[Profiler (computer science)|Profiler]] – to measure performance
* Many general-purpose [[Library (computing)|libraries]]

The native code compiler is available for many platforms, including [[Unix]], [[Microsoft Windows]], and [[Apple Inc.|Apple]] [[macOS]]. Portability is achieved through native code generation support for major architectures: [[IA-32]], [[X86-64]] (AMD64), [[Power Architecture|Power]], [[SPARC]], [[ARM architecture|ARM]], and [[ARM64]].<ref>{{cite web|url=https://github.com/ocaml/ocaml/tree/trunk/asmcomp|title=ocaml/asmcomp at trunk · ocaml/ocaml · GitHub|work=GitHub|access-date=2 May 2015}}</ref>

OCaml bytecode and native code programs can be written in a [[Thread (computer science)|multithreaded]] style, with preemptive context switching. However, because the garbage collector of the INRIA OCaml system (which is the only currently available full implementation of the language) is not designed for concurrency, [[symmetric multiprocessing]] is unsupported.<ref name = "INRIA">{{cite web|url=http://mirror.ocamlcore.org/caml.inria.fr/pub/ml-archives/caml-list/2002/11/64c14acb90cb14bedb2cacb73338fb15.en.html|title=Archives of the Caml mailing list > Message from Xavier Leroy|publisher=|access-date=2 May 2015}}</ref> OCaml threads in the same process execute by time sharing only. There are however several libraries for distributed computing such as [http://functory.lri.fr/About.html Functory] and [http://projects.camlcity.org/projects/ocamlnet.html ocamlnet/Plasma].

==Development environment==

Since 2011, many new tools and libraries have been contributed to the OCaml development environment:
* OCaml Package Manager (OPAM), developed by OCamlPro, is now an easy way to install OCaml and many of its tools and libraries
* Optimizing compilers for OCaml:
** ocamlcc is a compiler from OCaml to C, to complement the native code compiler for unsupported platforms.
** OCamlJava, developed by INRIA, is a compiler from OCaml to the [[Java virtual machine]] (JVM).
** OCaPic, developed by Lip6, is an OCaml compiler for [[PIC microcontroller]]s.
** js_of_ocaml, developed by the [[Ocsigen]] team, is an optimizing compiler from OCaml to [[JavaScript]].
* Development tools
** TypeRex is a set of open-source tools and libraries for OCaml, developed and maintained by OCamlPro.
** Merlin is an auto-completion tool for editing OCaml code in [[Emacs]] and [[Vim (text editor)|Vim]].
* Web sites:
** [https://ocaml.org/ OCaml.org] is a website managed by the OCaml community.
** [https://try.ocamlpro.com/ Try OCaml], developed by OCamlPro, is a website containing a complete OCaml REPL in a webpage.

==Code examples==
{{unreferenced section|date=May 2013}}
Snippets of OCaml code are most easily studied by entering them into the ''top-level''. This is an interactive OCaml session that prints the inferred types of resulting or defined expressions. The OCaml top-level is started by simply executing the OCaml program:
<source lang="console">
$ ocaml
     Objective Caml version 3.09.0
#
</source>
Code can then be entered at the "#" prompt. For example, to calculate 1+2*3:
<source lang="console">
# 1 + 2 * 3;;
- : int = 7
</source>
OCaml infers the type of the expression to be "int" (a [[Word (computer architecture)|machine-precision]] [[Integer (computer science)|integer]]) and gives the result "7".

===Hello World===
The following program "hello.ml":

<source lang=OCaml>
print_endline "Hello World!"
</source>

can be compiled into a bytecode executable:

 $ ocamlc hello.ml -o hello

or compiled into an optimized native-code executable:

 $ ocamlopt hello.ml -o hello

and executed:
<source lang="console">
$ ./hello
Hello World!
$
</source>
===Summing a list of integers===

Lists are one of the fundamental datatypes in OCaml. The following code example defines a ''recursive'' function ''sum'' that accepts one argument ''xs''. (Note the keyword '''rec'''). The function recursively iterates over a given list and provides a sum of integer elements. The ''match'' statement has similarities to [[C (programming language)|C]]'s [[Switch statement|switch]] element, though it is far more general.

<source lang=OCaml>
let rec sum xs =
  match xs with
  | [] -> 0                        (* yield 0 if xs has the form [] *)
  | x :: xs' -> x + sum xs';;      (* recursive call if xs has the form x::xs' for suitable x and xs' *)
</source>
<source lang=OCaml>
  # sum [1;2;3;4;5];;
  - : int = 15
</source>
Another way is to use standard [[fold function]] that works with lists.

<source lang=OCaml>
let sum xs =
  List.fold_left (fun acc x -> acc + x) 0 xs;;
</source>
<source lang=OCaml>
  # sum [1;2;3;4;5];;
  - : int = 15
</source>
Since the anonymous function is simply the application of the + operator, this can be shortened to:

<source lang=OCaml>
let sum xs =
  List.fold_left (+) 0 xs
</source>

Furthermore, one can omit the list argument by making use of a partial application:

<source lang=OCaml>
let sum =
  List.fold_left (+) 0
</source>

===Quicksort===
OCaml lends itself to concisely expressing recursive algorithms. The following code example implements an algorithm similar to [[quicksort]] that sorts a list in increasing order.

<source lang=OCaml>
 let rec qsort = function
   | [] -> []
   | pivot :: rest ->
     let is_less x = x < pivot in
     let left, right = List.partition is_less rest in
     qsort left @ [pivot] @ qsort right
</source>

===Birthday problem===
The following program calculates the smallest number of people in a room for whom the probability of completely unique birthdays is less than 50% (the [[birthday problem]], where for 1 person the probability is 365/365 (or 100%), for 2 it is 364/365, for 3 it is 364/365 × 363/365, etc.) (answer = 23).

<source lang=OCaml>
let year_size = 365.

let rec birthday_paradox prob people =
  let prob' = (year_size -. float people) /. year_size *. prob  in
  if prob' < 0.5 then
    Printf.printf "answer = %d\n" (people+1)
  else
    birthday_paradox prob' (people+1)
;;

birthday_paradox 1.0 1
</source>

===Church numerals===
The following code defines a [[Church encoding]] of [[natural number]]s, with successor (succ) and addition (add). A Church numeral {{OCaml|n}} is a [[higher-order function]] that accepts a function {{OCaml|f}} and a value {{OCaml|x}} and applies {{OCaml|f}} to {{OCaml|x}} exactly {{OCaml|n}} times. To convert a Church numeral from a functional value to a string, we pass it a function that prepends the string {{OCaml|"S"}} to its input and the constant string {{OCaml|"0"}}.

<source lang=OCaml>
let zero f x = x
let succ n f x = f (n f x)
let one = succ zero
let two = succ (succ zero)
let add n1 n2 f x = n1 f (n2 f x)
let to_string n = n (fun k -> "S" ^ k) "0"
let _ = to_string (add (succ two) two)
</source>

===Arbitrary-precision factorial function (libraries)===
A variety of libraries are directly accessible from OCaml. For example, OCaml has a built-in library for [[arbitrary-precision arithmetic]]. As the factorial function grows very rapidly, it quickly overflows machine-precision numbers (typically 32- or 64-bits). Thus, factorial is a suitable candidate for arbitrary-precision arithmetic.

In OCaml, the Num module (now superseded by the ZArith module) provides arbitrary-precision arithmetic and can be loaded into a running top-level using:
<div class="mw-highlight mw-content-ltr">
 <span class="gp">#</span> {{Unstyled inline syntax|lang=ocaml|monospace=1|#use "topfind";;}}
 <span class="gp">#</span> {{Unstyled inline syntax|lang=ocaml|monospace=1|#require "num";;}}
 <span class="gp">#</span> {{Unstyled inline syntax|lang=ocaml|monospace=1|open Num;;}}
</div>
The factorial function may then be written using the arbitrary-precision numeric operators {{mono|{{=}}/}}, {{mono|*/}} and {{mono|-/}} :

<source lang=OCaml>
# let rec fact n =
    if n =/ Int 0 then Int 1 else n */ fact(n -/ Int 1);;
val fact : Num.num -> Num.num = <fun>
</source>

This function can compute much larger factorials, such as 120!:

<source lang=OCaml>
# string_of_num (fact (Int 120));;
- : string =
"6689502913449127057588118054090372586752746333138029810295671352301633
55724496298936687416527198498130815763789321409055253440858940812185989
8481114389650005964960521256960000000000000000000000000000"
</source>

===Triangle (graphics)===
The following program "simple.ml" renders a rotating triangle in 2D using [[OpenGL]]:

<source lang=OCaml>
let () =
  ignore (Glut.init Sys.argv);
  Glut.initDisplayMode ~double_buffer:true ();
  ignore (Glut.createWindow ~title:"OpenGL Demo");
  let angle t = 10. *. t *. t in
  let render () =
    GlClear.clear [ `color ];
    GlMat.load_identity ();
    GlMat.rotate ~angle: (angle (Sys.time ())) ~z:1. ();
    GlDraw.begins `triangles;
    List.iter GlDraw.vertex2 [-1., -1.; 0., 1.; 1., -1.];
    GlDraw.ends ();
    Glut.swapBuffers () in
  GlMat.mode `modelview;
  Glut.displayFunc ~cb:render;
  Glut.idleFunc ~cb:(Some Glut.postRedisplay);
  Glut.mainLoop ()
</source>

The LablGL bindings to OpenGL are required. The program may then be compiled to bytecode with:

   $ ocamlc -I +lablGL lablglut.cma lablgl.cma simple.ml -o simple

or to nativecode with:

   $ ocamlopt -I +lablGL lablglut.cmxa lablgl.cmxa simple.ml -o simple

or, more simply, using the ocamlfind build command
   $ ocamlfind opt simple.ml -package lablgl.glut -linkpkg -o simple

and run:

   $ ./simple

Far more sophisticated, high-performance 2D and 3D graphical programs can be developed in OCaml. Thanks to the use of OpenGL and OCaml, the resulting programs can be cross-platform, compiling without any changes on many major platforms.

===Fibonacci sequence===
The following code calculates the [[Fibonacci number|Fibonacci sequence]] of a number ''n'' inputted. It uses [[tail recursion]] and pattern matching.
<source lang = OCaml>
let fib n =
  let rec fib_aux m a b =
    match m with
    | 0 -> a
    | _ -> fib_aux (m - 1) b (a + b)
  in fib_aux n 0 1
</source>

===Higher-order functions===
Functions may take functions as input and return functions as result. For example, applying ''twice'' to a function ''f'' yields a function that applies ''f'' two times to its argument.
<source lang = OCaml>
let twice (f : 'a -> 'a) = fun (x : 'a) -> f (f x);;
let inc (x : int) : int = x + 1;;
let add2 = twice inc;;
let inc_str (x : string) : string = x ^ " " ^ x;;
let add_str = twice(inc_str);;
</source>
<source lang = OCaml highlight="1,3">
  # add2 98;;
  - : int = 100
  # add_str "Test";;
  - : string = "Test Test Test Test"
</source>
The function ''twice'' uses a type variable'' 'a'' to indicate that it can be applied to any function ''f'' mapping from a type'' 'a'' to itself, rather than only to ''int->int'' functions. In particular, ''twice'' can even be applied to itself.
<source lang = OCaml highlight="1,3,5">
  # let fourtimes f = (twice twice) f;;
  val fourtimes : ('a -> 'a) -> 'a -> 'a = <fun>
  # let add4 = fourtimes inc;;
  val add4 : int -> int = <fun>
  # add4 98;;
  - : int = 102
</source>

==Derived languages==

===MetaOCaml===
MetaOCaml<ref name = "Meta">[http://okmij.org/ftp/ML/MetaOCaml.html BER MetaOCaml]</ref> is a [[multi-stage programming]] extension of OCaml enabling incremental compiling of new [[machine code]] during runtime. Under some circumstances, significant speedups are possible using multistage programming, because more detailed information about the data to process is available at runtime than at the regular compile time, so the incremental compiler can optimize away many cases of condition checking, etc.

As an example: if at compile time it is known that some [[Exponentiation|power function]] {{OCaml|x -> x^n}} is needed often, but the value of {{OCaml|n}} is known only at runtime, a two-stage power function can be used in MetaOCaml:

<source lang=OCaml>
 let rec power n x =
   if n = 0
   then .<1>.
   else
     if even n
     then sqr (power (n/2) x)
     else .<.~x *. .~(power (n - 1) x)>.
</source>

As soon as {{OCaml|n}} is known at runtime, a specialized and very fast power function can be created:

<source lang=OCaml>
 .<fun x -> .~(power 5 .<x>.)>.
</source>

The result is:

<source lang=OCaml>
 fun x_1 -> (x_1 *
     let y_3 = 
         let y_2 = (x_1 * 1)
         in (y_2 * y_2)
     in (y_3 * y_3))
</source>

The new function is automatically compiled.

===Other derived languages===
* AtomCaml provides a synchronization primitive for atomic (transactional) execution of code.
* Emily is a subset of OCaml that uses a design rule verifier to enforce [[object-capability model]] [[Capability-based security|security]] principles.
* [[F Sharp (programming language)|F#]] is a [[.NET Framework]] language based on OCaml.
* Fresh OCaml facilitates manipulating names and binders.
* GCaml adds extensional polymorphism to OCaml, thus allowing overloading and type-safe marshalling.
* [[JoCaml]] integrates constructions for developing concurrent and distributed programs.
* OCamlDuce extends OCaml with features such as XML expressions and regular-expression types.
* OCamlP3l is a [[parallel programming]] system based on OCaml and the P3L language.

==Software written in OCaml==
* [[Zero Install|0install]], a multi-platform package manager.
* [[Coccinelle_(software)|Coccinelle]], a utility for [[program transformation|transforming]] the [[source code]] of [[C (programming language)|C]] programs.
* [[Coq]], a [[formal proof]] management system.
* [[FFTW]], a [[library (computing)|library]] for computing [[discrete Fourier transform]]s. Several C routines have been generated by an OCaml program named {{OCaml|genfft}}.
* The web version of [[Facebook Messenger]].<ref>{{cite web|title=Messenger.com Now 50% Converted to Reason · Reason|url=https://reasonml.github.io/blog/2017/09/08/messenger-50-reason.html|website=reasonml.github.io|access-date=2018-02-27}}</ref>
* Flow, a [[static program analysis|static analyzer]] created at [[Facebook]] that infers and checks [[Type_system#Static_type_checking|static types]] for [[JavaScript]].<ref>[http://flowtype.org Flow static analyzer]</ref>
* [[Frama-C]], a framework for analyzing C programs.
* [[GeneWeb]], free and open-source multi-platform genealogy software.
* The [[Hack (programming language)|Hack]] programming language compiler, created at Facebook, extending [[PHP]] with static types.
* The [[Haxe]] programming language compiler.
* [[HOL Light]], a formal proof assistant.
* Infer, a static analyzer created at Facebook for [[Java]], C, and [[Objective-C]], used to detect bugs in [[iOS]] and [[Android (operating system)|Android]] apps.<ref>[http://fbinfer.com Infer static analyzer]</ref>
* [[MirageOS]], a [[unikernel]] programming framework written in pure OCaml.
* [[Mldonkey]], a [[peer-to-peer]] [[file sharing]] application based on the [[EDonkey network]].
* [[Ocsigen]], an OCaml [[web framework]].
* [[Opa (programming language)|Opa]], a free and open-source programming language for web development.
* pyre-check, a type checker for [[Python (programming language)|Python]] created at Facebook.<ref>[https://github.com/facebook/pyre-check facebook/pyre-check: Performant type-checking for python.]</ref>
* [[Unison (file synchronizer)|Unison]], a [[file synchronization]] program to synchronize files between two directories.
* The reference interpreter for [[WebAssembly]], a low-level [[bytecode]] intended for execution inside [[web browser]]s.<ref>[https://github.com/WebAssembly/spec WebAssembly specification repository, Github]</ref>
* [[Xen Cloud Platform]] (XCP), a [[turnkey]] [[virtualization]] solution for the [[Xen]] [[hypervisor]].

==Commercial users==
Several dozen companies use OCaml to some degree.<ref name='ocaml.org-companies'>{{cite web|url=http://ocaml.org/learn/companies.html|title=Companies using OCaml|access-date=17 August 2014|publisher=OCaml.org}}</ref> Notable examples include:
* [[Bloomberg L.P.]], which created [https://bucklescript.github.io/ BuckleScript], an OCaml compiler backend targeting JavaScript.<ref>{{cite web|url=https://www.techatbloomberg.com/blog/bucklescript-1-0-release-arrived/|title=BuckleScript: The 1.0 release has arrived! {{!}} Tech at Bloomberg|date=8 September 2016|website=Tech at Bloomberg|ref=12|accessdate=21 May 2017}}</ref>
* [[Citrix Systems]], which uses OCaml in [[Citrix_Systems#Networking_and_cloud|XenServer]] (rebranded as Citrix Hypervisor during 2018).
* [[Facebook]], which developed Flow, Hack, Infer, and Pfff in OCaml.
* [[Jane Street Capital]], a [[proprietary trading]] firm, which adopted OCaml as its preferred language in its early days.<ref>{{cite web|url=http://cacm.acm.org/magazines/2011/11/138203-ocaml-for-the-masses/fulltext|title=OCaml for the Masses|author=Yaron Minsky|date=1 November 2011|publisher=|access-date=2 May 2015}}</ref>

==See also==
* [[Caml]], and Caml Light, languages from which OCaml evolved
* [[Extensible ML]], another object-oriented dialect of ML
* [[O'Haskell]], an object-oriented extension to the functional language [[Haskell (programming language)|Haskell]]
* [https://reasonml.github.io/ Reason], an alternative OCaml [[syntax (programming languages)|syntax]] and [[toolchain]] created at Facebook
* [[Standard ML]], another popular dialect of ML

==References==
{{Reflist}}

==External links==
{{wikibooks|OCaml}}
* {{Official website}}
* [http://caml.inria.fr/pub/docs/manual-ocaml/ OCaml manual]
* [https://opam.ocaml.org/ OCaml Package Manager]
* [https://realworldocaml.org Real World OCaml]

{{Programming languages}}

{{Authority control}}

[[Category:Articles with example OCaml code]]
[[Category:Cross-platform free software]]
[[Category:Extensible syntax programming languages]]
[[Category:Free compilers and interpreters]]
[[Category:Functional languages]]
[[Category:ML programming language family]]
[[Category:Object-oriented programming languages]]
[[Category:OCaml programming language family]]
[[Category:OCaml software]]
[[Category:Pattern matching programming languages]]
[[Category:Programming languages created in 1996]]
[[Category:Articles with example code]]