{{Use mdy dates|date=October 2018}}
{{About|the Apple programming language|the scripting language|Swift (parallel scripting language)}}
{{Infobox programming language
| name                     = Swift (programming language)
| title                    = Swift
| logo                     = Swift logo with text.svg
| logo size                = 200px
| paradigm                 = [[Multi-paradigm programming language|Multi-paradigm]]: [[Protocol (object-oriented programming)|protocol-oriented]], [[Object-oriented programming|object-oriented]], [[Functional programming|functional]], [[Imperative programming|imperative]], [[Block (programming)|block structured]]
| released                 = {{start date and age|2014|6|2}}<ref name=version1>{{cite web |accessdate=March 8, 2015 |url=https://developer.apple.com/swift/blog/?id=14 |title= Swift Has Reached 1.0  |publisher=Apple |date=September 9, 2014 }}</ref>
| designer                 = [[Chris Lattner]], Doug Gregor, John McCall, Ted Kremenek, Joe Groff, and [[Apple Inc.]]<ref>U.S. patent no. 9329844</ref>
| developer                = [[Apple Inc.]]
| latest release version   = 4.2.1<ref>https://swift.org/download/#releases/</ref>
| latest release date      = {{start date and age|2018|10|30}}
| latest preview version   = 5.0 branch<ref>https://swift.org/blog/5-0-release-process/</ref>
| latest preview date      =
| typing                   = [[Type system#Static type-checking|Static]], [[strong typing|strong]], [[type inference|inferred]]
| operating system         = [[Darwin (operating system)|Darwin]], [[Linux]], [[FreeBSD]], [[z/OS]]
| license                  = [[Apache License]] 2.0 (Swift 2.2 and later) <br/> [[Proprietary software|Proprietary]] (up to Swift 2.2)<ref>{{cite web|url=http://www.drdobbs.com/architecture-and-design/swift-objectively/240168424|title=Swift, Objectively|quote=Swift is proprietary and closed: It is entirely controlled by Apple and there is no open source implementation.}}</ref><ref>{{cite web|url=http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-June/073698.html|title=Re: [LLVMdev] [cfe-dev] [Advertisement] open positions in Apple's Swift compiler team|first=Chris|last=Lattner|authorlink=Chris Lattner|date=June 11, 2014|accessdate=June 12, 2014|quote=You can imagine that many of us want it to be open source and part of LLVM, but the discussion hasn't happened yet, and won't for some time.|deadurl=yes|archiveurl=https://web.archive.org/web/20140714201921/http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-June/073698.html|archivedate=July 14, 2014|df=mdy-all}}</ref>
| website                  = {{URL|https://swift.org}}
| file ext                 = .swift
| influenced_by            = [[Objective-C]],<ref name="lattner2014">{{cite web|url=http://nondot.org/sabre/|title=Chris Lattner's Homepage|last=Lattner|first=Chris|date=June 3, 2014|accessdate=June 3, 2014|publisher=Chris Lattner|quote=The Swift language is the product of tireless effort from a team of language experts, documentation gurus, compiler optimization ninjas, and an incredibly important internal dogfooding group who provided feedback to help refine and battle-test ideas. Of course, it also greatly benefited from the experiences hard-won by many other languages in the field, drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list.}}</ref> [[Rust (programming language)|Rust]], [[Haskell (programming language)|Haskell]], [[Ruby (programming language)|Ruby]], [[Python (programming language)|Python]], [[C Sharp (programming language)|C#]], [[CLU (programming language)|CLU]],<ref name="lattner 2014 info 1">{{cite web|url=http://nondot.org/sabre|title=Chris Lattner's Homepage|publisher=Chris Lattner|first=Chris|last=Lattner|authorlink=Chris Lattner|date=June 3, 2014|accessdate=June 3, 2014|quote=I started work on the Swift Programming Language in July of 2010. I implemented much of the basic language structure, with only a few people knowing of its existence. A few other (amazing) people started contributing in earnest late in 2011, and it became a major focus for the Apple Developer Tools group in July 2013 [...] drawing ideas from [[Objective-C]], Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list.}}</ref> [[D (programming language)|D]],<ref name="Getting the location of a caller">{{cite web | url=https://developer.apple.com/swift/blog/?id=15 | title=Building assert() in Swift, Part 2: __FILE__ and __LINE__ | accessdate=September 25, 2014}}</ref>[[Object Pascal]]<ref>{{cite web|title=Why Does Apple's Swift Use Pascal's Variable Declaration Syntax?|url=http://www.innerexception.com/2014/06/why-does-apple-swift-use-pascal.html|website=Inner Exception|accessdate=March 10, 2018}}</ref>
}}

'''Swift''' is a [[General-purpose programming language|general-purpose]], [[Multi-paradigm programming language|multi-paradigm]], [[compiled language|compiled]] [[programming language]] developed by [[Apple Inc.]] for [[iOS]], [[macOS]], [[watchOS]], [[tvOS]], [[Linux]] and [[z/OS]]. Swift is designed to work with Apple's [[Cocoa (API)|Cocoa]] and [[Cocoa Touch]] [[Application framework|frameworks]] and the large body of existing [[Objective-C]] code written for Apple products. It is built with the open source [[LLVM]] [[compiler]] framework and has been included in [[Xcode]] since version 6, released back in 2014. On Apple platforms<ref>{{cite web|url=https://swift.org/blog/swift-linux-port/|website=Swift.org|publisher=Apple Inc|accessdate=August 3, 2016|title=The Swift Linux Port}}</ref>, it uses the Objective-C [[runtime library]] which allows [[C (programming language)|C]], Objective-C, [[C++]] and Swift code to run within one program.<ref>{{cite web|last1=Timmer|first1=John|title=A fast look at Swift, Apple's new programming language|url=https://arstechnica.com/apple/2014/06/a-fast-look-at-swift-apples-new-programming-language/|website=[[Ars Technica]]|publisher=[[Condé Nast]]|accessdate=June 6, 2014|date=June 5, 2014}}</ref>

Apple intended Swift to support many core concepts associated with Objective-C, notably [[dynamic dispatch]], widespread [[late binding]], [[extensible programming]] and similar features, but in a "safer" way, making it easier to catch [[software bugs]]; Swift has features addressing some common [[programming error]]s like [[null pointer]] dereferencing and provides [[syntactic sugar]] to help avoid the [[pyramid of doom (programming)|pyramid of doom]]. Swift supports the concept of [[Protocol (object-oriented programming)|protocol]] extensibility, an extensibility system that can be applied to types, [[Record (computer science)|structs]] and [[Class (computer programming)|classes]], which Apple promotes as a real change in programming paradigms they term "protocol-oriented programming"<ref>{{cite media |url=https://www.youtube.com/watch?v=g2LwFZatfTI |title= Protocol-oriented Programming in Swift |publisher=[[YouTube]]|work=Apple Inc.}}</ref> (similar to [[trait (computer programming)|traits]]).<ref>{{cite web|url=https://news.ycombinator.com/item?id=13225740|title=Concepts are similar to Rust Traits}}</ref>

Swift was introduced at Apple's [[Apple Worldwide Developers Conference#2010s|2014 Worldwide Developers Conference]] (WWDC).<ref name="tnw swift info 1">{{cite web|url=https://thenextweb.com/apple/2014/06/02/apple-announces-swift-new-programming-language-ios|title=Tim Berners-Lee's sixtieth birthday Apple announces Swift, a new programming language for iOS|work=The Next Web|first=Owen|last=Williams|date=June 2, 2014|accessdate=June 2, 2014}}</ref> It underwent an upgrade to version 1.2 during 2014 and a more major upgrade to Swift 2 at WWDC 2015. Initially a [[proprietary programming language|proprietary language]], version 2.2 was made [[open-source software]] under the [[Apache License]] 2.0 on December 3, 2015, for Apple's platforms and [[Linux]].<ref>{{Cite web|title = Apple's new programming language Swift is now open source|url = https://www.theverge.com/2015/12/3/9842854/apple-swift-open-source-released|website = The Verge|accessdate = December 5, 2015}}</ref><ref>{{Cite web|title = Apple Open Sources Swift in Latest Pitch to the Enterprise|url = https://blogs.wsj.com/cio/2015/12/03/apple-open-sources-swift-in-latest-pitch-to-the-enterprise/ |work=[[The Wall Street Journal]] Blogs |department=CIO Journal |registration=yes |date = December 3, 2015|accessdate = December 5, 2015}}</ref>

Through version 3.0 the syntax of Swift went through significant evolution, with the core team making source stability a focus in later versions.<ref>{{Cite web|title = Looking back on Swift 3 and ahead to Swift 4|url = https://forums.swift.org/t/looking-back-on-swift-3-and-ahead-to-swift-4/3610|website = Swift Forums|accessdate = November 19, 2018}}</ref><ref>{{Cite web|title = Swift-Evolution|url = https://github.com/apple/swift-evolution#source-stability|website = Swift Evolution|accessdate = November 19, 2018}}</ref> In the first quarter of 2018 Swift surpassed [[Objective-C]] in measured popularity.<ref>{{Cite web|url=https://redmonk.com/sogrady/2018/03/07/language-rankings-1-18/|title=The RedMonk Programming Language Rankings: January 2018 – tecosystems|website=redmonk.com|language=en-US|access-date=2018-11-20}}</ref>

Swift 4.0, released in 2017, introduced several changes to some built-in classes and structures. Code written with previous versions of Swift can be updated using the migration functionality built into Xcode.

== History ==
Development of Swift started in July 2010 by [[Chris Lattner]], with the eventual collaboration of many other programmers at [[Apple Inc.|Apple]]. Swift took language ideas "from [[Objective-C]], [[Rust (programming language)|Rust]], [[Haskell (programming language)|Haskell]], [[Ruby (programming language)|Ruby]], [[Python (programming language)|Python]], [[C Sharp (programming language)|C#]], [[CLU (programming language)|CLU]], and far too many others to list".<ref name="lattner 2014 info 1" /> On June 2, 2014, the [[Apple Worldwide Developers Conference]] (WWDC) application became the first publicly released app written with Swift.<ref name=stateoftheplatforms /> A [[Software release life cycle#Beta|beta version]] of the [[programming language]] was released to registered Apple developers at the conference, but the company did not promise that the final version of Swift would be [[source code]] compatible with the test version. Apple planned to make source code converters available if needed for the full release.<ref name=stateoftheplatforms>Platforms State of the Union, Session 102, [[Apple Worldwide Developers Conference]], June 2, 2014</ref> 

''The Swift Programming Language'', a free 500-page manual, was also released at WWDC, and is available on the [[iBooks]] Store and the official website.<ref name="Apple swift book">{{cite book|url=https://itunes.apple.com/book/swift-programming-language/id881256329?mt=11|title=The Swift Programming Language|date=June 2, 2014|publisher=[[Apple Inc.|Apple]]|lay-url=https://swift.org/documentation/|accessdate=June 2, 2014}}</ref>

Swift reached the 1.0 milestone on September 9, 2014, with the ''Gold Master'' of [[Xcode]] 6.0 for [[iOS]].<ref name="Swift Blog">{{cite web|url=https://developer.apple.com/swift/blog/?id=14|title=Swift Has Reached 1.0|date=September 9, 2014|accessdate=September 10, 2014}}</ref> Swift 1.1 was released on October 22, 2014, alongside the launch of Xcode 6.1.<ref name="Xcode 6.1 release notes">{{cite web|url=https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html|title=Xcode 6.1 Release Notes|date=October 22, 2014|accessdate=January 23, 2015}}</ref> Swift 1.2 was released on April 8, 2015, along with Xcode 6.3.<ref name="Xcode 6.3 release notes">{{cite web|url=https://developer.apple.com/library/ios/releasenotes/DeveloperTools/RN-Xcode/Chapters/xc6_release_notes.html|title=Xcode 6.3 Release Notes|date=April 8, 2015|accessdate=April 8, 2015}}</ref> Swift 2.0 was announced at WWDC 2015, and was made available for publishing apps in the App Store in September 21, 2015.<ref>{{Cite web|url=https://developer.apple.com/swift/blog/?id=32|title=Swift 2 Apps in the App Store |website=Swift Blog|access-date=March 13, 2016}}</ref> Swift 3.0 was released on September 13, 2016.<ref>{{Cite news|url=https://swift.org/blog/swift-3-0-released/|title=Swift 3.0 Released!|last=Inc.|first=Apple|date=September 13, 2016|newspaper=Swift.org|access-date=October 26, 2016}}</ref> Swift 4.0 was released on September 19, 2017.<ref>{{Cite news|url=https://swift.org/blog/swift-4-0-released/|title=Swift 4.0 Released!|last=Inc.|first=Apple|date=September 17, 2017|newspaper=Swift.org|access-date=March 1, 2018}}</ref> Swift 4.1 was released on March 29, 2018.<ref>{{Cite news|url=https://swift.org/blog/swift-4-1-released/|title=Swift 4.1 Released!|last=Inc.|first=Apple|date=March 29, 2018|newspaper=Swift.org|access-date=March 30, 2018}}</ref>

Swift won first place for ''Most Loved Programming Language'' in the [[Stack Overflow]] Developer Survey 2015<ref name="Stack Overflow Developer Survey Results 2015">{{cite web|url=https://stackoverflow.com/research/developer-survey-2015#tech-super|title=Stack Overflow Developer Survey Results 2015}}</ref> and second place in 2016.<ref name="Stack Overflow Developer Survey Results 2016">{{cite web|url=https://stackoverflow.com/research/developer-survey-2016#technology-most-loved-dreaded-and-wanted|title=Stack Overflow Developer Survey Results 2016}}</ref>

In December 2015, [[IBM]] announced its Swift Sandbox website, which allows developers to write Swift code in one pane and display output in another.<ref>{{Cite web|url=https://developer.ibm.com/swift/2015/12/03/introducing-the-ibm-swift-sandbox/|title=Introducing the IBM Swift Sandbox&nbsp;— Swift|website=Swift|language=en-US|accessdate=December 5, 2015}}</ref><ref>{{Cite web|url=https://9to5mac.com/2015/12/04/swift-web-browser-code-ibm-sandbox/|title=Write Swift code in a web browser with the IBM Swift Sandbox|last=Mayo|first=Benjamin|website=9to5Mac|accessdate=December 5, 2015}}</ref><ref>{{Cite web|url=http://www.zdnet.com/article/after-apple-open-sources-it-ibm-puts-swift-in-the-cloud/|title=After Apple open sources it, IBM puts Swift programming in the cloud {{!}} ZDNet|website=ZDNet|accessdate=December 5, 2015}}</ref> The Swift Sandbox was deprecated in January 2018.<ref>{{Cite web|url=https://developer.ibm.com/swift/2017/12/07/package-catalog-sandbox-deprecation/|title=Swift Package Catalog and Swift Sandbox Deprecation|language=en-US|accessdate=November 9, 2018}}</ref>

During the [[Apple Worldwide Developers Conference#2010s|WWDC 2016]], Apple announced an [[iPad]] exclusive [[Mobile app|app]], named Swift Playgrounds, intended to teach people how to code in Swift. The app is presented in a [[Video game graphics#3D|3D video game-like]] interface which provides feedback when lines of code are placed in a certain order and executed.<ref>{{Cite web|url=https://developer.apple.com/swift/playgrounds/|title=Swift Playgrounds |website=Apple Developer|access-date=June 19, 2016}}</ref><ref>{{Cite web|url=https://www.apple.com/swift/playgrounds/|title=Swift Playgrounds&nbsp;— Preview|website=Apple|language=en-US|access-date=June 19, 2016}}</ref><ref>{{Cite web|url=https://9to5mac.com/2016/06/13/apple-announces-swift-playgrounds-for-ipad/|title=Apple announces Swift Playgrounds for iPad at WWDC, public release in fall|last=Mayo|first=Benjamin|date=June 13, 2016|website=9to5Mac|access-date=June 19, 2016}}</ref>

In January 2017, Chris Lattner announced his departure from Apple for a new position with [[Tesla Motors]], with the Swift project lead role going to team veteran Ted Kremenek.<ref>{{cite web|url=https://arstechnica.com/apple/2017/01/longtime-apple-programmer-and-swift-creator-leaves-apple-for-tesla |title=Longtime Apple programmer and Swift creator leaves Apple for Tesla |first=Andrew |last=Cunningham |date=January 10, 2017 |publisher=Ars Technica}}</ref><ref>{{cite web|url=http://appleinsider.com/articles/17/01/13/new-swift-project-head-ted-kremenek-said-to-be-running-the-show-behind-the-scenes-for-some-time |title=New Swift project head Ted Kremenek said to be running the show behind the scenes for some time |first=Mike |last=Wuerthele |date=January 13, 2017 |publisher=AppleInsider}}</ref>

=== Version History ===
{| class = "wikitable"
|-
! Date !! Version
|-
| 2014-09-09 || Swift 1.0
|-
| 2014-10-22 || Swift 1.1
|-
| 2015-04-08 || Swift 1.2
|-
| 2015-09-21 || Swift 2.0
|-
| 2016-09-13 || Swift 3.0
|-
| 2017-09-19 || Swift 4.0
|-
| 2018-03-29 || Swift 4.1
|-
| 2018-09-17 || Swift 4.2
|}

== Features ==
{{Technical|section|date=June 2018}}

Swift is an alternative to the Objective-C language that employs modern programming-language theory concepts and strives to present a simpler syntax. During its introduction, it was described simply as "Objective-C without the C".<ref>{{cite web|url=https://www.technologyreview.com/news/527821/apple-seeks-a-swift-way-to-lure-more-developers|title=Apple Seeks a Swift Way to Lure More Developers|first1=Rachel|last1=Metz|date=June 3, 2014|publisher=[[Technology Review]]}}</ref><ref>{{cite web|url=https://venturebeat.com/2014/06/02/apple-introduces-a-new-programming-language-swift-objective-c-without-the-c/|title=Apple announces 'Swift,' a new programming language for macOS & iOS|first1=Harrison|last1=Weber|date=June 2, 2014|publisher=[[VentureBeat]]}}</ref>

By default, Swift does not expose pointers and other [[Memory safety|unsafe]] [[Mutator method|accessors]], in contrast to Objective-C, which uses pointers pervasively to refer to object instances. Also, Objective-C's use of a [[Smalltalk]]-like syntax for making [[method call]]s has been replaced with a dot-notation style and [[namespace]] system more familiar to programmers from other common [[Object-oriented programming|object-oriented]] (OO) languages like [[Java (programming language)|Java]] or [[C Sharp (programming language)|C#]]. Swift introduces true [[named parameter]]s and retains key Objective-C concepts, including [[Protocol (object-oriented programming)|protocols]], [[Closure (computer programming)|closures]] and [[Objective-C#Categories|categories]], often replacing former syntax with cleaner versions and allowing these concepts to be applied to other language structures, like [[enumerated type]]s (enums)<ref>{{cite web | url=https://themindstudios.com/blog/advantages-of-using-swift-over-objective-c/ | title=Advantages Of Using Swift | website=themindstudios.com | accessdate=February 24, 2017}}</ref>

=== Syntactic sugar===
Under the [[Cocoa (API)|Cocoa]] and [[Cocoa Touch]] environments, many common classes were part of the [[Foundation Kit]] library. This included the NSString string library (using [[Unicode]]), the NSArray and NSDictionary collection classes, and others. Objective-C provided various bits of [[syntactic sugar]] to allow some of these objects to be created on-the-fly within the language, but once created, the objects were manipulated with object calls. For instance, in Objective-C concatenating two NSStrings required method calls similar to this: <source lang="objc">NSString *str = @"hello,";
str = [str stringByAppendingString:@" world"];</source> In Swift, many of these basic types have been promoted to the language's core, and can be manipulated directly. For instance, strings are invisibly bridged to NSString (when Foundation is imported) and can now be concatenated with the <code>+</code> operator, allowing greatly simplified syntax; the prior example becoming:<ref>{{cite web|title=Strings and Characters|url=https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/StringsAndCharacters.html|website=developer.apple.com|publisher=[[Apple Inc.]]|accessdate=July 16, 2014}}</ref>

<source lang="swift">var str = "hello,"
str += " world"</source>

=== Access control ===
Swift supports five [[Encapsulation (object-oriented programming)|access control]] levels for symbols: <code>open</code>, <code>public</code>, <code>internal</code>, <code>fileprivate</code>, and <code>private</code>. Unlike many object-oriented languages, these access controls ignore [[inheritance (object-oriented programming)|inheritance]] hierarchies: <code>private</code> indicates that a symbol is accessible only in the immediate scope, <code>fileprivate</code> indicates it is accessible only from within the file, <code>internal</code> indicates it is accessible within the containing module, <code>public</code> indicates it is accessible from any module, and <code>open</code> (only for classes and their methods) indicates that the class may be subclassed outside of the module.<ref>{{cite web|title=Access Control|url=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html|website=developer.apple.com|publisher=[[Apple Inc.]]|accessdate=October 25, 2016}}</ref>

=== Optionals and chaining ===
An important new feature in Swift is [[option type]]s, which allow [[Reference (computer science)|references]] or values to operate in a manner similar to the common pattern in [[C (programming language)|C]], where a [[Pointer (computer programming)|pointer]] may refer to a value or may be null. This implies that non-optional types cannot result in a [[Pointer (computer programming)#Making pointers safer|null-pointer error]]; the compiler can ensure this is not possible.

Optional types are created with the <code>Optional</code> mechanism—to make an Integer that is nullable, one would use a declaration similar to <code>var optionalInteger: Optional<Int></code>. As in C#,<ref>[https://msdn.microsoft.com/en-us/library/1t3y8s4s.aspx "Nullable Types"], C# Programming Guide, Microsoft.</ref> Swift also includes syntactic sugar for this, allowing one to indicate a variable is optional by placing a question mark after the type name, <code>var optionalInteger: Int?</code>.<ref>{{cite web |title=Types |url=https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Types.html |website=developer.apple.com |publisher=[[Apple Inc.]] |accessdate=July 16, 2014}}</ref> Variables or constants that are marked optional either have a value of the underlying type or are <code>nil</code>. Optional types ''wrap'' the base type, resulting in a different instance. <code>String</code> and <code>String?</code> are fundamentally different types, the latter has more in common with <code>Int?</code> than <code>String</code>.

To access the value inside, assuming it is not nil, it must be ''unwrapped'' to expose the instance inside. This is performed with the <code>!</code> operator:

<source lang="swift">
    let myValue = anOptionalInstance!.someMethod()
</source>

In this case, the <code>!</code> operator unwraps <code>anOptionalInstance</code> to expose the instance inside, allowing the method call to be made on it. If <code>anOptionalInstance</code> is nil, a null-pointer error occurs. This can be annoying in practice, so Swift also includes the concept of [[Safe navigation operator|optional chaining]] to test whether the instance is nil and then unwrap it if it is non-null:

<source lang="swift">
    let myValue = anOptionalInstance?.someMethod()
</source>

In this case the runtime only calls <code>someMethod</code> if <code>anOptionalInstance</code> is not nil, suppressing the error. Normally this requires the programmer to test whether <code>myValue</code> is nil before proceeding. The origin of the term ''chaining'' comes from the more common case where several method calls/getters are chained together. For instance:

<source lang="swift">
    let aTenant = aBuilding.TenantList[5]
    let theirLease = aTenant.leaseDetails
    let leaseStart = theirLease?.startDate
</source>

can be reduced to:

<source lang="swift">
   let leaseStart = aBuilding.TenantList[5].leaseDetails?.startDate
</source>

The <code>?</code> syntax circumvents the [[Pyramid of doom (programming)|pyramid of doom]].

Swift 2 introduced the new keyword <code>guard</code> for cases in which code should stop executing if some condition is unmet:

<source lang="swift">
    guard let leaseStart = aBuilding.TenantList[5]?.leaseDetails?.startDate else {
        //handle the error case where anything in the chain is nil
        //else scope must exit the current method or loop
    }
    //continue, knowing that leaseStart is not nil
</source>

Using <code>guard</code> has three benefits. While the syntax can act as an <code>if</code> statement, its primary benefit is inferring non-nullability. Where an <code>if</code> statement requires a case, <code>guard</code> assumes the case based on the condition provided. Also, since <code>guard</code> contains no scope, with exception of the <code>else</code> closure, <code>leaseStart</code> is presented as an unwrapped optional to the guard's super-scope. Lastly, if the <code>guard</code> statement's test fails, Swift requires the <code>else</code> to exit the current method or loop, ensuring <code>leaseStart</code> never is accessed when <code>nil</code>.  This is performed with the keywords <code>return</code>, <code>continue</code>, <code>break</code>, or <code>throw</code>.

Objective-C was weakly typed, and allowed any method to be called on any object at any time. If the method call failed, there was a default handler in the runtime that returned nil. That meant that no unwrapping or testing was needed, the equivalent statement in Objective-C:

<source lang="objective-c">
    leaseStart = [[[aBuilding tenantList:5] leaseDetails] startDate]
</source>

would return nil and this could be tested. However, this also demanded that all method calls be dynamic, which introduces significant overhead. Swift's use of optionals provides a similar mechanism for testing and dealing with nils, but does so in a way that allows the compiler to use static dispatch because the unwrapping action is called on a defined instance (the wrapper), versus occurring in the runtime dispatch system.

=== Value types ===
In many object-oriented languages, objects are represented internally in two parts. The object is stored as a block of data placed on the [[Heap (data structure)|heap]], while the name (or "handle") to that object is represented by a [[Pointer (computer programming)|pointer]]. Objects are passed between methods by copying the value of the pointer, allowing the same underlying data on the heap to be accessed by anyone with a copy. In contrast, basic types like integers and floating point values are represented directly; the handle contains the data, not a pointer to it, and that data is passed directly to methods by copying. These styles of access are termed ''pass-by-reference'' in the case of objects, and ''pass-by-value'' for basic types.

Both concepts have their advantages and disadvantages. Objects are useful when the data is large, like the description of a window or the contents of a document. In these cases, access to that data is provided by copying a 32- or 64-bit value, versus copying an entire data structure. However, smaller values like integers are the same size as pointers (typically both are one [[Word (computer architecture)|word]]), so there is no advantage to passing a pointer, versus passing the value. Also, pass-by-reference inherently requires a dereferencing operation, which can produce noticeable overhead in some operations, typically those used with these basic value types, like mathematics.

Similarly to C# and in contrast to most other OO languages,{{cn|date=November 2017}} Swift offers built-in support for objects using either pass-by-reference or pass-by-value semantics, the former using the <code>class</code> declaration and the latter using <code>struct</code>. Structs in Swift have almost all the same features as classes: methods, implementing protocols, and using the extension mechanisms. For this reason, Apple terms all data generically as ''instances'', versus objects or values. Structs do not support inheritance, however.<ref name=classesstructs>{{cite web |url=https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html |title= Classes and Structures |website=Apple.com}}</ref>

The programmer is free to choose which semantics are more appropriate for each data structure in the application. Larger structures like windows would be defined as classes, allowing them to be passed around as pointers. Smaller structures, like a 2D point, can be defined as structs, which will be pass-by-value and allow direct access to their internal data with no dereference. The performance improvement inherent to the pass-by-value concept is such that Swift uses these types for almost all common data types, including <code>Int</code> and <code>Double</code>, and types normally represented by objects, like <code>String</code> and <code>Array</code>.<ref name=classesstructs/> Using value types can result in significant performance improvements in user applications as well.<ref>{{cite web |url=https://medium.com/@fielgood/swift-1-1-swift-1-2-and-objective-c-a-performance-case-study-d86f7a333e2a |title=Performance Case Study on Swift 1.1, Swift 1.2, and Objective-C |first=Fiel |last=Guhit}}</ref>

To ensure that even the largest structs do not cause a performance penalty when they are handed off, Swift uses [[copy on write]] so that the objects are copied only if and when the program attempts to change a value in them. This means that the various accessors have what is in effect a pointer to the same data storage, but this takes place far below the level of the language, in the computer's [[memory management unit]] (MMU). So while the data is physically stored as one instance in memory, at the level of the application, these values are separate, and physical separation is enforced by copy on write only if needed.<ref>{{cite AV media |url=https://developer.apple.com/videos/wwdc/2015/?id=414 |title=Building Better Apps with Value Types |publisher=Apple}}</ref>

=== Protocol-oriented programming ===
A key feature of Objective-C is its support for ''categories'', methods that can be added to extend classes at runtime. Categories allow extending classes in-place to add new functions with no need to subclass or even have access to the original [[source code]]. An example might be to add [[spell checker]] support to the base <code>NSString</code> class, which means all instances of NSString in the application gain spell checking. The system is also widely used as an organizational technique, allowing related code to be gathered into library-like extensions. Swift continues to support this concept, although they are now termed ''extensions'', and declared with the keyword <code>extension</code>. Unlike Objective-C, Swift can also add new properties accessors, types and enums to extant instances.

Another key feature of Objective-C is its use of [[Protocol_(object-oriented_programming)|''protocols'']], known in most modern languages as ''interfaces''. Protocols promise that a particular class implements a set of methods, meaning that other objects in the system can call those methods on any object supporting that protocol. This is often used in modern OO languages as a substitute for [[multiple inheritance]], although the feature sets are not entirely similar. A common example of a protocol in Cocoa is the <code>NSCopying</code> protocol, which defines one method, <code>copyWithZone</code>, that implements [[object copying#deep copy|deep copying]] on objects.<ref name=protocols>{{cite web |url=https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSCopying_Protocol/index.html |title= NSCopying Protocol Reference |website=Apple}}</ref>

In Objective-C, and most other languages implementing the protocol concept, it is up to the programmer to ensure that the required methods are implemented in each class.<ref>{{cite web |url=https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html |title=Working with Protocols |website=Apple}}</ref> Swift adds the ability to add these methods using extensions, and to use [[generic programming]] (generics) to implement them. Combined, these allow protocols to be written once and support a wide variety of instances. Also, the extension mechanism can be used to add protocol conformance to an object that does not list that protocol in its definition.<ref name=protocols/>

For example, a protocol might be declared called <code>StringConvertible</code>, which ensures that instances that conform to the protocol implement a <code>toString</code> method that returns a <code>String</code>. In Swift, this can be declared with code like this:
<source lang="Swift">
protocol StringConvertible {
    func toString() -> String
}
</source>
This protocol can now be added to String, with no access to the base class's source:
<source lang="Swift">
extension String: StringConvertible {
    func toString() -> String {
        return self
    }
}
</source>

In Swift, like many modern languages supporting interfaces, protocols can be used as types, which means variables and methods can be defined by protocol instead of their specific type:

<source lang="Swift">
var someSortOfPrintableObject: StringConvertible
...
print(someSortOfPrintableObject.toString())
</source>

It does not matter what sort of instance <code>someSortOfPrintableObject</code> is, the compiler will ensure that it conforms to the protocol and thus this code is safe. This syntax also means that collections can be based on protocols also, like <code>let printableArray = [StringConvertible]</code>.

As Swift treats structs and classes as similar concepts, both extensions and protocols are extensively used in Swift's runtime to provide a rich API based on structs. For instance, Swift uses an extension to add the <code>Equatable</code> protocol to many of their basic types, like Strings and Arrays, allowing them to be compared with the <code>==</code> operator. A concrete example of how all of these features interact can be seen in the concept of ''default protocol implementations'':
<source lang="Swift">
func !=<T : Equatable>(lhs: T, rhs: T) -> Bool
</source>
This function defines a method that works on any instance conforming to <code>Equatable</code>, providing a ''not equals'' function. Any instance, class or struct, automatically gains this implementation simply by conforming to <code>Equatable</code>. As many instances gain <code>Equatable</code> through their base implementations or other generic extensions, most basic objects in the runtime gain equals and not equals with no code.<ref>{{cite web |url=http://nshipster.com/swift-default-protocol-implementations/ |title=Swift Default Protocol Implementations |website=NSHipster |first=Mattt |last=Thompson |date=September 2, 2014}}</ref>

This combination of protocols, defaults, protocol inheritance, and extensions allows many of the functions normally associated with classes and inheritance to be implemented on value types.<ref name=protocols/> Properly used, this can lead to dramatic performance improvements with no significant limits in API. This concept is so widely used within Swift, that Apple has begun calling it a ''protocol-oriented programming language''. They suggest addressing many of the problem domains normally solved though classes and inheritance using protocols and structs instead.

=== Libraries, runtime and development ===
Swift uses the same runtime as the extant Objective-C system, but requires iOS 7 or macOS 10.9 or higher.<ref>[https://stackoverflow.com/questions/24001778/do-swift-based-apps-work-on-os-x-10-9-ios-7-and-lower/24038997#24038997 "Do Swift-based apps work on macOS 10.9/iOS 7 and lower?"], StackOverflow</ref> Swift and Objective-C code can be used in one program, and by extension, C and C++ also. In contrast to C, C++ code cannot be used directly from Swift. An Objective-C or C wrapper must be created between Swift and C++.<ref>{{cite web|url=https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html|title=Using Swift with Cocoa and Objective-C: Basic Setup|date=January 6, 2015|work=apple.com}}</ref> In the case of Objective-C, Swift has considerable access to the object model, and can be used to subclass, extend and use Objective-C code to provide protocol support.<ref>[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html "Writing Swift Classes with Objective-C Behavior"], Apple Inc.</ref> The converse is not true: a Swift class cannot be subclassed in Objective-C.<ref>{{cite web|url=https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Migration.html|title=Migrating Your Objective-C Code to Swift}}</ref>

To aid development of such programs, and the re-use of extant code, Xcode 6 offers a semi-automated system that builds and maintains a ''bridging header'' to expose Objective-C code to Swift. This takes the form of an additional [[header file]] that simply defines or imports all of the Objective-C symbols that are needed by the project's Swift code. At that point, Swift can refer to the types, functions, and variables declared in those imports as though they were written in Swift. Objective-C code can also use Swift code directly, by importing an automatically maintained header file with Objective-C declarations of the project's Swift symbols. For instance, an Objective-C file in a mixed project called "MyApp" could access Swift classes or functions with the code <code>#import "MyApp-Swift.h"</code>. Not all symbols are available through this mechanism, however—use of Swift-specific features like generic types, non-object optional types, sophisticated enums, or even Unicode identifiers may render a symbol inaccessible from Objective-C.<ref>[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77 "Swift and Objective-C in the Same Project"], Apple Inc.</ref>

Swift also has limited support for ''attributes'', metadata that is read by the development environment, and is not necessarily part of the compiled code. Like Objective-C, attributes use the <code>@</code> syntax, but the currently available set is small. One example is the <code>@IBOutlet</code> attribute, which marks a given value in the code as an ''outlet'', available for use within [[Interface Builder]] (IB). An ''outlet'' is a device that binds the value of the on-screen display to an object in code.

=== Memory management ===
Swift uses [[Automatic Reference Counting]] (ARC) to [[Memory management|manage memory]]. Apple used to require manual memory management in Objective-C, but introduced ARC in 2011 to allow for easier memory allocation and deallocation.<ref>[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html "Automatic Reference Counting"], Apple Inc.</ref> One problem with ARC is the possibility of creating a ''[[Reference counting#reference cycle|strong reference cycle]]'', where objects reference each other in a way that you can reach the object you started from by following references (e.g. A references B, B references A). This causes them to become leaked into memory as they are never released.  Swift provides the keywords <code>weak</code> and <code>unowned</code> to prevent strong reference cycles. Typically a parent-child relationship would use a strong reference while a child-parent would use either <code>weak</code> reference, where parents and children can be unrelated, or <code>unowned</code> where a child always has a parent, but parent may not have a child. Weak references must be optional variables, since they can change and become <code>nil</code>.<ref name="Intermediate Swift">{{cite web|last1=Lanier|first1=Brian|last2=Groff|first2=Joe|title=Intermediate Swift|url=https://developer.apple.com/videos/wwdc/2014/?include=403#403|publisher=Apple|accessdate=July 3, 2014}}</ref>

A closure within a class can also create a strong reference cycle by capturing self references. Self references to be treated as weak or unowned can be indicated using a ''capture list.''

=== Debugging and other elements ===
A key element of the Swift system is its ability to be cleanly debugged and run within the development environment, using a [[read–eval–print loop]] (REPL), giving it interactive properties more in common with the scripting abilities of Python than traditional [[system programming]] languages. The REPL is further enhanced with the new concept ''playgrounds''. These are interactive views running within the Xcode environment that respond to code or debugger changes on-the-fly.<ref>{{cite web|last1=Metz|first1=Cade|title=Why Coders Are Going Nuts Over Apple's New Programming Language|url=https://www.wired.com/2014/06/apple-swift-language/|publisher=[[Wired (magazine)|Wired]]|accessdate=July 16, 2014}}</ref> Playgrounds allow programmers to add in Swift code along with markdown documentation. If some code changes over time or with regard to some other ranged input value, the view can be used with the Timeline Assistant to demonstrate the output in an animated way. In addition, Xcode has debugging features for Swift development including breakpoints, step through and step over statements, as well as UI element placement breakdowns for app developers. 

Apple says that Swift is "an industrial-quality programming language that's as expressive and enjoyable as a scripting language".<ref>[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ About Swift], Apple Inc.</ref>

=== Performance ===
Many of the features introduced with Swift also have well-known performance and safety trade-offs. Apple has implemented [[Optimizing compiler|optimizations]] that reduce this overhead.<ref>{{cite web|url=https://developer.apple.com/videos/play/wwdc2015/409/ |title=Optimizing Swift Performance |publisher=Apple, Inc. |date=June 2015}}</ref>

== Comparisons to other languages ==
{{prose|section|date=February 2017}}

Swift is similar to C in various ways:

* Most C operators are used in Swift, but there are some new operators.
* [[Curly braces]] are used to group statements.
* Variables are assigned using an [[equals sign]], but compared using [[==|two consecutive equals signs]]. A new identity operator, ===,  is provided to check if two data elements refer to the same [[Pointer (computing)|object]].
* Control statements <code>while</code>, <code>if</code>, and <code>switch</code> are similar, but have extended functions, e.g., a <code>switch</code> that takes non-integer cases, <code>while</code> and <code>if</code> supporting pattern matching and conditionally unwrapping optionals, etc.
* [[Square brackets]] are used with [[Array data structure|arrays]], both to declare them and to get a value at a given index in one of them.

It also has similarities to Objective-C:

* Basic numeric types (<code>Int, UInt, Float, Double</code>)
* Class methods are inherited, like instance methods; <code>self</code> in class methods is the class the method was called on.
* Similar <code>for</code>...<code>in</code> enumeration syntax.

Differences from Objective-C include:

* Statements do not need to end with semicolons (<code>;</code>), though these must be used to allow more than one statement on a line.
* No header files.
* Uses [[type inference]].
* [[Generic programming]].
* Functions are [[first class function|first-class]] objects.
* Enumeration cases can have associated data ([[algebraic data type]]s).
* Operators can be redefined for classes ([[operator overloading]]), and new operators can be defined.
* Strings fully support [[Unicode]]. Most Unicode characters can be used in either identifiers or operators.
* No [[exception handling]]. Swift 2 introduces a different and incompatible error-handling model.<ref>{{cite web|url=https://stackoverflow.com/a/26749528|title=Error-Handling in Swift-Language|work=stackoverflow.com}}</ref>
* Several notoriously error-prone behaviors of earlier [[List of C-family programming languages|C-family languages]] have been changed:
** [[Pointer (computer programming)|Pointers]] are not exposed by default. There is no need for the programmer to keep track of and mark names for referencing or dereferencing.
** Assignments return no value. This prevents the common error of writing <code>i = 0</code> instead of <code>i == 0</code> by throwing a compile-time error.
** No need to use <code>break</code> statements in <code>[[Switch statement|switch]]</code> blocks. Individual cases do not fall through to the next case unless the <code>fallthrough</code> statement is used.
** Variables and constants are always initialized and array bounds are always checked.
** [[Integer overflow]]s, which result in [[undefined behavior]] for signed integers in C, are trapped as a run-time error in Swift. Programmers can choose to allow overflows by using the special arithmetical operators <code>&+</code>, <code>&-</code>, <code>&*</code>, <code>&/</code> and <code>&%</code>.  The properties <code>min</code> and <code>max</code> are defined in Swift for all integer types and can be used to safely check for potential overflows, versus relying on constants defined for each type in external libraries.
** The one-statement form of <code>if</code> and <code>while</code>, which allows for the omission of braces around the statement, is unsupported.
** C-style enumeration <code>for (int i = 0; i < c; i++)</code>, which is prone to [[off-by-one error]]s, is unsupported (from Swift 3 onward).<ref>{{Cite web|url=https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md|title=apple/swift-evolution|website=GitHub|access-date=April 4, 2016}}</ref>
** The pre- and post- [[increment and decrement operators]] (<code>i++</code>, <code>--i</code> ...) are unsupported (from Swift 3 onward), more so since C-style <code>for</code> statements are also unsupported from Swift 3 onward.<ref>{{Cite web|url=https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md|title=apple/swift-evolution|website=GitHub|access-date=April 4, 2016}}</ref>

== Development and other implementations ==
Since the language is open-source, there are prospects of it being ported to the web.<ref>{{Cite web|url=https://9to5mac.com/2016/02/22/ibm-swift-cloud-kitura/|title=IBM brings Swift to the cloud, releases web framework Kitura written in Apple’s programming language|last=Barbosa|first=Greg|date=February 22, 2016|website=9to5Mac|access-date=May 16, 2016}}</ref> Some web frameworks have already been developed, such as [[IBM]]'s [[Kitura]], [[Perfect (server framework)|Perfect]] and [[Vapor (Server-side Swift)|Vapor]].

An official "Server APIs" work group has also been started by Apple,<ref>{{Cite news|url=https://swift.org/blog/server-api-workgroup/|title=Server APIs Work Group|last=Inc.|first=Apple|date=October 25, 2016|newspaper=Swift.org|access-date=October 28, 2016}}</ref> with members of the Swift developer community playing a central role.<ref>{{Cite web|url=https://swift.org/server-apis/|title=Swift.org|last=Inc.|first=Apple|website=Swift.org|access-date=October 28, 2016}}</ref>

A second free implementation of Swift that targets [[Cocoa (API)|Cocoa]], [[Microsoft]]'s [[Common Language Infrastructure]] ([[.NET Framework|.NET]]), and the [[Java (software platform)|Java]] and [[Android (operating system)|Android]] platform exists as part of the ''Elements Compiler'' from [[RemObjects Software]].<ref>{{Cite web|title = RemObjects Elements Compiler|url = http://www.elementscompiler.com/silver|accessdate = January 17, 2016}}</ref>

== See also ==
{{portal|Apple Inc.|Computer programming}}

* [[Comparison of programming languages]]
* [[Objective-C]]
* [[Kotlin (programming language)]]
* [[Python (programming language)]]

== References ==
{{reflist|30em}}

== External links ==
* {{Official website}}
* [https://developer.apple.com/swift/ Swift] at [[Apple Developer]]
* {{GitHub|apple/swift|Swift's source code}}
* [https://developer.ibm.com/swift/ Server-side Swift]
* [https://developer.ibm.com/mainframe/products/ibm-toolkit-swift-z-os/ Swift for IBM z/OS]
* [https://www.ibm.com/us-en/marketplace/swift-compiler Swift for Linux on z Systems]

{{Programming languages}}
{{Apple Software}}

{{Authority control}}

[[Category:Apple Inc.]]
[[Category:Computer-related introductions in 2014]]
[[Category:Object-oriented programming languages]]
[[Category:Pattern matching programming languages]]
[[Category:Programming languages]]
[[Category:Programming languages created in 2014]]
[[Category:Software using the Apache license]]
[[Category:Statically typed programming languages]]
[[Category:Systems programming languages]]